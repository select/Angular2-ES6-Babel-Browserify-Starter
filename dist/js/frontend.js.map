{"version":3,"names":[],"mappings":"","sources":["frontend.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';function __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n__export(require('./src/common/pipes'));\r\n__export(require('./src/common/directives'));\r\n__export(require('./src/common/forms'));\r\n__export(require('./src/common/common_directives'));\r\n},{\"./src/common/common_directives\":11,\"./src/common/directives\":12,\"./src/common/forms\":20,\"./src/common/pipes\":43}],2:[function(require,module,exports){\n'use strict';function __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n/**\r\n * @module\r\n * @description\r\n * Starting point to import all compiler APIs.\r\n */\r\n__export(require('./src/compiler/url_resolver'));\r\n__export(require('./src/compiler/xhr'));\r\n__export(require('./src/compiler/compiler'));\r\n},{\"./src/compiler/compiler\":54,\"./src/compiler/url_resolver\":76,\"./src/compiler/xhr\":79}],3:[function(require,module,exports){\n'use strict';function __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n/**\r\n * @module\r\n * @description\r\n * Starting point to import all public core APIs.\r\n */\r\n__export(require('./src/core/metadata'));\r\n__export(require('./src/core/util'));\r\n__export(require('./src/core/prod_mode'));\r\n__export(require('./src/core/di'));\r\n__export(require('./src/facade/facade'));\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nexports.enableProdMode = lang_1.enableProdMode;\r\nvar application_ref_1 = require('./src/core/application_ref');\r\nexports.platform = application_ref_1.platform;\r\nexports.createNgZone = application_ref_1.createNgZone;\r\nexports.PlatformRef = application_ref_1.PlatformRef;\r\nexports.ApplicationRef = application_ref_1.ApplicationRef;\r\nvar application_tokens_1 = require('./src/core/application_tokens');\r\nexports.APP_ID = application_tokens_1.APP_ID;\r\nexports.APP_COMPONENT = application_tokens_1.APP_COMPONENT;\r\nexports.APP_INITIALIZER = application_tokens_1.APP_INITIALIZER;\r\nexports.PACKAGE_ROOT_URL = application_tokens_1.PACKAGE_ROOT_URL;\r\nexports.PLATFORM_INITIALIZER = application_tokens_1.PLATFORM_INITIALIZER;\r\n__export(require('./src/core/zone'));\r\n__export(require('./src/core/render'));\r\n__export(require('./src/core/linker'));\r\nvar debug_element_1 = require('./src/core/debug/debug_element');\r\nexports.DebugElement = debug_element_1.DebugElement;\r\nexports.Scope = debug_element_1.Scope;\r\nexports.inspectElement = debug_element_1.inspectElement;\r\nexports.asNativeElements = debug_element_1.asNativeElements;\r\n__export(require('./src/core/testability/testability'));\r\n__export(require('./src/core/change_detection'));\r\n__export(require('./src/core/platform_directives_and_pipes'));\r\n__export(require('./src/core/platform_common_providers'));\r\n__export(require('./src/core/application_common_providers'));\r\n__export(require('./src/core/reflection/reflection'));\r\n},{\"./src/core/application_common_providers\":81,\"./src/core/application_ref\":82,\"./src/core/application_tokens\":83,\"./src/core/change_detection\":84,\"./src/core/debug/debug_element\":116,\"./src/core/di\":117,\"./src/core/linker\":127,\"./src/core/metadata\":146,\"./src/core/platform_common_providers\":152,\"./src/core/platform_directives_and_pipes\":153,\"./src/core/prod_mode\":154,\"./src/core/reflection/reflection\":158,\"./src/core/render\":161,\"./src/core/testability/testability\":164,\"./src/core/util\":165,\"./src/core/zone\":167,\"./src/facade/facade\":174,\"angular2/src/facade/lang\":176}],4:[function(require,module,exports){\n'use strict';var angular_entrypoint_1 = require('angular2/src/core/angular_entrypoint');\r\nexports.AngularEntrypoint = angular_entrypoint_1.AngularEntrypoint;\r\nvar browser_common_1 = require('angular2/src/platform/browser_common');\r\nexports.BROWSER_PROVIDERS = browser_common_1.BROWSER_PROVIDERS;\r\nexports.ELEMENT_PROBE_BINDINGS = browser_common_1.ELEMENT_PROBE_BINDINGS;\r\nexports.ELEMENT_PROBE_PROVIDERS = browser_common_1.ELEMENT_PROBE_PROVIDERS;\r\nexports.inspectNativeElement = browser_common_1.inspectNativeElement;\r\nexports.BrowserDomAdapter = browser_common_1.BrowserDomAdapter;\r\nexports.By = browser_common_1.By;\r\nexports.Title = browser_common_1.Title;\r\nexports.DOCUMENT = browser_common_1.DOCUMENT;\r\nexports.enableDebugTools = browser_common_1.enableDebugTools;\r\nexports.disableDebugTools = browser_common_1.disableDebugTools;\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar browser_common_2 = require('angular2/src/platform/browser_common');\r\nvar compiler_1 = require('angular2/compiler');\r\nvar core_1 = require('angular2/core');\r\nvar reflection_capabilities_1 = require('angular2/src/core/reflection/reflection_capabilities');\r\nvar xhr_impl_1 = require(\"angular2/src/platform/browser/xhr_impl\");\r\nvar compiler_2 = require('angular2/compiler');\r\nvar di_1 = require('angular2/src/core/di');\r\n/**\r\n * An array of providers that should be passed into `application()` when bootstrapping a component.\r\n */\r\nexports.BROWSER_APP_PROVIDERS = lang_1.CONST_EXPR([\r\n    browser_common_2.BROWSER_APP_COMMON_PROVIDERS,\r\n    compiler_1.COMPILER_PROVIDERS,\r\n    new di_1.Provider(compiler_2.XHR, { useClass: xhr_impl_1.XHRImpl }),\r\n]);\r\n/**\r\n * Bootstrapping for Angular applications.\r\n *\r\n * You instantiate an Angular application by explicitly specifying a component to use\r\n * as the root component for your application via the `bootstrap()` method.\r\n *\r\n * ## Simple Example\r\n *\r\n * Assuming this `index.html`:\r\n *\r\n * ```html\r\n * <html>\r\n *   <!-- load Angular script tags here. -->\r\n *   <body>\r\n *     <my-app>loading...</my-app>\r\n *   </body>\r\n * </html>\r\n * ```\r\n *\r\n * An application is bootstrapped inside an existing browser DOM, typically `index.html`.\r\n * Unlike Angular 1, Angular 2 does not compile/process providers in `index.html`. This is\r\n * mainly for security reasons, as well as architectural changes in Angular 2. This means\r\n * that `index.html` can safely be processed using server-side technologies such as\r\n * providers. Bindings can thus use double-curly `{{ syntax }}` without collision from\r\n * Angular 2 component double-curly `{{ syntax }}`.\r\n *\r\n * We can use this script code:\r\n *\r\n * {@example core/ts/bootstrap/bootstrap.ts region='bootstrap'}\r\n *\r\n * When the app developer invokes `bootstrap()` with the root component `MyApp` as its\r\n * argument, Angular performs the following tasks:\r\n *\r\n *  1. It uses the component's `selector` property to locate the DOM element which needs\r\n *     to be upgraded into the angular component.\r\n *  2. It creates a new child injector (from the platform injector). Optionally, you can\r\n *     also override the injector configuration for an app by invoking `bootstrap` with the\r\n *     `componentInjectableBindings` argument.\r\n *  3. It creates a new `Zone` and connects it to the angular application's change detection\r\n *     domain instance.\r\n *  4. It creates an emulated or shadow DOM on the selected component's host element and loads the\r\n *     template into it.\r\n *  5. It instantiates the specified component.\r\n *  6. Finally, Angular performs change detection to apply the initial data providers for the\r\n *     application.\r\n *\r\n *\r\n * ## Bootstrapping Multiple Applications\r\n *\r\n * When working within a browser window, there are many singleton resources: cookies, title,\r\n * location, and others. Angular services that represent these resources must likewise be\r\n * shared across all Angular applications that occupy the same browser window. For this\r\n * reason, Angular creates exactly one global platform object which stores all shared\r\n * services, and each angular application injector has the platform injector as its parent.\r\n *\r\n * Each application has its own private injector as well. When there are multiple\r\n * applications on a page, Angular treats each application injector's services as private\r\n * to that application.\r\n *\r\n * ## API\r\n *\r\n * - `appComponentType`: The root component which should act as the application. This is\r\n *   a reference to a `Type` which is annotated with `@Component(...)`.\r\n * - `customProviders`: An additional set of providers that can be added to the\r\n *   app injector to override default injection behavior.\r\n *\r\n * Returns a `Promise` of {@link ComponentRef}.\r\n */\r\nfunction bootstrap(appComponentType, customProviders) {\r\n    core_1.reflector.reflectionCapabilities = new reflection_capabilities_1.ReflectionCapabilities();\r\n    var appProviders = lang_1.isPresent(customProviders) ? [exports.BROWSER_APP_PROVIDERS, customProviders] : exports.BROWSER_APP_PROVIDERS;\r\n    return core_1.platform(browser_common_2.BROWSER_PROVIDERS).application(appProviders).bootstrap(appComponentType);\r\n}\r\nexports.bootstrap = bootstrap;\r\n},{\"angular2/compiler\":2,\"angular2/core\":3,\"angular2/src/core/angular_entrypoint\":80,\"angular2/src/core/di\":117,\"angular2/src/core/reflection/reflection_capabilities\":159,\"angular2/src/facade/lang\":176,\"angular2/src/platform/browser/xhr_impl\":185,\"angular2/src/platform/browser_common\":186}],5:[function(require,module,exports){\n'use strict';function __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n/**\r\n * This is a set of classes and objects that can be used both in the browser and on the server.\r\n */\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nexports.DOM = dom_adapter_1.DOM;\r\nexports.setRootDomAdapter = dom_adapter_1.setRootDomAdapter;\r\nexports.DomAdapter = dom_adapter_1.DomAdapter;\r\nvar dom_renderer_1 = require('angular2/src/platform/dom/dom_renderer');\r\nexports.DomRenderer = dom_renderer_1.DomRenderer;\r\nvar dom_tokens_1 = require('angular2/src/platform/dom/dom_tokens');\r\nexports.DOCUMENT = dom_tokens_1.DOCUMENT;\r\nvar shared_styles_host_1 = require('angular2/src/platform/dom/shared_styles_host');\r\nexports.SharedStylesHost = shared_styles_host_1.SharedStylesHost;\r\nexports.DomSharedStylesHost = shared_styles_host_1.DomSharedStylesHost;\r\nvar dom_events_1 = require('angular2/src/platform/dom/events/dom_events');\r\nexports.DomEventsPlugin = dom_events_1.DomEventsPlugin;\r\nvar event_manager_1 = require('angular2/src/platform/dom/events/event_manager');\r\nexports.EVENT_MANAGER_PLUGINS = event_manager_1.EVENT_MANAGER_PLUGINS;\r\nexports.EventManager = event_manager_1.EventManager;\r\nexports.EventManagerPlugin = event_manager_1.EventManagerPlugin;\r\n__export(require('angular2/src/platform/dom/debug/by'));\r\n__export(require('angular2/src/platform/dom/debug/debug_element_view_listener'));\r\n},{\"angular2/src/platform/dom/debug/by\":187,\"angular2/src/platform/dom/debug/debug_element_view_listener\":188,\"angular2/src/platform/dom/dom_adapter\":189,\"angular2/src/platform/dom/dom_renderer\":190,\"angular2/src/platform/dom/dom_tokens\":191,\"angular2/src/platform/dom/events/dom_events\":192,\"angular2/src/platform/dom/events/event_manager\":193,\"angular2/src/platform/dom/shared_styles_host\":197}],6:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar math_1 = require('angular2/src/facade/math');\r\nvar util_1 = require('angular2/src/platform/dom/util');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar Animation = (function () {\r\n    /**\r\n     * Stores the start time and starts the animation\r\n     * @param element\r\n     * @param data\r\n     * @param browserDetails\r\n     */\r\n    function Animation(element, data, browserDetails) {\r\n        var _this = this;\r\n        this.element = element;\r\n        this.data = data;\r\n        this.browserDetails = browserDetails;\r\n        /** functions to be called upon completion */\r\n        this.callbacks = [];\r\n        /** functions for removing event listeners */\r\n        this.eventClearFunctions = [];\r\n        /** flag used to track whether or not the animation has finished */\r\n        this.completed = false;\r\n        this._stringPrefix = '';\r\n        this.startTime = lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now());\r\n        this._stringPrefix = dom_adapter_1.DOM.getAnimationPrefix();\r\n        this.setup();\r\n        this.wait(function (timestamp) { return _this.start(); });\r\n    }\r\n    Object.defineProperty(Animation.prototype, \"totalTime\", {\r\n        /** total amount of time that the animation should take including delay */\r\n        get: function () {\r\n            var delay = this.computedDelay != null ? this.computedDelay : 0;\r\n            var duration = this.computedDuration != null ? this.computedDuration : 0;\r\n            return delay + duration;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Animation.prototype.wait = function (callback) {\r\n        // Firefox requires 2 frames for some reason\r\n        this.browserDetails.raf(callback, 2);\r\n    };\r\n    /**\r\n     * Sets up the initial styles before the animation is started\r\n     */\r\n    Animation.prototype.setup = function () {\r\n        if (this.data.fromStyles != null)\r\n            this.applyStyles(this.data.fromStyles);\r\n        if (this.data.duration != null)\r\n            this.applyStyles({ 'transitionDuration': this.data.duration.toString() + 'ms' });\r\n        if (this.data.delay != null)\r\n            this.applyStyles({ 'transitionDelay': this.data.delay.toString() + 'ms' });\r\n    };\r\n    /**\r\n     * After the initial setup has occurred, this method adds the animation styles\r\n     */\r\n    Animation.prototype.start = function () {\r\n        this.addClasses(this.data.classesToAdd);\r\n        this.addClasses(this.data.animationClasses);\r\n        this.removeClasses(this.data.classesToRemove);\r\n        if (this.data.toStyles != null)\r\n            this.applyStyles(this.data.toStyles);\r\n        var computedStyles = dom_adapter_1.DOM.getComputedStyle(this.element);\r\n        this.computedDelay =\r\n            math_1.Math.max(this.parseDurationString(computedStyles.getPropertyValue(this._stringPrefix + 'transition-delay')), this.parseDurationString(this.element.style.getPropertyValue(this._stringPrefix + 'transition-delay')));\r\n        this.computedDuration = math_1.Math.max(this.parseDurationString(computedStyles.getPropertyValue(this._stringPrefix + 'transition-duration')), this.parseDurationString(this.element.style.getPropertyValue(this._stringPrefix + 'transition-duration')));\r\n        this.addEvents();\r\n    };\r\n    /**\r\n     * Applies the provided styles to the element\r\n     * @param styles\r\n     */\r\n    Animation.prototype.applyStyles = function (styles) {\r\n        var _this = this;\r\n        collection_1.StringMapWrapper.forEach(styles, function (value, key) {\r\n            var dashCaseKey = util_1.camelCaseToDashCase(key);\r\n            if (lang_1.isPresent(dom_adapter_1.DOM.getStyle(_this.element, dashCaseKey))) {\r\n                dom_adapter_1.DOM.setStyle(_this.element, dashCaseKey, value.toString());\r\n            }\r\n            else {\r\n                dom_adapter_1.DOM.setStyle(_this.element, _this._stringPrefix + dashCaseKey, value.toString());\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Adds the provided classes to the element\r\n     * @param classes\r\n     */\r\n    Animation.prototype.addClasses = function (classes) {\r\n        for (var i = 0, len = classes.length; i < len; i++)\r\n            dom_adapter_1.DOM.addClass(this.element, classes[i]);\r\n    };\r\n    /**\r\n     * Removes the provided classes from the element\r\n     * @param classes\r\n     */\r\n    Animation.prototype.removeClasses = function (classes) {\r\n        for (var i = 0, len = classes.length; i < len; i++)\r\n            dom_adapter_1.DOM.removeClass(this.element, classes[i]);\r\n    };\r\n    /**\r\n     * Adds events to track when animations have finished\r\n     */\r\n    Animation.prototype.addEvents = function () {\r\n        var _this = this;\r\n        if (this.totalTime > 0) {\r\n            this.eventClearFunctions.push(dom_adapter_1.DOM.onAndCancel(this.element, dom_adapter_1.DOM.getTransitionEnd(), function (event) { return _this.handleAnimationEvent(event); }));\r\n        }\r\n        else {\r\n            this.handleAnimationCompleted();\r\n        }\r\n    };\r\n    Animation.prototype.handleAnimationEvent = function (event) {\r\n        var elapsedTime = math_1.Math.round(event.elapsedTime * 1000);\r\n        if (!this.browserDetails.elapsedTimeIncludesDelay)\r\n            elapsedTime += this.computedDelay;\r\n        event.stopPropagation();\r\n        if (elapsedTime >= this.totalTime)\r\n            this.handleAnimationCompleted();\r\n    };\r\n    /**\r\n     * Runs all animation callbacks and removes temporary classes\r\n     */\r\n    Animation.prototype.handleAnimationCompleted = function () {\r\n        this.removeClasses(this.data.animationClasses);\r\n        this.callbacks.forEach(function (callback) { return callback(); });\r\n        this.callbacks = [];\r\n        this.eventClearFunctions.forEach(function (fn) { return fn(); });\r\n        this.eventClearFunctions = [];\r\n        this.completed = true;\r\n    };\r\n    /**\r\n     * Adds animation callbacks to be called upon completion\r\n     * @param callback\r\n     * @returns {Animation}\r\n     */\r\n    Animation.prototype.onComplete = function (callback) {\r\n        if (this.completed) {\r\n            callback();\r\n        }\r\n        else {\r\n            this.callbacks.push(callback);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Converts the duration string to the number of milliseconds\r\n     * @param duration\r\n     * @returns {number}\r\n     */\r\n    Animation.prototype.parseDurationString = function (duration) {\r\n        var maxValue = 0;\r\n        // duration must have at least 2 characters to be valid. (number + type)\r\n        if (duration == null || duration.length < 2) {\r\n            return maxValue;\r\n        }\r\n        else if (duration.substring(duration.length - 2) == 'ms') {\r\n            var value = lang_1.NumberWrapper.parseInt(this.stripLetters(duration), 10);\r\n            if (value > maxValue)\r\n                maxValue = value;\r\n        }\r\n        else if (duration.substring(duration.length - 1) == 's') {\r\n            var ms = lang_1.NumberWrapper.parseFloat(this.stripLetters(duration)) * 1000;\r\n            var value = math_1.Math.floor(ms);\r\n            if (value > maxValue)\r\n                maxValue = value;\r\n        }\r\n        return maxValue;\r\n    };\r\n    /**\r\n     * Strips the letters from the duration string\r\n     * @param str\r\n     * @returns {string}\r\n     */\r\n    Animation.prototype.stripLetters = function (str) {\r\n        return lang_1.StringWrapper.replaceAll(str, lang_1.RegExpWrapper.create('[^0-9]+$', ''), '');\r\n    };\r\n    return Animation;\r\n})();\r\nexports.Animation = Animation;\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176,\"angular2/src/facade/math\":177,\"angular2/src/platform/dom/dom_adapter\":189,\"angular2/src/platform/dom/util\":198}],7:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar css_animation_builder_1 = require('./css_animation_builder');\r\nvar browser_details_1 = require('./browser_details');\r\nvar AnimationBuilder = (function () {\r\n    /**\r\n     * Used for DI\r\n     * @param browserDetails\r\n     */\r\n    function AnimationBuilder(browserDetails) {\r\n        this.browserDetails = browserDetails;\r\n    }\r\n    /**\r\n     * Creates a new CSS Animation\r\n     * @returns {CssAnimationBuilder}\r\n     */\r\n    AnimationBuilder.prototype.css = function () { return new css_animation_builder_1.CssAnimationBuilder(this.browserDetails); };\r\n    AnimationBuilder = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [browser_details_1.BrowserDetails])\r\n    ], AnimationBuilder);\r\n    return AnimationBuilder;\r\n})();\r\nexports.AnimationBuilder = AnimationBuilder;\r\n},{\"./browser_details\":8,\"./css_animation_builder\":9,\"angular2/src/core/di\":117}],8:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar math_1 = require('angular2/src/facade/math');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar BrowserDetails = (function () {\r\n    function BrowserDetails() {\r\n        this.elapsedTimeIncludesDelay = false;\r\n        this.doesElapsedTimeIncludesDelay();\r\n    }\r\n    /**\r\n     * Determines if `event.elapsedTime` includes transition delay in the current browser.  At this\r\n     * time, Chrome and Opera seem to be the only browsers that include this.\r\n     */\r\n    BrowserDetails.prototype.doesElapsedTimeIncludesDelay = function () {\r\n        var _this = this;\r\n        var div = dom_adapter_1.DOM.createElement('div');\r\n        dom_adapter_1.DOM.setAttribute(div, 'style', \"position: absolute; top: -9999px; left: -9999px; width: 1px;\\n      height: 1px; transition: all 1ms linear 1ms;\");\r\n        // Firefox requires that we wait for 2 frames for some reason\r\n        this.raf(function (timestamp) {\r\n            dom_adapter_1.DOM.on(div, 'transitionend', function (event) {\r\n                var elapsed = math_1.Math.round(event.elapsedTime * 1000);\r\n                _this.elapsedTimeIncludesDelay = elapsed == 2;\r\n                dom_adapter_1.DOM.remove(div);\r\n            });\r\n            dom_adapter_1.DOM.setStyle(div, 'width', '2px');\r\n        }, 2);\r\n    };\r\n    BrowserDetails.prototype.raf = function (callback, frames) {\r\n        if (frames === void 0) { frames = 1; }\r\n        var queue = new RafQueue(callback, frames);\r\n        return function () { return queue.cancel(); };\r\n    };\r\n    BrowserDetails = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], BrowserDetails);\r\n    return BrowserDetails;\r\n})();\r\nexports.BrowserDetails = BrowserDetails;\r\nvar RafQueue = (function () {\r\n    function RafQueue(callback, frames) {\r\n        this.callback = callback;\r\n        this.frames = frames;\r\n        this._raf();\r\n    }\r\n    RafQueue.prototype._raf = function () {\r\n        var _this = this;\r\n        this.currentFrameId = dom_adapter_1.DOM.requestAnimationFrame(function (timestamp) { return _this._nextFrame(timestamp); });\r\n    };\r\n    RafQueue.prototype._nextFrame = function (timestamp) {\r\n        this.frames--;\r\n        if (this.frames > 0) {\r\n            this._raf();\r\n        }\r\n        else {\r\n            this.callback(timestamp);\r\n        }\r\n    };\r\n    RafQueue.prototype.cancel = function () {\r\n        dom_adapter_1.DOM.cancelAnimationFrame(this.currentFrameId);\r\n        this.currentFrameId = null;\r\n    };\r\n    return RafQueue;\r\n})();\r\n},{\"angular2/src/core/di\":117,\"angular2/src/facade/math\":177,\"angular2/src/platform/dom/dom_adapter\":189}],9:[function(require,module,exports){\n'use strict';var css_animation_options_1 = require('./css_animation_options');\r\nvar animation_1 = require('./animation');\r\nvar CssAnimationBuilder = (function () {\r\n    /**\r\n     * Accepts public properties for CssAnimationBuilder\r\n     */\r\n    function CssAnimationBuilder(browserDetails) {\r\n        this.browserDetails = browserDetails;\r\n        /** @type {CssAnimationOptions} */\r\n        this.data = new css_animation_options_1.CssAnimationOptions();\r\n    }\r\n    /**\r\n     * Adds a temporary class that will be removed at the end of the animation\r\n     * @param className\r\n     */\r\n    CssAnimationBuilder.prototype.addAnimationClass = function (className) {\r\n        this.data.animationClasses.push(className);\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds a class that will remain on the element after the animation has finished\r\n     * @param className\r\n     */\r\n    CssAnimationBuilder.prototype.addClass = function (className) {\r\n        this.data.classesToAdd.push(className);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes a class from the element\r\n     * @param className\r\n     */\r\n    CssAnimationBuilder.prototype.removeClass = function (className) {\r\n        this.data.classesToRemove.push(className);\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the animation duration (and overrides any defined through CSS)\r\n     * @param duration\r\n     */\r\n    CssAnimationBuilder.prototype.setDuration = function (duration) {\r\n        this.data.duration = duration;\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the animation delay (and overrides any defined through CSS)\r\n     * @param delay\r\n     */\r\n    CssAnimationBuilder.prototype.setDelay = function (delay) {\r\n        this.data.delay = delay;\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets styles for both the initial state and the destination state\r\n     * @param from\r\n     * @param to\r\n     */\r\n    CssAnimationBuilder.prototype.setStyles = function (from, to) {\r\n        return this.setFromStyles(from).setToStyles(to);\r\n    };\r\n    /**\r\n     * Sets the initial styles for the animation\r\n     * @param from\r\n     */\r\n    CssAnimationBuilder.prototype.setFromStyles = function (from) {\r\n        this.data.fromStyles = from;\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the destination styles for the animation\r\n     * @param to\r\n     */\r\n    CssAnimationBuilder.prototype.setToStyles = function (to) {\r\n        this.data.toStyles = to;\r\n        return this;\r\n    };\r\n    /**\r\n     * Starts the animation and returns a promise\r\n     * @param element\r\n     */\r\n    CssAnimationBuilder.prototype.start = function (element) {\r\n        return new animation_1.Animation(element, this.data, this.browserDetails);\r\n    };\r\n    return CssAnimationBuilder;\r\n})();\r\nexports.CssAnimationBuilder = CssAnimationBuilder;\r\n},{\"./animation\":6,\"./css_animation_options\":10}],10:[function(require,module,exports){\n'use strict';var CssAnimationOptions = (function () {\r\n    function CssAnimationOptions() {\r\n        /** classes to be added to the element */\r\n        this.classesToAdd = [];\r\n        /** classes to be removed from the element */\r\n        this.classesToRemove = [];\r\n        /** classes to be added for the duration of the animation */\r\n        this.animationClasses = [];\r\n    }\r\n    return CssAnimationOptions;\r\n})();\r\nexports.CssAnimationOptions = CssAnimationOptions;\r\n},{}],11:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar forms_1 = require('./forms');\r\nvar directives_1 = require('./directives');\r\n/**\r\n * A collection of Angular core directives that are likely to be used in each and every Angular\r\n * application. This includes core directives (e.g., NgIf and NgFor), and forms directives (e.g.,\r\n * NgModel).\r\n *\r\n * This collection can be used to quickly enumerate all the built-in directives in the `directives`\r\n * property of the `@Component` or `@View` decorators.\r\n *\r\n * ### Example\r\n *\r\n * Instead of writing:\r\n *\r\n * ```typescript\r\n * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm} from\r\n * 'angular2/common';\r\n * import {OtherDirective} from './myDirectives';\r\n *\r\n * @Component({\r\n *   selector: 'my-component',\r\n *   templateUrl: 'myComponent.html',\r\n *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm,\r\n * OtherDirective]\r\n * })\r\n * export class MyComponent {\r\n *   ...\r\n * }\r\n * ```\r\n * one could import all the common directives at once:\r\n *\r\n * ```typescript\r\n * import {COMMON_DIRECTIVES} from 'angular2/common';\r\n * import {OtherDirective} from './myDirectives';\r\n *\r\n * @Component({\r\n *   selector: 'my-component',\r\n *   templateUrl: 'myComponent.html',\r\n *   directives: [COMMON_DIRECTIVES, OtherDirective]\r\n * })\r\n * export class MyComponent {\r\n *   ...\r\n * }\r\n * ```\r\n */\r\nexports.COMMON_DIRECTIVES = lang_1.CONST_EXPR([directives_1.CORE_DIRECTIVES, forms_1.FORM_DIRECTIVES]);\r\n},{\"./directives\":12,\"./forms\":20,\"angular2/src/facade/lang\":176}],12:[function(require,module,exports){\n'use strict';function __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n/**\r\n * @module\r\n * @description\r\n * Common directives shipped with Angular.\r\n */\r\nvar ng_class_1 = require('./directives/ng_class');\r\nexports.NgClass = ng_class_1.NgClass;\r\nvar ng_for_1 = require('./directives/ng_for');\r\nexports.NgFor = ng_for_1.NgFor;\r\nvar ng_if_1 = require('./directives/ng_if');\r\nexports.NgIf = ng_if_1.NgIf;\r\nvar ng_style_1 = require('./directives/ng_style');\r\nexports.NgStyle = ng_style_1.NgStyle;\r\nvar ng_switch_1 = require('./directives/ng_switch');\r\nexports.NgSwitch = ng_switch_1.NgSwitch;\r\nexports.NgSwitchWhen = ng_switch_1.NgSwitchWhen;\r\nexports.NgSwitchDefault = ng_switch_1.NgSwitchDefault;\r\n__export(require('./directives/observable_list_diff'));\r\nvar core_directives_1 = require('./directives/core_directives');\r\nexports.CORE_DIRECTIVES = core_directives_1.CORE_DIRECTIVES;\r\n},{\"./directives/core_directives\":13,\"./directives/ng_class\":14,\"./directives/ng_for\":15,\"./directives/ng_if\":16,\"./directives/ng_style\":17,\"./directives/ng_switch\":18,\"./directives/observable_list_diff\":19}],13:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar ng_class_1 = require('./ng_class');\r\nvar ng_for_1 = require('./ng_for');\r\nvar ng_if_1 = require('./ng_if');\r\nvar ng_style_1 = require('./ng_style');\r\nvar ng_switch_1 = require('./ng_switch');\r\n/**\r\n * A collection of Angular core directives that are likely to be used in each and every Angular\r\n * application.\r\n *\r\n * This collection can be used to quickly enumerate all the built-in directives in the `directives`\r\n * property of the `@View` annotation.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/yakGwpCdUkg0qfzX5m8g?p=preview))\r\n *\r\n * Instead of writing:\r\n *\r\n * ```typescript\r\n * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/common';\r\n * import {OtherDirective} from './myDirectives';\r\n *\r\n * @Component({\r\n *   selector: 'my-component',\r\n *   templateUrl: 'myComponent.html',\r\n *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]\r\n * })\r\n * export class MyComponent {\r\n *   ...\r\n * }\r\n * ```\r\n * one could import all the core directives at once:\r\n *\r\n * ```typescript\r\n * import {CORE_DIRECTIVES} from 'angular2/common';\r\n * import {OtherDirective} from './myDirectives';\r\n *\r\n * @Component({\r\n *   selector: 'my-component',\r\n *   templateUrl: 'myComponent.html',\r\n *   directives: [CORE_DIRECTIVES, OtherDirective]\r\n * })\r\n * export class MyComponent {\r\n *   ...\r\n * }\r\n * ```\r\n */\r\nexports.CORE_DIRECTIVES = lang_1.CONST_EXPR([ng_class_1.NgClass, ng_for_1.NgFor, ng_if_1.NgIf, ng_style_1.NgStyle, ng_switch_1.NgSwitch, ng_switch_1.NgSwitchWhen, ng_switch_1.NgSwitchDefault]);\r\n},{\"./ng_class\":14,\"./ng_for\":15,\"./ng_if\":16,\"./ng_style\":17,\"./ng_switch\":18,\"angular2/src/facade/lang\":176}],14:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar core_1 = require('angular2/core');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\n/**\r\n * The `NgClass` directive conditionally adds and removes CSS classes on an HTML element based on\r\n * an expression's evaluation result.\r\n *\r\n * The result of an expression evaluation is interpreted differently depending on type of\r\n * the expression evaluation result:\r\n * - `string` - all the CSS classes listed in a string (space delimited) are added\r\n * - `Array` - all the CSS classes (Array elements) are added\r\n * - `Object` - each key corresponds to a CSS class name while values are interpreted as expressions\r\n * evaluating to `Boolean`. If a given expression evaluates to `true` a corresponding CSS class\r\n * is added - otherwise it is removed.\r\n *\r\n * While the `NgClass` directive can interpret expressions evaluating to `string`, `Array`\r\n * or `Object`, the `Object`-based version is the most often used and has an advantage of keeping\r\n * all the CSS class names in a template.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/a4YdtmWywhJ33uqfpPPn?p=preview)):\r\n *\r\n * ```\r\n * import {Component} from 'angular2/core';\r\n * import {NgClass} from 'angular2/common';\r\n *\r\n * @Component({\r\n *   selector: 'toggle-button',\r\n *   inputs: ['isDisabled'],\r\n *   template: `\r\n *      <div class=\"button\" [ngClass]=\"{active: isOn, disabled: isDisabled}\"\r\n *          (click)=\"toggle(!isOn)\">\r\n *          Click me!\r\n *      </div>`,\r\n *   styles: [`\r\n *     .button {\r\n *       width: 120px;\r\n *       border: medium solid black;\r\n *     }\r\n *\r\n *     .active {\r\n *       background-color: red;\r\n *    }\r\n *\r\n *     .disabled {\r\n *       color: gray;\r\n *       border: medium solid gray;\r\n *     }\r\n *   `]\r\n *   directives: [NgClass]\r\n * })\r\n * class ToggleButton {\r\n *   isOn = false;\r\n *   isDisabled = false;\r\n *\r\n *   toggle(newState) {\r\n *     if (!this.isDisabled) {\r\n *       this.isOn = newState;\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n */\r\nvar NgClass = (function () {\r\n    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {\r\n        this._iterableDiffers = _iterableDiffers;\r\n        this._keyValueDiffers = _keyValueDiffers;\r\n        this._ngEl = _ngEl;\r\n        this._renderer = _renderer;\r\n        this._initialClasses = [];\r\n    }\r\n    Object.defineProperty(NgClass.prototype, \"initialClasses\", {\r\n        set: function (v) {\r\n            this._applyInitialClasses(true);\r\n            this._initialClasses = lang_1.isPresent(v) && lang_1.isString(v) ? v.split(' ') : [];\r\n            this._applyInitialClasses(false);\r\n            this._applyClasses(this._rawClass, false);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgClass.prototype, \"rawClass\", {\r\n        set: function (v) {\r\n            this._cleanupClasses(this._rawClass);\r\n            if (lang_1.isString(v)) {\r\n                v = v.split(' ');\r\n            }\r\n            this._rawClass = v;\r\n            if (lang_1.isPresent(v)) {\r\n                if (collection_1.isListLikeIterable(v)) {\r\n                    this._differ = this._iterableDiffers.find(v).create(null);\r\n                    this._mode = 'iterable';\r\n                }\r\n                else {\r\n                    this._differ = this._keyValueDiffers.find(v).create(null);\r\n                    this._mode = 'keyValue';\r\n                }\r\n            }\r\n            else {\r\n                this._differ = null;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgClass.prototype.ngDoCheck = function () {\r\n        if (lang_1.isPresent(this._differ)) {\r\n            var changes = this._differ.diff(this._rawClass);\r\n            if (lang_1.isPresent(changes)) {\r\n                if (this._mode == 'iterable') {\r\n                    this._applyIterableChanges(changes);\r\n                }\r\n                else {\r\n                    this._applyKeyValueChanges(changes);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    NgClass.prototype.ngOnDestroy = function () { this._cleanupClasses(this._rawClass); };\r\n    NgClass.prototype._cleanupClasses = function (rawClassVal) {\r\n        this._applyClasses(rawClassVal, true);\r\n        this._applyInitialClasses(false);\r\n    };\r\n    NgClass.prototype._applyKeyValueChanges = function (changes) {\r\n        var _this = this;\r\n        changes.forEachAddedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });\r\n        changes.forEachChangedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });\r\n        changes.forEachRemovedItem(function (record) {\r\n            if (record.previousValue) {\r\n                _this._toggleClass(record.key, false);\r\n            }\r\n        });\r\n    };\r\n    NgClass.prototype._applyIterableChanges = function (changes) {\r\n        var _this = this;\r\n        changes.forEachAddedItem(function (record) { _this._toggleClass(record.item, true); });\r\n        changes.forEachRemovedItem(function (record) { _this._toggleClass(record.item, false); });\r\n    };\r\n    NgClass.prototype._applyInitialClasses = function (isCleanup) {\r\n        var _this = this;\r\n        this._initialClasses.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });\r\n    };\r\n    NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {\r\n        var _this = this;\r\n        if (lang_1.isPresent(rawClassVal)) {\r\n            if (lang_1.isArray(rawClassVal)) {\r\n                rawClassVal.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });\r\n            }\r\n            else if (rawClassVal instanceof Set) {\r\n                rawClassVal.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });\r\n            }\r\n            else {\r\n                collection_1.StringMapWrapper.forEach(rawClassVal, function (expVal, className) {\r\n                    if (expVal)\r\n                        _this._toggleClass(className, !isCleanup);\r\n                });\r\n            }\r\n        }\r\n    };\r\n    NgClass.prototype._toggleClass = function (className, enabled) {\r\n        className = className.trim();\r\n        if (className.length > 0) {\r\n            if (className.indexOf(' ') > -1) {\r\n                var classes = className.split(/\\s+/g);\r\n                for (var i = 0, len = classes.length; i < len; i++) {\r\n                    this._renderer.setElementClass(this._ngEl.nativeElement, classes[i], enabled);\r\n                }\r\n            }\r\n            else {\r\n                this._renderer.setElementClass(this._ngEl.nativeElement, className, enabled);\r\n            }\r\n        }\r\n    };\r\n    NgClass = __decorate([\r\n        core_1.Directive({ selector: '[ngClass]', inputs: ['rawClass: ngClass', 'initialClasses: class'] }), \r\n        __metadata('design:paramtypes', [core_1.IterableDiffers, core_1.KeyValueDiffers, core_1.ElementRef, core_1.Renderer])\r\n    ], NgClass);\r\n    return NgClass;\r\n})();\r\nexports.NgClass = NgClass;\r\n},{\"angular2/core\":3,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],15:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * The `NgFor` directive instantiates a template once per item from an iterable. The context for\r\n * each instantiated template inherits from the outer context with the given loop variable set\r\n * to the current item from the iterable.\r\n *\r\n * # Local Variables\r\n *\r\n * `NgFor` provides several exported values that can be aliased to local variables:\r\n *\r\n * * `index` will be set to the current loop iteration for each template context.\r\n * * `last` will be set to a boolean value indicating whether the item is the last one in the\r\n *   iteration.\r\n * * `even` will be set to a boolean value indicating whether this item has an even index.\r\n * * `odd` will be set to a boolean value indicating whether this item has an odd index.\r\n *\r\n * # Change Propagation\r\n *\r\n * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:\r\n *\r\n * * When an item is added, a new instance of the template is added to the DOM.\r\n * * When an item is removed, its template instance is removed from the DOM.\r\n * * When items are reordered, their respective templates are reordered in the DOM.\r\n * * Otherwise, the DOM element for that item will remain the same.\r\n *\r\n * Angular uses object identity to track insertions and deletions within the iterator and reproduce\r\n * those changes in the DOM. This has important implications for animations and any stateful\r\n * controls\r\n * (such as `<input>` elements which accept user input) that are present. Inserted rows can be\r\n * animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state such\r\n * as user input.\r\n *\r\n * It is possible for the identities of elements in the iterator to change while the data does not.\r\n * This can happen, for example, if the iterator produced from an RPC to the server, and that\r\n * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with\r\n * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old\r\n * elements were deleted and all new elements inserted). This is an expensive operation and should\r\n * be avoided if possible.\r\n *\r\n * # Syntax\r\n *\r\n * - `<li *ngFor=\"#item of items; #i = index\">...</li>`\r\n * - `<li template=\"ngFor #item of items; #i = index\">...</li>`\r\n * - `<template ngFor #item [ngForOf]=\"items\" #i=\"index\"><li>...</li></template>`\r\n *\r\n * ### Example\r\n *\r\n * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed\r\n * example.\r\n */\r\nvar NgFor = (function () {\r\n    function NgFor(_viewContainer, _templateRef, _iterableDiffers, _cdr) {\r\n        this._viewContainer = _viewContainer;\r\n        this._templateRef = _templateRef;\r\n        this._iterableDiffers = _iterableDiffers;\r\n        this._cdr = _cdr;\r\n    }\r\n    Object.defineProperty(NgFor.prototype, \"ngForOf\", {\r\n        set: function (value) {\r\n            this._ngForOf = value;\r\n            if (lang_1.isBlank(this._differ) && lang_1.isPresent(value)) {\r\n                this._differ = this._iterableDiffers.find(value).create(this._cdr);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgFor.prototype, \"ngForTemplate\", {\r\n        set: function (value) {\r\n            if (lang_1.isPresent(value)) {\r\n                this._templateRef = value;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgFor.prototype.ngDoCheck = function () {\r\n        if (lang_1.isPresent(this._differ)) {\r\n            var changes = this._differ.diff(this._ngForOf);\r\n            if (lang_1.isPresent(changes))\r\n                this._applyChanges(changes);\r\n        }\r\n    };\r\n    NgFor.prototype._applyChanges = function (changes) {\r\n        // TODO(rado): check if change detection can produce a change record that is\r\n        // easier to consume than current.\r\n        var recordViewTuples = [];\r\n        changes.forEachRemovedItem(function (removedRecord) {\r\n            return recordViewTuples.push(new RecordViewTuple(removedRecord, null));\r\n        });\r\n        changes.forEachMovedItem(function (movedRecord) {\r\n            return recordViewTuples.push(new RecordViewTuple(movedRecord, null));\r\n        });\r\n        var insertTuples = this._bulkRemove(recordViewTuples);\r\n        changes.forEachAddedItem(function (addedRecord) {\r\n            return insertTuples.push(new RecordViewTuple(addedRecord, null));\r\n        });\r\n        this._bulkInsert(insertTuples);\r\n        for (var i = 0; i < insertTuples.length; i++) {\r\n            this._perViewChange(insertTuples[i].view, insertTuples[i].record);\r\n        }\r\n        for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {\r\n            var viewRef = this._viewContainer.get(i);\r\n            viewRef.setLocal('last', i === ilen - 1);\r\n        }\r\n    };\r\n    NgFor.prototype._perViewChange = function (view, record) {\r\n        view.setLocal('\\$implicit', record.item);\r\n        view.setLocal('index', record.currentIndex);\r\n        view.setLocal('even', (record.currentIndex % 2 == 0));\r\n        view.setLocal('odd', (record.currentIndex % 2 == 1));\r\n    };\r\n    NgFor.prototype._bulkRemove = function (tuples) {\r\n        tuples.sort(function (a, b) { return a.record.previousIndex - b.record.previousIndex; });\r\n        var movedTuples = [];\r\n        for (var i = tuples.length - 1; i >= 0; i--) {\r\n            var tuple = tuples[i];\r\n            // separate moved views from removed views.\r\n            if (lang_1.isPresent(tuple.record.currentIndex)) {\r\n                tuple.view = this._viewContainer.detach(tuple.record.previousIndex);\r\n                movedTuples.push(tuple);\r\n            }\r\n            else {\r\n                this._viewContainer.remove(tuple.record.previousIndex);\r\n            }\r\n        }\r\n        return movedTuples;\r\n    };\r\n    NgFor.prototype._bulkInsert = function (tuples) {\r\n        tuples.sort(function (a, b) { return a.record.currentIndex - b.record.currentIndex; });\r\n        for (var i = 0; i < tuples.length; i++) {\r\n            var tuple = tuples[i];\r\n            if (lang_1.isPresent(tuple.view)) {\r\n                this._viewContainer.insert(tuple.view, tuple.record.currentIndex);\r\n            }\r\n            else {\r\n                tuple.view =\r\n                    this._viewContainer.createEmbeddedView(this._templateRef, tuple.record.currentIndex);\r\n            }\r\n        }\r\n        return tuples;\r\n    };\r\n    NgFor = __decorate([\r\n        core_1.Directive({ selector: '[ngFor][ngForOf]', inputs: ['ngForOf', 'ngForTemplate'] }), \r\n        __metadata('design:paramtypes', [core_1.ViewContainerRef, core_1.TemplateRef, core_1.IterableDiffers, core_1.ChangeDetectorRef])\r\n    ], NgFor);\r\n    return NgFor;\r\n})();\r\nexports.NgFor = NgFor;\r\nvar RecordViewTuple = (function () {\r\n    function RecordViewTuple(record, view) {\r\n        this.record = record;\r\n        this.view = view;\r\n    }\r\n    return RecordViewTuple;\r\n})();\r\n},{\"angular2/core\":3,\"angular2/src/facade/lang\":176}],16:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * Removes or recreates a portion of the DOM tree based on an {expression}.\r\n *\r\n * If the expression assigned to `ngIf` evaluates to a false value then the element\r\n * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):\r\n *\r\n * ```\r\n * <div *ngIf=\"errorCount > 0\" class=\"error\">\r\n *   <!-- Error message displayed when the errorCount property on the current context is greater\r\n * than 0. -->\r\n *   {{errorCount}} errors detected\r\n * </div>\r\n * ```\r\n *\r\n * ### Syntax\r\n *\r\n * - `<div *ngIf=\"condition\">...</div>`\r\n * - `<div template=\"ngIf condition\">...</div>`\r\n * - `<template [ngIf]=\"condition\"><div>...</div></template>`\r\n */\r\nvar NgIf = (function () {\r\n    function NgIf(_viewContainer, _templateRef) {\r\n        this._viewContainer = _viewContainer;\r\n        this._templateRef = _templateRef;\r\n        this._prevCondition = null;\r\n    }\r\n    Object.defineProperty(NgIf.prototype, \"ngIf\", {\r\n        set: function (newCondition /* boolean */) {\r\n            if (newCondition && (lang_1.isBlank(this._prevCondition) || !this._prevCondition)) {\r\n                this._prevCondition = true;\r\n                this._viewContainer.createEmbeddedView(this._templateRef);\r\n            }\r\n            else if (!newCondition && (lang_1.isBlank(this._prevCondition) || this._prevCondition)) {\r\n                this._prevCondition = false;\r\n                this._viewContainer.clear();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgIf = __decorate([\r\n        core_1.Directive({ selector: '[ngIf]', inputs: ['ngIf'] }), \r\n        __metadata('design:paramtypes', [core_1.ViewContainerRef, core_1.TemplateRef])\r\n    ], NgIf);\r\n    return NgIf;\r\n})();\r\nexports.NgIf = NgIf;\r\n},{\"angular2/core\":3,\"angular2/src/facade/lang\":176}],17:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * The `NgStyle` directive changes styles based on a result of expression evaluation.\r\n *\r\n * An expression assigned to the `ngStyle` property must evaluate to an object and the\r\n * corresponding element styles are updated based on changes to this object. Style names to update\r\n * are taken from the object's keys, and values - from the corresponding object's values.\r\n *\r\n * ### Syntax\r\n *\r\n * - `<div [ngStyle]=\"{'font-style': style}\"></div>`\r\n * - `<div [ngStyle]=\"styleExp\"></div>` - here the `styleExp` must evaluate to an object\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/YamGS6GkUh9GqWNQhCyM?p=preview)):\r\n *\r\n * ```\r\n * import {Component} from 'angular2/core';\r\n * import {NgStyle} from 'angular2/common';\r\n *\r\n * @Component({\r\n *  selector: 'ngStyle-example',\r\n *  template: `\r\n *    <h1 [ngStyle]=\"{'font-style': style, 'font-size': size, 'font-weight': weight}\">\r\n *      Change style of this text!\r\n *    </h1>\r\n *\r\n *    <hr>\r\n *\r\n *    <label>Italic: <input type=\"checkbox\" (change)=\"changeStyle($event)\"></label>\r\n *    <label>Bold: <input type=\"checkbox\" (change)=\"changeWeight($event)\"></label>\r\n *    <label>Size: <input type=\"text\" [value]=\"size\" (change)=\"size = $event.target.value\"></label>\r\n *  `,\r\n *  directives: [NgStyle]\r\n * })\r\n * export class NgStyleExample {\r\n *    style = 'normal';\r\n *    weight = 'normal';\r\n *    size = '20px';\r\n *\r\n *    changeStyle($event: any) {\r\n *      this.style = $event.target.checked ? 'italic' : 'normal';\r\n *    }\r\n *\r\n *    changeWeight($event: any) {\r\n *      this.weight = $event.target.checked ? 'bold' : 'normal';\r\n *    }\r\n * }\r\n * ```\r\n *\r\n * In this example the `font-style`, `font-size` and `font-weight` styles will be updated\r\n * based on the `style` property's value changes.\r\n */\r\nvar NgStyle = (function () {\r\n    function NgStyle(_differs, _ngEl, _renderer) {\r\n        this._differs = _differs;\r\n        this._ngEl = _ngEl;\r\n        this._renderer = _renderer;\r\n    }\r\n    Object.defineProperty(NgStyle.prototype, \"rawStyle\", {\r\n        set: function (v) {\r\n            this._rawStyle = v;\r\n            if (lang_1.isBlank(this._differ) && lang_1.isPresent(v)) {\r\n                this._differ = this._differs.find(this._rawStyle).create(null);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgStyle.prototype.ngDoCheck = function () {\r\n        if (lang_1.isPresent(this._differ)) {\r\n            var changes = this._differ.diff(this._rawStyle);\r\n            if (lang_1.isPresent(changes)) {\r\n                this._applyChanges(changes);\r\n            }\r\n        }\r\n    };\r\n    NgStyle.prototype._applyChanges = function (changes) {\r\n        var _this = this;\r\n        changes.forEachAddedItem(function (record) { _this._setStyle(record.key, record.currentValue); });\r\n        changes.forEachChangedItem(function (record) { _this._setStyle(record.key, record.currentValue); });\r\n        changes.forEachRemovedItem(function (record) { _this._setStyle(record.key, null); });\r\n    };\r\n    NgStyle.prototype._setStyle = function (name, val) {\r\n        this._renderer.setElementStyle(this._ngEl.nativeElement, name, val);\r\n    };\r\n    NgStyle = __decorate([\r\n        core_1.Directive({ selector: '[ngStyle]', inputs: ['rawStyle: ngStyle'] }), \r\n        __metadata('design:paramtypes', [core_1.KeyValueDiffers, core_1.ElementRef, core_1.Renderer])\r\n    ], NgStyle);\r\n    return NgStyle;\r\n})();\r\nexports.NgStyle = NgStyle;\r\n},{\"angular2/core\":3,\"angular2/src/facade/lang\":176}],18:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar _WHEN_DEFAULT = lang_1.CONST_EXPR(new Object());\r\nvar SwitchView = (function () {\r\n    function SwitchView(_viewContainerRef, _templateRef) {\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._templateRef = _templateRef;\r\n    }\r\n    SwitchView.prototype.create = function () { this._viewContainerRef.createEmbeddedView(this._templateRef); };\r\n    SwitchView.prototype.destroy = function () { this._viewContainerRef.clear(); };\r\n    return SwitchView;\r\n})();\r\n/**\r\n * Adds or removes DOM sub-trees when their match expressions match the switch expression.\r\n *\r\n * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be\r\n * preserved at the location as specified in the template.\r\n *\r\n * `NgSwitch` simply inserts nested elements based on which match expression matches the value\r\n * obtained from the evaluated switch expression. In other words, you define a container element\r\n * (where you place the directive with a switch expression on the\r\n * **`[ngSwitch]=\"...\"` attribute**), define any inner elements inside of the directive and\r\n * place a `[ngSwitchWhen]` attribute per element.\r\n *\r\n * The `ngSwitchWhen` property is used to inform `NgSwitch` which element to display when the\r\n * expression is evaluated. If a matching expression is not found via a `ngSwitchWhen` property\r\n * then an element with the `ngSwitchDefault` attribute is displayed.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/DQMTII95CbuqWrl3lYAs?p=preview))\r\n *\r\n * ```typescript\r\n * @Component({selector: 'app'})\r\n * @View({\r\n *   template: `\r\n *     <p>Value = {{value}}</p>\r\n *     <button (click)=\"inc()\">Increment</button>\r\n *\r\n *     <div [ngSwitch]=\"value\">\r\n *       <p *ngSwitchWhen=\"'init'\">increment to start</p>\r\n *       <p *ngSwitchWhen=\"0\">0, increment again</p>\r\n *       <p *ngSwitchWhen=\"1\">1, increment again</p>\r\n *       <p *ngSwitchWhen=\"2\">2, stop incrementing</p>\r\n *       <p *ngSwitchDefault>&gt; 2, STOP!</p>\r\n *     </div>\r\n *\r\n *     <!-- alternate syntax -->\r\n *\r\n *     <p [ngSwitch]=\"value\">\r\n *       <template ngSwitchWhen=\"init\">increment to start</template>\r\n *       <template [ngSwitchWhen]=\"0\">0, increment again</template>\r\n *       <template [ngSwitchWhen]=\"1\">1, increment again</template>\r\n *       <template [ngSwitchWhen]=\"2\">2, stop incrementing</template>\r\n *       <template ngSwitchDefault>&gt; 2, STOP!</template>\r\n *     </p>\r\n *   `,\r\n *   directives: [NgSwitch, NgSwitchWhen, NgSwitchDefault]\r\n * })\r\n * export class App {\r\n *   value = 'init';\r\n *\r\n *   inc() {\r\n *     this.value = this.value === 'init' ? 0 : this.value + 1;\r\n *   }\r\n * }\r\n *\r\n * bootstrap(App).catch(err => console.error(err));\r\n * ```\r\n */\r\nvar NgSwitch = (function () {\r\n    function NgSwitch() {\r\n        this._useDefault = false;\r\n        this._valueViews = new collection_1.Map();\r\n        this._activeViews = [];\r\n    }\r\n    Object.defineProperty(NgSwitch.prototype, \"ngSwitch\", {\r\n        set: function (value) {\r\n            // Empty the currently active ViewContainers\r\n            this._emptyAllActiveViews();\r\n            // Add the ViewContainers matching the value (with a fallback to default)\r\n            this._useDefault = false;\r\n            var views = this._valueViews.get(value);\r\n            if (lang_1.isBlank(views)) {\r\n                this._useDefault = true;\r\n                views = lang_1.normalizeBlank(this._valueViews.get(_WHEN_DEFAULT));\r\n            }\r\n            this._activateViews(views);\r\n            this._switchValue = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @internal */\r\n    NgSwitch.prototype._onWhenValueChanged = function (oldWhen, newWhen, view) {\r\n        this._deregisterView(oldWhen, view);\r\n        this._registerView(newWhen, view);\r\n        if (oldWhen === this._switchValue) {\r\n            view.destroy();\r\n            collection_1.ListWrapper.remove(this._activeViews, view);\r\n        }\r\n        else if (newWhen === this._switchValue) {\r\n            if (this._useDefault) {\r\n                this._useDefault = false;\r\n                this._emptyAllActiveViews();\r\n            }\r\n            view.create();\r\n            this._activeViews.push(view);\r\n        }\r\n        // Switch to default when there is no more active ViewContainers\r\n        if (this._activeViews.length === 0 && !this._useDefault) {\r\n            this._useDefault = true;\r\n            this._activateViews(this._valueViews.get(_WHEN_DEFAULT));\r\n        }\r\n    };\r\n    /** @internal */\r\n    NgSwitch.prototype._emptyAllActiveViews = function () {\r\n        var activeContainers = this._activeViews;\r\n        for (var i = 0; i < activeContainers.length; i++) {\r\n            activeContainers[i].destroy();\r\n        }\r\n        this._activeViews = [];\r\n    };\r\n    /** @internal */\r\n    NgSwitch.prototype._activateViews = function (views) {\r\n        // TODO(vicb): assert(this._activeViews.length === 0);\r\n        if (lang_1.isPresent(views)) {\r\n            for (var i = 0; i < views.length; i++) {\r\n                views[i].create();\r\n            }\r\n            this._activeViews = views;\r\n        }\r\n    };\r\n    /** @internal */\r\n    NgSwitch.prototype._registerView = function (value, view) {\r\n        var views = this._valueViews.get(value);\r\n        if (lang_1.isBlank(views)) {\r\n            views = [];\r\n            this._valueViews.set(value, views);\r\n        }\r\n        views.push(view);\r\n    };\r\n    /** @internal */\r\n    NgSwitch.prototype._deregisterView = function (value, view) {\r\n        // `_WHEN_DEFAULT` is used a marker for non-registered whens\r\n        if (value === _WHEN_DEFAULT)\r\n            return;\r\n        var views = this._valueViews.get(value);\r\n        if (views.length == 1) {\r\n            this._valueViews.delete(value);\r\n        }\r\n        else {\r\n            collection_1.ListWrapper.remove(views, view);\r\n        }\r\n    };\r\n    NgSwitch = __decorate([\r\n        core_1.Directive({ selector: '[ngSwitch]', inputs: ['ngSwitch'] }), \r\n        __metadata('design:paramtypes', [])\r\n    ], NgSwitch);\r\n    return NgSwitch;\r\n})();\r\nexports.NgSwitch = NgSwitch;\r\n/**\r\n * Insert the sub-tree when the `ngSwitchWhen` expression evaluates to the same value as the\r\n * enclosing switch expression.\r\n *\r\n * If multiple match expression match the switch expression value, all of them are displayed.\r\n *\r\n * See {@link NgSwitch} for more details and example.\r\n */\r\nvar NgSwitchWhen = (function () {\r\n    function NgSwitchWhen(viewContainer, templateRef, ngSwitch) {\r\n        // `_WHEN_DEFAULT` is used as a marker for a not yet initialized value\r\n        /** @internal */\r\n        this._value = _WHEN_DEFAULT;\r\n        this._switch = ngSwitch;\r\n        this._view = new SwitchView(viewContainer, templateRef);\r\n    }\r\n    Object.defineProperty(NgSwitchWhen.prototype, \"ngSwitchWhen\", {\r\n        set: function (value) {\r\n            this._switch._onWhenValueChanged(this._value, value, this._view);\r\n            this._value = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgSwitchWhen = __decorate([\r\n        core_1.Directive({ selector: '[ngSwitchWhen]', inputs: ['ngSwitchWhen'] }),\r\n        __param(2, core_1.Host()), \r\n        __metadata('design:paramtypes', [core_1.ViewContainerRef, core_1.TemplateRef, NgSwitch])\r\n    ], NgSwitchWhen);\r\n    return NgSwitchWhen;\r\n})();\r\nexports.NgSwitchWhen = NgSwitchWhen;\r\n/**\r\n * Default case statements are displayed when no match expression matches the switch expression\r\n * value.\r\n *\r\n * See {@link NgSwitch} for more details and example.\r\n */\r\nvar NgSwitchDefault = (function () {\r\n    function NgSwitchDefault(viewContainer, templateRef, sswitch) {\r\n        sswitch._registerView(_WHEN_DEFAULT, new SwitchView(viewContainer, templateRef));\r\n    }\r\n    NgSwitchDefault = __decorate([\r\n        core_1.Directive({ selector: '[ngSwitchDefault]' }),\r\n        __param(2, core_1.Host()), \r\n        __metadata('design:paramtypes', [core_1.ViewContainerRef, core_1.TemplateRef, NgSwitch])\r\n    ], NgSwitchDefault);\r\n    return NgSwitchDefault;\r\n})();\r\nexports.NgSwitchDefault = NgSwitchDefault;\r\n},{\"angular2/core\":3,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],19:[function(require,module,exports){\n'use strict';// TS does not have Observables\r\n},{}],20:[function(require,module,exports){\n'use strict';/**\r\n * @module\r\n * @description\r\n * This module is used for handling user input, by defining and building a {@link ControlGroup} that\r\n * consists of\r\n * {@link Control} objects, and mapping them onto the DOM. {@link Control} objects can then be used\r\n * to read information\r\n * from the form DOM elements.\r\n *\r\n * This module is not included in the `angular2` module; you must import the forms module\r\n * explicitly.\r\n *\r\n */\r\nvar model_1 = require('./forms/model');\r\nexports.AbstractControl = model_1.AbstractControl;\r\nexports.Control = model_1.Control;\r\nexports.ControlGroup = model_1.ControlGroup;\r\nexports.ControlArray = model_1.ControlArray;\r\nvar abstract_control_directive_1 = require('./forms/directives/abstract_control_directive');\r\nexports.AbstractControlDirective = abstract_control_directive_1.AbstractControlDirective;\r\nvar control_container_1 = require('./forms/directives/control_container');\r\nexports.ControlContainer = control_container_1.ControlContainer;\r\nvar ng_control_name_1 = require('./forms/directives/ng_control_name');\r\nexports.NgControlName = ng_control_name_1.NgControlName;\r\nvar ng_form_control_1 = require('./forms/directives/ng_form_control');\r\nexports.NgFormControl = ng_form_control_1.NgFormControl;\r\nvar ng_model_1 = require('./forms/directives/ng_model');\r\nexports.NgModel = ng_model_1.NgModel;\r\nvar ng_control_1 = require('./forms/directives/ng_control');\r\nexports.NgControl = ng_control_1.NgControl;\r\nvar ng_control_group_1 = require('./forms/directives/ng_control_group');\r\nexports.NgControlGroup = ng_control_group_1.NgControlGroup;\r\nvar ng_form_model_1 = require('./forms/directives/ng_form_model');\r\nexports.NgFormModel = ng_form_model_1.NgFormModel;\r\nvar ng_form_1 = require('./forms/directives/ng_form');\r\nexports.NgForm = ng_form_1.NgForm;\r\nvar control_value_accessor_1 = require('./forms/directives/control_value_accessor');\r\nexports.NG_VALUE_ACCESSOR = control_value_accessor_1.NG_VALUE_ACCESSOR;\r\nvar default_value_accessor_1 = require('./forms/directives/default_value_accessor');\r\nexports.DefaultValueAccessor = default_value_accessor_1.DefaultValueAccessor;\r\nvar ng_control_status_1 = require('./forms/directives/ng_control_status');\r\nexports.NgControlStatus = ng_control_status_1.NgControlStatus;\r\nvar checkbox_value_accessor_1 = require('./forms/directives/checkbox_value_accessor');\r\nexports.CheckboxControlValueAccessor = checkbox_value_accessor_1.CheckboxControlValueAccessor;\r\nvar select_control_value_accessor_1 = require('./forms/directives/select_control_value_accessor');\r\nexports.NgSelectOption = select_control_value_accessor_1.NgSelectOption;\r\nexports.SelectControlValueAccessor = select_control_value_accessor_1.SelectControlValueAccessor;\r\nvar directives_1 = require('./forms/directives');\r\nexports.FORM_DIRECTIVES = directives_1.FORM_DIRECTIVES;\r\nvar validators_1 = require('./forms/validators');\r\nexports.NG_VALIDATORS = validators_1.NG_VALIDATORS;\r\nexports.NG_ASYNC_VALIDATORS = validators_1.NG_ASYNC_VALIDATORS;\r\nexports.Validators = validators_1.Validators;\r\nvar validators_2 = require('./forms/directives/validators');\r\nexports.RequiredValidator = validators_2.RequiredValidator;\r\nexports.MinLengthValidator = validators_2.MinLengthValidator;\r\nexports.MaxLengthValidator = validators_2.MaxLengthValidator;\r\nvar form_builder_1 = require('./forms/form_builder');\r\nexports.FormBuilder = form_builder_1.FormBuilder;\r\nexports.FORM_PROVIDERS = form_builder_1.FORM_PROVIDERS;\r\nexports.FORM_BINDINGS = form_builder_1.FORM_BINDINGS;\r\n},{\"./forms/directives\":21,\"./forms/directives/abstract_control_directive\":22,\"./forms/directives/checkbox_value_accessor\":23,\"./forms/directives/control_container\":24,\"./forms/directives/control_value_accessor\":25,\"./forms/directives/default_value_accessor\":26,\"./forms/directives/ng_control\":27,\"./forms/directives/ng_control_group\":28,\"./forms/directives/ng_control_name\":29,\"./forms/directives/ng_control_status\":30,\"./forms/directives/ng_form\":31,\"./forms/directives/ng_form_control\":32,\"./forms/directives/ng_form_model\":33,\"./forms/directives/ng_model\":34,\"./forms/directives/select_control_value_accessor\":37,\"./forms/directives/validators\":39,\"./forms/form_builder\":40,\"./forms/model\":41,\"./forms/validators\":42}],21:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar ng_control_name_1 = require('./directives/ng_control_name');\r\nvar ng_form_control_1 = require('./directives/ng_form_control');\r\nvar ng_model_1 = require('./directives/ng_model');\r\nvar ng_control_group_1 = require('./directives/ng_control_group');\r\nvar ng_form_model_1 = require('./directives/ng_form_model');\r\nvar ng_form_1 = require('./directives/ng_form');\r\nvar default_value_accessor_1 = require('./directives/default_value_accessor');\r\nvar checkbox_value_accessor_1 = require('./directives/checkbox_value_accessor');\r\nvar number_value_accessor_1 = require('./directives/number_value_accessor');\r\nvar ng_control_status_1 = require('./directives/ng_control_status');\r\nvar select_control_value_accessor_1 = require('./directives/select_control_value_accessor');\r\nvar validators_1 = require('./directives/validators');\r\nvar ng_control_name_2 = require('./directives/ng_control_name');\r\nexports.NgControlName = ng_control_name_2.NgControlName;\r\nvar ng_form_control_2 = require('./directives/ng_form_control');\r\nexports.NgFormControl = ng_form_control_2.NgFormControl;\r\nvar ng_model_2 = require('./directives/ng_model');\r\nexports.NgModel = ng_model_2.NgModel;\r\nvar ng_control_group_2 = require('./directives/ng_control_group');\r\nexports.NgControlGroup = ng_control_group_2.NgControlGroup;\r\nvar ng_form_model_2 = require('./directives/ng_form_model');\r\nexports.NgFormModel = ng_form_model_2.NgFormModel;\r\nvar ng_form_2 = require('./directives/ng_form');\r\nexports.NgForm = ng_form_2.NgForm;\r\nvar default_value_accessor_2 = require('./directives/default_value_accessor');\r\nexports.DefaultValueAccessor = default_value_accessor_2.DefaultValueAccessor;\r\nvar checkbox_value_accessor_2 = require('./directives/checkbox_value_accessor');\r\nexports.CheckboxControlValueAccessor = checkbox_value_accessor_2.CheckboxControlValueAccessor;\r\nvar number_value_accessor_2 = require('./directives/number_value_accessor');\r\nexports.NumberValueAccessor = number_value_accessor_2.NumberValueAccessor;\r\nvar ng_control_status_2 = require('./directives/ng_control_status');\r\nexports.NgControlStatus = ng_control_status_2.NgControlStatus;\r\nvar select_control_value_accessor_2 = require('./directives/select_control_value_accessor');\r\nexports.SelectControlValueAccessor = select_control_value_accessor_2.SelectControlValueAccessor;\r\nexports.NgSelectOption = select_control_value_accessor_2.NgSelectOption;\r\nvar validators_2 = require('./directives/validators');\r\nexports.RequiredValidator = validators_2.RequiredValidator;\r\nexports.MinLengthValidator = validators_2.MinLengthValidator;\r\nexports.MaxLengthValidator = validators_2.MaxLengthValidator;\r\nvar ng_control_1 = require('./directives/ng_control');\r\nexports.NgControl = ng_control_1.NgControl;\r\n/**\r\n *\r\n * A list of all the form directives used as part of a `@View` annotation.\r\n *\r\n *  This is a shorthand for importing them each individually.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * @Component({\r\n *   selector: 'my-app',\r\n *   directives: [FORM_DIRECTIVES]\r\n * })\r\n * class MyApp {}\r\n * ```\r\n */\r\nexports.FORM_DIRECTIVES = lang_1.CONST_EXPR([\r\n    ng_control_name_1.NgControlName,\r\n    ng_control_group_1.NgControlGroup,\r\n    ng_form_control_1.NgFormControl,\r\n    ng_model_1.NgModel,\r\n    ng_form_model_1.NgFormModel,\r\n    ng_form_1.NgForm,\r\n    select_control_value_accessor_1.NgSelectOption,\r\n    default_value_accessor_1.DefaultValueAccessor,\r\n    number_value_accessor_1.NumberValueAccessor,\r\n    checkbox_value_accessor_1.CheckboxControlValueAccessor,\r\n    select_control_value_accessor_1.SelectControlValueAccessor,\r\n    ng_control_status_1.NgControlStatus,\r\n    validators_1.RequiredValidator,\r\n    validators_1.MinLengthValidator,\r\n    validators_1.MaxLengthValidator\r\n]);\r\n},{\"./directives/checkbox_value_accessor\":23,\"./directives/default_value_accessor\":26,\"./directives/ng_control\":27,\"./directives/ng_control_group\":28,\"./directives/ng_control_name\":29,\"./directives/ng_control_status\":30,\"./directives/ng_form\":31,\"./directives/ng_form_control\":32,\"./directives/ng_form_model\":33,\"./directives/ng_model\":34,\"./directives/number_value_accessor\":36,\"./directives/select_control_value_accessor\":37,\"./directives/validators\":39,\"angular2/src/facade/lang\":176}],22:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\n/**\r\n * Base class for control directives.\r\n *\r\n * Only used internally in the forms module.\r\n */\r\nvar AbstractControlDirective = (function () {\r\n    function AbstractControlDirective() {\r\n    }\r\n    Object.defineProperty(AbstractControlDirective.prototype, \"control\", {\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControlDirective.prototype, \"value\", {\r\n        get: function () { return lang_1.isPresent(this.control) ? this.control.value : null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControlDirective.prototype, \"valid\", {\r\n        get: function () { return lang_1.isPresent(this.control) ? this.control.valid : null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControlDirective.prototype, \"errors\", {\r\n        get: function () {\r\n            return lang_1.isPresent(this.control) ? this.control.errors : null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControlDirective.prototype, \"pristine\", {\r\n        get: function () { return lang_1.isPresent(this.control) ? this.control.pristine : null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControlDirective.prototype, \"dirty\", {\r\n        get: function () { return lang_1.isPresent(this.control) ? this.control.dirty : null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControlDirective.prototype, \"touched\", {\r\n        get: function () { return lang_1.isPresent(this.control) ? this.control.touched : null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControlDirective.prototype, \"untouched\", {\r\n        get: function () { return lang_1.isPresent(this.control) ? this.control.untouched : null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControlDirective.prototype, \"path\", {\r\n        get: function () { return null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return AbstractControlDirective;\r\n})();\r\nexports.AbstractControlDirective = AbstractControlDirective;\r\n},{\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],23:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar control_value_accessor_1 = require('./control_value_accessor');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar CHECKBOX_VALUE_ACCESSOR = lang_1.CONST_EXPR(new core_1.Provider(control_value_accessor_1.NG_VALUE_ACCESSOR, { useExisting: core_1.forwardRef(function () { return CheckboxControlValueAccessor; }), multi: true }));\r\n/**\r\n * The accessor for writing a value and listening to changes on a checkbox input element.\r\n *\r\n *  ### Example\r\n *  ```\r\n *  <input type=\"checkbox\" ngControl=\"rememberLogin\">\r\n *  ```\r\n */\r\nvar CheckboxControlValueAccessor = (function () {\r\n    function CheckboxControlValueAccessor(_renderer, _elementRef) {\r\n        this._renderer = _renderer;\r\n        this._elementRef = _elementRef;\r\n        this.onChange = function (_) { };\r\n        this.onTouched = function () { };\r\n    }\r\n    CheckboxControlValueAccessor.prototype.writeValue = function (value) {\r\n        this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);\r\n    };\r\n    CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };\r\n    CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\r\n    CheckboxControlValueAccessor = __decorate([\r\n        core_1.Directive({\r\n            selector: 'input[type=checkbox][ngControl],input[type=checkbox][ngFormControl],input[type=checkbox][ngModel]',\r\n            host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },\r\n            bindings: [CHECKBOX_VALUE_ACCESSOR]\r\n        }), \r\n        __metadata('design:paramtypes', [core_1.Renderer, core_1.ElementRef])\r\n    ], CheckboxControlValueAccessor);\r\n    return CheckboxControlValueAccessor;\r\n})();\r\nexports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;\r\n},{\"./control_value_accessor\":25,\"angular2/core\":3,\"angular2/src/facade/lang\":176}],24:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar abstract_control_directive_1 = require('./abstract_control_directive');\r\n/**\r\n * A directive that contains multiple {@link NgControl}s.\r\n *\r\n * Only used by the forms module.\r\n */\r\nvar ControlContainer = (function (_super) {\r\n    __extends(ControlContainer, _super);\r\n    function ControlContainer() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    Object.defineProperty(ControlContainer.prototype, \"formDirective\", {\r\n        /**\r\n         * Get the form to which this container belongs.\r\n         */\r\n        get: function () { return null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ControlContainer.prototype, \"path\", {\r\n        /**\r\n         * Get the path to this container.\r\n         */\r\n        get: function () { return null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return ControlContainer;\r\n})(abstract_control_directive_1.AbstractControlDirective);\r\nexports.ControlContainer = ControlContainer;\r\n},{\"./abstract_control_directive\":22}],25:[function(require,module,exports){\n'use strict';var core_1 = require('angular2/core');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * Used to provide a {@link ControlValueAccessor} for form controls.\r\n *\r\n * See {@link DefaultValueAccessor} for how to implement one.\r\n */\r\nexports.NG_VALUE_ACCESSOR = lang_1.CONST_EXPR(new core_1.OpaqueToken(\"NgValueAccessor\"));\r\n},{\"angular2/core\":3,\"angular2/src/facade/lang\":176}],26:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar control_value_accessor_1 = require('./control_value_accessor');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar DEFAULT_VALUE_ACCESSOR = lang_1.CONST_EXPR(new core_1.Provider(control_value_accessor_1.NG_VALUE_ACCESSOR, { useExisting: core_1.forwardRef(function () { return DefaultValueAccessor; }), multi: true }));\r\n/**\r\n * The default accessor for writing a value and listening to changes that is used by the\r\n * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.\r\n *\r\n *  ### Example\r\n *  ```\r\n *  <input type=\"text\" ngControl=\"searchQuery\">\r\n *  ```\r\n */\r\nvar DefaultValueAccessor = (function () {\r\n    function DefaultValueAccessor(_renderer, _elementRef) {\r\n        this._renderer = _renderer;\r\n        this._elementRef = _elementRef;\r\n        this.onChange = function (_) { };\r\n        this.onTouched = function () { };\r\n    }\r\n    DefaultValueAccessor.prototype.writeValue = function (value) {\r\n        var normalizedValue = lang_1.isBlank(value) ? '' : value;\r\n        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);\r\n    };\r\n    DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };\r\n    DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\r\n    DefaultValueAccessor = __decorate([\r\n        core_1.Directive({\r\n            selector: 'input:not([type=checkbox])[ngControl],textarea[ngControl],input:not([type=checkbox])[ngFormControl],textarea[ngFormControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',\r\n            // TODO: vsavkin replace the above selector with the one below it once\r\n            // https://github.com/angular/angular/issues/3011 is implemented\r\n            // selector: '[ngControl],[ngModel],[ngFormControl]',\r\n            host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },\r\n            bindings: [DEFAULT_VALUE_ACCESSOR]\r\n        }), \r\n        __metadata('design:paramtypes', [core_1.Renderer, core_1.ElementRef])\r\n    ], DefaultValueAccessor);\r\n    return DefaultValueAccessor;\r\n})();\r\nexports.DefaultValueAccessor = DefaultValueAccessor;\r\n},{\"./control_value_accessor\":25,\"angular2/core\":3,\"angular2/src/facade/lang\":176}],27:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar abstract_control_directive_1 = require('./abstract_control_directive');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\n/**\r\n * A base class that all control directive extend.\r\n * It binds a {@link Control} object to a DOM element.\r\n *\r\n * Used internally by Angular forms.\r\n */\r\nvar NgControl = (function (_super) {\r\n    __extends(NgControl, _super);\r\n    function NgControl() {\r\n        _super.apply(this, arguments);\r\n        this.name = null;\r\n        this.valueAccessor = null;\r\n    }\r\n    Object.defineProperty(NgControl.prototype, \"validator\", {\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControl.prototype, \"asyncValidator\", {\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return NgControl;\r\n})(abstract_control_directive_1.AbstractControlDirective);\r\nexports.NgControl = NgControl;\r\n},{\"./abstract_control_directive\":22,\"angular2/src/facade/exceptions\":173}],28:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar control_container_1 = require('./control_container');\r\nvar shared_1 = require('./shared');\r\nvar validators_1 = require('../validators');\r\nvar controlGroupProvider = lang_1.CONST_EXPR(new core_1.Provider(control_container_1.ControlContainer, { useExisting: core_1.forwardRef(function () { return NgControlGroup; }) }));\r\n/**\r\n * Creates and binds a control group to a DOM element.\r\n *\r\n * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/7EJ11uGeaggViYM6T5nq?p=preview))\r\n *\r\n * ```typescript\r\n * @Component({\r\n *   selector: 'my-app',\r\n *   directives: [FORM_DIRECTIVES],\r\n * })\r\n * @View({\r\n *   template: `\r\n *     <div>\r\n *       <h2>Angular2 Control &amp; ControlGroup Example</h2>\r\n *       <form #f=\"ngForm\">\r\n *         <div ngControlGroup=\"name\" #cg-name=\"form\">\r\n *           <h3>Enter your name:</h3>\r\n *           <p>First: <input ngControl=\"first\" required></p>\r\n *           <p>Middle: <input ngControl=\"middle\"></p>\r\n *           <p>Last: <input ngControl=\"last\" required></p>\r\n *         </div>\r\n *         <h3>Name value:</h3>\r\n *         <pre>{{valueOf(cgName)}}</pre>\r\n *         <p>Name is {{cgName?.control?.valid ? \"valid\" : \"invalid\"}}</p>\r\n *         <h3>What's your favorite food?</h3>\r\n *         <p><input ngControl=\"food\"></p>\r\n *         <h3>Form value</h3>\r\n *         <pre>{{valueOf(f)}}</pre>\r\n *       </form>\r\n *     </div>\r\n *   `,\r\n *   directives: [FORM_DIRECTIVES]\r\n * })\r\n * export class App {\r\n *   valueOf(cg: NgControlGroup): string {\r\n *     if (cg.control == null) {\r\n *       return null;\r\n *     }\r\n *     return JSON.stringify(cg.control.value, null, 2);\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This example declares a control group for a user's name. The value and validation state of\r\n * this group can be accessed separately from the overall form.\r\n */\r\nvar NgControlGroup = (function (_super) {\r\n    __extends(NgControlGroup, _super);\r\n    function NgControlGroup(parent, _validators, _asyncValidators) {\r\n        _super.call(this);\r\n        this._validators = _validators;\r\n        this._asyncValidators = _asyncValidators;\r\n        this._parent = parent;\r\n    }\r\n    NgControlGroup.prototype.ngOnInit = function () { this.formDirective.addControlGroup(this); };\r\n    NgControlGroup.prototype.ngOnDestroy = function () { this.formDirective.removeControlGroup(this); };\r\n    Object.defineProperty(NgControlGroup.prototype, \"control\", {\r\n        /**\r\n         * Get the {@link ControlGroup} backing this binding.\r\n         */\r\n        get: function () { return this.formDirective.getControlGroup(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlGroup.prototype, \"path\", {\r\n        /**\r\n         * Get the path to this control group.\r\n         */\r\n        get: function () { return shared_1.controlPath(this.name, this._parent); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlGroup.prototype, \"formDirective\", {\r\n        /**\r\n         * Get the {@link Form} to which this group belongs.\r\n         */\r\n        get: function () { return this._parent.formDirective; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlGroup.prototype, \"validator\", {\r\n        get: function () { return shared_1.composeValidators(this._validators); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlGroup.prototype, \"asyncValidator\", {\r\n        get: function () { return shared_1.composeAsyncValidators(this._asyncValidators); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgControlGroup = __decorate([\r\n        core_1.Directive({\r\n            selector: '[ngControlGroup]',\r\n            providers: [controlGroupProvider],\r\n            inputs: ['name: ngControlGroup'],\r\n            exportAs: 'ngForm'\r\n        }),\r\n        __param(0, core_1.Host()),\r\n        __param(0, core_1.SkipSelf()),\r\n        __param(1, core_1.Optional()),\r\n        __param(1, core_1.Self()),\r\n        __param(1, core_1.Inject(validators_1.NG_VALIDATORS)),\r\n        __param(2, core_1.Optional()),\r\n        __param(2, core_1.Self()),\r\n        __param(2, core_1.Inject(validators_1.NG_ASYNC_VALIDATORS)), \r\n        __metadata('design:paramtypes', [control_container_1.ControlContainer, Array, Array])\r\n    ], NgControlGroup);\r\n    return NgControlGroup;\r\n})(control_container_1.ControlContainer);\r\nexports.NgControlGroup = NgControlGroup;\r\n},{\"../validators\":42,\"./control_container\":24,\"./shared\":38,\"angular2/core\":3,\"angular2/src/facade/lang\":176}],29:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar core_1 = require('angular2/core');\r\nvar control_container_1 = require('./control_container');\r\nvar ng_control_1 = require('./ng_control');\r\nvar control_value_accessor_1 = require('./control_value_accessor');\r\nvar shared_1 = require('./shared');\r\nvar validators_1 = require('../validators');\r\nvar controlNameBinding = lang_1.CONST_EXPR(new core_1.Provider(ng_control_1.NgControl, { useExisting: core_1.forwardRef(function () { return NgControlName; }) }));\r\n/**\r\n * Creates and binds a control with a specified name to a DOM element.\r\n *\r\n * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.\r\n\r\n * ### Example\r\n *\r\n * In this example, we create the login and password controls.\r\n * We can work with each control separately: check its validity, get its value, listen to its\r\n * changes.\r\n *\r\n *  ```\r\n * @Component({\r\n *      selector: \"login-comp\",\r\n *      directives: [FORM_DIRECTIVES],\r\n *      template: `\r\n *        <form #f=\"ngForm\" (submit)='onLogIn(f.value)'>\r\n *          Login <input type='text' ngControl='login' #l=\"form\">\r\n *          <div *ngIf=\"!l.valid\">Login is invalid</div>\r\n *\r\n *          Password <input type='password' ngControl='password'>\r\n *          <button type='submit'>Log in!</button>\r\n *        </form>\r\n *      `})\r\n * class LoginComp {\r\n *  onLogIn(value): void {\r\n *    // value === {login: 'some login', password: 'some password'}\r\n *  }\r\n * }\r\n *  ```\r\n *\r\n * We can also use ngModel to bind a domain model to the form.\r\n *\r\n *  ```\r\n * @Component({\r\n *      selector: \"login-comp\",\r\n *      directives: [FORM_DIRECTIVES],\r\n *      template: `\r\n *        <form (submit)='onLogIn()'>\r\n *          Login <input type='text' ngControl='login' [(ngModel)]=\"credentials.login\">\r\n *          Password <input type='password' ngControl='password'\r\n *                          [(ngModel)]=\"credentials.password\">\r\n *          <button type='submit'>Log in!</button>\r\n *        </form>\r\n *      `})\r\n * class LoginComp {\r\n *  credentials: {login:string, password:string};\r\n *\r\n *  onLogIn(): void {\r\n *    // this.credentials.login === \"some login\"\r\n *    // this.credentials.password === \"some password\"\r\n *  }\r\n * }\r\n *  ```\r\n */\r\nvar NgControlName = (function (_super) {\r\n    __extends(NgControlName, _super);\r\n    function NgControlName(_parent, _validators, _asyncValidators, valueAccessors) {\r\n        _super.call(this);\r\n        this._parent = _parent;\r\n        this._validators = _validators;\r\n        this._asyncValidators = _asyncValidators;\r\n        /** @internal */\r\n        this.update = new async_1.EventEmitter();\r\n        this._added = false;\r\n        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);\r\n    }\r\n    NgControlName.prototype.ngOnChanges = function (changes) {\r\n        if (!this._added) {\r\n            this.formDirective.addControl(this);\r\n            this._added = true;\r\n        }\r\n        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {\r\n            this.viewModel = this.model;\r\n            this.formDirective.updateModel(this, this.model);\r\n        }\r\n    };\r\n    NgControlName.prototype.ngOnDestroy = function () { this.formDirective.removeControl(this); };\r\n    NgControlName.prototype.viewToModelUpdate = function (newValue) {\r\n        this.viewModel = newValue;\r\n        async_1.ObservableWrapper.callEmit(this.update, newValue);\r\n    };\r\n    Object.defineProperty(NgControlName.prototype, \"path\", {\r\n        get: function () { return shared_1.controlPath(this.name, this._parent); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlName.prototype, \"formDirective\", {\r\n        get: function () { return this._parent.formDirective; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlName.prototype, \"validator\", {\r\n        get: function () { return shared_1.composeValidators(this._validators); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlName.prototype, \"asyncValidator\", {\r\n        get: function () { return shared_1.composeAsyncValidators(this._asyncValidators); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlName.prototype, \"control\", {\r\n        get: function () { return this.formDirective.getControl(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgControlName = __decorate([\r\n        core_1.Directive({\r\n            selector: '[ngControl]',\r\n            bindings: [controlNameBinding],\r\n            inputs: ['name: ngControl', 'model: ngModel'],\r\n            outputs: ['update: ngModelChange'],\r\n            exportAs: 'ngForm'\r\n        }),\r\n        __param(0, core_1.Host()),\r\n        __param(0, core_1.SkipSelf()),\r\n        __param(1, core_1.Optional()),\r\n        __param(1, core_1.Self()),\r\n        __param(1, core_1.Inject(validators_1.NG_VALIDATORS)),\r\n        __param(2, core_1.Optional()),\r\n        __param(2, core_1.Self()),\r\n        __param(2, core_1.Inject(validators_1.NG_ASYNC_VALIDATORS)),\r\n        __param(3, core_1.Optional()),\r\n        __param(3, core_1.Self()),\r\n        __param(3, core_1.Inject(control_value_accessor_1.NG_VALUE_ACCESSOR)), \r\n        __metadata('design:paramtypes', [control_container_1.ControlContainer, Array, Array, Array])\r\n    ], NgControlName);\r\n    return NgControlName;\r\n})(ng_control_1.NgControl);\r\nexports.NgControlName = NgControlName;\r\n},{\"../validators\":42,\"./control_container\":24,\"./control_value_accessor\":25,\"./ng_control\":27,\"./shared\":38,\"angular2/core\":3,\"angular2/src/facade/async\":169,\"angular2/src/facade/lang\":176}],30:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar ng_control_1 = require('./ng_control');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * Directive automatically applied to Angular forms that sets CSS classes\r\n * based on control status (valid/invalid/dirty/etc).\r\n */\r\nvar NgControlStatus = (function () {\r\n    function NgControlStatus(cd) {\r\n        this._cd = cd;\r\n    }\r\n    Object.defineProperty(NgControlStatus.prototype, \"ngClassUntouched\", {\r\n        get: function () {\r\n            return lang_1.isPresent(this._cd.control) ? this._cd.control.untouched : false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlStatus.prototype, \"ngClassTouched\", {\r\n        get: function () {\r\n            return lang_1.isPresent(this._cd.control) ? this._cd.control.touched : false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlStatus.prototype, \"ngClassPristine\", {\r\n        get: function () {\r\n            return lang_1.isPresent(this._cd.control) ? this._cd.control.pristine : false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlStatus.prototype, \"ngClassDirty\", {\r\n        get: function () {\r\n            return lang_1.isPresent(this._cd.control) ? this._cd.control.dirty : false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlStatus.prototype, \"ngClassValid\", {\r\n        get: function () {\r\n            return lang_1.isPresent(this._cd.control) ? this._cd.control.valid : false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgControlStatus.prototype, \"ngClassInvalid\", {\r\n        get: function () {\r\n            return lang_1.isPresent(this._cd.control) ? !this._cd.control.valid : false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgControlStatus = __decorate([\r\n        core_1.Directive({\r\n            selector: '[ngControl],[ngModel],[ngFormControl]',\r\n            host: {\r\n                '[class.ng-untouched]': 'ngClassUntouched',\r\n                '[class.ng-touched]': 'ngClassTouched',\r\n                '[class.ng-pristine]': 'ngClassPristine',\r\n                '[class.ng-dirty]': 'ngClassDirty',\r\n                '[class.ng-valid]': 'ngClassValid',\r\n                '[class.ng-invalid]': 'ngClassInvalid'\r\n            }\r\n        }),\r\n        __param(0, core_1.Self()), \r\n        __metadata('design:paramtypes', [ng_control_1.NgControl])\r\n    ], NgControlStatus);\r\n    return NgControlStatus;\r\n})();\r\nexports.NgControlStatus = NgControlStatus;\r\n},{\"./ng_control\":27,\"angular2/core\":3,\"angular2/src/facade/lang\":176}],31:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar core_1 = require('angular2/core');\r\nvar control_container_1 = require('./control_container');\r\nvar model_1 = require('../model');\r\nvar shared_1 = require('./shared');\r\nvar validators_1 = require('../validators');\r\nvar formDirectiveProvider = lang_1.CONST_EXPR(new core_1.Provider(control_container_1.ControlContainer, { useExisting: core_1.forwardRef(function () { return NgForm; }) }));\r\n/**\r\n * If `NgForm` is bound in a component, `<form>` elements in that component will be\r\n * upgraded to use the Angular form system.\r\n *\r\n * ### Typical Use\r\n *\r\n * Include `FORM_DIRECTIVES` in the `directives` section of a {@link View} annotation\r\n * to use `NgForm` and its associated controls.\r\n *\r\n * ### Structure\r\n *\r\n * An Angular form is a collection of `Control`s in some hierarchy.\r\n * `Control`s can be at the top level or can be organized in `ControlGroup`s\r\n * or `ControlArray`s. This hierarchy is reflected in the form's `value`, a\r\n * JSON object that mirrors the form structure.\r\n *\r\n * ### Submission\r\n *\r\n * The `ngSubmit` event signals when the user triggers a form submission.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/ltdgYj4P0iY64AR71EpL?p=preview))\r\n *\r\n *  ```typescript\r\n * @Component({\r\n *   selector: 'my-app',\r\n *   template: `\r\n *     <div>\r\n *       <p>Submit the form to see the data object Angular builds</p>\r\n *       <h2>NgForm demo</h2>\r\n *       <form #f=\"ngForm\" (ngSubmit)=\"onSubmit(f.value)\">\r\n *         <h3>Control group: credentials</h3>\r\n *         <div ngControlGroup=\"credentials\">\r\n *           <p>Login: <input type=\"text\" ngControl=\"login\"></p>\r\n *           <p>Password: <input type=\"password\" ngControl=\"password\"></p>\r\n *         </div>\r\n *         <h3>Control group: person</h3>\r\n *         <div ngControlGroup=\"person\">\r\n *           <p>First name: <input type=\"text\" ngControl=\"firstName\"></p>\r\n *           <p>Last name: <input type=\"text\" ngControl=\"lastName\"></p>\r\n *         </div>\r\n *         <button type=\"submit\">Submit Form</button>\r\n *       <p>Form data submitted:</p>\r\n *       </form>\r\n *       <pre>{{data}}</pre>\r\n *     </div>\r\n * `,\r\n *   directives: [CORE_DIRECTIVES, FORM_DIRECTIVES]\r\n * })\r\n * export class App {\r\n *   constructor() {}\r\n *\r\n *   data: string;\r\n *\r\n *   onSubmit(data) {\r\n *     this.data = JSON.stringify(data, null, 2);\r\n *   }\r\n * }\r\n *  ```\r\n */\r\nvar NgForm = (function (_super) {\r\n    __extends(NgForm, _super);\r\n    function NgForm(validators, asyncValidators) {\r\n        _super.call(this);\r\n        this.ngSubmit = new async_1.EventEmitter();\r\n        this.form = new model_1.ControlGroup({}, null, shared_1.composeValidators(validators), shared_1.composeAsyncValidators(asyncValidators));\r\n    }\r\n    Object.defineProperty(NgForm.prototype, \"formDirective\", {\r\n        get: function () { return this; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForm.prototype, \"control\", {\r\n        get: function () { return this.form; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForm.prototype, \"path\", {\r\n        get: function () { return []; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForm.prototype, \"controls\", {\r\n        get: function () { return this.form.controls; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgForm.prototype.addControl = function (dir) {\r\n        var _this = this;\r\n        async_1.PromiseWrapper.scheduleMicrotask(function () {\r\n            var container = _this._findContainer(dir.path);\r\n            var ctrl = new model_1.Control();\r\n            shared_1.setUpControl(ctrl, dir);\r\n            container.addControl(dir.name, ctrl);\r\n            ctrl.updateValueAndValidity({ emitEvent: false });\r\n        });\r\n    };\r\n    NgForm.prototype.getControl = function (dir) { return this.form.find(dir.path); };\r\n    NgForm.prototype.removeControl = function (dir) {\r\n        var _this = this;\r\n        async_1.PromiseWrapper.scheduleMicrotask(function () {\r\n            var container = _this._findContainer(dir.path);\r\n            if (lang_1.isPresent(container)) {\r\n                container.removeControl(dir.name);\r\n                container.updateValueAndValidity({ emitEvent: false });\r\n            }\r\n        });\r\n    };\r\n    NgForm.prototype.addControlGroup = function (dir) {\r\n        var _this = this;\r\n        async_1.PromiseWrapper.scheduleMicrotask(function () {\r\n            var container = _this._findContainer(dir.path);\r\n            var group = new model_1.ControlGroup({});\r\n            shared_1.setUpControlGroup(group, dir);\r\n            container.addControl(dir.name, group);\r\n            group.updateValueAndValidity({ emitEvent: false });\r\n        });\r\n    };\r\n    NgForm.prototype.removeControlGroup = function (dir) {\r\n        var _this = this;\r\n        async_1.PromiseWrapper.scheduleMicrotask(function () {\r\n            var container = _this._findContainer(dir.path);\r\n            if (lang_1.isPresent(container)) {\r\n                container.removeControl(dir.name);\r\n                container.updateValueAndValidity({ emitEvent: false });\r\n            }\r\n        });\r\n    };\r\n    NgForm.prototype.getControlGroup = function (dir) {\r\n        return this.form.find(dir.path);\r\n    };\r\n    NgForm.prototype.updateModel = function (dir, value) {\r\n        var _this = this;\r\n        async_1.PromiseWrapper.scheduleMicrotask(function () {\r\n            var ctrl = _this.form.find(dir.path);\r\n            ctrl.updateValue(value);\r\n        });\r\n    };\r\n    NgForm.prototype.onSubmit = function () {\r\n        async_1.ObservableWrapper.callEmit(this.ngSubmit, null);\r\n        return false;\r\n    };\r\n    /** @internal */\r\n    NgForm.prototype._findContainer = function (path) {\r\n        path.pop();\r\n        return collection_1.ListWrapper.isEmpty(path) ? this.form : this.form.find(path);\r\n    };\r\n    NgForm = __decorate([\r\n        core_1.Directive({\r\n            selector: 'form:not([ngNoForm]):not([ngFormModel]),ngForm,[ngForm]',\r\n            bindings: [formDirectiveProvider],\r\n            host: {\r\n                '(submit)': 'onSubmit()',\r\n            },\r\n            outputs: ['ngSubmit'],\r\n            exportAs: 'ngForm'\r\n        }),\r\n        __param(0, core_1.Optional()),\r\n        __param(0, core_1.Self()),\r\n        __param(0, core_1.Inject(validators_1.NG_VALIDATORS)),\r\n        __param(1, core_1.Optional()),\r\n        __param(1, core_1.Self()),\r\n        __param(1, core_1.Inject(validators_1.NG_ASYNC_VALIDATORS)), \r\n        __metadata('design:paramtypes', [Array, Array])\r\n    ], NgForm);\r\n    return NgForm;\r\n})(control_container_1.ControlContainer);\r\nexports.NgForm = NgForm;\r\n},{\"../model\":41,\"../validators\":42,\"./control_container\":24,\"./shared\":38,\"angular2/core\":3,\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],32:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar core_1 = require('angular2/core');\r\nvar ng_control_1 = require('./ng_control');\r\nvar validators_1 = require('../validators');\r\nvar control_value_accessor_1 = require('./control_value_accessor');\r\nvar shared_1 = require('./shared');\r\nvar formControlBinding = lang_1.CONST_EXPR(new core_1.Provider(ng_control_1.NgControl, { useExisting: core_1.forwardRef(function () { return NgFormControl; }) }));\r\n/**\r\n * Binds an existing {@link Control} to a DOM element.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/jcQlZ2tTh22BZZ2ucNAT?p=preview))\r\n *\r\n * In this example, we bind the control to an input element. When the value of the input element\r\n * changes, the value of the control will reflect that change. Likewise, if the value of the\r\n * control changes, the input element reflects that change.\r\n *\r\n *  ```typescript\r\n * @Component({\r\n *   selector: 'my-app',\r\n *   template: `\r\n *     <div>\r\n *       <h2>NgFormControl Example</h2>\r\n *       <form>\r\n *         <p>Element with existing control: <input type=\"text\"\r\n * [ngFormControl]=\"loginControl\"></p>\r\n *         <p>Value of existing control: {{loginControl.value}}</p>\r\n *       </form>\r\n *     </div>\r\n *   `,\r\n *   directives: [CORE_DIRECTIVES, FORM_DIRECTIVES]\r\n * })\r\n * export class App {\r\n *   loginControl: Control = new Control('');\r\n * }\r\n *  ```\r\n *\r\n * ###ngModel\r\n *\r\n * We can also use `ngModel` to bind a domain model to the form.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/yHMLuHO7DNgT8XvtjTDH?p=preview))\r\n *\r\n *  ```typescript\r\n * @Component({\r\n *      selector: \"login-comp\",\r\n *      directives: [FORM_DIRECTIVES],\r\n *      template: \"<input type='text' [ngFormControl]='loginControl' [(ngModel)]='login'>\"\r\n *      })\r\n * class LoginComp {\r\n *  loginControl: Control = new Control('');\r\n *  login:string;\r\n * }\r\n *  ```\r\n */\r\nvar NgFormControl = (function (_super) {\r\n    __extends(NgFormControl, _super);\r\n    function NgFormControl(_validators, _asyncValidators, valueAccessors) {\r\n        _super.call(this);\r\n        this._validators = _validators;\r\n        this._asyncValidators = _asyncValidators;\r\n        this.update = new async_1.EventEmitter();\r\n        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);\r\n    }\r\n    NgFormControl.prototype.ngOnChanges = function (changes) {\r\n        if (this._isControlChanged(changes)) {\r\n            shared_1.setUpControl(this.form, this);\r\n            this.form.updateValueAndValidity({ emitEvent: false });\r\n        }\r\n        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {\r\n            this.form.updateValue(this.model);\r\n            this.viewModel = this.model;\r\n        }\r\n    };\r\n    Object.defineProperty(NgFormControl.prototype, \"path\", {\r\n        get: function () { return []; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgFormControl.prototype, \"validator\", {\r\n        get: function () { return shared_1.composeValidators(this._validators); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgFormControl.prototype, \"asyncValidator\", {\r\n        get: function () { return shared_1.composeAsyncValidators(this._asyncValidators); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgFormControl.prototype, \"control\", {\r\n        get: function () { return this.form; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgFormControl.prototype.viewToModelUpdate = function (newValue) {\r\n        this.viewModel = newValue;\r\n        async_1.ObservableWrapper.callEmit(this.update, newValue);\r\n    };\r\n    NgFormControl.prototype._isControlChanged = function (changes) {\r\n        return collection_1.StringMapWrapper.contains(changes, \"form\");\r\n    };\r\n    NgFormControl = __decorate([\r\n        core_1.Directive({\r\n            selector: '[ngFormControl]',\r\n            bindings: [formControlBinding],\r\n            inputs: ['form: ngFormControl', 'model: ngModel'],\r\n            outputs: ['update: ngModelChange'],\r\n            exportAs: 'ngForm'\r\n        }),\r\n        __param(0, core_1.Optional()),\r\n        __param(0, core_1.Self()),\r\n        __param(0, core_1.Inject(validators_1.NG_VALIDATORS)),\r\n        __param(1, core_1.Optional()),\r\n        __param(1, core_1.Self()),\r\n        __param(1, core_1.Inject(validators_1.NG_ASYNC_VALIDATORS)),\r\n        __param(2, core_1.Optional()),\r\n        __param(2, core_1.Self()),\r\n        __param(2, core_1.Inject(control_value_accessor_1.NG_VALUE_ACCESSOR)), \r\n        __metadata('design:paramtypes', [Array, Array, Array])\r\n    ], NgFormControl);\r\n    return NgFormControl;\r\n})(ng_control_1.NgControl);\r\nexports.NgFormControl = NgFormControl;\r\n},{\"../validators\":42,\"./control_value_accessor\":25,\"./ng_control\":27,\"./shared\":38,\"angular2/core\":3,\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],33:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar core_1 = require('angular2/core');\r\nvar control_container_1 = require('./control_container');\r\nvar shared_1 = require('./shared');\r\nvar validators_1 = require('../validators');\r\nvar formDirectiveProvider = lang_1.CONST_EXPR(new core_1.Provider(control_container_1.ControlContainer, { useExisting: core_1.forwardRef(function () { return NgFormModel; }) }));\r\n/**\r\n * Binds an existing control group to a DOM element.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/jqrVirudY8anJxTMUjTP?p=preview))\r\n *\r\n * In this example, we bind the control group to the form element, and we bind the login and\r\n * password controls to the login and password elements.\r\n *\r\n *  ```typescript\r\n * @Component({\r\n *   selector: 'my-app',\r\n *   template: `\r\n *     <div>\r\n *       <h2>NgFormModel Example</h2>\r\n *       <form [ngFormModel]=\"loginForm\">\r\n *         <p>Login: <input type=\"text\" ngControl=\"login\"></p>\r\n *         <p>Password: <input type=\"password\" ngControl=\"password\"></p>\r\n *       </form>\r\n *       <p>Value:</p>\r\n *       <pre>{{value}}</pre>\r\n *     </div>\r\n *   `,\r\n *   directives: [FORM_DIRECTIVES]\r\n * })\r\n * export class App {\r\n *   loginForm: ControlGroup;\r\n *\r\n *   constructor() {\r\n *     this.loginForm = new ControlGroup({\r\n *       login: new Control(\"\"),\r\n *       password: new Control(\"\")\r\n *     });\r\n *   }\r\n *\r\n *   get value(): string {\r\n *     return JSON.stringify(this.loginForm.value, null, 2);\r\n *   }\r\n * }\r\n *  ```\r\n *\r\n * We can also use ngModel to bind a domain model to the form.\r\n *\r\n *  ```typescript\r\n * @Component({\r\n *      selector: \"login-comp\",\r\n *      directives: [FORM_DIRECTIVES],\r\n *      template: `\r\n *        <form [ngFormModel]='loginForm'>\r\n *          Login <input type='text' ngControl='login' [(ngModel)]='credentials.login'>\r\n *          Password <input type='password' ngControl='password'\r\n *                          [(ngModel)]='credentials.password'>\r\n *          <button (click)=\"onLogin()\">Login</button>\r\n *        </form>`\r\n *      })\r\n * class LoginComp {\r\n *  credentials: {login: string, password: string};\r\n *  loginForm: ControlGroup;\r\n *\r\n *  constructor() {\r\n *    this.loginForm = new ControlGroup({\r\n *      login: new Control(\"\"),\r\n *      password: new Control(\"\")\r\n *    });\r\n *  }\r\n *\r\n *  onLogin(): void {\r\n *    // this.credentials.login === 'some login'\r\n *    // this.credentials.password === 'some password'\r\n *  }\r\n * }\r\n *  ```\r\n */\r\nvar NgFormModel = (function (_super) {\r\n    __extends(NgFormModel, _super);\r\n    function NgFormModel(_validators, _asyncValidators) {\r\n        _super.call(this);\r\n        this._validators = _validators;\r\n        this._asyncValidators = _asyncValidators;\r\n        this.form = null;\r\n        this.directives = [];\r\n        this.ngSubmit = new async_1.EventEmitter();\r\n    }\r\n    NgFormModel.prototype.ngOnChanges = function (changes) {\r\n        if (collection_1.StringMapWrapper.contains(changes, \"form\")) {\r\n            var sync = shared_1.composeValidators(this._validators);\r\n            this.form.validator = validators_1.Validators.compose([this.form.validator, sync]);\r\n            var async = shared_1.composeAsyncValidators(this._asyncValidators);\r\n            this.form.asyncValidator = validators_1.Validators.composeAsync([this.form.asyncValidator, async]);\r\n            this.form.updateValueAndValidity({ onlySelf: true, emitEvent: false });\r\n        }\r\n        this._updateDomValue();\r\n    };\r\n    Object.defineProperty(NgFormModel.prototype, \"formDirective\", {\r\n        get: function () { return this; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgFormModel.prototype, \"control\", {\r\n        get: function () { return this.form; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgFormModel.prototype, \"path\", {\r\n        get: function () { return []; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgFormModel.prototype.addControl = function (dir) {\r\n        var ctrl = this.form.find(dir.path);\r\n        shared_1.setUpControl(ctrl, dir);\r\n        ctrl.updateValueAndValidity({ emitEvent: false });\r\n        this.directives.push(dir);\r\n    };\r\n    NgFormModel.prototype.getControl = function (dir) { return this.form.find(dir.path); };\r\n    NgFormModel.prototype.removeControl = function (dir) { collection_1.ListWrapper.remove(this.directives, dir); };\r\n    NgFormModel.prototype.addControlGroup = function (dir) {\r\n        var ctrl = this.form.find(dir.path);\r\n        shared_1.setUpControlGroup(ctrl, dir);\r\n        ctrl.updateValueAndValidity({ emitEvent: false });\r\n    };\r\n    NgFormModel.prototype.removeControlGroup = function (dir) { };\r\n    NgFormModel.prototype.getControlGroup = function (dir) {\r\n        return this.form.find(dir.path);\r\n    };\r\n    NgFormModel.prototype.updateModel = function (dir, value) {\r\n        var ctrl = this.form.find(dir.path);\r\n        ctrl.updateValue(value);\r\n    };\r\n    NgFormModel.prototype.onSubmit = function () {\r\n        async_1.ObservableWrapper.callEmit(this.ngSubmit, null);\r\n        return false;\r\n    };\r\n    /** @internal */\r\n    NgFormModel.prototype._updateDomValue = function () {\r\n        var _this = this;\r\n        this.directives.forEach(function (dir) {\r\n            var ctrl = _this.form.find(dir.path);\r\n            dir.valueAccessor.writeValue(ctrl.value);\r\n        });\r\n    };\r\n    NgFormModel = __decorate([\r\n        core_1.Directive({\r\n            selector: '[ngFormModel]',\r\n            bindings: [formDirectiveProvider],\r\n            inputs: ['form: ngFormModel'],\r\n            host: { '(submit)': 'onSubmit()' },\r\n            outputs: ['ngSubmit'],\r\n            exportAs: 'ngForm'\r\n        }),\r\n        __param(0, core_1.Optional()),\r\n        __param(0, core_1.Self()),\r\n        __param(0, core_1.Inject(validators_1.NG_VALIDATORS)),\r\n        __param(1, core_1.Optional()),\r\n        __param(1, core_1.Self()),\r\n        __param(1, core_1.Inject(validators_1.NG_ASYNC_VALIDATORS)), \r\n        __metadata('design:paramtypes', [Array, Array])\r\n    ], NgFormModel);\r\n    return NgFormModel;\r\n})(control_container_1.ControlContainer);\r\nexports.NgFormModel = NgFormModel;\r\n},{\"../validators\":42,\"./control_container\":24,\"./shared\":38,\"angular2/core\":3,\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],34:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar core_1 = require('angular2/core');\r\nvar control_value_accessor_1 = require('./control_value_accessor');\r\nvar ng_control_1 = require('./ng_control');\r\nvar model_1 = require('../model');\r\nvar validators_1 = require('../validators');\r\nvar shared_1 = require('./shared');\r\nvar formControlBinding = lang_1.CONST_EXPR(new core_1.Provider(ng_control_1.NgControl, { useExisting: core_1.forwardRef(function () { return NgModel; }) }));\r\n/**\r\n * Binds a domain model to a form control.\r\n *\r\n * ### Usage\r\n *\r\n * `ngModel` binds an existing domain model to a form control. For a\r\n * two-way binding, use `[(ngModel)]` to ensure the model updates in\r\n * both directions.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/R3UX5qDaUqFO2VYR0UzH?p=preview))\r\n *  ```typescript\r\n * @Component({\r\n *      selector: \"search-comp\",\r\n *      directives: [FORM_DIRECTIVES],\r\n *      template: `<input type='text' [(ngModel)]=\"searchQuery\">`\r\n *      })\r\n * class SearchComp {\r\n *  searchQuery: string;\r\n * }\r\n *  ```\r\n */\r\nvar NgModel = (function (_super) {\r\n    __extends(NgModel, _super);\r\n    function NgModel(_validators, _asyncValidators, valueAccessors) {\r\n        _super.call(this);\r\n        this._validators = _validators;\r\n        this._asyncValidators = _asyncValidators;\r\n        /** @internal */\r\n        this._control = new model_1.Control();\r\n        /** @internal */\r\n        this._added = false;\r\n        this.update = new async_1.EventEmitter();\r\n        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);\r\n    }\r\n    NgModel.prototype.ngOnChanges = function (changes) {\r\n        if (!this._added) {\r\n            shared_1.setUpControl(this._control, this);\r\n            this._control.updateValueAndValidity({ emitEvent: false });\r\n            this._added = true;\r\n        }\r\n        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {\r\n            this._control.updateValue(this.model);\r\n            this.viewModel = this.model;\r\n        }\r\n    };\r\n    Object.defineProperty(NgModel.prototype, \"control\", {\r\n        get: function () { return this._control; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgModel.prototype, \"path\", {\r\n        get: function () { return []; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgModel.prototype, \"validator\", {\r\n        get: function () { return shared_1.composeValidators(this._validators); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgModel.prototype, \"asyncValidator\", {\r\n        get: function () { return shared_1.composeAsyncValidators(this._asyncValidators); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgModel.prototype.viewToModelUpdate = function (newValue) {\r\n        this.viewModel = newValue;\r\n        async_1.ObservableWrapper.callEmit(this.update, newValue);\r\n    };\r\n    NgModel = __decorate([\r\n        core_1.Directive({\r\n            selector: '[ngModel]:not([ngControl]):not([ngFormControl])',\r\n            bindings: [formControlBinding],\r\n            inputs: ['model: ngModel'],\r\n            outputs: ['update: ngModelChange'],\r\n            exportAs: 'ngForm'\r\n        }),\r\n        __param(0, core_1.Optional()),\r\n        __param(0, core_1.Self()),\r\n        __param(0, core_1.Inject(validators_1.NG_VALIDATORS)),\r\n        __param(1, core_1.Optional()),\r\n        __param(1, core_1.Self()),\r\n        __param(1, core_1.Inject(validators_1.NG_ASYNC_VALIDATORS)),\r\n        __param(2, core_1.Optional()),\r\n        __param(2, core_1.Self()),\r\n        __param(2, core_1.Inject(control_value_accessor_1.NG_VALUE_ACCESSOR)), \r\n        __metadata('design:paramtypes', [Array, Array, Array])\r\n    ], NgModel);\r\n    return NgModel;\r\n})(ng_control_1.NgControl);\r\nexports.NgModel = NgModel;\r\n},{\"../model\":41,\"../validators\":42,\"./control_value_accessor\":25,\"./ng_control\":27,\"./shared\":38,\"angular2/core\":3,\"angular2/src/facade/async\":169,\"angular2/src/facade/lang\":176}],35:[function(require,module,exports){\n'use strict';function normalizeValidator(validator) {\r\n    if (validator.validate !== undefined) {\r\n        return function (c) { return validator.validate(c); };\r\n    }\r\n    else {\r\n        return validator;\r\n    }\r\n}\r\nexports.normalizeValidator = normalizeValidator;\r\n},{}],36:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar control_value_accessor_1 = require('./control_value_accessor');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar NUMBER_VALUE_ACCESSOR = lang_1.CONST_EXPR(new core_1.Provider(control_value_accessor_1.NG_VALUE_ACCESSOR, { useExisting: core_1.forwardRef(function () { return NumberValueAccessor; }), multi: true }));\r\n/**\r\n * The accessor for writing a number value and listening to changes that is used by the\r\n * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.\r\n *\r\n *  ### Example\r\n *  ```\r\n *  <input type=\"number\" [(ngModel)]=\"age\">\r\n *  ```\r\n */\r\nvar NumberValueAccessor = (function () {\r\n    function NumberValueAccessor(_renderer, _elementRef) {\r\n        this._renderer = _renderer;\r\n        this._elementRef = _elementRef;\r\n        this.onChange = function (_) { };\r\n        this.onTouched = function () { };\r\n    }\r\n    NumberValueAccessor.prototype.writeValue = function (value) {\r\n        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', value);\r\n    };\r\n    NumberValueAccessor.prototype.registerOnChange = function (fn) {\r\n        this.onChange = function (value) { fn(lang_1.NumberWrapper.parseFloat(value)); };\r\n    };\r\n    NumberValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\r\n    NumberValueAccessor = __decorate([\r\n        core_1.Directive({\r\n            selector: 'input[type=number][ngControl],input[type=number][ngFormControl],input[type=number][ngModel]',\r\n            host: {\r\n                '(change)': 'onChange($event.target.value)',\r\n                '(input)': 'onChange($event.target.value)',\r\n                '(blur)': 'onTouched()'\r\n            },\r\n            bindings: [NUMBER_VALUE_ACCESSOR]\r\n        }), \r\n        __metadata('design:paramtypes', [core_1.Renderer, core_1.ElementRef])\r\n    ], NumberValueAccessor);\r\n    return NumberValueAccessor;\r\n})();\r\nexports.NumberValueAccessor = NumberValueAccessor;\r\n},{\"./control_value_accessor\":25,\"angular2/core\":3,\"angular2/src/facade/lang\":176}],37:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar control_value_accessor_1 = require('./control_value_accessor');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar SELECT_VALUE_ACCESSOR = lang_1.CONST_EXPR(new core_1.Provider(control_value_accessor_1.NG_VALUE_ACCESSOR, { useExisting: core_1.forwardRef(function () { return SelectControlValueAccessor; }), multi: true }));\r\n/**\r\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * <select ngControl=\"city\">\r\n *   <option *ngFor=\"#c of cities\" [value]=\"c\"></option>\r\n * </select>\r\n * ```\r\n */\r\nvar NgSelectOption = (function () {\r\n    function NgSelectOption() {\r\n    }\r\n    NgSelectOption = __decorate([\r\n        core_1.Directive({ selector: 'option' }), \r\n        __metadata('design:paramtypes', [])\r\n    ], NgSelectOption);\r\n    return NgSelectOption;\r\n})();\r\nexports.NgSelectOption = NgSelectOption;\r\n/**\r\n * The accessor for writing a value and listening to changes on a select element.\r\n */\r\nvar SelectControlValueAccessor = (function () {\r\n    function SelectControlValueAccessor(_renderer, _elementRef, query) {\r\n        this._renderer = _renderer;\r\n        this._elementRef = _elementRef;\r\n        this.onChange = function (_) { };\r\n        this.onTouched = function () { };\r\n        this._updateValueWhenListOfOptionsChanges(query);\r\n    }\r\n    SelectControlValueAccessor.prototype.writeValue = function (value) {\r\n        this.value = value;\r\n        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', value);\r\n    };\r\n    SelectControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };\r\n    SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\r\n    SelectControlValueAccessor.prototype._updateValueWhenListOfOptionsChanges = function (query) {\r\n        var _this = this;\r\n        async_1.ObservableWrapper.subscribe(query.changes, function (_) { return _this.writeValue(_this.value); });\r\n    };\r\n    SelectControlValueAccessor = __decorate([\r\n        core_1.Directive({\r\n            selector: 'select[ngControl],select[ngFormControl],select[ngModel]',\r\n            host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },\r\n            bindings: [SELECT_VALUE_ACCESSOR]\r\n        }),\r\n        __param(2, core_1.Query(NgSelectOption, { descendants: true })), \r\n        __metadata('design:paramtypes', [core_1.Renderer, core_1.ElementRef, core_1.QueryList])\r\n    ], SelectControlValueAccessor);\r\n    return SelectControlValueAccessor;\r\n})();\r\nexports.SelectControlValueAccessor = SelectControlValueAccessor;\r\n},{\"./control_value_accessor\":25,\"angular2/core\":3,\"angular2/src/facade/async\":169,\"angular2/src/facade/lang\":176}],38:[function(require,module,exports){\n'use strict';var collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar validators_1 = require('../validators');\r\nvar default_value_accessor_1 = require('./default_value_accessor');\r\nvar number_value_accessor_1 = require('./number_value_accessor');\r\nvar checkbox_value_accessor_1 = require('./checkbox_value_accessor');\r\nvar select_control_value_accessor_1 = require('./select_control_value_accessor');\r\nvar normalize_validator_1 = require('./normalize_validator');\r\nfunction controlPath(name, parent) {\r\n    var p = collection_1.ListWrapper.clone(parent.path);\r\n    p.push(name);\r\n    return p;\r\n}\r\nexports.controlPath = controlPath;\r\nfunction setUpControl(control, dir) {\r\n    if (lang_1.isBlank(control))\r\n        _throwError(dir, \"Cannot find control\");\r\n    if (lang_1.isBlank(dir.valueAccessor))\r\n        _throwError(dir, \"No value accessor for\");\r\n    control.validator = validators_1.Validators.compose([control.validator, dir.validator]);\r\n    control.asyncValidator = validators_1.Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);\r\n    dir.valueAccessor.writeValue(control.value);\r\n    // view -> model\r\n    dir.valueAccessor.registerOnChange(function (newValue) {\r\n        dir.viewToModelUpdate(newValue);\r\n        control.updateValue(newValue, { emitModelToViewChange: false });\r\n        control.markAsDirty();\r\n    });\r\n    // model -> view\r\n    control.registerOnChange(function (newValue) { return dir.valueAccessor.writeValue(newValue); });\r\n    // touched\r\n    dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });\r\n}\r\nexports.setUpControl = setUpControl;\r\nfunction setUpControlGroup(control, dir) {\r\n    if (lang_1.isBlank(control))\r\n        _throwError(dir, \"Cannot find control\");\r\n    control.validator = validators_1.Validators.compose([control.validator, dir.validator]);\r\n    control.asyncValidator = validators_1.Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);\r\n}\r\nexports.setUpControlGroup = setUpControlGroup;\r\nfunction _throwError(dir, message) {\r\n    var path = dir.path.join(\" -> \");\r\n    throw new exceptions_1.BaseException(message + \" '\" + path + \"'\");\r\n}\r\nfunction composeValidators(validators) {\r\n    return lang_1.isPresent(validators) ? validators_1.Validators.compose(validators.map(normalize_validator_1.normalizeValidator)) : null;\r\n}\r\nexports.composeValidators = composeValidators;\r\nfunction composeAsyncValidators(validators) {\r\n    return lang_1.isPresent(validators) ? validators_1.Validators.composeAsync(validators.map(normalize_validator_1.normalizeValidator)) : null;\r\n}\r\nexports.composeAsyncValidators = composeAsyncValidators;\r\nfunction isPropertyUpdated(changes, viewModel) {\r\n    if (!collection_1.StringMapWrapper.contains(changes, \"model\"))\r\n        return false;\r\n    var change = changes[\"model\"];\r\n    if (change.isFirstChange())\r\n        return true;\r\n    return !lang_1.looseIdentical(viewModel, change.currentValue);\r\n}\r\nexports.isPropertyUpdated = isPropertyUpdated;\r\n// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented\r\nfunction selectValueAccessor(dir, valueAccessors) {\r\n    if (lang_1.isBlank(valueAccessors))\r\n        return null;\r\n    var defaultAccessor;\r\n    var builtinAccessor;\r\n    var customAccessor;\r\n    valueAccessors.forEach(function (v) {\r\n        if (v instanceof default_value_accessor_1.DefaultValueAccessor) {\r\n            defaultAccessor = v;\r\n        }\r\n        else if (v instanceof checkbox_value_accessor_1.CheckboxControlValueAccessor || v instanceof number_value_accessor_1.NumberValueAccessor ||\r\n            v instanceof select_control_value_accessor_1.SelectControlValueAccessor) {\r\n            if (lang_1.isPresent(builtinAccessor))\r\n                _throwError(dir, \"More than one built-in value accessor matches\");\r\n            builtinAccessor = v;\r\n        }\r\n        else {\r\n            if (lang_1.isPresent(customAccessor))\r\n                _throwError(dir, \"More than one custom value accessor matches\");\r\n            customAccessor = v;\r\n        }\r\n    });\r\n    if (lang_1.isPresent(customAccessor))\r\n        return customAccessor;\r\n    if (lang_1.isPresent(builtinAccessor))\r\n        return builtinAccessor;\r\n    if (lang_1.isPresent(defaultAccessor))\r\n        return defaultAccessor;\r\n    _throwError(dir, \"No valid value accessor for\");\r\n    return null;\r\n}\r\nexports.selectValueAccessor = selectValueAccessor;\r\n},{\"../validators\":42,\"./checkbox_value_accessor\":23,\"./default_value_accessor\":26,\"./normalize_validator\":35,\"./number_value_accessor\":36,\"./select_control_value_accessor\":37,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],39:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar validators_1 = require('../validators');\r\nvar lang_2 = require(\"angular2/src/facade/lang\");\r\nvar REQUIRED_VALIDATOR = lang_1.CONST_EXPR(new core_1.Provider(validators_1.NG_VALIDATORS, { useValue: validators_1.Validators.required, multi: true }));\r\n/**\r\n * A Directive that adds the `required` validator to any controls marked with the\r\n * `required` attribute, via the {@link NG_VALIDATORS} binding.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * <input ngControl=\"fullName\" required>\r\n * ```\r\n */\r\nvar RequiredValidator = (function () {\r\n    function RequiredValidator() {\r\n    }\r\n    RequiredValidator = __decorate([\r\n        core_1.Directive({\r\n            selector: '[required][ngControl],[required][ngFormControl],[required][ngModel]',\r\n            providers: [REQUIRED_VALIDATOR]\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], RequiredValidator);\r\n    return RequiredValidator;\r\n})();\r\nexports.RequiredValidator = RequiredValidator;\r\n/**\r\n * Provivder which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.\r\n *\r\n * ## Example:\r\n *\r\n * {@example common/forms/ts/validators/validators.ts region='min'}\r\n */\r\nvar MIN_LENGTH_VALIDATOR = lang_1.CONST_EXPR(new core_1.Provider(validators_1.NG_VALIDATORS, { useExisting: core_1.forwardRef(function () { return MinLengthValidator; }), multi: true }));\r\n/**\r\n * A directive which installs the {@link MinLengthValidator} for any `ngControl`,\r\n * `ngFormControl`, or control with `ngModel` that also has a `minlength` attribute.\r\n */\r\nvar MinLengthValidator = (function () {\r\n    function MinLengthValidator(minLength) {\r\n        this._validator = validators_1.Validators.minLength(lang_2.NumberWrapper.parseInt(minLength, 10));\r\n    }\r\n    MinLengthValidator.prototype.validate = function (c) { return this._validator(c); };\r\n    MinLengthValidator = __decorate([\r\n        core_1.Directive({\r\n            selector: '[minlength][ngControl],[minlength][ngFormControl],[minlength][ngModel]',\r\n            providers: [MIN_LENGTH_VALIDATOR]\r\n        }),\r\n        __param(0, core_1.Attribute(\"minlength\")), \r\n        __metadata('design:paramtypes', [String])\r\n    ], MinLengthValidator);\r\n    return MinLengthValidator;\r\n})();\r\nexports.MinLengthValidator = MinLengthValidator;\r\n/**\r\n * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.\r\n *\r\n * ## Example:\r\n *\r\n * {@example common/forms/ts/validators/validators.ts region='max'}\r\n */\r\nvar MAX_LENGTH_VALIDATOR = lang_1.CONST_EXPR(new core_1.Provider(validators_1.NG_VALIDATORS, { useExisting: core_1.forwardRef(function () { return MaxLengthValidator; }), multi: true }));\r\n/**\r\n * A directive which installs the {@link MaxLengthValidator} for any `ngControl, `ngFormControl`,\r\n * or control with `ngModel` that also has a `maxlength` attribute.\r\n */\r\nvar MaxLengthValidator = (function () {\r\n    function MaxLengthValidator(maxLength) {\r\n        this._validator = validators_1.Validators.maxLength(lang_2.NumberWrapper.parseInt(maxLength, 10));\r\n    }\r\n    MaxLengthValidator.prototype.validate = function (c) { return this._validator(c); };\r\n    MaxLengthValidator = __decorate([\r\n        core_1.Directive({\r\n            selector: '[maxlength][ngControl],[maxlength][ngFormControl],[maxlength][ngModel]',\r\n            providers: [MAX_LENGTH_VALIDATOR]\r\n        }),\r\n        __param(0, core_1.Attribute(\"maxlength\")), \r\n        __metadata('design:paramtypes', [String])\r\n    ], MaxLengthValidator);\r\n    return MaxLengthValidator;\r\n})();\r\nexports.MaxLengthValidator = MaxLengthValidator;\r\n},{\"../validators\":42,\"angular2/core\":3,\"angular2/src/facade/lang\":176}],40:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar core_1 = require('angular2/core');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar modelModule = require('./model');\r\n/**\r\n * Creates a form object from a user-specified configuration.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/ENgZo8EuIECZNensZCVr?p=preview))\r\n *\r\n * ```typescript\r\n * @Component({\r\n *   selector: 'my-app',\r\n *   viewBindings: [FORM_BINDINGS]\r\n *   template: `\r\n *     <form [ngFormModel]=\"loginForm\">\r\n *       <p>Login <input ngControl=\"login\"></p>\r\n *       <div ngControlGroup=\"passwordRetry\">\r\n *         <p>Password <input type=\"password\" ngControl=\"password\"></p>\r\n *         <p>Confirm password <input type=\"password\" ngControl=\"passwordConfirmation\"></p>\r\n *       </div>\r\n *     </form>\r\n *     <h3>Form value:</h3>\r\n *     <pre>{{value}}</pre>\r\n *   `,\r\n *   directives: [FORM_DIRECTIVES]\r\n * })\r\n * export class App {\r\n *   loginForm: ControlGroup;\r\n *\r\n *   constructor(builder: FormBuilder) {\r\n *     this.loginForm = builder.group({\r\n *       login: [\"\", Validators.required],\r\n *       passwordRetry: builder.group({\r\n *         password: [\"\", Validators.required],\r\n *         passwordConfirmation: [\"\", Validators.required, asyncValidator]\r\n *       })\r\n *     });\r\n *   }\r\n *\r\n *   get value(): string {\r\n *     return JSON.stringify(this.loginForm.value, null, 2);\r\n *   }\r\n * }\r\n * ```\r\n */\r\nvar FormBuilder = (function () {\r\n    function FormBuilder() {\r\n    }\r\n    /**\r\n     * Construct a new {@link ControlGroup} with the given map of configuration.\r\n     * Valid keys for the `extra` parameter map are `optionals` and `validator`.\r\n     *\r\n     * See the {@link ControlGroup} constructor for more details.\r\n     */\r\n    FormBuilder.prototype.group = function (controlsConfig, extra) {\r\n        if (extra === void 0) { extra = null; }\r\n        var controls = this._reduceControls(controlsConfig);\r\n        var optionals = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, \"optionals\") : null;\r\n        var validator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, \"validator\") : null;\r\n        var asyncValidator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, \"asyncValidator\") : null;\r\n        return new modelModule.ControlGroup(controls, optionals, validator, asyncValidator);\r\n    };\r\n    /**\r\n     * Construct a new {@link Control} with the given `value`,`validator`, and `asyncValidator`.\r\n     */\r\n    FormBuilder.prototype.control = function (value, validator, asyncValidator) {\r\n        if (validator === void 0) { validator = null; }\r\n        if (asyncValidator === void 0) { asyncValidator = null; }\r\n        return new modelModule.Control(value, validator, asyncValidator);\r\n    };\r\n    /**\r\n     * Construct an array of {@link Control}s from the given `controlsConfig` array of\r\n     * configuration, with the given optional `validator` and `asyncValidator`.\r\n     */\r\n    FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {\r\n        var _this = this;\r\n        if (validator === void 0) { validator = null; }\r\n        if (asyncValidator === void 0) { asyncValidator = null; }\r\n        var controls = controlsConfig.map(function (c) { return _this._createControl(c); });\r\n        return new modelModule.ControlArray(controls, validator, asyncValidator);\r\n    };\r\n    /** @internal */\r\n    FormBuilder.prototype._reduceControls = function (controlsConfig) {\r\n        var _this = this;\r\n        var controls = {};\r\n        collection_1.StringMapWrapper.forEach(controlsConfig, function (controlConfig, controlName) {\r\n            controls[controlName] = _this._createControl(controlConfig);\r\n        });\r\n        return controls;\r\n    };\r\n    /** @internal */\r\n    FormBuilder.prototype._createControl = function (controlConfig) {\r\n        if (controlConfig instanceof modelModule.Control ||\r\n            controlConfig instanceof modelModule.ControlGroup ||\r\n            controlConfig instanceof modelModule.ControlArray) {\r\n            return controlConfig;\r\n        }\r\n        else if (lang_1.isArray(controlConfig)) {\r\n            var value = controlConfig[0];\r\n            var validator = controlConfig.length > 1 ? controlConfig[1] : null;\r\n            var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;\r\n            return this.control(value, validator, asyncValidator);\r\n        }\r\n        else {\r\n            return this.control(controlConfig);\r\n        }\r\n    };\r\n    FormBuilder = __decorate([\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], FormBuilder);\r\n    return FormBuilder;\r\n})();\r\nexports.FormBuilder = FormBuilder;\r\n/**\r\n * Shorthand set of providers used for building Angular forms.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * bootstrap(MyApp, [FORM_PROVIDERS]);\r\n * ```\r\n */\r\nexports.FORM_PROVIDERS = lang_1.CONST_EXPR([FormBuilder]);\r\n/**\r\n * See {@link FORM_PROVIDERS} instead.\r\n *\r\n * @deprecated\r\n */\r\nexports.FORM_BINDINGS = exports.FORM_PROVIDERS;\r\n},{\"./model\":41,\"angular2/core\":3,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],41:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar promise_1 = require('angular2/src/facade/promise');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\n/**\r\n * Indicates that a Control is valid, i.e. that no errors exist in the input value.\r\n */\r\nexports.VALID = \"VALID\";\r\n/**\r\n * Indicates that a Control is invalid, i.e. that an error exists in the input value.\r\n */\r\nexports.INVALID = \"INVALID\";\r\n/**\r\n * Indicates that a Control is pending, i.e. that async validation is occurring and\r\n * errors are not yet available for the input value.\r\n */\r\nexports.PENDING = \"PENDING\";\r\nfunction isControl(control) {\r\n    return control instanceof AbstractControl;\r\n}\r\nexports.isControl = isControl;\r\nfunction _find(control, path) {\r\n    if (lang_1.isBlank(path))\r\n        return null;\r\n    if (!(path instanceof Array)) {\r\n        path = path.split(\"/\");\r\n    }\r\n    if (path instanceof Array && collection_1.ListWrapper.isEmpty(path))\r\n        return null;\r\n    return path\r\n        .reduce(function (v, name) {\r\n        if (v instanceof ControlGroup) {\r\n            return lang_1.isPresent(v.controls[name]) ? v.controls[name] : null;\r\n        }\r\n        else if (v instanceof ControlArray) {\r\n            var index = name;\r\n            return lang_1.isPresent(v.at(index)) ? v.at(index) : null;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }, control);\r\n}\r\nfunction toObservable(r) {\r\n    return promise_1.PromiseWrapper.isPromise(r) ? async_1.ObservableWrapper.fromPromise(r) : r;\r\n}\r\n/**\r\n *\r\n */\r\nvar AbstractControl = (function () {\r\n    function AbstractControl(validator, asyncValidator) {\r\n        this.validator = validator;\r\n        this.asyncValidator = asyncValidator;\r\n        this._pristine = true;\r\n        this._touched = false;\r\n    }\r\n    Object.defineProperty(AbstractControl.prototype, \"value\", {\r\n        get: function () { return this._value; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControl.prototype, \"status\", {\r\n        get: function () { return this._status; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControl.prototype, \"valid\", {\r\n        get: function () { return this._status === exports.VALID; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControl.prototype, \"errors\", {\r\n        /**\r\n         * Returns the errors of this control.\r\n         */\r\n        get: function () { return this._errors; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControl.prototype, \"pristine\", {\r\n        get: function () { return this._pristine; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControl.prototype, \"dirty\", {\r\n        get: function () { return !this.pristine; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControl.prototype, \"touched\", {\r\n        get: function () { return this._touched; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControl.prototype, \"untouched\", {\r\n        get: function () { return !this._touched; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControl.prototype, \"valueChanges\", {\r\n        get: function () { return this._valueChanges; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControl.prototype, \"statusChanges\", {\r\n        get: function () { return this._statusChanges; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractControl.prototype, \"pending\", {\r\n        get: function () { return this._status == exports.PENDING; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    AbstractControl.prototype.markAsTouched = function () { this._touched = true; };\r\n    AbstractControl.prototype.markAsDirty = function (_a) {\r\n        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\r\n        onlySelf = lang_1.normalizeBool(onlySelf);\r\n        this._pristine = false;\r\n        if (lang_1.isPresent(this._parent) && !onlySelf) {\r\n            this._parent.markAsDirty({ onlySelf: onlySelf });\r\n        }\r\n    };\r\n    AbstractControl.prototype.markAsPending = function (_a) {\r\n        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\r\n        onlySelf = lang_1.normalizeBool(onlySelf);\r\n        this._status = exports.PENDING;\r\n        if (lang_1.isPresent(this._parent) && !onlySelf) {\r\n            this._parent.markAsPending({ onlySelf: onlySelf });\r\n        }\r\n    };\r\n    AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };\r\n    AbstractControl.prototype.updateValueAndValidity = function (_a) {\r\n        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;\r\n        onlySelf = lang_1.normalizeBool(onlySelf);\r\n        emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;\r\n        this._updateValue();\r\n        this._errors = this._runValidator();\r\n        this._status = this._calculateStatus();\r\n        if (this._status == exports.VALID || this._status == exports.PENDING) {\r\n            this._runAsyncValidator(emitEvent);\r\n        }\r\n        if (emitEvent) {\r\n            async_1.ObservableWrapper.callEmit(this._valueChanges, this._value);\r\n            async_1.ObservableWrapper.callEmit(this._statusChanges, this._status);\r\n        }\r\n        if (lang_1.isPresent(this._parent) && !onlySelf) {\r\n            this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });\r\n        }\r\n    };\r\n    AbstractControl.prototype._runValidator = function () { return lang_1.isPresent(this.validator) ? this.validator(this) : null; };\r\n    AbstractControl.prototype._runAsyncValidator = function (emitEvent) {\r\n        var _this = this;\r\n        if (lang_1.isPresent(this.asyncValidator)) {\r\n            this._status = exports.PENDING;\r\n            this._cancelExistingSubscription();\r\n            var obs = toObservable(this.asyncValidator(this));\r\n            this._asyncValidationSubscription =\r\n                async_1.ObservableWrapper.subscribe(obs, function (res) { return _this.setErrors(res, { emitEvent: emitEvent }); });\r\n        }\r\n    };\r\n    AbstractControl.prototype._cancelExistingSubscription = function () {\r\n        if (lang_1.isPresent(this._asyncValidationSubscription)) {\r\n            async_1.ObservableWrapper.dispose(this._asyncValidationSubscription);\r\n        }\r\n    };\r\n    /**\r\n     * Sets errors on a control.\r\n     *\r\n     * This is used when validations are run not automatically, but manually by the user.\r\n     *\r\n     * Calling `setErrors` will also update the validity of the parent control.\r\n     *\r\n     * ## Usage\r\n     *\r\n     * ```\r\n     * var login = new Control(\"someLogin\");\r\n     * login.setErrors({\r\n     *   \"notUnique\": true\r\n     * });\r\n     *\r\n     * expect(login.valid).toEqual(false);\r\n     * expect(login.errors).toEqual({\"notUnique\": true});\r\n     *\r\n     * login.updateValue(\"someOtherLogin\");\r\n     *\r\n     * expect(login.valid).toEqual(true);\r\n     * ```\r\n     */\r\n    AbstractControl.prototype.setErrors = function (errors, _a) {\r\n        var emitEvent = (_a === void 0 ? {} : _a).emitEvent;\r\n        emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;\r\n        this._errors = errors;\r\n        this._status = this._calculateStatus();\r\n        if (emitEvent) {\r\n            async_1.ObservableWrapper.callEmit(this._statusChanges, this._status);\r\n        }\r\n        if (lang_1.isPresent(this._parent)) {\r\n            this._parent._updateControlsErrors();\r\n        }\r\n    };\r\n    AbstractControl.prototype.find = function (path) { return _find(this, path); };\r\n    AbstractControl.prototype.getError = function (errorCode, path) {\r\n        if (path === void 0) { path = null; }\r\n        var control = lang_1.isPresent(path) && !collection_1.ListWrapper.isEmpty(path) ? this.find(path) : this;\r\n        if (lang_1.isPresent(control) && lang_1.isPresent(control._errors)) {\r\n            return collection_1.StringMapWrapper.get(control._errors, errorCode);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    AbstractControl.prototype.hasError = function (errorCode, path) {\r\n        if (path === void 0) { path = null; }\r\n        return lang_1.isPresent(this.getError(errorCode, path));\r\n    };\r\n    /** @internal */\r\n    AbstractControl.prototype._updateControlsErrors = function () {\r\n        this._status = this._calculateStatus();\r\n        if (lang_1.isPresent(this._parent)) {\r\n            this._parent._updateControlsErrors();\r\n        }\r\n    };\r\n    /** @internal */\r\n    AbstractControl.prototype._initObservables = function () {\r\n        this._valueChanges = new async_1.EventEmitter();\r\n        this._statusChanges = new async_1.EventEmitter();\r\n    };\r\n    AbstractControl.prototype._calculateStatus = function () {\r\n        if (lang_1.isPresent(this._errors))\r\n            return exports.INVALID;\r\n        if (this._anyControlsHaveStatus(exports.PENDING))\r\n            return exports.PENDING;\r\n        if (this._anyControlsHaveStatus(exports.INVALID))\r\n            return exports.INVALID;\r\n        return exports.VALID;\r\n    };\r\n    return AbstractControl;\r\n})();\r\nexports.AbstractControl = AbstractControl;\r\n/**\r\n * Defines a part of a form that cannot be divided into other controls. `Control`s have values and\r\n * validation state, which is determined by an optional validation function.\r\n *\r\n * `Control` is one of the three fundamental building blocks used to define forms in Angular, along\r\n * with {@link ControlGroup} and {@link ControlArray}.\r\n *\r\n * ## Usage\r\n *\r\n * By default, a `Control` is created for every `<input>` or other form component.\r\n * With {@link NgFormControl} or {@link NgFormModel} an existing {@link Control} can be\r\n * bound to a DOM element instead. This `Control` can be configured with a custom\r\n * validation function.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))\r\n */\r\nvar Control = (function (_super) {\r\n    __extends(Control, _super);\r\n    function Control(value, validator, asyncValidator) {\r\n        if (value === void 0) { value = null; }\r\n        if (validator === void 0) { validator = null; }\r\n        if (asyncValidator === void 0) { asyncValidator = null; }\r\n        _super.call(this, validator, asyncValidator);\r\n        this._value = value;\r\n        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });\r\n        this._initObservables();\r\n    }\r\n    /**\r\n     * Set the value of the control to `value`.\r\n     *\r\n     * If `onlySelf` is `true`, this change will only affect the validation of this `Control`\r\n     * and not its parent component. If `emitEvent` is `true`, this change will cause a\r\n     * `valueChanges` event on the `Control` to be emitted. Both of these options default to\r\n     * `false`.\r\n     *\r\n     * If `emitModelToViewChange` is `true`, the view will be notified about the new value\r\n     * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not\r\n     * specified.\r\n     */\r\n    Control.prototype.updateValue = function (value, _a) {\r\n        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange;\r\n        emitModelToViewChange = lang_1.isPresent(emitModelToViewChange) ? emitModelToViewChange : true;\r\n        this._value = value;\r\n        if (lang_1.isPresent(this._onChange) && emitModelToViewChange)\r\n            this._onChange(this._value);\r\n        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    Control.prototype._updateValue = function () { };\r\n    /**\r\n     * @internal\r\n     */\r\n    Control.prototype._anyControlsHaveStatus = function (status) { return false; };\r\n    /**\r\n     * Register a listener for change events.\r\n     */\r\n    Control.prototype.registerOnChange = function (fn) { this._onChange = fn; };\r\n    return Control;\r\n})(AbstractControl);\r\nexports.Control = Control;\r\n/**\r\n * Defines a part of a form, of fixed length, that can contain other controls.\r\n *\r\n * A `ControlGroup` aggregates the values and errors of each {@link Control} in the group. Thus, if\r\n * one of the controls in a group is invalid, the entire group is invalid. Similarly, if a control\r\n * changes its value, the entire group changes as well.\r\n *\r\n * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,\r\n * along with {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other\r\n * controls, but is of variable length.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))\r\n */\r\nvar ControlGroup = (function (_super) {\r\n    __extends(ControlGroup, _super);\r\n    function ControlGroup(controls, optionals, validator, asyncValidator) {\r\n        if (optionals === void 0) { optionals = null; }\r\n        if (validator === void 0) { validator = null; }\r\n        if (asyncValidator === void 0) { asyncValidator = null; }\r\n        _super.call(this, validator, asyncValidator);\r\n        this.controls = controls;\r\n        this._optionals = lang_1.isPresent(optionals) ? optionals : {};\r\n        this._initObservables();\r\n        this._setParentForControls();\r\n        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });\r\n    }\r\n    /**\r\n     * Add a control to this group.\r\n     */\r\n    ControlGroup.prototype.addControl = function (name, control) {\r\n        this.controls[name] = control;\r\n        control.setParent(this);\r\n    };\r\n    /**\r\n     * Remove a control from this group.\r\n     */\r\n    ControlGroup.prototype.removeControl = function (name) { collection_1.StringMapWrapper.delete(this.controls, name); };\r\n    /**\r\n     * Mark the named control as non-optional.\r\n     */\r\n    ControlGroup.prototype.include = function (controlName) {\r\n        collection_1.StringMapWrapper.set(this._optionals, controlName, true);\r\n        this.updateValueAndValidity();\r\n    };\r\n    /**\r\n     * Mark the named control as optional.\r\n     */\r\n    ControlGroup.prototype.exclude = function (controlName) {\r\n        collection_1.StringMapWrapper.set(this._optionals, controlName, false);\r\n        this.updateValueAndValidity();\r\n    };\r\n    /**\r\n     * Check whether there is a control with the given name in the group.\r\n     */\r\n    ControlGroup.prototype.contains = function (controlName) {\r\n        var c = collection_1.StringMapWrapper.contains(this.controls, controlName);\r\n        return c && this._included(controlName);\r\n    };\r\n    /** @internal */\r\n    ControlGroup.prototype._setParentForControls = function () {\r\n        var _this = this;\r\n        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) { control.setParent(_this); });\r\n    };\r\n    /** @internal */\r\n    ControlGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };\r\n    /** @internal */\r\n    ControlGroup.prototype._anyControlsHaveStatus = function (status) {\r\n        var _this = this;\r\n        var res = false;\r\n        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) {\r\n            res = res || (_this.contains(name) && control.status == status);\r\n        });\r\n        return res;\r\n    };\r\n    /** @internal */\r\n    ControlGroup.prototype._reduceValue = function () {\r\n        return this._reduceChildren({}, function (acc, control, name) {\r\n            acc[name] = control.value;\r\n            return acc;\r\n        });\r\n    };\r\n    /** @internal */\r\n    ControlGroup.prototype._reduceChildren = function (initValue, fn) {\r\n        var _this = this;\r\n        var res = initValue;\r\n        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) {\r\n            if (_this._included(name)) {\r\n                res = fn(res, control, name);\r\n            }\r\n        });\r\n        return res;\r\n    };\r\n    /** @internal */\r\n    ControlGroup.prototype._included = function (controlName) {\r\n        var isOptional = collection_1.StringMapWrapper.contains(this._optionals, controlName);\r\n        return !isOptional || collection_1.StringMapWrapper.get(this._optionals, controlName);\r\n    };\r\n    return ControlGroup;\r\n})(AbstractControl);\r\nexports.ControlGroup = ControlGroup;\r\n/**\r\n * Defines a part of a form, of variable length, that can contain other controls.\r\n *\r\n * A `ControlArray` aggregates the values and errors of each {@link Control} in the group. Thus, if\r\n * one of the controls in a group is invalid, the entire group is invalid. Similarly, if a control\r\n * changes its value, the entire group changes as well.\r\n *\r\n * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,\r\n * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain\r\n * other controls, but is of fixed length.\r\n *\r\n * ## Adding or removing controls\r\n *\r\n * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods\r\n * in `ControlArray` itself. These methods ensure the controls are properly tracked in the\r\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\r\n * the `ControlArray` directly, as that will result in strange and unexpected behavior such\r\n * as broken change detection.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))\r\n */\r\nvar ControlArray = (function (_super) {\r\n    __extends(ControlArray, _super);\r\n    function ControlArray(controls, validator, asyncValidator) {\r\n        if (validator === void 0) { validator = null; }\r\n        if (asyncValidator === void 0) { asyncValidator = null; }\r\n        _super.call(this, validator, asyncValidator);\r\n        this.controls = controls;\r\n        this._initObservables();\r\n        this._setParentForControls();\r\n        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });\r\n    }\r\n    /**\r\n     * Get the {@link AbstractControl} at the given `index` in the array.\r\n     */\r\n    ControlArray.prototype.at = function (index) { return this.controls[index]; };\r\n    /**\r\n     * Insert a new {@link AbstractControl} at the end of the array.\r\n     */\r\n    ControlArray.prototype.push = function (control) {\r\n        this.controls.push(control);\r\n        control.setParent(this);\r\n        this.updateValueAndValidity();\r\n    };\r\n    /**\r\n     * Insert a new {@link AbstractControl} at the given `index` in the array.\r\n     */\r\n    ControlArray.prototype.insert = function (index, control) {\r\n        collection_1.ListWrapper.insert(this.controls, index, control);\r\n        control.setParent(this);\r\n        this.updateValueAndValidity();\r\n    };\r\n    /**\r\n     * Remove the control at the given `index` in the array.\r\n     */\r\n    ControlArray.prototype.removeAt = function (index) {\r\n        collection_1.ListWrapper.removeAt(this.controls, index);\r\n        this.updateValueAndValidity();\r\n    };\r\n    Object.defineProperty(ControlArray.prototype, \"length\", {\r\n        /**\r\n         * Length of the control array.\r\n         */\r\n        get: function () { return this.controls.length; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @internal */\r\n    ControlArray.prototype._updateValue = function () { this._value = this.controls.map(function (control) { return control.value; }); };\r\n    /** @internal */\r\n    ControlArray.prototype._anyControlsHaveStatus = function (status) {\r\n        return this.controls.some(function (c) { return c.status == status; });\r\n    };\r\n    /** @internal */\r\n    ControlArray.prototype._setParentForControls = function () {\r\n        var _this = this;\r\n        this.controls.forEach(function (control) { control.setParent(_this); });\r\n    };\r\n    return ControlArray;\r\n})(AbstractControl);\r\nexports.ControlArray = ControlArray;\r\n},{\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176,\"angular2/src/facade/promise\":178}],42:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar promise_1 = require('angular2/src/facade/promise');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar core_1 = require('angular2/core');\r\n/**\r\n * Providers for validators to be used for {@link Control}s in a form.\r\n *\r\n * Provide this using `multi: true` to add validators.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}\r\n */\r\nexports.NG_VALIDATORS = lang_1.CONST_EXPR(new core_1.OpaqueToken(\"NgValidators\"));\r\n/**\r\n * Providers for asynchronous validators to be used for {@link Control}s\r\n * in a form.\r\n *\r\n * Provide this using `multi: true` to add validators.\r\n *\r\n * See {@link NG_VALIDATORS} for more details.\r\n */\r\nexports.NG_ASYNC_VALIDATORS = lang_1.CONST_EXPR(new core_1.OpaqueToken(\"NgAsyncValidators\"));\r\n/**\r\n * Provides a set of validators used by form controls.\r\n *\r\n * A validator is a function that processes a {@link Control} or collection of\r\n * controls and returns a map of errors. A null map means that validation has passed.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * var loginControl = new Control(\"\", Validators.required)\r\n * ```\r\n */\r\nvar Validators = (function () {\r\n    function Validators() {\r\n    }\r\n    /**\r\n     * Validator that requires controls to have a non-empty value.\r\n     */\r\n    Validators.required = function (control) {\r\n        return lang_1.isBlank(control.value) || control.value == \"\" ? { \"required\": true } : null;\r\n    };\r\n    /**\r\n     * Validator that requires controls to have a value of a minimum length.\r\n     */\r\n    Validators.minLength = function (minLength) {\r\n        return function (control) {\r\n            if (lang_1.isPresent(Validators.required(control)))\r\n                return null;\r\n            var v = control.value;\r\n            return v.length < minLength ?\r\n                { \"minlength\": { \"requiredLength\": minLength, \"actualLength\": v.length } } :\r\n                null;\r\n        };\r\n    };\r\n    /**\r\n     * Validator that requires controls to have a value of a maximum length.\r\n     */\r\n    Validators.maxLength = function (maxLength) {\r\n        return function (control) {\r\n            if (lang_1.isPresent(Validators.required(control)))\r\n                return null;\r\n            var v = control.value;\r\n            return v.length > maxLength ?\r\n                { \"maxlength\": { \"requiredLength\": maxLength, \"actualLength\": v.length } } :\r\n                null;\r\n        };\r\n    };\r\n    /**\r\n     * No-op validator.\r\n     */\r\n    Validators.nullValidator = function (c) { return null; };\r\n    /**\r\n     * Compose multiple validators into a single function that returns the union\r\n     * of the individual error maps.\r\n     */\r\n    Validators.compose = function (validators) {\r\n        if (lang_1.isBlank(validators))\r\n            return null;\r\n        var presentValidators = validators.filter(lang_1.isPresent);\r\n        if (presentValidators.length == 0)\r\n            return null;\r\n        return function (control) {\r\n            return _mergeErrors(_executeValidators(control, presentValidators));\r\n        };\r\n    };\r\n    Validators.composeAsync = function (validators) {\r\n        if (lang_1.isBlank(validators))\r\n            return null;\r\n        var presentValidators = validators.filter(lang_1.isPresent);\r\n        if (presentValidators.length == 0)\r\n            return null;\r\n        return function (control) {\r\n            var promises = _executeValidators(control, presentValidators).map(_convertToPromise);\r\n            return promise_1.PromiseWrapper.all(promises).then(_mergeErrors);\r\n        };\r\n    };\r\n    return Validators;\r\n})();\r\nexports.Validators = Validators;\r\nfunction _convertToPromise(obj) {\r\n    return promise_1.PromiseWrapper.isPromise(obj) ? obj : async_1.ObservableWrapper.toPromise(obj);\r\n}\r\nfunction _executeValidators(control, validators) {\r\n    return validators.map(function (v) { return v(control); });\r\n}\r\nfunction _mergeErrors(arrayOfErrors) {\r\n    var res = arrayOfErrors.reduce(function (res, errors) {\r\n        return lang_1.isPresent(errors) ? collection_1.StringMapWrapper.merge(res, errors) : res;\r\n    }, {});\r\n    return collection_1.StringMapWrapper.isEmpty(res) ? null : res;\r\n}\r\n},{\"angular2/core\":3,\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176,\"angular2/src/facade/promise\":178}],43:[function(require,module,exports){\n'use strict';/**\r\n * @module\r\n * @description\r\n * This module provides a set of common Pipes.\r\n */\r\nvar async_pipe_1 = require('./pipes/async_pipe');\r\nvar uppercase_pipe_1 = require('./pipes/uppercase_pipe');\r\nvar lowercase_pipe_1 = require('./pipes/lowercase_pipe');\r\nvar json_pipe_1 = require('./pipes/json_pipe');\r\nvar slice_pipe_1 = require('./pipes/slice_pipe');\r\nvar date_pipe_1 = require('./pipes/date_pipe');\r\nvar number_pipe_1 = require('./pipes/number_pipe');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar async_pipe_2 = require('./pipes/async_pipe');\r\nexports.AsyncPipe = async_pipe_2.AsyncPipe;\r\nvar date_pipe_2 = require('./pipes/date_pipe');\r\nexports.DatePipe = date_pipe_2.DatePipe;\r\nvar json_pipe_2 = require('./pipes/json_pipe');\r\nexports.JsonPipe = json_pipe_2.JsonPipe;\r\nvar slice_pipe_2 = require('./pipes/slice_pipe');\r\nexports.SlicePipe = slice_pipe_2.SlicePipe;\r\nvar lowercase_pipe_2 = require('./pipes/lowercase_pipe');\r\nexports.LowerCasePipe = lowercase_pipe_2.LowerCasePipe;\r\nvar number_pipe_2 = require('./pipes/number_pipe');\r\nexports.NumberPipe = number_pipe_2.NumberPipe;\r\nexports.DecimalPipe = number_pipe_2.DecimalPipe;\r\nexports.PercentPipe = number_pipe_2.PercentPipe;\r\nexports.CurrencyPipe = number_pipe_2.CurrencyPipe;\r\nvar uppercase_pipe_2 = require('./pipes/uppercase_pipe');\r\nexports.UpperCasePipe = uppercase_pipe_2.UpperCasePipe;\r\n/**\r\n * A collection of Angular core pipes that are likely to be used in each and every\r\n * application.\r\n *\r\n * This collection can be used to quickly enumerate all the built-in pipes in the `pipes`\r\n * property of the `@Component` or `@View` decorators.\r\n */\r\nexports.COMMON_PIPES = lang_1.CONST_EXPR([\r\n    async_pipe_1.AsyncPipe,\r\n    uppercase_pipe_1.UpperCasePipe,\r\n    lowercase_pipe_1.LowerCasePipe,\r\n    json_pipe_1.JsonPipe,\r\n    slice_pipe_1.SlicePipe,\r\n    number_pipe_1.DecimalPipe,\r\n    number_pipe_1.PercentPipe,\r\n    number_pipe_1.CurrencyPipe,\r\n    date_pipe_1.DatePipe\r\n]);\r\n},{\"./pipes/async_pipe\":44,\"./pipes/date_pipe\":45,\"./pipes/json_pipe\":47,\"./pipes/lowercase_pipe\":48,\"./pipes/number_pipe\":49,\"./pipes/slice_pipe\":50,\"./pipes/uppercase_pipe\":51,\"angular2/src/facade/lang\":176}],44:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar core_1 = require('angular2/core');\r\nvar invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');\r\nvar ObservableStrategy = (function () {\r\n    function ObservableStrategy() {\r\n    }\r\n    ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {\r\n        return async_1.ObservableWrapper.subscribe(async, updateLatestValue, function (e) { throw e; });\r\n    };\r\n    ObservableStrategy.prototype.dispose = function (subscription) { async_1.ObservableWrapper.dispose(subscription); };\r\n    ObservableStrategy.prototype.onDestroy = function (subscription) { async_1.ObservableWrapper.dispose(subscription); };\r\n    return ObservableStrategy;\r\n})();\r\nvar PromiseStrategy = (function () {\r\n    function PromiseStrategy() {\r\n    }\r\n    PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {\r\n        return async.then(updateLatestValue);\r\n    };\r\n    PromiseStrategy.prototype.dispose = function (subscription) { };\r\n    PromiseStrategy.prototype.onDestroy = function (subscription) { };\r\n    return PromiseStrategy;\r\n})();\r\nvar _promiseStrategy = new PromiseStrategy();\r\nvar _observableStrategy = new ObservableStrategy();\r\n/**\r\n * The `async` pipe subscribes to an Observable or Promise and returns the latest value it has\r\n * emitted.\r\n * When a new value is emitted, the `async` pipe marks the component to be checked for changes.\r\n *\r\n * ### Example\r\n *\r\n * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the\r\n * promise.\r\n *\r\n * {@example core/pipes/ts/async_pipe/async_pipe_example.ts region='AsyncPipe'}\r\n *\r\n * It's also possible to use `async` with Observables. The example below binds the `time` Observable\r\n * to the view. Every 500ms, the `time` Observable updates the view with the current time.\r\n *\r\n * ```typescript\r\n * ```\r\n */\r\nvar AsyncPipe = (function () {\r\n    function AsyncPipe(_ref) {\r\n        /** @internal */\r\n        this._latestValue = null;\r\n        /** @internal */\r\n        this._latestReturnedValue = null;\r\n        /** @internal */\r\n        this._subscription = null;\r\n        /** @internal */\r\n        this._obj = null;\r\n        this._strategy = null;\r\n        this._ref = _ref;\r\n    }\r\n    AsyncPipe.prototype.ngOnDestroy = function () {\r\n        if (lang_1.isPresent(this._subscription)) {\r\n            this._dispose();\r\n        }\r\n    };\r\n    AsyncPipe.prototype.transform = function (obj, args) {\r\n        if (lang_1.isBlank(this._obj)) {\r\n            if (lang_1.isPresent(obj)) {\r\n                this._subscribe(obj);\r\n            }\r\n            return this._latestValue;\r\n        }\r\n        if (obj !== this._obj) {\r\n            this._dispose();\r\n            return this.transform(obj);\r\n        }\r\n        if (this._latestValue === this._latestReturnedValue) {\r\n            return this._latestReturnedValue;\r\n        }\r\n        else {\r\n            this._latestReturnedValue = this._latestValue;\r\n            return core_1.WrappedValue.wrap(this._latestValue);\r\n        }\r\n    };\r\n    /** @internal */\r\n    AsyncPipe.prototype._subscribe = function (obj) {\r\n        var _this = this;\r\n        this._obj = obj;\r\n        this._strategy = this._selectStrategy(obj);\r\n        this._subscription =\r\n            this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });\r\n    };\r\n    /** @internal */\r\n    AsyncPipe.prototype._selectStrategy = function (obj) {\r\n        if (lang_1.isPromise(obj)) {\r\n            return _promiseStrategy;\r\n        }\r\n        else if (async_1.ObservableWrapper.isObservable(obj)) {\r\n            return _observableStrategy;\r\n        }\r\n        else {\r\n            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(AsyncPipe, obj);\r\n        }\r\n    };\r\n    /** @internal */\r\n    AsyncPipe.prototype._dispose = function () {\r\n        this._strategy.dispose(this._subscription);\r\n        this._latestValue = null;\r\n        this._latestReturnedValue = null;\r\n        this._subscription = null;\r\n        this._obj = null;\r\n    };\r\n    /** @internal */\r\n    AsyncPipe.prototype._updateLatestValue = function (async, value) {\r\n        if (async === this._obj) {\r\n            this._latestValue = value;\r\n            this._ref.markForCheck();\r\n        }\r\n    };\r\n    AsyncPipe = __decorate([\r\n        core_1.Pipe({ name: 'async', pure: false }),\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [core_1.ChangeDetectorRef])\r\n    ], AsyncPipe);\r\n    return AsyncPipe;\r\n})();\r\nexports.AsyncPipe = AsyncPipe;\r\n},{\"./invalid_pipe_argument_exception\":46,\"angular2/core\":3,\"angular2/src/facade/async\":169,\"angular2/src/facade/lang\":176}],45:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar intl_1 = require('angular2/src/facade/intl');\r\nvar core_1 = require('angular2/core');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');\r\n// TODO: move to a global configurable location along with other i18n components.\r\nvar defaultLocale = 'en-US';\r\n/**\r\n * Formats a date value to a string based on the requested format.\r\n *\r\n * WARNINGS:\r\n * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.\r\n *   Instead users should treat the date as an immutable object and change the reference when the\r\n *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run\r\n *   which would be an expensive operation).\r\n * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera\r\n *   browsers.\r\n *\r\n * ## Usage\r\n *\r\n *     expression | date[:format]\r\n *\r\n * where `expression` is a date object or a number (milliseconds since UTC epoch) and\r\n * `format` indicates which date/time components to include:\r\n *\r\n *  | Component | Symbol | Short Form   | Long Form         | Numeric   | 2-digit   |\r\n *  |-----------|:------:|--------------|-------------------|-----------|-----------|\r\n *  | era       |   G    | G (AD)       | GGGG (Anno Domini)| -         | -         |\r\n *  | year      |   y    | -            | -                 | y (2015)  | yy (15)   |\r\n *  | month     |   M    | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |\r\n *  | day       |   d    | -            | -                 | d (3)     | dd (03)   |\r\n *  | weekday   |   E    | EEE (Sun)    | EEEE (Sunday)     | -         | -         |\r\n *  | hour      |   j    | -            | -                 | j (13)    | jj (13)   |\r\n *  | hour12    |   h    | -            | -                 | h (1 PM)  | hh (01 PM)|\r\n *  | hour24    |   H    | -            | -                 | H (13)    | HH (13)   |\r\n *  | minute    |   m    | -            | -                 | m (5)     | mm (05)   |\r\n *  | second    |   s    | -            | -                 | s (9)     | ss (09)   |\r\n *  | timezone  |   z    | -            | z (Pacific Standard Time)| -  | -         |\r\n *  | timezone  |   Z    | Z (GMT-8:00) | -                 | -         | -         |\r\n *\r\n * In javascript, only the components specified will be respected (not the ordering,\r\n * punctuations, ...) and details of the formatting will be dependent on the locale.\r\n * On the other hand in Dart version, you can also include quoted text as well as some extra\r\n * date/time components such as quarter. For more information see:\r\n * https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/intl/intl.DateFormat.\r\n *\r\n * `format` can also be one of the following predefined formats:\r\n *\r\n *  - `'medium'`: equivalent to `'yMMMdjms'` (e.g. Sep 3, 2010, 12:05:08 PM for en-US)\r\n *  - `'short'`: equivalent to `'yMdjm'` (e.g. 9/3/2010, 12:05 PM for en-US)\r\n *  - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. Friday, September 3, 2010 for en-US)\r\n *  - `'longDate'`: equivalent to `'yMMMMd'` (e.g. September 3, 2010)\r\n *  - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. Sep 3, 2010 for en-US)\r\n *  - `'shortDate'`: equivalent to `'yMd'` (e.g. 9/3/2010 for en-US)\r\n *  - `'mediumTime'`: equivalent to `'jms'` (e.g. 12:05:08 PM for en-US)\r\n *  - `'shortTime'`: equivalent to `'jm'` (e.g. 12:05 PM for en-US)\r\n *\r\n * Timezone of the formatted text will be the local system timezone of the end-users machine.\r\n *\r\n * ### Examples\r\n *\r\n * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)\r\n * in the _local_ time and locale is 'en-US':\r\n *\r\n * ```\r\n *     {{ dateObj | date }}               // output is 'Jun 15, 2015'\r\n *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'\r\n *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'\r\n *     {{ dateObj | date:'mmss' }}        // output is '43:11'\r\n * ```\r\n *\r\n * {@example core/pipes/ts/date_pipe/date_pipe_example.ts region='DatePipe'}\r\n */\r\nvar DatePipe = (function () {\r\n    function DatePipe() {\r\n    }\r\n    DatePipe.prototype.transform = function (value, args) {\r\n        if (lang_1.isBlank(value))\r\n            return null;\r\n        if (!this.supports(value)) {\r\n            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(DatePipe, value);\r\n        }\r\n        var pattern = lang_1.isPresent(args) && args.length > 0 ? args[0] : 'mediumDate';\r\n        if (lang_1.isNumber(value)) {\r\n            value = lang_1.DateWrapper.fromMillis(value);\r\n        }\r\n        if (collection_1.StringMapWrapper.contains(DatePipe._ALIASES, pattern)) {\r\n            pattern = collection_1.StringMapWrapper.get(DatePipe._ALIASES, pattern);\r\n        }\r\n        return intl_1.DateFormatter.format(value, defaultLocale, pattern);\r\n    };\r\n    DatePipe.prototype.supports = function (obj) { return lang_1.isDate(obj) || lang_1.isNumber(obj); };\r\n    /** @internal */\r\n    DatePipe._ALIASES = {\r\n        'medium': 'yMMMdjms',\r\n        'short': 'yMdjm',\r\n        'fullDate': 'yMMMMEEEEd',\r\n        'longDate': 'yMMMMd',\r\n        'mediumDate': 'yMMMd',\r\n        'shortDate': 'yMd',\r\n        'mediumTime': 'jms',\r\n        'shortTime': 'jm'\r\n    };\r\n    DatePipe = __decorate([\r\n        lang_1.CONST(),\r\n        core_1.Pipe({ name: 'date', pure: true }),\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], DatePipe);\r\n    return DatePipe;\r\n})();\r\nexports.DatePipe = DatePipe;\r\n},{\"./invalid_pipe_argument_exception\":46,\"angular2/core\":3,\"angular2/src/facade/collection\":171,\"angular2/src/facade/intl\":175,\"angular2/src/facade/lang\":176}],46:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar InvalidPipeArgumentException = (function (_super) {\r\n    __extends(InvalidPipeArgumentException, _super);\r\n    function InvalidPipeArgumentException(type, value) {\r\n        _super.call(this, \"Invalid argument '\" + value + \"' for pipe '\" + lang_1.stringify(type) + \"'\");\r\n    }\r\n    return InvalidPipeArgumentException;\r\n})(exceptions_1.BaseException);\r\nexports.InvalidPipeArgumentException = InvalidPipeArgumentException;\r\n},{\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],47:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar core_1 = require('angular2/core');\r\n/**\r\n * Transforms any input value using `JSON.stringify`. Useful for debugging.\r\n *\r\n * ### Example\r\n * {@example core/pipes/ts/json_pipe/json_pipe_example.ts region='JsonPipe'}\r\n */\r\nvar JsonPipe = (function () {\r\n    function JsonPipe() {\r\n    }\r\n    JsonPipe.prototype.transform = function (value, args) {\r\n        if (args === void 0) { args = null; }\r\n        return lang_1.Json.stringify(value);\r\n    };\r\n    JsonPipe = __decorate([\r\n        lang_1.CONST(),\r\n        core_1.Pipe({ name: 'json', pure: false }),\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], JsonPipe);\r\n    return JsonPipe;\r\n})();\r\nexports.JsonPipe = JsonPipe;\r\n},{\"angular2/core\":3,\"angular2/src/facade/lang\":176}],48:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar core_1 = require('angular2/core');\r\nvar invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');\r\n/**\r\n * Transforms text to lowercase.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/pipes/ts/lowerupper_pipe/lowerupper_pipe_example.ts region='LowerUpperPipe'}\r\n */\r\nvar LowerCasePipe = (function () {\r\n    function LowerCasePipe() {\r\n    }\r\n    LowerCasePipe.prototype.transform = function (value, args) {\r\n        if (args === void 0) { args = null; }\r\n        if (lang_1.isBlank(value))\r\n            return value;\r\n        if (!lang_1.isString(value)) {\r\n            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(LowerCasePipe, value);\r\n        }\r\n        return value.toLowerCase();\r\n    };\r\n    LowerCasePipe = __decorate([\r\n        lang_1.CONST(),\r\n        core_1.Pipe({ name: 'lowercase' }),\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], LowerCasePipe);\r\n    return LowerCasePipe;\r\n})();\r\nexports.LowerCasePipe = LowerCasePipe;\r\n},{\"./invalid_pipe_argument_exception\":46,\"angular2/core\":3,\"angular2/src/facade/lang\":176}],49:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar intl_1 = require('angular2/src/facade/intl');\r\nvar core_1 = require('angular2/core');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');\r\nvar defaultLocale = 'en-US';\r\nvar _re = lang_1.RegExpWrapper.create('^(\\\\d+)?\\\\.((\\\\d+)(\\\\-(\\\\d+))?)?$');\r\n/**\r\n * Internal base class for numeric pipes.\r\n */\r\nvar NumberPipe = (function () {\r\n    function NumberPipe() {\r\n    }\r\n    /** @internal */\r\n    NumberPipe._format = function (value, style, digits, currency, currencyAsSymbol) {\r\n        if (currency === void 0) { currency = null; }\r\n        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }\r\n        if (lang_1.isBlank(value))\r\n            return null;\r\n        if (!lang_1.isNumber(value)) {\r\n            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(NumberPipe, value);\r\n        }\r\n        var minInt = 1, minFraction = 0, maxFraction = 3;\r\n        if (lang_1.isPresent(digits)) {\r\n            var parts = lang_1.RegExpWrapper.firstMatch(_re, digits);\r\n            if (lang_1.isBlank(parts)) {\r\n                throw new exceptions_1.BaseException(digits + \" is not a valid digit info for number pipes\");\r\n            }\r\n            if (lang_1.isPresent(parts[1])) {\r\n                minInt = lang_1.NumberWrapper.parseIntAutoRadix(parts[1]);\r\n            }\r\n            if (lang_1.isPresent(parts[3])) {\r\n                minFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[3]);\r\n            }\r\n            if (lang_1.isPresent(parts[5])) {\r\n                maxFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[5]);\r\n            }\r\n        }\r\n        return intl_1.NumberFormatter.format(value, defaultLocale, style, {\r\n            minimumIntegerDigits: minInt,\r\n            minimumFractionDigits: minFraction,\r\n            maximumFractionDigits: maxFraction,\r\n            currency: currency,\r\n            currencyAsSymbol: currencyAsSymbol\r\n        });\r\n    };\r\n    NumberPipe = __decorate([\r\n        lang_1.CONST(),\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], NumberPipe);\r\n    return NumberPipe;\r\n})();\r\nexports.NumberPipe = NumberPipe;\r\n/**\r\n * WARNING: this pipe uses the Internationalization API.\r\n * Therefore it is only reliable in Chrome and Opera browsers.\r\n *\r\n * Formats a number as local text. i.e. group sizing and separator and other locale-specific\r\n * configurations are based on the active locale.\r\n *\r\n * ### Usage\r\n *\r\n *     expression | number[:digitInfo]\r\n *\r\n * where `expression` is a number and `digitInfo` has the following format:\r\n *\r\n *     {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}\r\n *\r\n * - minIntegerDigits is the minimum number of integer digits to use. Defaults to 1.\r\n * - minFractionDigits is the minimum number of digits after fraction. Defaults to 0.\r\n * - maxFractionDigits is the maximum number of digits after fraction. Defaults to 3.\r\n *\r\n * For more information on the acceptable range for each of these numbers and other\r\n * details see your native internationalization library.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/pipes/ts/number_pipe/number_pipe_example.ts region='NumberPipe'}\r\n */\r\nvar DecimalPipe = (function (_super) {\r\n    __extends(DecimalPipe, _super);\r\n    function DecimalPipe() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    DecimalPipe.prototype.transform = function (value, args) {\r\n        var digits = collection_1.ListWrapper.first(args);\r\n        return NumberPipe._format(value, intl_1.NumberFormatStyle.Decimal, digits);\r\n    };\r\n    DecimalPipe = __decorate([\r\n        lang_1.CONST(),\r\n        core_1.Pipe({ name: 'number' }),\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], DecimalPipe);\r\n    return DecimalPipe;\r\n})(NumberPipe);\r\nexports.DecimalPipe = DecimalPipe;\r\n/**\r\n * WARNING: this pipe uses the Internationalization API.\r\n * Therefore it is only reliable in Chrome and Opera browsers.\r\n *\r\n * Formats a number as local percent.\r\n *\r\n * ### Usage\r\n *\r\n *     expression | percent[:digitInfo]\r\n *\r\n * For more information about `digitInfo` see {@link DecimalPipe}\r\n *\r\n * ### Example\r\n *\r\n * {@example core/pipes/ts/number_pipe/number_pipe_example.ts region='PercentPipe'}\r\n */\r\nvar PercentPipe = (function (_super) {\r\n    __extends(PercentPipe, _super);\r\n    function PercentPipe() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    PercentPipe.prototype.transform = function (value, args) {\r\n        var digits = collection_1.ListWrapper.first(args);\r\n        return NumberPipe._format(value, intl_1.NumberFormatStyle.Percent, digits);\r\n    };\r\n    PercentPipe = __decorate([\r\n        lang_1.CONST(),\r\n        core_1.Pipe({ name: 'percent' }),\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], PercentPipe);\r\n    return PercentPipe;\r\n})(NumberPipe);\r\nexports.PercentPipe = PercentPipe;\r\n/**\r\n * WARNING: this pipe uses the Internationalization API.\r\n * Therefore it is only reliable in Chrome and Opera browsers.\r\n *\r\n * Formats a number as local currency.\r\n *\r\n * ### Usage\r\n *\r\n *     expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]\r\n *\r\n * where `currencyCode` is the ISO 4217 currency code, such as \"USD\" for the US dollar and\r\n * \"EUR\" for the euro. `symbolDisplay` is a boolean indicating whether to use the currency\r\n * symbol (e.g. $) or the currency code (e.g. USD) in the output. The default for this value\r\n * is `false`.\r\n * For more information about `digitInfo` see {@link DecimalPipe}\r\n *\r\n * ### Example\r\n *\r\n * {@example core/pipes/ts/number_pipe/number_pipe_example.ts region='CurrencyPipe'}\r\n */\r\nvar CurrencyPipe = (function (_super) {\r\n    __extends(CurrencyPipe, _super);\r\n    function CurrencyPipe() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    CurrencyPipe.prototype.transform = function (value, args) {\r\n        var currencyCode = lang_1.isPresent(args) && args.length > 0 ? args[0] : 'USD';\r\n        var symbolDisplay = lang_1.isPresent(args) && args.length > 1 ? args[1] : false;\r\n        var digits = lang_1.isPresent(args) && args.length > 2 ? args[2] : null;\r\n        return NumberPipe._format(value, intl_1.NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);\r\n    };\r\n    CurrencyPipe = __decorate([\r\n        lang_1.CONST(),\r\n        core_1.Pipe({ name: 'currency' }),\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], CurrencyPipe);\r\n    return CurrencyPipe;\r\n})(NumberPipe);\r\nexports.CurrencyPipe = CurrencyPipe;\r\n},{\"./invalid_pipe_argument_exception\":46,\"angular2/core\":3,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/intl\":175,\"angular2/src/facade/lang\":176}],50:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar core_1 = require('angular2/core');\r\nvar invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');\r\n/**\r\n * Creates a new List or String containing only a subset (slice) of the\r\n * elements.\r\n *\r\n * The starting index of the subset to return is specified by the `start` parameter.\r\n *\r\n * The ending index of the subset to return is specified by the optional `end` parameter.\r\n *\r\n * ### Usage\r\n *\r\n *     expression | slice:start[:end]\r\n *\r\n * All behavior is based on the expected behavior of the JavaScript API\r\n * Array.prototype.slice() and String.prototype.slice()\r\n *\r\n * Where the input expression is a [List] or [String], and `start` is:\r\n *\r\n * - **a positive integer**: return the item at _start_ index and all items after\r\n * in the list or string expression.\r\n * - **a negative integer**: return the item at _start_ index from the end and all items after\r\n * in the list or string expression.\r\n * - **`|start|` greater than the size of the expression**: return an empty list or string.\r\n * - **`|start|` negative greater than the size of the expression**: return entire list or\r\n * string expression.\r\n *\r\n * and where `end` is:\r\n *\r\n * - **omitted**: return all items until the end of the input\r\n * - **a positive integer**: return all items before _end_ index of the list or string\r\n * expression.\r\n * - **a negative integer**: return all items before _end_ index from the end of the list\r\n * or string expression.\r\n *\r\n * When operating on a [List], the returned list is always a copy even when all\r\n * the elements are being returned.\r\n *\r\n * ## List Example\r\n *\r\n * This `ngFor` example:\r\n *\r\n * {@example core/pipes/ts/slice_pipe/slice_pipe_example.ts region='SlicePipe_list'}\r\n *\r\n * produces the following:\r\n *\r\n *     <li>b</li>\r\n *     <li>c</li>\r\n *\r\n * ## String Examples\r\n *\r\n * {@example core/pipes/ts/slice_pipe/slice_pipe_example.ts region='SlicePipe_string'}\r\n */\r\nvar SlicePipe = (function () {\r\n    function SlicePipe() {\r\n    }\r\n    SlicePipe.prototype.transform = function (value, args) {\r\n        if (args === void 0) { args = null; }\r\n        if (lang_1.isBlank(args) || args.length == 0) {\r\n            throw new exceptions_1.BaseException('Slice pipe requires one argument');\r\n        }\r\n        if (!this.supports(value)) {\r\n            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(SlicePipe, value);\r\n        }\r\n        if (lang_1.isBlank(value))\r\n            return value;\r\n        var start = args[0];\r\n        var end = args.length > 1 ? args[1] : null;\r\n        if (lang_1.isString(value)) {\r\n            return lang_1.StringWrapper.slice(value, start, end);\r\n        }\r\n        return collection_1.ListWrapper.slice(value, start, end);\r\n    };\r\n    SlicePipe.prototype.supports = function (obj) { return lang_1.isString(obj) || lang_1.isArray(obj); };\r\n    SlicePipe = __decorate([\r\n        core_1.Pipe({ name: 'slice', pure: false }),\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], SlicePipe);\r\n    return SlicePipe;\r\n})();\r\nexports.SlicePipe = SlicePipe;\r\n},{\"./invalid_pipe_argument_exception\":46,\"angular2/core\":3,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],51:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar core_1 = require('angular2/core');\r\nvar invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');\r\n/**\r\n * Implements uppercase transforms to text.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/pipes/ts/lowerupper_pipe/lowerupper_pipe_example.ts region='LowerUpperPipe'}\r\n */\r\nvar UpperCasePipe = (function () {\r\n    function UpperCasePipe() {\r\n    }\r\n    UpperCasePipe.prototype.transform = function (value, args) {\r\n        if (args === void 0) { args = null; }\r\n        if (lang_1.isBlank(value))\r\n            return value;\r\n        if (!lang_1.isString(value)) {\r\n            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(UpperCasePipe, value);\r\n        }\r\n        return value.toUpperCase();\r\n    };\r\n    UpperCasePipe = __decorate([\r\n        lang_1.CONST(),\r\n        core_1.Pipe({ name: 'uppercase' }),\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], UpperCasePipe);\r\n    return UpperCasePipe;\r\n})();\r\nexports.UpperCasePipe = UpperCasePipe;\r\n},{\"./invalid_pipe_argument_exception\":46,\"angular2/core\":3,\"angular2/src/facade/lang\":176}],52:[function(require,module,exports){\n'use strict';var collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar reflection_1 = require('angular2/src/core/reflection/reflection');\r\nvar change_detection_1 = require('angular2/src/core/change_detection/change_detection');\r\nvar template_ast_1 = require('./template_ast');\r\nvar interfaces_1 = require('angular2/src/core/linker/interfaces');\r\nfunction createChangeDetectorDefinitions(componentType, componentStrategy, genConfig, parsedTemplate) {\r\n    var pvVisitors = [];\r\n    var visitor = new ProtoViewVisitor(null, pvVisitors, componentStrategy);\r\n    template_ast_1.templateVisitAll(visitor, parsedTemplate);\r\n    return createChangeDefinitions(pvVisitors, componentType, genConfig);\r\n}\r\nexports.createChangeDetectorDefinitions = createChangeDetectorDefinitions;\r\nvar ProtoViewVisitor = (function () {\r\n    function ProtoViewVisitor(parent, allVisitors, strategy) {\r\n        this.parent = parent;\r\n        this.allVisitors = allVisitors;\r\n        this.strategy = strategy;\r\n        this.nodeCount = 0;\r\n        this.boundElementCount = 0;\r\n        this.variableNames = [];\r\n        this.bindingRecords = [];\r\n        this.eventRecords = [];\r\n        this.directiveRecords = [];\r\n        this.viewIndex = allVisitors.length;\r\n        allVisitors.push(this);\r\n    }\r\n    ProtoViewVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {\r\n        this.nodeCount++;\r\n        this.boundElementCount++;\r\n        template_ast_1.templateVisitAll(this, ast.outputs);\r\n        for (var i = 0; i < ast.directives.length; i++) {\r\n            ast.directives[i].visit(this, i);\r\n        }\r\n        var childVisitor = new ProtoViewVisitor(this, this.allVisitors, change_detection_1.ChangeDetectionStrategy.Default);\r\n        // Attention: variables present on an embedded template count towards\r\n        // the embedded template and not the template anchor!\r\n        template_ast_1.templateVisitAll(childVisitor, ast.vars);\r\n        template_ast_1.templateVisitAll(childVisitor, ast.children);\r\n        return null;\r\n    };\r\n    ProtoViewVisitor.prototype.visitElement = function (ast, context) {\r\n        this.nodeCount++;\r\n        if (ast.isBound()) {\r\n            this.boundElementCount++;\r\n        }\r\n        template_ast_1.templateVisitAll(this, ast.inputs, null);\r\n        template_ast_1.templateVisitAll(this, ast.outputs);\r\n        template_ast_1.templateVisitAll(this, ast.exportAsVars);\r\n        for (var i = 0; i < ast.directives.length; i++) {\r\n            ast.directives[i].visit(this, i);\r\n        }\r\n        template_ast_1.templateVisitAll(this, ast.children);\r\n        return null;\r\n    };\r\n    ProtoViewVisitor.prototype.visitNgContent = function (ast, context) { return null; };\r\n    ProtoViewVisitor.prototype.visitVariable = function (ast, context) {\r\n        this.variableNames.push(ast.name);\r\n        return null;\r\n    };\r\n    ProtoViewVisitor.prototype.visitEvent = function (ast, directiveRecord) {\r\n        var bindingRecord = lang_1.isPresent(directiveRecord) ?\r\n            change_detection_1.BindingRecord.createForHostEvent(ast.handler, ast.fullName, directiveRecord) :\r\n            change_detection_1.BindingRecord.createForEvent(ast.handler, ast.fullName, this.boundElementCount - 1);\r\n        this.eventRecords.push(bindingRecord);\r\n        return null;\r\n    };\r\n    ProtoViewVisitor.prototype.visitElementProperty = function (ast, directiveRecord) {\r\n        var boundElementIndex = this.boundElementCount - 1;\r\n        var dirIndex = lang_1.isPresent(directiveRecord) ? directiveRecord.directiveIndex : null;\r\n        var bindingRecord;\r\n        if (ast.type === template_ast_1.PropertyBindingType.Property) {\r\n            bindingRecord =\r\n                lang_1.isPresent(dirIndex) ?\r\n                    change_detection_1.BindingRecord.createForHostProperty(dirIndex, ast.value, ast.name) :\r\n                    change_detection_1.BindingRecord.createForElementProperty(ast.value, boundElementIndex, ast.name);\r\n        }\r\n        else if (ast.type === template_ast_1.PropertyBindingType.Attribute) {\r\n            bindingRecord =\r\n                lang_1.isPresent(dirIndex) ?\r\n                    change_detection_1.BindingRecord.createForHostAttribute(dirIndex, ast.value, ast.name) :\r\n                    change_detection_1.BindingRecord.createForElementAttribute(ast.value, boundElementIndex, ast.name);\r\n        }\r\n        else if (ast.type === template_ast_1.PropertyBindingType.Class) {\r\n            bindingRecord =\r\n                lang_1.isPresent(dirIndex) ?\r\n                    change_detection_1.BindingRecord.createForHostClass(dirIndex, ast.value, ast.name) :\r\n                    change_detection_1.BindingRecord.createForElementClass(ast.value, boundElementIndex, ast.name);\r\n        }\r\n        else if (ast.type === template_ast_1.PropertyBindingType.Style) {\r\n            bindingRecord =\r\n                lang_1.isPresent(dirIndex) ?\r\n                    change_detection_1.BindingRecord.createForHostStyle(dirIndex, ast.value, ast.name, ast.unit) :\r\n                    change_detection_1.BindingRecord.createForElementStyle(ast.value, boundElementIndex, ast.name, ast.unit);\r\n        }\r\n        this.bindingRecords.push(bindingRecord);\r\n        return null;\r\n    };\r\n    ProtoViewVisitor.prototype.visitAttr = function (ast, context) { return null; };\r\n    ProtoViewVisitor.prototype.visitBoundText = function (ast, context) {\r\n        var nodeIndex = this.nodeCount++;\r\n        this.bindingRecords.push(change_detection_1.BindingRecord.createForTextNode(ast.value, nodeIndex));\r\n        return null;\r\n    };\r\n    ProtoViewVisitor.prototype.visitText = function (ast, context) {\r\n        this.nodeCount++;\r\n        return null;\r\n    };\r\n    ProtoViewVisitor.prototype.visitDirective = function (ast, directiveIndexAsNumber) {\r\n        var directiveIndex = new change_detection_1.DirectiveIndex(this.boundElementCount - 1, directiveIndexAsNumber);\r\n        var directiveMetadata = ast.directive;\r\n        var outputsArray = [];\r\n        collection_1.StringMapWrapper.forEach(ast.directive.outputs, function (eventName, dirProperty) { return outputsArray.push([dirProperty, eventName]); });\r\n        var directiveRecord = new change_detection_1.DirectiveRecord({\r\n            directiveIndex: directiveIndex,\r\n            callAfterContentInit: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterContentInit) !== -1,\r\n            callAfterContentChecked: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterContentChecked) !== -1,\r\n            callAfterViewInit: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterViewInit) !== -1,\r\n            callAfterViewChecked: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.AfterViewChecked) !== -1,\r\n            callOnChanges: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.OnChanges) !== -1,\r\n            callDoCheck: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.DoCheck) !== -1,\r\n            callOnInit: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.OnInit) !== -1,\r\n            callOnDestroy: directiveMetadata.lifecycleHooks.indexOf(interfaces_1.LifecycleHooks.OnDestroy) !== -1,\r\n            changeDetection: directiveMetadata.changeDetection,\r\n            outputs: outputsArray\r\n        });\r\n        this.directiveRecords.push(directiveRecord);\r\n        template_ast_1.templateVisitAll(this, ast.inputs, directiveRecord);\r\n        var bindingRecords = this.bindingRecords;\r\n        if (directiveRecord.callOnChanges) {\r\n            bindingRecords.push(change_detection_1.BindingRecord.createDirectiveOnChanges(directiveRecord));\r\n        }\r\n        if (directiveRecord.callOnInit) {\r\n            bindingRecords.push(change_detection_1.BindingRecord.createDirectiveOnInit(directiveRecord));\r\n        }\r\n        if (directiveRecord.callDoCheck) {\r\n            bindingRecords.push(change_detection_1.BindingRecord.createDirectiveDoCheck(directiveRecord));\r\n        }\r\n        template_ast_1.templateVisitAll(this, ast.hostProperties, directiveRecord);\r\n        template_ast_1.templateVisitAll(this, ast.hostEvents, directiveRecord);\r\n        template_ast_1.templateVisitAll(this, ast.exportAsVars);\r\n        return null;\r\n    };\r\n    ProtoViewVisitor.prototype.visitDirectiveProperty = function (ast, directiveRecord) {\r\n        // TODO: these setters should eventually be created by change detection, to make\r\n        // it monomorphic!\r\n        var setter = reflection_1.reflector.setter(ast.directiveName);\r\n        this.bindingRecords.push(change_detection_1.BindingRecord.createForDirective(ast.value, ast.directiveName, setter, directiveRecord));\r\n        return null;\r\n    };\r\n    return ProtoViewVisitor;\r\n})();\r\nfunction createChangeDefinitions(pvVisitors, componentType, genConfig) {\r\n    var pvVariableNames = _collectNestedProtoViewsVariableNames(pvVisitors);\r\n    return pvVisitors.map(function (pvVisitor) {\r\n        var id = componentType.name + \"_\" + pvVisitor.viewIndex;\r\n        return new change_detection_1.ChangeDetectorDefinition(id, pvVisitor.strategy, pvVariableNames[pvVisitor.viewIndex], pvVisitor.bindingRecords, pvVisitor.eventRecords, pvVisitor.directiveRecords, genConfig);\r\n    });\r\n}\r\nfunction _collectNestedProtoViewsVariableNames(pvVisitors) {\r\n    var nestedPvVariableNames = collection_1.ListWrapper.createFixedSize(pvVisitors.length);\r\n    pvVisitors.forEach(function (pv) {\r\n        var parentVariableNames = lang_1.isPresent(pv.parent) ? nestedPvVariableNames[pv.parent.viewIndex] : [];\r\n        nestedPvVariableNames[pv.viewIndex] = parentVariableNames.concat(pv.variableNames);\r\n    });\r\n    return nestedPvVariableNames;\r\n}\r\n},{\"./template_ast\":71,\"angular2/src/core/change_detection/change_detection\":87,\"angular2/src/core/linker/interfaces\":134,\"angular2/src/core/reflection/reflection\":158,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],53:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar source_module_1 = require('./source_module');\r\nvar change_detection_jit_generator_1 = require('angular2/src/core/change_detection/change_detection_jit_generator');\r\nvar abstract_change_detector_1 = require('angular2/src/core/change_detection/abstract_change_detector');\r\nvar change_detection_util_1 = require('angular2/src/core/change_detection/change_detection_util');\r\nvar constants_1 = require('angular2/src/core/change_detection/constants');\r\nvar change_definition_factory_1 = require('./change_definition_factory');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar change_detection_1 = require('angular2/src/core/change_detection/change_detection');\r\nvar change_detector_codegen_1 = require('angular2/src/transform/template_compiler/change_detector_codegen');\r\nvar util_1 = require('./util');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar ABSTRACT_CHANGE_DETECTOR = \"AbstractChangeDetector\";\r\nvar UTIL = \"ChangeDetectionUtil\";\r\nvar CHANGE_DETECTOR_STATE = \"ChangeDetectorState\";\r\nexports.CHANGE_DETECTION_JIT_IMPORTS = lang_1.CONST_EXPR({\r\n    'AbstractChangeDetector': abstract_change_detector_1.AbstractChangeDetector,\r\n    'ChangeDetectionUtil': change_detection_util_1.ChangeDetectionUtil,\r\n    'ChangeDetectorState': constants_1.ChangeDetectorState\r\n});\r\nvar ABSTRACT_CHANGE_DETECTOR_MODULE = source_module_1.moduleRef(\"package:angular2/src/core/change_detection/abstract_change_detector\" + util_1.MODULE_SUFFIX);\r\nvar UTIL_MODULE = source_module_1.moduleRef(\"package:angular2/src/core/change_detection/change_detection_util\" + util_1.MODULE_SUFFIX);\r\nvar PREGEN_PROTO_CHANGE_DETECTOR_MODULE = source_module_1.moduleRef(\"package:angular2/src/core/change_detection/pregen_proto_change_detector\" + util_1.MODULE_SUFFIX);\r\nvar CONSTANTS_MODULE = source_module_1.moduleRef(\"package:angular2/src/core/change_detection/constants\" + util_1.MODULE_SUFFIX);\r\nvar ChangeDetectionCompiler = (function () {\r\n    function ChangeDetectionCompiler(_genConfig) {\r\n        this._genConfig = _genConfig;\r\n    }\r\n    ChangeDetectionCompiler.prototype.compileComponentRuntime = function (componentType, strategy, parsedTemplate) {\r\n        var _this = this;\r\n        var changeDetectorDefinitions = change_definition_factory_1.createChangeDetectorDefinitions(componentType, strategy, this._genConfig, parsedTemplate);\r\n        return changeDetectorDefinitions.map(function (definition) {\r\n            return _this._createChangeDetectorFactory(definition);\r\n        });\r\n    };\r\n    ChangeDetectionCompiler.prototype._createChangeDetectorFactory = function (definition) {\r\n        var proto = new change_detection_1.DynamicProtoChangeDetector(definition);\r\n        return function () { return proto.instantiate(); };\r\n    };\r\n    ChangeDetectionCompiler.prototype.compileComponentCodeGen = function (componentType, strategy, parsedTemplate) {\r\n        var changeDetectorDefinitions = change_definition_factory_1.createChangeDetectorDefinitions(componentType, strategy, this._genConfig, parsedTemplate);\r\n        var factories = [];\r\n        var index = 0;\r\n        var sourceParts = changeDetectorDefinitions.map(function (definition) {\r\n            var codegen;\r\n            var sourcePart;\r\n            // TODO(tbosch): move the 2 code generators to the same place, one with .dart and one with .ts\r\n            // suffix\r\n            // and have the same API for calling them!\r\n            if (lang_1.IS_DART) {\r\n                codegen = new change_detector_codegen_1.Codegen(PREGEN_PROTO_CHANGE_DETECTOR_MODULE);\r\n                var className = \"_\" + definition.id;\r\n                var typeRef = (index === 0 && componentType.isHost) ?\r\n                    'dynamic' :\r\n                    \"\" + source_module_1.moduleRef(componentType.moduleUrl) + componentType.name;\r\n                codegen.generate(typeRef, className, definition);\r\n                factories.push(className + \".newChangeDetector\");\r\n                sourcePart = codegen.toString();\r\n            }\r\n            else {\r\n                codegen = new change_detection_jit_generator_1.ChangeDetectorJITGenerator(definition, \"\" + UTIL_MODULE + UTIL, \"\" + ABSTRACT_CHANGE_DETECTOR_MODULE + ABSTRACT_CHANGE_DETECTOR, \"\" + CONSTANTS_MODULE + CHANGE_DETECTOR_STATE);\r\n                factories.push(\"function() { return new \" + codegen.typeName + \"(); }\");\r\n                sourcePart = codegen.generateSource();\r\n            }\r\n            index++;\r\n            return sourcePart;\r\n        });\r\n        return new source_module_1.SourceExpressions(sourceParts, factories);\r\n    };\r\n    ChangeDetectionCompiler = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [change_detection_1.ChangeDetectorGenConfig])\r\n    ], ChangeDetectionCompiler);\r\n    return ChangeDetectionCompiler;\r\n})();\r\nexports.ChangeDetectionCompiler = ChangeDetectionCompiler;\r\n},{\"./change_definition_factory\":52,\"./source_module\":68,\"./util\":77,\"angular2/src/core/change_detection/abstract_change_detector\":85,\"angular2/src/core/change_detection/change_detection\":87,\"angular2/src/core/change_detection/change_detection_jit_generator\":88,\"angular2/src/core/change_detection/change_detection_util\":89,\"angular2/src/core/change_detection/constants\":95,\"angular2/src/core/di\":117,\"angular2/src/facade/lang\":176,\"angular2/src/transform/template_compiler/change_detector_codegen\":199}],54:[function(require,module,exports){\n'use strict';function __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nvar runtime_compiler_1 = require(\"./runtime_compiler\");\r\nvar template_compiler_1 = require('./template_compiler');\r\nexports.TemplateCompiler = template_compiler_1.TemplateCompiler;\r\nvar directive_metadata_1 = require('./directive_metadata');\r\nexports.CompileDirectiveMetadata = directive_metadata_1.CompileDirectiveMetadata;\r\nexports.CompileTypeMetadata = directive_metadata_1.CompileTypeMetadata;\r\nexports.CompileTemplateMetadata = directive_metadata_1.CompileTemplateMetadata;\r\nvar source_module_1 = require('./source_module');\r\nexports.SourceModule = source_module_1.SourceModule;\r\nexports.SourceWithImports = source_module_1.SourceWithImports;\r\nvar platform_directives_and_pipes_1 = require('angular2/src/core/platform_directives_and_pipes');\r\nexports.PLATFORM_DIRECTIVES = platform_directives_and_pipes_1.PLATFORM_DIRECTIVES;\r\nexports.PLATFORM_PIPES = platform_directives_and_pipes_1.PLATFORM_PIPES;\r\n__export(require('angular2/src/compiler/template_ast'));\r\nvar template_parser_1 = require('angular2/src/compiler/template_parser');\r\nexports.TEMPLATE_TRANSFORMS = template_parser_1.TEMPLATE_TRANSFORMS;\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar template_parser_2 = require('angular2/src/compiler/template_parser');\r\nvar html_parser_1 = require('angular2/src/compiler/html_parser');\r\nvar template_normalizer_1 = require('angular2/src/compiler/template_normalizer');\r\nvar runtime_metadata_1 = require('angular2/src/compiler/runtime_metadata');\r\nvar change_detector_compiler_1 = require('angular2/src/compiler/change_detector_compiler');\r\nvar style_compiler_1 = require('angular2/src/compiler/style_compiler');\r\nvar view_compiler_1 = require('angular2/src/compiler/view_compiler');\r\nvar proto_view_compiler_1 = require('angular2/src/compiler/proto_view_compiler');\r\nvar template_compiler_2 = require('angular2/src/compiler/template_compiler');\r\nvar change_detection_1 = require('angular2/src/core/change_detection/change_detection');\r\nvar compiler_1 = require('angular2/src/core/linker/compiler');\r\nvar runtime_compiler_2 = require('angular2/src/compiler/runtime_compiler');\r\nvar element_schema_registry_1 = require('angular2/src/compiler/schema/element_schema_registry');\r\nvar dom_element_schema_registry_1 = require('angular2/src/compiler/schema/dom_element_schema_registry');\r\nvar url_resolver_1 = require('angular2/src/compiler/url_resolver');\r\nvar change_detection_2 = require('angular2/src/core/change_detection/change_detection');\r\nfunction _createChangeDetectorGenConfig() {\r\n    return new change_detection_1.ChangeDetectorGenConfig(lang_1.assertionsEnabled(), false, true);\r\n}\r\n/**\r\n * A set of providers that provide `RuntimeCompiler` and its dependencies to use for\r\n * template compilation.\r\n */\r\nexports.COMPILER_PROVIDERS = lang_1.CONST_EXPR([\r\n    change_detection_2.Lexer,\r\n    change_detection_2.Parser,\r\n    html_parser_1.HtmlParser,\r\n    template_parser_2.TemplateParser,\r\n    template_normalizer_1.TemplateNormalizer,\r\n    runtime_metadata_1.RuntimeMetadataResolver,\r\n    url_resolver_1.DEFAULT_PACKAGE_URL_PROVIDER,\r\n    style_compiler_1.StyleCompiler,\r\n    proto_view_compiler_1.ProtoViewCompiler,\r\n    view_compiler_1.ViewCompiler,\r\n    change_detector_compiler_1.ChangeDetectionCompiler,\r\n    new di_1.Provider(change_detection_1.ChangeDetectorGenConfig, { useFactory: _createChangeDetectorGenConfig, deps: [] }),\r\n    template_compiler_2.TemplateCompiler,\r\n    new di_1.Provider(runtime_compiler_2.RuntimeCompiler, { useClass: runtime_compiler_1.RuntimeCompiler_ }),\r\n    new di_1.Provider(compiler_1.Compiler, { useExisting: runtime_compiler_2.RuntimeCompiler }),\r\n    dom_element_schema_registry_1.DomElementSchemaRegistry,\r\n    new di_1.Provider(element_schema_registry_1.ElementSchemaRegistry, { useExisting: dom_element_schema_registry_1.DomElementSchemaRegistry }),\r\n    url_resolver_1.UrlResolver\r\n]);\r\n},{\"./directive_metadata\":55,\"./runtime_compiler\":62,\"./source_module\":68,\"./template_compiler\":72,\"angular2/src/compiler/change_detector_compiler\":53,\"angular2/src/compiler/html_parser\":58,\"angular2/src/compiler/proto_view_compiler\":61,\"angular2/src/compiler/runtime_compiler\":62,\"angular2/src/compiler/runtime_metadata\":63,\"angular2/src/compiler/schema/dom_element_schema_registry\":64,\"angular2/src/compiler/schema/element_schema_registry\":65,\"angular2/src/compiler/style_compiler\":69,\"angular2/src/compiler/template_ast\":71,\"angular2/src/compiler/template_compiler\":72,\"angular2/src/compiler/template_normalizer\":73,\"angular2/src/compiler/template_parser\":74,\"angular2/src/compiler/url_resolver\":76,\"angular2/src/compiler/view_compiler\":78,\"angular2/src/core/change_detection/change_detection\":87,\"angular2/src/core/di\":117,\"angular2/src/core/linker/compiler\":128,\"angular2/src/core/platform_directives_and_pipes\":153,\"angular2/src/facade/lang\":176}],55:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar change_detection_1 = require('angular2/src/core/change_detection/change_detection');\r\nvar view_1 = require('angular2/src/core/metadata/view');\r\nvar selector_1 = require('angular2/src/compiler/selector');\r\nvar util_1 = require('./util');\r\nvar interfaces_1 = require('angular2/src/core/linker/interfaces');\r\n// group 1: \"property\" from \"[property]\"\r\n// group 2: \"event\" from \"(event)\"\r\nvar HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))$/g;\r\nvar CompileMetadataWithType = (function () {\r\n    function CompileMetadataWithType() {\r\n    }\r\n    CompileMetadataWithType.fromJson = function (data) {\r\n        return _COMPILE_METADATA_FROM_JSON[data['class']](data);\r\n    };\r\n    Object.defineProperty(CompileMetadataWithType.prototype, \"type\", {\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return CompileMetadataWithType;\r\n})();\r\nexports.CompileMetadataWithType = CompileMetadataWithType;\r\n/**\r\n * Metadata regarding compilation of a type.\r\n */\r\nvar CompileTypeMetadata = (function () {\r\n    function CompileTypeMetadata(_a) {\r\n        var _b = _a === void 0 ? {} : _a, runtime = _b.runtime, name = _b.name, moduleUrl = _b.moduleUrl, isHost = _b.isHost;\r\n        this.runtime = runtime;\r\n        this.name = name;\r\n        this.moduleUrl = moduleUrl;\r\n        this.isHost = lang_1.normalizeBool(isHost);\r\n    }\r\n    CompileTypeMetadata.fromJson = function (data) {\r\n        return new CompileTypeMetadata({ name: data['name'], moduleUrl: data['moduleUrl'], isHost: data['isHost'] });\r\n    };\r\n    CompileTypeMetadata.prototype.toJson = function () {\r\n        return {\r\n            // Note: Runtime type can't be serialized...\r\n            'name': this.name,\r\n            'moduleUrl': this.moduleUrl,\r\n            'isHost': this.isHost\r\n        };\r\n    };\r\n    return CompileTypeMetadata;\r\n})();\r\nexports.CompileTypeMetadata = CompileTypeMetadata;\r\n/**\r\n * Metadata regarding compilation of a template.\r\n */\r\nvar CompileTemplateMetadata = (function () {\r\n    function CompileTemplateMetadata(_a) {\r\n        var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, ngContentSelectors = _b.ngContentSelectors;\r\n        this.encapsulation = lang_1.isPresent(encapsulation) ? encapsulation : view_1.ViewEncapsulation.Emulated;\r\n        this.template = template;\r\n        this.templateUrl = templateUrl;\r\n        this.styles = lang_1.isPresent(styles) ? styles : [];\r\n        this.styleUrls = lang_1.isPresent(styleUrls) ? styleUrls : [];\r\n        this.ngContentSelectors = lang_1.isPresent(ngContentSelectors) ? ngContentSelectors : [];\r\n    }\r\n    CompileTemplateMetadata.fromJson = function (data) {\r\n        return new CompileTemplateMetadata({\r\n            encapsulation: lang_1.isPresent(data['encapsulation']) ?\r\n                view_1.VIEW_ENCAPSULATION_VALUES[data['encapsulation']] :\r\n                data['encapsulation'],\r\n            template: data['template'],\r\n            templateUrl: data['templateUrl'],\r\n            styles: data['styles'],\r\n            styleUrls: data['styleUrls'],\r\n            ngContentSelectors: data['ngContentSelectors']\r\n        });\r\n    };\r\n    CompileTemplateMetadata.prototype.toJson = function () {\r\n        return {\r\n            'encapsulation': lang_1.isPresent(this.encapsulation) ? lang_1.serializeEnum(this.encapsulation) : this.encapsulation,\r\n            'template': this.template,\r\n            'templateUrl': this.templateUrl,\r\n            'styles': this.styles,\r\n            'styleUrls': this.styleUrls,\r\n            'ngContentSelectors': this.ngContentSelectors\r\n        };\r\n    };\r\n    return CompileTemplateMetadata;\r\n})();\r\nexports.CompileTemplateMetadata = CompileTemplateMetadata;\r\n/**\r\n * Metadata regarding compilation of a directive.\r\n */\r\nvar CompileDirectiveMetadata = (function () {\r\n    function CompileDirectiveMetadata(_a) {\r\n        var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, dynamicLoadable = _b.dynamicLoadable, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, lifecycleHooks = _b.lifecycleHooks, template = _b.template;\r\n        this.type = type;\r\n        this.isComponent = isComponent;\r\n        this.dynamicLoadable = dynamicLoadable;\r\n        this.selector = selector;\r\n        this.exportAs = exportAs;\r\n        this.changeDetection = changeDetection;\r\n        this.inputs = inputs;\r\n        this.outputs = outputs;\r\n        this.hostListeners = hostListeners;\r\n        this.hostProperties = hostProperties;\r\n        this.hostAttributes = hostAttributes;\r\n        this.lifecycleHooks = lifecycleHooks;\r\n        this.template = template;\r\n    }\r\n    CompileDirectiveMetadata.create = function (_a) {\r\n        var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, dynamicLoadable = _b.dynamicLoadable, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, lifecycleHooks = _b.lifecycleHooks, template = _b.template;\r\n        var hostListeners = {};\r\n        var hostProperties = {};\r\n        var hostAttributes = {};\r\n        if (lang_1.isPresent(host)) {\r\n            collection_1.StringMapWrapper.forEach(host, function (value, key) {\r\n                var matches = lang_1.RegExpWrapper.firstMatch(HOST_REG_EXP, key);\r\n                if (lang_1.isBlank(matches)) {\r\n                    hostAttributes[key] = value;\r\n                }\r\n                else if (lang_1.isPresent(matches[1])) {\r\n                    hostProperties[matches[1]] = value;\r\n                }\r\n                else if (lang_1.isPresent(matches[2])) {\r\n                    hostListeners[matches[2]] = value;\r\n                }\r\n            });\r\n        }\r\n        var inputsMap = {};\r\n        if (lang_1.isPresent(inputs)) {\r\n            inputs.forEach(function (bindConfig) {\r\n                // canonical syntax: `dirProp: elProp`\r\n                // if there is no `:`, use dirProp = elProp\r\n                var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);\r\n                inputsMap[parts[0]] = parts[1];\r\n            });\r\n        }\r\n        var outputsMap = {};\r\n        if (lang_1.isPresent(outputs)) {\r\n            outputs.forEach(function (bindConfig) {\r\n                // canonical syntax: `dirProp: elProp`\r\n                // if there is no `:`, use dirProp = elProp\r\n                var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);\r\n                outputsMap[parts[0]] = parts[1];\r\n            });\r\n        }\r\n        return new CompileDirectiveMetadata({\r\n            type: type,\r\n            isComponent: lang_1.normalizeBool(isComponent),\r\n            dynamicLoadable: lang_1.normalizeBool(dynamicLoadable),\r\n            selector: selector,\r\n            exportAs: exportAs,\r\n            changeDetection: changeDetection,\r\n            inputs: inputsMap,\r\n            outputs: outputsMap,\r\n            hostListeners: hostListeners,\r\n            hostProperties: hostProperties,\r\n            hostAttributes: hostAttributes,\r\n            lifecycleHooks: lang_1.isPresent(lifecycleHooks) ? lifecycleHooks : [],\r\n            template: template\r\n        });\r\n    };\r\n    CompileDirectiveMetadata.fromJson = function (data) {\r\n        return new CompileDirectiveMetadata({\r\n            isComponent: data['isComponent'],\r\n            dynamicLoadable: data['dynamicLoadable'],\r\n            selector: data['selector'],\r\n            exportAs: data['exportAs'],\r\n            type: lang_1.isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],\r\n            changeDetection: lang_1.isPresent(data['changeDetection']) ?\r\n                change_detection_1.CHANGE_DETECTION_STRATEGY_VALUES[data['changeDetection']] :\r\n                data['changeDetection'],\r\n            inputs: data['inputs'],\r\n            outputs: data['outputs'],\r\n            hostListeners: data['hostListeners'],\r\n            hostProperties: data['hostProperties'],\r\n            hostAttributes: data['hostAttributes'],\r\n            lifecycleHooks: data['lifecycleHooks'].map(function (hookValue) { return interfaces_1.LIFECYCLE_HOOKS_VALUES[hookValue]; }),\r\n            template: lang_1.isPresent(data['template']) ? CompileTemplateMetadata.fromJson(data['template']) :\r\n                data['template']\r\n        });\r\n    };\r\n    CompileDirectiveMetadata.prototype.toJson = function () {\r\n        return {\r\n            'class': 'Directive',\r\n            'isComponent': this.isComponent,\r\n            'dynamicLoadable': this.dynamicLoadable,\r\n            'selector': this.selector,\r\n            'exportAs': this.exportAs,\r\n            'type': lang_1.isPresent(this.type) ? this.type.toJson() : this.type,\r\n            'changeDetection': lang_1.isPresent(this.changeDetection) ? lang_1.serializeEnum(this.changeDetection) :\r\n                this.changeDetection,\r\n            'inputs': this.inputs,\r\n            'outputs': this.outputs,\r\n            'hostListeners': this.hostListeners,\r\n            'hostProperties': this.hostProperties,\r\n            'hostAttributes': this.hostAttributes,\r\n            'lifecycleHooks': this.lifecycleHooks.map(function (hook) { return lang_1.serializeEnum(hook); }),\r\n            'template': lang_1.isPresent(this.template) ? this.template.toJson() : this.template\r\n        };\r\n    };\r\n    return CompileDirectiveMetadata;\r\n})();\r\nexports.CompileDirectiveMetadata = CompileDirectiveMetadata;\r\n/**\r\n * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.\r\n */\r\nfunction createHostComponentMeta(componentType, componentSelector) {\r\n    var template = selector_1.CssSelector.parse(componentSelector)[0].getMatchingElementTemplate();\r\n    return CompileDirectiveMetadata.create({\r\n        type: new CompileTypeMetadata({\r\n            runtime: Object,\r\n            name: \"Host\" + componentType.name,\r\n            moduleUrl: componentType.moduleUrl,\r\n            isHost: true\r\n        }),\r\n        template: new CompileTemplateMetadata({ template: template, templateUrl: '', styles: [], styleUrls: [], ngContentSelectors: [] }),\r\n        changeDetection: change_detection_1.ChangeDetectionStrategy.Default,\r\n        inputs: [],\r\n        outputs: [],\r\n        host: {},\r\n        lifecycleHooks: [],\r\n        isComponent: true,\r\n        dynamicLoadable: false,\r\n        selector: '*'\r\n    });\r\n}\r\nexports.createHostComponentMeta = createHostComponentMeta;\r\nvar CompilePipeMetadata = (function () {\r\n    function CompilePipeMetadata(_a) {\r\n        var _b = _a === void 0 ? {} : _a, type = _b.type, name = _b.name, pure = _b.pure;\r\n        this.type = type;\r\n        this.name = name;\r\n        this.pure = lang_1.normalizeBool(pure);\r\n    }\r\n    CompilePipeMetadata.fromJson = function (data) {\r\n        return new CompilePipeMetadata({\r\n            type: lang_1.isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],\r\n            name: data['name'],\r\n            pure: data['pure']\r\n        });\r\n    };\r\n    CompilePipeMetadata.prototype.toJson = function () {\r\n        return {\r\n            'class': 'Pipe',\r\n            'type': lang_1.isPresent(this.type) ? this.type.toJson() : null,\r\n            'name': this.name,\r\n            'pure': this.pure\r\n        };\r\n    };\r\n    return CompilePipeMetadata;\r\n})();\r\nexports.CompilePipeMetadata = CompilePipeMetadata;\r\nvar _COMPILE_METADATA_FROM_JSON = {\r\n    'Directive': CompileDirectiveMetadata.fromJson,\r\n    'Pipe': CompilePipeMetadata.fromJson\r\n};\r\n},{\"./util\":77,\"angular2/src/compiler/selector\":66,\"angular2/src/core/change_detection/change_detection\":87,\"angular2/src/core/linker/interfaces\":134,\"angular2/src/core/metadata/view\":149,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],56:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar HtmlTextAst = (function () {\r\n    function HtmlTextAst(value, sourceSpan) {\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    HtmlTextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\r\n    return HtmlTextAst;\r\n})();\r\nexports.HtmlTextAst = HtmlTextAst;\r\nvar HtmlAttrAst = (function () {\r\n    function HtmlAttrAst(name, value, sourceSpan) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    HtmlAttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };\r\n    return HtmlAttrAst;\r\n})();\r\nexports.HtmlAttrAst = HtmlAttrAst;\r\nvar HtmlElementAst = (function () {\r\n    function HtmlElementAst(name, attrs, children, sourceSpan) {\r\n        this.name = name;\r\n        this.attrs = attrs;\r\n        this.children = children;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    HtmlElementAst.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };\r\n    return HtmlElementAst;\r\n})();\r\nexports.HtmlElementAst = HtmlElementAst;\r\nfunction htmlVisitAll(visitor, asts, context) {\r\n    if (context === void 0) { context = null; }\r\n    var result = [];\r\n    asts.forEach(function (ast) {\r\n        var astResult = ast.visit(visitor, context);\r\n        if (lang_1.isPresent(astResult)) {\r\n            result.push(astResult);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nexports.htmlVisitAll = htmlVisitAll;\r\n},{\"angular2/src/facade/lang\":176}],57:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar parse_util_1 = require('./parse_util');\r\nvar html_tags_1 = require('./html_tags');\r\n(function (HtmlTokenType) {\r\n    HtmlTokenType[HtmlTokenType[\"TAG_OPEN_START\"] = 0] = \"TAG_OPEN_START\";\r\n    HtmlTokenType[HtmlTokenType[\"TAG_OPEN_END\"] = 1] = \"TAG_OPEN_END\";\r\n    HtmlTokenType[HtmlTokenType[\"TAG_OPEN_END_VOID\"] = 2] = \"TAG_OPEN_END_VOID\";\r\n    HtmlTokenType[HtmlTokenType[\"TAG_CLOSE\"] = 3] = \"TAG_CLOSE\";\r\n    HtmlTokenType[HtmlTokenType[\"TEXT\"] = 4] = \"TEXT\";\r\n    HtmlTokenType[HtmlTokenType[\"ESCAPABLE_RAW_TEXT\"] = 5] = \"ESCAPABLE_RAW_TEXT\";\r\n    HtmlTokenType[HtmlTokenType[\"RAW_TEXT\"] = 6] = \"RAW_TEXT\";\r\n    HtmlTokenType[HtmlTokenType[\"COMMENT_START\"] = 7] = \"COMMENT_START\";\r\n    HtmlTokenType[HtmlTokenType[\"COMMENT_END\"] = 8] = \"COMMENT_END\";\r\n    HtmlTokenType[HtmlTokenType[\"CDATA_START\"] = 9] = \"CDATA_START\";\r\n    HtmlTokenType[HtmlTokenType[\"CDATA_END\"] = 10] = \"CDATA_END\";\r\n    HtmlTokenType[HtmlTokenType[\"ATTR_NAME\"] = 11] = \"ATTR_NAME\";\r\n    HtmlTokenType[HtmlTokenType[\"ATTR_VALUE\"] = 12] = \"ATTR_VALUE\";\r\n    HtmlTokenType[HtmlTokenType[\"DOC_TYPE\"] = 13] = \"DOC_TYPE\";\r\n    HtmlTokenType[HtmlTokenType[\"EOF\"] = 14] = \"EOF\";\r\n})(exports.HtmlTokenType || (exports.HtmlTokenType = {}));\r\nvar HtmlTokenType = exports.HtmlTokenType;\r\nvar HtmlToken = (function () {\r\n    function HtmlToken(type, parts, sourceSpan) {\r\n        this.type = type;\r\n        this.parts = parts;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    return HtmlToken;\r\n})();\r\nexports.HtmlToken = HtmlToken;\r\nvar HtmlTokenError = (function (_super) {\r\n    __extends(HtmlTokenError, _super);\r\n    function HtmlTokenError(errorMsg, tokenType, location) {\r\n        _super.call(this, location, errorMsg);\r\n        this.tokenType = tokenType;\r\n    }\r\n    return HtmlTokenError;\r\n})(parse_util_1.ParseError);\r\nexports.HtmlTokenError = HtmlTokenError;\r\nvar HtmlTokenizeResult = (function () {\r\n    function HtmlTokenizeResult(tokens, errors) {\r\n        this.tokens = tokens;\r\n        this.errors = errors;\r\n    }\r\n    return HtmlTokenizeResult;\r\n})();\r\nexports.HtmlTokenizeResult = HtmlTokenizeResult;\r\nfunction tokenizeHtml(sourceContent, sourceUrl) {\r\n    return new _HtmlTokenizer(new parse_util_1.ParseSourceFile(sourceContent, sourceUrl)).tokenize();\r\n}\r\nexports.tokenizeHtml = tokenizeHtml;\r\nvar $EOF = 0;\r\nvar $TAB = 9;\r\nvar $LF = 10;\r\nvar $FF = 12;\r\nvar $CR = 13;\r\nvar $SPACE = 32;\r\nvar $BANG = 33;\r\nvar $DQ = 34;\r\nvar $HASH = 35;\r\nvar $$ = 36;\r\nvar $AMPERSAND = 38;\r\nvar $SQ = 39;\r\nvar $MINUS = 45;\r\nvar $SLASH = 47;\r\nvar $0 = 48;\r\nvar $SEMICOLON = 59;\r\nvar $9 = 57;\r\nvar $COLON = 58;\r\nvar $LT = 60;\r\nvar $EQ = 61;\r\nvar $GT = 62;\r\nvar $QUESTION = 63;\r\nvar $A = 65;\r\nvar $Z = 90;\r\nvar $LBRACKET = 91;\r\nvar $RBRACKET = 93;\r\nvar $a = 97;\r\nvar $f = 102;\r\nvar $z = 122;\r\nvar $x = 120;\r\nvar $NBSP = 160;\r\nvar CR_OR_CRLF_REGEXP = /\\r\\n?/g;\r\nfunction unexpectedCharacterErrorMsg(charCode) {\r\n    var char = charCode === $EOF ? 'EOF' : lang_1.StringWrapper.fromCharCode(charCode);\r\n    return \"Unexpected character \\\"\" + char + \"\\\"\";\r\n}\r\nfunction unknownEntityErrorMsg(entitySrc) {\r\n    return \"Unknown entity \\\"\" + entitySrc + \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\";\r\n}\r\nvar ControlFlowError = (function () {\r\n    function ControlFlowError(error) {\r\n        this.error = error;\r\n    }\r\n    return ControlFlowError;\r\n})();\r\n// See http://www.w3.org/TR/html51/syntax.html#writing\r\nvar _HtmlTokenizer = (function () {\r\n    function _HtmlTokenizer(file) {\r\n        this.file = file;\r\n        // Note: this is always lowercase!\r\n        this.peek = -1;\r\n        this.index = -1;\r\n        this.line = 0;\r\n        this.column = -1;\r\n        this.tokens = [];\r\n        this.errors = [];\r\n        this.input = file.content;\r\n        this.inputLowercase = file.content.toLowerCase();\r\n        this.length = file.content.length;\r\n        this._advance();\r\n    }\r\n    _HtmlTokenizer.prototype._processCarriageReturns = function (content) {\r\n        // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\r\n        // In order to keep the original position in the source, we can not pre-process it.\r\n        // Instead CRs are processed right before instantiating the tokens.\r\n        return lang_1.StringWrapper.replaceAll(content, CR_OR_CRLF_REGEXP, '\\n');\r\n    };\r\n    _HtmlTokenizer.prototype.tokenize = function () {\r\n        while (this.peek !== $EOF) {\r\n            var start = this._getLocation();\r\n            try {\r\n                if (this._attemptChar($LT)) {\r\n                    if (this._attemptChar($BANG)) {\r\n                        if (this._attemptChar($LBRACKET)) {\r\n                            this._consumeCdata(start);\r\n                        }\r\n                        else if (this._attemptChar($MINUS)) {\r\n                            this._consumeComment(start);\r\n                        }\r\n                        else {\r\n                            this._consumeDocType(start);\r\n                        }\r\n                    }\r\n                    else if (this._attemptChar($SLASH)) {\r\n                        this._consumeTagClose(start);\r\n                    }\r\n                    else {\r\n                        this._consumeTagOpen(start);\r\n                    }\r\n                }\r\n                else {\r\n                    this._consumeText();\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (e instanceof ControlFlowError) {\r\n                    this.errors.push(e.error);\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        this._beginToken(HtmlTokenType.EOF);\r\n        this._endToken([]);\r\n        return new HtmlTokenizeResult(mergeTextTokens(this.tokens), this.errors);\r\n    };\r\n    _HtmlTokenizer.prototype._getLocation = function () {\r\n        return new parse_util_1.ParseLocation(this.file, this.index, this.line, this.column);\r\n    };\r\n    _HtmlTokenizer.prototype._beginToken = function (type, start) {\r\n        if (start === void 0) { start = null; }\r\n        if (lang_1.isBlank(start)) {\r\n            start = this._getLocation();\r\n        }\r\n        this.currentTokenStart = start;\r\n        this.currentTokenType = type;\r\n    };\r\n    _HtmlTokenizer.prototype._endToken = function (parts, end) {\r\n        if (end === void 0) { end = null; }\r\n        if (lang_1.isBlank(end)) {\r\n            end = this._getLocation();\r\n        }\r\n        var token = new HtmlToken(this.currentTokenType, parts, new parse_util_1.ParseSourceSpan(this.currentTokenStart, end));\r\n        this.tokens.push(token);\r\n        this.currentTokenStart = null;\r\n        this.currentTokenType = null;\r\n        return token;\r\n    };\r\n    _HtmlTokenizer.prototype._createError = function (msg, position) {\r\n        var error = new HtmlTokenError(msg, this.currentTokenType, position);\r\n        this.currentTokenStart = null;\r\n        this.currentTokenType = null;\r\n        return new ControlFlowError(error);\r\n    };\r\n    _HtmlTokenizer.prototype._advance = function () {\r\n        if (this.index >= this.length) {\r\n            throw this._createError(unexpectedCharacterErrorMsg($EOF), this._getLocation());\r\n        }\r\n        if (this.peek === $LF) {\r\n            this.line++;\r\n            this.column = 0;\r\n        }\r\n        else if (this.peek !== $LF && this.peek !== $CR) {\r\n            this.column++;\r\n        }\r\n        this.index++;\r\n        this.peek = this.index >= this.length ? $EOF : lang_1.StringWrapper.charCodeAt(this.inputLowercase, this.index);\r\n    };\r\n    _HtmlTokenizer.prototype._attemptChar = function (charCode) {\r\n        if (this.peek === charCode) {\r\n            this._advance();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    _HtmlTokenizer.prototype._requireChar = function (charCode) {\r\n        var location = this._getLocation();\r\n        if (!this._attemptChar(charCode)) {\r\n            throw this._createError(unexpectedCharacterErrorMsg(this.peek), location);\r\n        }\r\n    };\r\n    _HtmlTokenizer.prototype._attemptChars = function (chars) {\r\n        for (var i = 0; i < chars.length; i++) {\r\n            if (!this._attemptChar(lang_1.StringWrapper.charCodeAt(chars, i))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    _HtmlTokenizer.prototype._requireChars = function (chars) {\r\n        var location = this._getLocation();\r\n        if (!this._attemptChars(chars)) {\r\n            throw this._createError(unexpectedCharacterErrorMsg(this.peek), location);\r\n        }\r\n    };\r\n    _HtmlTokenizer.prototype._attemptUntilFn = function (predicate) {\r\n        while (!predicate(this.peek)) {\r\n            this._advance();\r\n        }\r\n    };\r\n    _HtmlTokenizer.prototype._requireUntilFn = function (predicate, len) {\r\n        var start = this._getLocation();\r\n        this._attemptUntilFn(predicate);\r\n        if (this.index - start.offset < len) {\r\n            throw this._createError(unexpectedCharacterErrorMsg(this.peek), start);\r\n        }\r\n    };\r\n    _HtmlTokenizer.prototype._attemptUntilChar = function (char) {\r\n        while (this.peek !== char) {\r\n            this._advance();\r\n        }\r\n    };\r\n    _HtmlTokenizer.prototype._readChar = function (decodeEntities) {\r\n        if (decodeEntities && this.peek === $AMPERSAND) {\r\n            return this._decodeEntity();\r\n        }\r\n        else {\r\n            var index = this.index;\r\n            this._advance();\r\n            return this.input[index];\r\n        }\r\n    };\r\n    _HtmlTokenizer.prototype._decodeEntity = function () {\r\n        var start = this._getLocation();\r\n        this._advance();\r\n        if (this._attemptChar($HASH)) {\r\n            var isHex = this._attemptChar($x);\r\n            var numberStart = this._getLocation().offset;\r\n            this._attemptUntilFn(isDigitEntityEnd);\r\n            if (this.peek != $SEMICOLON) {\r\n                throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getLocation());\r\n            }\r\n            this._advance();\r\n            var strNum = this.input.substring(numberStart, this.index - 1);\r\n            try {\r\n                var charCode = lang_1.NumberWrapper.parseInt(strNum, isHex ? 16 : 10);\r\n                return lang_1.StringWrapper.fromCharCode(charCode);\r\n            }\r\n            catch (e) {\r\n                var entity = this.input.substring(start.offset + 1, this.index - 1);\r\n                throw this._createError(unknownEntityErrorMsg(entity), start);\r\n            }\r\n        }\r\n        else {\r\n            var startPosition = this._savePosition();\r\n            this._attemptUntilFn(isNamedEntityEnd);\r\n            if (this.peek != $SEMICOLON) {\r\n                this._restorePosition(startPosition);\r\n                return '&';\r\n            }\r\n            this._advance();\r\n            var name_1 = this.input.substring(start.offset + 1, this.index - 1);\r\n            var char = html_tags_1.NAMED_ENTITIES[name_1];\r\n            if (lang_1.isBlank(char)) {\r\n                throw this._createError(unknownEntityErrorMsg(name_1), start);\r\n            }\r\n            return char;\r\n        }\r\n    };\r\n    _HtmlTokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {\r\n        var tagCloseStart;\r\n        var textStart = this._getLocation();\r\n        this._beginToken(decodeEntities ? HtmlTokenType.ESCAPABLE_RAW_TEXT : HtmlTokenType.RAW_TEXT, textStart);\r\n        var parts = [];\r\n        while (true) {\r\n            tagCloseStart = this._getLocation();\r\n            if (this._attemptChar(firstCharOfEnd) && attemptEndRest()) {\r\n                break;\r\n            }\r\n            if (this.index > tagCloseStart.offset) {\r\n                parts.push(this.input.substring(tagCloseStart.offset, this.index));\r\n            }\r\n            while (this.peek !== firstCharOfEnd) {\r\n                parts.push(this._readChar(decodeEntities));\r\n            }\r\n        }\r\n        return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);\r\n    };\r\n    _HtmlTokenizer.prototype._consumeComment = function (start) {\r\n        var _this = this;\r\n        this._beginToken(HtmlTokenType.COMMENT_START, start);\r\n        this._requireChar($MINUS);\r\n        this._endToken([]);\r\n        var textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptChars('->'); });\r\n        this._beginToken(HtmlTokenType.COMMENT_END, textToken.sourceSpan.end);\r\n        this._endToken([]);\r\n    };\r\n    _HtmlTokenizer.prototype._consumeCdata = function (start) {\r\n        var _this = this;\r\n        this._beginToken(HtmlTokenType.CDATA_START, start);\r\n        this._requireChars('cdata[');\r\n        this._endToken([]);\r\n        var textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptChars(']>'); });\r\n        this._beginToken(HtmlTokenType.CDATA_END, textToken.sourceSpan.end);\r\n        this._endToken([]);\r\n    };\r\n    _HtmlTokenizer.prototype._consumeDocType = function (start) {\r\n        this._beginToken(HtmlTokenType.DOC_TYPE, start);\r\n        this._attemptUntilChar($GT);\r\n        this._advance();\r\n        this._endToken([this.input.substring(start.offset + 2, this.index - 1)]);\r\n    };\r\n    _HtmlTokenizer.prototype._consumePrefixAndName = function () {\r\n        var nameOrPrefixStart = this.index;\r\n        var prefix = null;\r\n        while (this.peek !== $COLON && !isPrefixEnd(this.peek)) {\r\n            this._advance();\r\n        }\r\n        var nameStart;\r\n        if (this.peek === $COLON) {\r\n            this._advance();\r\n            prefix = this.input.substring(nameOrPrefixStart, this.index - 1);\r\n            nameStart = this.index;\r\n        }\r\n        else {\r\n            nameStart = nameOrPrefixStart;\r\n        }\r\n        this._requireUntilFn(isNameEnd, this.index === nameStart ? 1 : 0);\r\n        var name = this.input.substring(nameStart, this.index);\r\n        return [prefix, name];\r\n    };\r\n    _HtmlTokenizer.prototype._consumeTagOpen = function (start) {\r\n        var savedPos = this._savePosition();\r\n        var lowercaseTagName;\r\n        try {\r\n            if (!isAsciiLetter(this.peek)) {\r\n                throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getLocation());\r\n            }\r\n            var nameStart = this.index;\r\n            this._consumeTagOpenStart(start);\r\n            lowercaseTagName = this.inputLowercase.substring(nameStart, this.index);\r\n            this._attemptUntilFn(isNotWhitespace);\r\n            while (this.peek !== $SLASH && this.peek !== $GT) {\r\n                this._consumeAttributeName();\r\n                this._attemptUntilFn(isNotWhitespace);\r\n                if (this._attemptChar($EQ)) {\r\n                    this._attemptUntilFn(isNotWhitespace);\r\n                    this._consumeAttributeValue();\r\n                }\r\n                this._attemptUntilFn(isNotWhitespace);\r\n            }\r\n            this._consumeTagOpenEnd();\r\n        }\r\n        catch (e) {\r\n            if (e instanceof ControlFlowError) {\r\n                // When the start tag is invalid, assume we want a \"<\"\r\n                this._restorePosition(savedPos);\r\n                // Back to back text tokens are merged at the end\r\n                this._beginToken(HtmlTokenType.TEXT, start);\r\n                this._endToken(['<']);\r\n                return;\r\n            }\r\n            throw e;\r\n        }\r\n        var contentTokenType = html_tags_1.getHtmlTagDefinition(lowercaseTagName).contentType;\r\n        if (contentTokenType === html_tags_1.HtmlTagContentType.RAW_TEXT) {\r\n            this._consumeRawTextWithTagClose(lowercaseTagName, false);\r\n        }\r\n        else if (contentTokenType === html_tags_1.HtmlTagContentType.ESCAPABLE_RAW_TEXT) {\r\n            this._consumeRawTextWithTagClose(lowercaseTagName, true);\r\n        }\r\n    };\r\n    _HtmlTokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {\r\n        var _this = this;\r\n        var textToken = this._consumeRawText(decodeEntities, $LT, function () {\r\n            if (!_this._attemptChar($SLASH))\r\n                return false;\r\n            _this._attemptUntilFn(isNotWhitespace);\r\n            if (!_this._attemptChars(lowercaseTagName))\r\n                return false;\r\n            _this._attemptUntilFn(isNotWhitespace);\r\n            if (!_this._attemptChar($GT))\r\n                return false;\r\n            return true;\r\n        });\r\n        this._beginToken(HtmlTokenType.TAG_CLOSE, textToken.sourceSpan.end);\r\n        this._endToken([null, lowercaseTagName]);\r\n    };\r\n    _HtmlTokenizer.prototype._consumeTagOpenStart = function (start) {\r\n        this._beginToken(HtmlTokenType.TAG_OPEN_START, start);\r\n        var parts = this._consumePrefixAndName();\r\n        this._endToken(parts);\r\n    };\r\n    _HtmlTokenizer.prototype._consumeAttributeName = function () {\r\n        this._beginToken(HtmlTokenType.ATTR_NAME);\r\n        var prefixAndName = this._consumePrefixAndName();\r\n        this._endToken(prefixAndName);\r\n    };\r\n    _HtmlTokenizer.prototype._consumeAttributeValue = function () {\r\n        this._beginToken(HtmlTokenType.ATTR_VALUE);\r\n        var value;\r\n        if (this.peek === $SQ || this.peek === $DQ) {\r\n            var quoteChar = this.peek;\r\n            this._advance();\r\n            var parts = [];\r\n            while (this.peek !== quoteChar) {\r\n                parts.push(this._readChar(true));\r\n            }\r\n            value = parts.join('');\r\n            this._advance();\r\n        }\r\n        else {\r\n            var valueStart = this.index;\r\n            this._requireUntilFn(isNameEnd, 1);\r\n            value = this.input.substring(valueStart, this.index);\r\n        }\r\n        this._endToken([this._processCarriageReturns(value)]);\r\n    };\r\n    _HtmlTokenizer.prototype._consumeTagOpenEnd = function () {\r\n        var tokenType = this._attemptChar($SLASH) ? HtmlTokenType.TAG_OPEN_END_VOID : HtmlTokenType.TAG_OPEN_END;\r\n        this._beginToken(tokenType);\r\n        this._requireChar($GT);\r\n        this._endToken([]);\r\n    };\r\n    _HtmlTokenizer.prototype._consumeTagClose = function (start) {\r\n        this._beginToken(HtmlTokenType.TAG_CLOSE, start);\r\n        this._attemptUntilFn(isNotWhitespace);\r\n        var prefixAndName;\r\n        prefixAndName = this._consumePrefixAndName();\r\n        this._attemptUntilFn(isNotWhitespace);\r\n        this._requireChar($GT);\r\n        this._endToken(prefixAndName);\r\n    };\r\n    _HtmlTokenizer.prototype._consumeText = function () {\r\n        var start = this._getLocation();\r\n        this._beginToken(HtmlTokenType.TEXT, start);\r\n        var parts = [this._readChar(true)];\r\n        while (!isTextEnd(this.peek)) {\r\n            parts.push(this._readChar(true));\r\n        }\r\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\r\n    };\r\n    _HtmlTokenizer.prototype._savePosition = function () {\r\n        return [this.peek, this.index, this.column, this.line, this.tokens.length];\r\n    };\r\n    _HtmlTokenizer.prototype._restorePosition = function (position) {\r\n        this.peek = position[0];\r\n        this.index = position[1];\r\n        this.column = position[2];\r\n        this.line = position[3];\r\n        var nbTokens = position[4];\r\n        if (nbTokens < this.tokens.length) {\r\n            // remove any extra tokens\r\n            this.tokens = collection_1.ListWrapper.slice(this.tokens, 0, nbTokens);\r\n        }\r\n    };\r\n    return _HtmlTokenizer;\r\n})();\r\nfunction isNotWhitespace(code) {\r\n    return !isWhitespace(code) || code === $EOF;\r\n}\r\nfunction isWhitespace(code) {\r\n    return (code >= $TAB && code <= $SPACE) || (code === $NBSP);\r\n}\r\nfunction isNameEnd(code) {\r\n    return isWhitespace(code) || code === $GT || code === $SLASH || code === $SQ || code === $DQ ||\r\n        code === $EQ;\r\n}\r\nfunction isPrefixEnd(code) {\r\n    return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);\r\n}\r\nfunction isDigitEntityEnd(code) {\r\n    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\r\n}\r\nfunction isNamedEntityEnd(code) {\r\n    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\r\n}\r\nfunction isTextEnd(code) {\r\n    return code === $LT || code === $EOF;\r\n}\r\nfunction isAsciiLetter(code) {\r\n    return code >= $a && code <= $z;\r\n}\r\nfunction isAsciiHexDigit(code) {\r\n    return code >= $a && code <= $f || code >= $0 && code <= $9;\r\n}\r\nfunction mergeTextTokens(srcTokens) {\r\n    var dstTokens = [];\r\n    var lastDstToken;\r\n    for (var i = 0; i < srcTokens.length; i++) {\r\n        var token = srcTokens[i];\r\n        if (lang_1.isPresent(lastDstToken) && lastDstToken.type == HtmlTokenType.TEXT &&\r\n            token.type == HtmlTokenType.TEXT) {\r\n            lastDstToken.parts[0] += token.parts[0];\r\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\r\n        }\r\n        else {\r\n            lastDstToken = token;\r\n            dstTokens.push(lastDstToken);\r\n        }\r\n    }\r\n    return dstTokens;\r\n}\r\n},{\"./html_tags\":59,\"./parse_util\":60,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],58:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar html_ast_1 = require('./html_ast');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar html_lexer_1 = require('./html_lexer');\r\nvar parse_util_1 = require('./parse_util');\r\nvar html_tags_1 = require('./html_tags');\r\nvar HtmlTreeError = (function (_super) {\r\n    __extends(HtmlTreeError, _super);\r\n    function HtmlTreeError(elementName, location, msg) {\r\n        _super.call(this, location, msg);\r\n        this.elementName = elementName;\r\n    }\r\n    HtmlTreeError.create = function (elementName, location, msg) {\r\n        return new HtmlTreeError(elementName, location, msg);\r\n    };\r\n    return HtmlTreeError;\r\n})(parse_util_1.ParseError);\r\nexports.HtmlTreeError = HtmlTreeError;\r\nvar HtmlParseTreeResult = (function () {\r\n    function HtmlParseTreeResult(rootNodes, errors) {\r\n        this.rootNodes = rootNodes;\r\n        this.errors = errors;\r\n    }\r\n    return HtmlParseTreeResult;\r\n})();\r\nexports.HtmlParseTreeResult = HtmlParseTreeResult;\r\nvar HtmlParser = (function () {\r\n    function HtmlParser() {\r\n    }\r\n    HtmlParser.prototype.parse = function (sourceContent, sourceUrl) {\r\n        var tokensAndErrors = html_lexer_1.tokenizeHtml(sourceContent, sourceUrl);\r\n        var treeAndErrors = new TreeBuilder(tokensAndErrors.tokens).build();\r\n        return new HtmlParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors\r\n            .concat(treeAndErrors.errors));\r\n    };\r\n    HtmlParser = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], HtmlParser);\r\n    return HtmlParser;\r\n})();\r\nexports.HtmlParser = HtmlParser;\r\nvar TreeBuilder = (function () {\r\n    function TreeBuilder(tokens) {\r\n        this.tokens = tokens;\r\n        this.index = -1;\r\n        this.rootNodes = [];\r\n        this.errors = [];\r\n        this.elementStack = [];\r\n        this._advance();\r\n    }\r\n    TreeBuilder.prototype.build = function () {\r\n        while (this.peek.type !== html_lexer_1.HtmlTokenType.EOF) {\r\n            if (this.peek.type === html_lexer_1.HtmlTokenType.TAG_OPEN_START) {\r\n                this._consumeStartTag(this._advance());\r\n            }\r\n            else if (this.peek.type === html_lexer_1.HtmlTokenType.TAG_CLOSE) {\r\n                this._consumeEndTag(this._advance());\r\n            }\r\n            else if (this.peek.type === html_lexer_1.HtmlTokenType.CDATA_START) {\r\n                this._closeVoidElement();\r\n                this._consumeCdata(this._advance());\r\n            }\r\n            else if (this.peek.type === html_lexer_1.HtmlTokenType.COMMENT_START) {\r\n                this._closeVoidElement();\r\n                this._consumeComment(this._advance());\r\n            }\r\n            else if (this.peek.type === html_lexer_1.HtmlTokenType.TEXT ||\r\n                this.peek.type === html_lexer_1.HtmlTokenType.RAW_TEXT ||\r\n                this.peek.type === html_lexer_1.HtmlTokenType.ESCAPABLE_RAW_TEXT) {\r\n                this._closeVoidElement();\r\n                this._consumeText(this._advance());\r\n            }\r\n            else {\r\n                // Skip all other tokens...\r\n                this._advance();\r\n            }\r\n        }\r\n        return new HtmlParseTreeResult(this.rootNodes, this.errors);\r\n    };\r\n    TreeBuilder.prototype._advance = function () {\r\n        var prev = this.peek;\r\n        if (this.index < this.tokens.length - 1) {\r\n            // Note: there is always an EOF token at the end\r\n            this.index++;\r\n        }\r\n        this.peek = this.tokens[this.index];\r\n        return prev;\r\n    };\r\n    TreeBuilder.prototype._advanceIf = function (type) {\r\n        if (this.peek.type === type) {\r\n            return this._advance();\r\n        }\r\n        return null;\r\n    };\r\n    TreeBuilder.prototype._consumeCdata = function (startToken) {\r\n        this._consumeText(this._advance());\r\n        this._advanceIf(html_lexer_1.HtmlTokenType.CDATA_END);\r\n    };\r\n    TreeBuilder.prototype._consumeComment = function (startToken) {\r\n        this._advanceIf(html_lexer_1.HtmlTokenType.RAW_TEXT);\r\n        this._advanceIf(html_lexer_1.HtmlTokenType.COMMENT_END);\r\n    };\r\n    TreeBuilder.prototype._consumeText = function (token) {\r\n        var text = token.parts[0];\r\n        if (text.length > 0 && text[0] == '\\n') {\r\n            var parent_1 = this._getParentElement();\r\n            if (lang_1.isPresent(parent_1) && parent_1.children.length == 0 &&\r\n                html_tags_1.getHtmlTagDefinition(parent_1.name).ignoreFirstLf) {\r\n                text = text.substring(1);\r\n            }\r\n        }\r\n        if (text.length > 0) {\r\n            this._addToParent(new html_ast_1.HtmlTextAst(text, token.sourceSpan));\r\n        }\r\n    };\r\n    TreeBuilder.prototype._closeVoidElement = function () {\r\n        if (this.elementStack.length > 0) {\r\n            var el = collection_1.ListWrapper.last(this.elementStack);\r\n            if (html_tags_1.getHtmlTagDefinition(el.name).isVoid) {\r\n                this.elementStack.pop();\r\n            }\r\n        }\r\n    };\r\n    TreeBuilder.prototype._consumeStartTag = function (startTagToken) {\r\n        var prefix = startTagToken.parts[0];\r\n        var name = startTagToken.parts[1];\r\n        var attrs = [];\r\n        while (this.peek.type === html_lexer_1.HtmlTokenType.ATTR_NAME) {\r\n            attrs.push(this._consumeAttr(this._advance()));\r\n        }\r\n        var fullName = getElementFullName(prefix, name, this._getParentElement());\r\n        var selfClosing = false;\r\n        // Note: There could have been a tokenizer error\r\n        // so that we don't get a token for the end tag...\r\n        if (this.peek.type === html_lexer_1.HtmlTokenType.TAG_OPEN_END_VOID) {\r\n            this._advance();\r\n            selfClosing = true;\r\n            if (html_tags_1.getNsPrefix(fullName) == null && !html_tags_1.getHtmlTagDefinition(fullName).isVoid) {\r\n                this.errors.push(HtmlTreeError.create(fullName, startTagToken.sourceSpan.start, \"Only void and foreign elements can be self closed \\\"\" + startTagToken.parts[1] + \"\\\"\"));\r\n            }\r\n        }\r\n        else if (this.peek.type === html_lexer_1.HtmlTokenType.TAG_OPEN_END) {\r\n            this._advance();\r\n            selfClosing = false;\r\n        }\r\n        var end = this.peek.sourceSpan.start;\r\n        var el = new html_ast_1.HtmlElementAst(fullName, attrs, [], new parse_util_1.ParseSourceSpan(startTagToken.sourceSpan.start, end));\r\n        this._pushElement(el);\r\n        if (selfClosing) {\r\n            this._popElement(fullName);\r\n        }\r\n    };\r\n    TreeBuilder.prototype._pushElement = function (el) {\r\n        if (this.elementStack.length > 0) {\r\n            var parentEl = collection_1.ListWrapper.last(this.elementStack);\r\n            if (html_tags_1.getHtmlTagDefinition(parentEl.name).isClosedByChild(el.name)) {\r\n                this.elementStack.pop();\r\n            }\r\n        }\r\n        var tagDef = html_tags_1.getHtmlTagDefinition(el.name);\r\n        var parentEl = this._getParentElement();\r\n        if (tagDef.requireExtraParent(lang_1.isPresent(parentEl) ? parentEl.name : null)) {\r\n            var newParent = new html_ast_1.HtmlElementAst(tagDef.parentToAdd, [], [el], el.sourceSpan);\r\n            this._addToParent(newParent);\r\n            this.elementStack.push(newParent);\r\n            this.elementStack.push(el);\r\n        }\r\n        else {\r\n            this._addToParent(el);\r\n            this.elementStack.push(el);\r\n        }\r\n    };\r\n    TreeBuilder.prototype._consumeEndTag = function (endTagToken) {\r\n        var fullName = getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\r\n        if (html_tags_1.getHtmlTagDefinition(fullName).isVoid) {\r\n            this.errors.push(HtmlTreeError.create(fullName, endTagToken.sourceSpan.start, \"Void elements do not have end tags \\\"\" + endTagToken.parts[1] + \"\\\"\"));\r\n        }\r\n        else if (!this._popElement(fullName)) {\r\n            this.errors.push(HtmlTreeError.create(fullName, endTagToken.sourceSpan.start, \"Unexpected closing tag \\\"\" + endTagToken.parts[1] + \"\\\"\"));\r\n        }\r\n    };\r\n    TreeBuilder.prototype._popElement = function (fullName) {\r\n        for (var stackIndex = this.elementStack.length - 1; stackIndex >= 0; stackIndex--) {\r\n            var el = this.elementStack[stackIndex];\r\n            if (el.name == fullName) {\r\n                collection_1.ListWrapper.splice(this.elementStack, stackIndex, this.elementStack.length - stackIndex);\r\n                return true;\r\n            }\r\n            if (!html_tags_1.getHtmlTagDefinition(el.name).closedByParent) {\r\n                return false;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    TreeBuilder.prototype._consumeAttr = function (attrName) {\r\n        var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\r\n        var end = attrName.sourceSpan.end;\r\n        var value = '';\r\n        if (this.peek.type === html_lexer_1.HtmlTokenType.ATTR_VALUE) {\r\n            var valueToken = this._advance();\r\n            value = valueToken.parts[0];\r\n            end = valueToken.sourceSpan.end;\r\n        }\r\n        return new html_ast_1.HtmlAttrAst(fullName, value, new parse_util_1.ParseSourceSpan(attrName.sourceSpan.start, end));\r\n    };\r\n    TreeBuilder.prototype._getParentElement = function () {\r\n        return this.elementStack.length > 0 ? collection_1.ListWrapper.last(this.elementStack) : null;\r\n    };\r\n    TreeBuilder.prototype._addToParent = function (node) {\r\n        var parent = this._getParentElement();\r\n        if (lang_1.isPresent(parent)) {\r\n            parent.children.push(node);\r\n        }\r\n        else {\r\n            this.rootNodes.push(node);\r\n        }\r\n    };\r\n    return TreeBuilder;\r\n})();\r\nfunction mergeNsAndName(prefix, localName) {\r\n    return lang_1.isPresent(prefix) ? \"@\" + prefix + \":\" + localName : localName;\r\n}\r\nfunction getElementFullName(prefix, localName, parentElement) {\r\n    if (lang_1.isBlank(prefix)) {\r\n        prefix = html_tags_1.getHtmlTagDefinition(localName).implicitNamespacePrefix;\r\n        if (lang_1.isBlank(prefix) && lang_1.isPresent(parentElement)) {\r\n            prefix = html_tags_1.getNsPrefix(parentElement.name);\r\n        }\r\n    }\r\n    return mergeNsAndName(prefix, localName);\r\n}\r\n},{\"./html_ast\":56,\"./html_lexer\":57,\"./html_tags\":59,\"./parse_util\":60,\"angular2/src/core/di\":117,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],59:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\r\n// see https://html.spec.whatwg.org/multipage/entities.json\r\n// This list is not exhaustive to keep the compiler footprint low.\r\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not exist.\r\nexports.NAMED_ENTITIES = lang_1.CONST_EXPR({\r\n    'Aacute': '\\u00C1',\r\n    'aacute': '\\u00E1',\r\n    'Acirc': '\\u00C2',\r\n    'acirc': '\\u00E2',\r\n    'acute': '\\u00B4',\r\n    'AElig': '\\u00C6',\r\n    'aelig': '\\u00E6',\r\n    'Agrave': '\\u00C0',\r\n    'agrave': '\\u00E0',\r\n    'alefsym': '\\u2135',\r\n    'Alpha': '\\u0391',\r\n    'alpha': '\\u03B1',\r\n    'amp': '&',\r\n    'and': '\\u2227',\r\n    'ang': '\\u2220',\r\n    'apos': '\\u0027',\r\n    'Aring': '\\u00C5',\r\n    'aring': '\\u00E5',\r\n    'asymp': '\\u2248',\r\n    'Atilde': '\\u00C3',\r\n    'atilde': '\\u00E3',\r\n    'Auml': '\\u00C4',\r\n    'auml': '\\u00E4',\r\n    'bdquo': '\\u201E',\r\n    'Beta': '\\u0392',\r\n    'beta': '\\u03B2',\r\n    'brvbar': '\\u00A6',\r\n    'bull': '\\u2022',\r\n    'cap': '\\u2229',\r\n    'Ccedil': '\\u00C7',\r\n    'ccedil': '\\u00E7',\r\n    'cedil': '\\u00B8',\r\n    'cent': '\\u00A2',\r\n    'Chi': '\\u03A7',\r\n    'chi': '\\u03C7',\r\n    'circ': '\\u02C6',\r\n    'clubs': '\\u2663',\r\n    'cong': '\\u2245',\r\n    'copy': '\\u00A9',\r\n    'crarr': '\\u21B5',\r\n    'cup': '\\u222A',\r\n    'curren': '\\u00A4',\r\n    'dagger': '\\u2020',\r\n    'Dagger': '\\u2021',\r\n    'darr': '\\u2193',\r\n    'dArr': '\\u21D3',\r\n    'deg': '\\u00B0',\r\n    'Delta': '\\u0394',\r\n    'delta': '\\u03B4',\r\n    'diams': '\\u2666',\r\n    'divide': '\\u00F7',\r\n    'Eacute': '\\u00C9',\r\n    'eacute': '\\u00E9',\r\n    'Ecirc': '\\u00CA',\r\n    'ecirc': '\\u00EA',\r\n    'Egrave': '\\u00C8',\r\n    'egrave': '\\u00E8',\r\n    'empty': '\\u2205',\r\n    'emsp': '\\u2003',\r\n    'ensp': '\\u2002',\r\n    'Epsilon': '\\u0395',\r\n    'epsilon': '\\u03B5',\r\n    'equiv': '\\u2261',\r\n    'Eta': '\\u0397',\r\n    'eta': '\\u03B7',\r\n    'ETH': '\\u00D0',\r\n    'eth': '\\u00F0',\r\n    'Euml': '\\u00CB',\r\n    'euml': '\\u00EB',\r\n    'euro': '\\u20AC',\r\n    'exist': '\\u2203',\r\n    'fnof': '\\u0192',\r\n    'forall': '\\u2200',\r\n    'frac12': '\\u00BD',\r\n    'frac14': '\\u00BC',\r\n    'frac34': '\\u00BE',\r\n    'frasl': '\\u2044',\r\n    'Gamma': '\\u0393',\r\n    'gamma': '\\u03B3',\r\n    'ge': '\\u2265',\r\n    'gt': '>',\r\n    'harr': '\\u2194',\r\n    'hArr': '\\u21D4',\r\n    'hearts': '\\u2665',\r\n    'hellip': '\\u2026',\r\n    'Iacute': '\\u00CD',\r\n    'iacute': '\\u00ED',\r\n    'Icirc': '\\u00CE',\r\n    'icirc': '\\u00EE',\r\n    'iexcl': '\\u00A1',\r\n    'Igrave': '\\u00CC',\r\n    'igrave': '\\u00EC',\r\n    'image': '\\u2111',\r\n    'infin': '\\u221E',\r\n    'int': '\\u222B',\r\n    'Iota': '\\u0399',\r\n    'iota': '\\u03B9',\r\n    'iquest': '\\u00BF',\r\n    'isin': '\\u2208',\r\n    'Iuml': '\\u00CF',\r\n    'iuml': '\\u00EF',\r\n    'Kappa': '\\u039A',\r\n    'kappa': '\\u03BA',\r\n    'Lambda': '\\u039B',\r\n    'lambda': '\\u03BB',\r\n    'lang': '\\u27E8',\r\n    'laquo': '\\u00AB',\r\n    'larr': '\\u2190',\r\n    'lArr': '\\u21D0',\r\n    'lceil': '\\u2308',\r\n    'ldquo': '\\u201C',\r\n    'le': '\\u2264',\r\n    'lfloor': '\\u230A',\r\n    'lowast': '\\u2217',\r\n    'loz': '\\u25CA',\r\n    'lrm': '\\u200E',\r\n    'lsaquo': '\\u2039',\r\n    'lsquo': '\\u2018',\r\n    'lt': '<',\r\n    'macr': '\\u00AF',\r\n    'mdash': '\\u2014',\r\n    'micro': '\\u00B5',\r\n    'middot': '\\u00B7',\r\n    'minus': '\\u2212',\r\n    'Mu': '\\u039C',\r\n    'mu': '\\u03BC',\r\n    'nabla': '\\u2207',\r\n    'nbsp': '\\u00A0',\r\n    'ndash': '\\u2013',\r\n    'ne': '\\u2260',\r\n    'ni': '\\u220B',\r\n    'not': '\\u00AC',\r\n    'notin': '\\u2209',\r\n    'nsub': '\\u2284',\r\n    'Ntilde': '\\u00D1',\r\n    'ntilde': '\\u00F1',\r\n    'Nu': '\\u039D',\r\n    'nu': '\\u03BD',\r\n    'Oacute': '\\u00D3',\r\n    'oacute': '\\u00F3',\r\n    'Ocirc': '\\u00D4',\r\n    'ocirc': '\\u00F4',\r\n    'OElig': '\\u0152',\r\n    'oelig': '\\u0153',\r\n    'Ograve': '\\u00D2',\r\n    'ograve': '\\u00F2',\r\n    'oline': '\\u203E',\r\n    'Omega': '\\u03A9',\r\n    'omega': '\\u03C9',\r\n    'Omicron': '\\u039F',\r\n    'omicron': '\\u03BF',\r\n    'oplus': '\\u2295',\r\n    'or': '\\u2228',\r\n    'ordf': '\\u00AA',\r\n    'ordm': '\\u00BA',\r\n    'Oslash': '\\u00D8',\r\n    'oslash': '\\u00F8',\r\n    'Otilde': '\\u00D5',\r\n    'otilde': '\\u00F5',\r\n    'otimes': '\\u2297',\r\n    'Ouml': '\\u00D6',\r\n    'ouml': '\\u00F6',\r\n    'para': '\\u00B6',\r\n    'permil': '\\u2030',\r\n    'perp': '\\u22A5',\r\n    'Phi': '\\u03A6',\r\n    'phi': '\\u03C6',\r\n    'Pi': '\\u03A0',\r\n    'pi': '\\u03C0',\r\n    'piv': '\\u03D6',\r\n    'plusmn': '\\u00B1',\r\n    'pound': '\\u00A3',\r\n    'prime': '\\u2032',\r\n    'Prime': '\\u2033',\r\n    'prod': '\\u220F',\r\n    'prop': '\\u221D',\r\n    'Psi': '\\u03A8',\r\n    'psi': '\\u03C8',\r\n    'quot': '\\u0022',\r\n    'radic': '\\u221A',\r\n    'rang': '\\u27E9',\r\n    'raquo': '\\u00BB',\r\n    'rarr': '\\u2192',\r\n    'rArr': '\\u21D2',\r\n    'rceil': '\\u2309',\r\n    'rdquo': '\\u201D',\r\n    'real': '\\u211C',\r\n    'reg': '\\u00AE',\r\n    'rfloor': '\\u230B',\r\n    'Rho': '\\u03A1',\r\n    'rho': '\\u03C1',\r\n    'rlm': '\\u200F',\r\n    'rsaquo': '\\u203A',\r\n    'rsquo': '\\u2019',\r\n    'sbquo': '\\u201A',\r\n    'Scaron': '\\u0160',\r\n    'scaron': '\\u0161',\r\n    'sdot': '\\u22C5',\r\n    'sect': '\\u00A7',\r\n    'shy': '\\u00AD',\r\n    'Sigma': '\\u03A3',\r\n    'sigma': '\\u03C3',\r\n    'sigmaf': '\\u03C2',\r\n    'sim': '\\u223C',\r\n    'spades': '\\u2660',\r\n    'sub': '\\u2282',\r\n    'sube': '\\u2286',\r\n    'sum': '\\u2211',\r\n    'sup': '\\u2283',\r\n    'sup1': '\\u00B9',\r\n    'sup2': '\\u00B2',\r\n    'sup3': '\\u00B3',\r\n    'supe': '\\u2287',\r\n    'szlig': '\\u00DF',\r\n    'Tau': '\\u03A4',\r\n    'tau': '\\u03C4',\r\n    'there4': '\\u2234',\r\n    'Theta': '\\u0398',\r\n    'theta': '\\u03B8',\r\n    'thetasym': '\\u03D1',\r\n    'thinsp': '\\u2009',\r\n    'THORN': '\\u00DE',\r\n    'thorn': '\\u00FE',\r\n    'tilde': '\\u02DC',\r\n    'times': '\\u00D7',\r\n    'trade': '\\u2122',\r\n    'Uacute': '\\u00DA',\r\n    'uacute': '\\u00FA',\r\n    'uarr': '\\u2191',\r\n    'uArr': '\\u21D1',\r\n    'Ucirc': '\\u00DB',\r\n    'ucirc': '\\u00FB',\r\n    'Ugrave': '\\u00D9',\r\n    'ugrave': '\\u00F9',\r\n    'uml': '\\u00A8',\r\n    'upsih': '\\u03D2',\r\n    'Upsilon': '\\u03A5',\r\n    'upsilon': '\\u03C5',\r\n    'Uuml': '\\u00DC',\r\n    'uuml': '\\u00FC',\r\n    'weierp': '\\u2118',\r\n    'Xi': '\\u039E',\r\n    'xi': '\\u03BE',\r\n    'Yacute': '\\u00DD',\r\n    'yacute': '\\u00FD',\r\n    'yen': '\\u00A5',\r\n    'yuml': '\\u00FF',\r\n    'Yuml': '\\u0178',\r\n    'Zeta': '\\u0396',\r\n    'zeta': '\\u03B6',\r\n    'zwj': '\\u200D',\r\n    'zwnj': '\\u200C',\r\n});\r\n(function (HtmlTagContentType) {\r\n    HtmlTagContentType[HtmlTagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\r\n    HtmlTagContentType[HtmlTagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\r\n    HtmlTagContentType[HtmlTagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\r\n})(exports.HtmlTagContentType || (exports.HtmlTagContentType = {}));\r\nvar HtmlTagContentType = exports.HtmlTagContentType;\r\nvar HtmlTagDefinition = (function () {\r\n    function HtmlTagDefinition(_a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, contentType = _b.contentType, closedByParent = _b.closedByParent, isVoid = _b.isVoid, ignoreFirstLf = _b.ignoreFirstLf;\r\n        this.closedByChildren = {};\r\n        this.closedByParent = false;\r\n        if (lang_1.isPresent(closedByChildren) && closedByChildren.length > 0) {\r\n            closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });\r\n        }\r\n        this.isVoid = lang_1.normalizeBool(isVoid);\r\n        this.closedByParent = lang_1.normalizeBool(closedByParent) || this.isVoid;\r\n        if (lang_1.isPresent(requiredParents) && requiredParents.length > 0) {\r\n            this.requiredParents = {};\r\n            this.parentToAdd = requiredParents[0];\r\n            requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });\r\n        }\r\n        this.implicitNamespacePrefix = implicitNamespacePrefix;\r\n        this.contentType = lang_1.isPresent(contentType) ? contentType : HtmlTagContentType.PARSABLE_DATA;\r\n        this.ignoreFirstLf = lang_1.normalizeBool(ignoreFirstLf);\r\n    }\r\n    HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {\r\n        if (lang_1.isBlank(this.requiredParents)) {\r\n            return false;\r\n        }\r\n        if (lang_1.isBlank(currentParent)) {\r\n            return true;\r\n        }\r\n        var lcParent = currentParent.toLowerCase();\r\n        return this.requiredParents[lcParent] != true && lcParent != 'template';\r\n    };\r\n    HtmlTagDefinition.prototype.isClosedByChild = function (name) {\r\n        return this.isVoid || lang_1.normalizeBool(this.closedByChildren[name.toLowerCase()]);\r\n    };\r\n    return HtmlTagDefinition;\r\n})();\r\nexports.HtmlTagDefinition = HtmlTagDefinition;\r\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\r\n// This implementation does not fully conform to the HTML5 spec.\r\nvar TAG_DEFINITIONS = {\r\n    'area': new HtmlTagDefinition({ isVoid: true }),\r\n    'embed': new HtmlTagDefinition({ isVoid: true }),\r\n    'link': new HtmlTagDefinition({ isVoid: true }),\r\n    'img': new HtmlTagDefinition({ isVoid: true }),\r\n    'input': new HtmlTagDefinition({ isVoid: true }),\r\n    'param': new HtmlTagDefinition({ isVoid: true }),\r\n    'hr': new HtmlTagDefinition({ isVoid: true }),\r\n    'br': new HtmlTagDefinition({ isVoid: true }),\r\n    'source': new HtmlTagDefinition({ isVoid: true }),\r\n    'track': new HtmlTagDefinition({ isVoid: true }),\r\n    'wbr': new HtmlTagDefinition({ isVoid: true }),\r\n    'p': new HtmlTagDefinition({\r\n        closedByChildren: [\r\n            'address',\r\n            'article',\r\n            'aside',\r\n            'blockquote',\r\n            'div',\r\n            'dl',\r\n            'fieldset',\r\n            'footer',\r\n            'form',\r\n            'h1',\r\n            'h2',\r\n            'h3',\r\n            'h4',\r\n            'h5',\r\n            'h6',\r\n            'header',\r\n            'hgroup',\r\n            'hr',\r\n            'main',\r\n            'nav',\r\n            'ol',\r\n            'p',\r\n            'pre',\r\n            'section',\r\n            'table',\r\n            'ul'\r\n        ],\r\n        closedByParent: true\r\n    }),\r\n    'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\r\n    'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\r\n    'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\r\n    'tr': new HtmlTagDefinition({\r\n        closedByChildren: ['tr'],\r\n        requiredParents: ['tbody', 'tfoot', 'thead'],\r\n        closedByParent: true\r\n    }),\r\n    'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\r\n    'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\r\n    'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),\r\n    'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\r\n    'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\r\n    'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\r\n    'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\r\n    'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\r\n    'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\r\n    'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\r\n    'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\r\n    'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\r\n    'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\r\n    'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\r\n    'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\r\n    'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\r\n    'style': new HtmlTagDefinition({ contentType: HtmlTagContentType.RAW_TEXT }),\r\n    'script': new HtmlTagDefinition({ contentType: HtmlTagContentType.RAW_TEXT }),\r\n    'title': new HtmlTagDefinition({ contentType: HtmlTagContentType.ESCAPABLE_RAW_TEXT }),\r\n    'textarea': new HtmlTagDefinition({ contentType: HtmlTagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\r\n};\r\nvar DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\r\nfunction getHtmlTagDefinition(tagName) {\r\n    var result = TAG_DEFINITIONS[tagName.toLowerCase()];\r\n    return lang_1.isPresent(result) ? result : DEFAULT_TAG_DEFINITION;\r\n}\r\nexports.getHtmlTagDefinition = getHtmlTagDefinition;\r\nvar NS_PREFIX_RE = /^@([^:]+):(.+)/g;\r\nfunction splitNsName(elementName) {\r\n    if (elementName[0] != '@') {\r\n        return [null, elementName];\r\n    }\r\n    var match = lang_1.RegExpWrapper.firstMatch(NS_PREFIX_RE, elementName);\r\n    return [match[1], match[2]];\r\n}\r\nexports.splitNsName = splitNsName;\r\nfunction getNsPrefix(elementName) {\r\n    return splitNsName(elementName)[0];\r\n}\r\nexports.getNsPrefix = getNsPrefix;\r\n},{\"angular2/src/facade/lang\":176}],60:[function(require,module,exports){\n'use strict';var ParseLocation = (function () {\r\n    function ParseLocation(file, offset, line, col) {\r\n        this.file = file;\r\n        this.offset = offset;\r\n        this.line = line;\r\n        this.col = col;\r\n    }\r\n    ParseLocation.prototype.toString = function () { return this.file.url + \"@\" + this.line + \":\" + this.col; };\r\n    return ParseLocation;\r\n})();\r\nexports.ParseLocation = ParseLocation;\r\nvar ParseSourceFile = (function () {\r\n    function ParseSourceFile(content, url) {\r\n        this.content = content;\r\n        this.url = url;\r\n    }\r\n    return ParseSourceFile;\r\n})();\r\nexports.ParseSourceFile = ParseSourceFile;\r\nvar ParseError = (function () {\r\n    function ParseError(location, msg) {\r\n        this.location = location;\r\n        this.msg = msg;\r\n    }\r\n    ParseError.prototype.toString = function () {\r\n        var source = this.location.file.content;\r\n        var ctxStart = this.location.offset;\r\n        if (ctxStart > source.length - 1) {\r\n            ctxStart = source.length - 1;\r\n        }\r\n        var ctxEnd = ctxStart;\r\n        var ctxLen = 0;\r\n        var ctxLines = 0;\r\n        while (ctxLen < 100 && ctxStart > 0) {\r\n            ctxStart--;\r\n            ctxLen++;\r\n            if (source[ctxStart] == \"\\n\") {\r\n                if (++ctxLines == 3) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        ctxLen = 0;\r\n        ctxLines = 0;\r\n        while (ctxLen < 100 && ctxEnd < source.length - 1) {\r\n            ctxEnd++;\r\n            ctxLen++;\r\n            if (source[ctxEnd] == \"\\n\") {\r\n                if (++ctxLines == 3) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        var context = source.substring(ctxStart, this.location.offset) + '[ERROR ->]' +\r\n            source.substring(this.location.offset, ctxEnd + 1);\r\n        return this.msg + \" (\\\"\" + context + \"\\\"): \" + this.location;\r\n    };\r\n    return ParseError;\r\n})();\r\nexports.ParseError = ParseError;\r\nvar ParseSourceSpan = (function () {\r\n    function ParseSourceSpan(start, end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n    ParseSourceSpan.prototype.toString = function () {\r\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\r\n    };\r\n    return ParseSourceSpan;\r\n})();\r\nexports.ParseSourceSpan = ParseSourceSpan;\r\n},{}],61:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar template_ast_1 = require('./template_ast');\r\nvar source_module_1 = require('./source_module');\r\nvar view_1 = require('angular2/src/core/linker/view');\r\nvar view_type_1 = require('angular2/src/core/linker/view_type');\r\nvar element_1 = require('angular2/src/core/linker/element');\r\nvar util_1 = require('./util');\r\nvar di_1 = require('angular2/src/core/di');\r\nexports.PROTO_VIEW_JIT_IMPORTS = lang_1.CONST_EXPR({ 'AppProtoView': view_1.AppProtoView, 'AppProtoElement': element_1.AppProtoElement, 'ViewType': view_type_1.ViewType });\r\n// TODO: have a single file that reexports everything needed for\r\n// codegen explicitly\r\n// - helps understanding what codegen works against\r\n// - less imports in codegen code\r\nexports.APP_VIEW_MODULE_REF = source_module_1.moduleRef('package:angular2/src/core/linker/view' + util_1.MODULE_SUFFIX);\r\nexports.VIEW_TYPE_MODULE_REF = source_module_1.moduleRef('package:angular2/src/core/linker/view_type' + util_1.MODULE_SUFFIX);\r\nexports.APP_EL_MODULE_REF = source_module_1.moduleRef('package:angular2/src/core/linker/element' + util_1.MODULE_SUFFIX);\r\nexports.METADATA_MODULE_REF = source_module_1.moduleRef('package:angular2/src/core/metadata/view' + util_1.MODULE_SUFFIX);\r\nvar IMPLICIT_TEMPLATE_VAR = '\\$implicit';\r\nvar CLASS_ATTR = 'class';\r\nvar STYLE_ATTR = 'style';\r\nvar ProtoViewCompiler = (function () {\r\n    function ProtoViewCompiler() {\r\n    }\r\n    ProtoViewCompiler.prototype.compileProtoViewRuntime = function (metadataCache, component, template, pipes) {\r\n        var protoViewFactory = new RuntimeProtoViewFactory(metadataCache, component, pipes);\r\n        var allProtoViews = [];\r\n        protoViewFactory.createCompileProtoView(template, [], [], allProtoViews);\r\n        return new CompileProtoViews([], allProtoViews);\r\n    };\r\n    ProtoViewCompiler.prototype.compileProtoViewCodeGen = function (resolvedMetadataCacheExpr, component, template, pipes) {\r\n        var protoViewFactory = new CodeGenProtoViewFactory(resolvedMetadataCacheExpr, component, pipes);\r\n        var allProtoViews = [];\r\n        var allStatements = [];\r\n        protoViewFactory.createCompileProtoView(template, [], allStatements, allProtoViews);\r\n        return new CompileProtoViews(allStatements.map(function (stmt) { return stmt.statement; }), allProtoViews);\r\n    };\r\n    ProtoViewCompiler = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], ProtoViewCompiler);\r\n    return ProtoViewCompiler;\r\n})();\r\nexports.ProtoViewCompiler = ProtoViewCompiler;\r\nvar CompileProtoViews = (function () {\r\n    function CompileProtoViews(declarations, protoViews) {\r\n        this.declarations = declarations;\r\n        this.protoViews = protoViews;\r\n    }\r\n    return CompileProtoViews;\r\n})();\r\nexports.CompileProtoViews = CompileProtoViews;\r\nvar CompileProtoView = (function () {\r\n    function CompileProtoView(embeddedTemplateIndex, protoElements, protoView) {\r\n        this.embeddedTemplateIndex = embeddedTemplateIndex;\r\n        this.protoElements = protoElements;\r\n        this.protoView = protoView;\r\n    }\r\n    return CompileProtoView;\r\n})();\r\nexports.CompileProtoView = CompileProtoView;\r\nvar CompileProtoElement = (function () {\r\n    function CompileProtoElement(boundElementIndex, attrNameAndValues, variableNameAndValues, renderEvents, directives, embeddedTemplateIndex, appProtoEl) {\r\n        this.boundElementIndex = boundElementIndex;\r\n        this.attrNameAndValues = attrNameAndValues;\r\n        this.variableNameAndValues = variableNameAndValues;\r\n        this.renderEvents = renderEvents;\r\n        this.directives = directives;\r\n        this.embeddedTemplateIndex = embeddedTemplateIndex;\r\n        this.appProtoEl = appProtoEl;\r\n    }\r\n    return CompileProtoElement;\r\n})();\r\nexports.CompileProtoElement = CompileProtoElement;\r\nfunction visitAndReturnContext(visitor, asts, context) {\r\n    template_ast_1.templateVisitAll(visitor, asts, context);\r\n    return context;\r\n}\r\nvar ProtoViewFactory = (function () {\r\n    function ProtoViewFactory(component) {\r\n        this.component = component;\r\n    }\r\n    ProtoViewFactory.prototype.createCompileProtoView = function (template, templateVariableBindings, targetStatements, targetProtoViews) {\r\n        var embeddedTemplateIndex = targetProtoViews.length;\r\n        // Note: targetProtoViews needs to be in depth first order.\r\n        // So we \"reserve\" a space here that we fill after the recursion is done\r\n        targetProtoViews.push(null);\r\n        var builder = new ProtoViewBuilderVisitor(this, targetStatements, targetProtoViews);\r\n        template_ast_1.templateVisitAll(builder, template);\r\n        var viewType = getViewType(this.component, embeddedTemplateIndex);\r\n        var appProtoView = this.createAppProtoView(embeddedTemplateIndex, viewType, templateVariableBindings, targetStatements);\r\n        var cpv = new CompileProtoView(embeddedTemplateIndex, builder.protoElements, appProtoView);\r\n        targetProtoViews[embeddedTemplateIndex] = cpv;\r\n        return cpv;\r\n    };\r\n    return ProtoViewFactory;\r\n})();\r\nvar CodeGenProtoViewFactory = (function (_super) {\r\n    __extends(CodeGenProtoViewFactory, _super);\r\n    function CodeGenProtoViewFactory(resolvedMetadataCacheExpr, component, pipes) {\r\n        _super.call(this, component);\r\n        this.resolvedMetadataCacheExpr = resolvedMetadataCacheExpr;\r\n        this.pipes = pipes;\r\n        this._nextVarId = 0;\r\n    }\r\n    CodeGenProtoViewFactory.prototype._nextProtoViewVar = function (embeddedTemplateIndex) {\r\n        return \"appProtoView\" + this._nextVarId++ + \"_\" + this.component.type.name + embeddedTemplateIndex;\r\n    };\r\n    CodeGenProtoViewFactory.prototype.createAppProtoView = function (embeddedTemplateIndex, viewType, templateVariableBindings, targetStatements) {\r\n        var protoViewVarName = this._nextProtoViewVar(embeddedTemplateIndex);\r\n        var viewTypeExpr = codeGenViewType(viewType);\r\n        var pipesExpr = embeddedTemplateIndex === 0 ?\r\n            codeGenTypesArray(this.pipes.map(function (pipeMeta) { return pipeMeta.type; })) :\r\n            null;\r\n        var statement = \"var \" + protoViewVarName + \" = \" + exports.APP_VIEW_MODULE_REF + \"AppProtoView.create(\" + this.resolvedMetadataCacheExpr.expression + \", \" + viewTypeExpr + \", \" + pipesExpr + \", \" + util_1.codeGenStringMap(templateVariableBindings) + \");\";\r\n        targetStatements.push(new util_1.Statement(statement));\r\n        return new util_1.Expression(protoViewVarName);\r\n    };\r\n    CodeGenProtoViewFactory.prototype.createAppProtoElement = function (boundElementIndex, attrNameAndValues, variableNameAndValues, directives, targetStatements) {\r\n        var varName = \"appProtoEl\" + this._nextVarId++ + \"_\" + this.component.type.name;\r\n        var value = exports.APP_EL_MODULE_REF + \"AppProtoElement.create(\\n        \" + this.resolvedMetadataCacheExpr.expression + \",\\n        \" + boundElementIndex + \",\\n        \" + util_1.codeGenStringMap(attrNameAndValues) + \",\\n        \" + codeGenDirectivesArray(directives) + \",\\n        \" + util_1.codeGenStringMap(variableNameAndValues) + \"\\n      )\";\r\n        var statement = \"var \" + varName + \" = \" + value + \";\";\r\n        targetStatements.push(new util_1.Statement(statement));\r\n        return new util_1.Expression(varName);\r\n    };\r\n    return CodeGenProtoViewFactory;\r\n})(ProtoViewFactory);\r\nvar RuntimeProtoViewFactory = (function (_super) {\r\n    __extends(RuntimeProtoViewFactory, _super);\r\n    function RuntimeProtoViewFactory(metadataCache, component, pipes) {\r\n        _super.call(this, component);\r\n        this.metadataCache = metadataCache;\r\n        this.pipes = pipes;\r\n    }\r\n    RuntimeProtoViewFactory.prototype.createAppProtoView = function (embeddedTemplateIndex, viewType, templateVariableBindings, targetStatements) {\r\n        var pipes = embeddedTemplateIndex === 0 ? this.pipes.map(function (pipeMeta) { return pipeMeta.type.runtime; }) : [];\r\n        var templateVars = keyValueArrayToStringMap(templateVariableBindings);\r\n        return view_1.AppProtoView.create(this.metadataCache, viewType, pipes, templateVars);\r\n    };\r\n    RuntimeProtoViewFactory.prototype.createAppProtoElement = function (boundElementIndex, attrNameAndValues, variableNameAndValues, directives, targetStatements) {\r\n        var attrs = keyValueArrayToStringMap(attrNameAndValues);\r\n        return element_1.AppProtoElement.create(this.metadataCache, boundElementIndex, attrs, directives.map(function (dirMeta) { return dirMeta.type.runtime; }), keyValueArrayToStringMap(variableNameAndValues));\r\n    };\r\n    return RuntimeProtoViewFactory;\r\n})(ProtoViewFactory);\r\nvar ProtoViewBuilderVisitor = (function () {\r\n    function ProtoViewBuilderVisitor(factory, allStatements, allProtoViews) {\r\n        this.factory = factory;\r\n        this.allStatements = allStatements;\r\n        this.allProtoViews = allProtoViews;\r\n        this.protoElements = [];\r\n        this.boundElementCount = 0;\r\n    }\r\n    ProtoViewBuilderVisitor.prototype._readAttrNameAndValues = function (directives, attrAsts) {\r\n        var attrs = visitAndReturnContext(this, attrAsts, {});\r\n        directives.forEach(function (directiveMeta) {\r\n            collection_1.StringMapWrapper.forEach(directiveMeta.hostAttributes, function (value, name) {\r\n                var prevValue = attrs[name];\r\n                attrs[name] = lang_1.isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;\r\n            });\r\n        });\r\n        return mapToKeyValueArray(attrs);\r\n    };\r\n    ProtoViewBuilderVisitor.prototype.visitBoundText = function (ast, context) { return null; };\r\n    ProtoViewBuilderVisitor.prototype.visitText = function (ast, context) { return null; };\r\n    ProtoViewBuilderVisitor.prototype.visitNgContent = function (ast, context) { return null; };\r\n    ProtoViewBuilderVisitor.prototype.visitElement = function (ast, context) {\r\n        var _this = this;\r\n        var boundElementIndex = null;\r\n        if (ast.isBound()) {\r\n            boundElementIndex = this.boundElementCount++;\r\n        }\r\n        var component = ast.getComponent();\r\n        var variableNameAndValues = [];\r\n        if (lang_1.isBlank(component)) {\r\n            ast.exportAsVars.forEach(function (varAst) { variableNameAndValues.push([varAst.name, null]); });\r\n        }\r\n        var directives = [];\r\n        var renderEvents = visitAndReturnContext(this, ast.outputs, new Map());\r\n        collection_1.ListWrapper.forEachWithIndex(ast.directives, function (directiveAst, index) {\r\n            directiveAst.visit(_this, new DirectiveContext(index, boundElementIndex, renderEvents, variableNameAndValues, directives));\r\n        });\r\n        var renderEventArray = [];\r\n        renderEvents.forEach(function (eventAst, _) { return renderEventArray.push(eventAst); });\r\n        var attrNameAndValues = this._readAttrNameAndValues(directives, ast.attrs);\r\n        this._addProtoElement(ast.isBound(), boundElementIndex, attrNameAndValues, variableNameAndValues, renderEventArray, directives, null);\r\n        template_ast_1.templateVisitAll(this, ast.children);\r\n        return null;\r\n    };\r\n    ProtoViewBuilderVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {\r\n        var _this = this;\r\n        var boundElementIndex = this.boundElementCount++;\r\n        var directives = [];\r\n        collection_1.ListWrapper.forEachWithIndex(ast.directives, function (directiveAst, index) {\r\n            directiveAst.visit(_this, new DirectiveContext(index, boundElementIndex, new Map(), [], directives));\r\n        });\r\n        var attrNameAndValues = this._readAttrNameAndValues(directives, ast.attrs);\r\n        var templateVariableBindings = ast.vars.map(function (varAst) { return [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name]; });\r\n        var nestedProtoView = this.factory.createCompileProtoView(ast.children, templateVariableBindings, this.allStatements, this.allProtoViews);\r\n        this._addProtoElement(true, boundElementIndex, attrNameAndValues, [], [], directives, nestedProtoView.embeddedTemplateIndex);\r\n        return null;\r\n    };\r\n    ProtoViewBuilderVisitor.prototype._addProtoElement = function (isBound, boundElementIndex, attrNameAndValues, variableNameAndValues, renderEvents, directives, embeddedTemplateIndex) {\r\n        var appProtoEl = null;\r\n        if (isBound) {\r\n            appProtoEl =\r\n                this.factory.createAppProtoElement(boundElementIndex, attrNameAndValues, variableNameAndValues, directives, this.allStatements);\r\n        }\r\n        var compileProtoEl = new CompileProtoElement(boundElementIndex, attrNameAndValues, variableNameAndValues, renderEvents, directives, embeddedTemplateIndex, appProtoEl);\r\n        this.protoElements.push(compileProtoEl);\r\n    };\r\n    ProtoViewBuilderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };\r\n    ProtoViewBuilderVisitor.prototype.visitAttr = function (ast, attrNameAndValues) {\r\n        attrNameAndValues[ast.name] = ast.value;\r\n        return null;\r\n    };\r\n    ProtoViewBuilderVisitor.prototype.visitDirective = function (ast, ctx) {\r\n        ctx.targetDirectives.push(ast.directive);\r\n        template_ast_1.templateVisitAll(this, ast.hostEvents, ctx.hostEventTargetAndNames);\r\n        ast.exportAsVars.forEach(function (varAst) { ctx.targetVariableNameAndValues.push([varAst.name, ctx.index]); });\r\n        return null;\r\n    };\r\n    ProtoViewBuilderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {\r\n        eventTargetAndNames.set(ast.fullName, ast);\r\n        return null;\r\n    };\r\n    ProtoViewBuilderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };\r\n    ProtoViewBuilderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };\r\n    return ProtoViewBuilderVisitor;\r\n})();\r\nfunction mapToKeyValueArray(data) {\r\n    var entryArray = [];\r\n    collection_1.StringMapWrapper.forEach(data, function (value, name) { entryArray.push([name, value]); });\r\n    // We need to sort to get a defined output order\r\n    // for tests and for caching generated artifacts...\r\n    collection_1.ListWrapper.sort(entryArray, function (entry1, entry2) { return lang_1.StringWrapper.compare(entry1[0], entry2[0]); });\r\n    var keyValueArray = [];\r\n    entryArray.forEach(function (entry) { keyValueArray.push([entry[0], entry[1]]); });\r\n    return keyValueArray;\r\n}\r\nfunction mergeAttributeValue(attrName, attrValue1, attrValue2) {\r\n    if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {\r\n        return attrValue1 + \" \" + attrValue2;\r\n    }\r\n    else {\r\n        return attrValue2;\r\n    }\r\n}\r\nvar DirectiveContext = (function () {\r\n    function DirectiveContext(index, boundElementIndex, hostEventTargetAndNames, targetVariableNameAndValues, targetDirectives) {\r\n        this.index = index;\r\n        this.boundElementIndex = boundElementIndex;\r\n        this.hostEventTargetAndNames = hostEventTargetAndNames;\r\n        this.targetVariableNameAndValues = targetVariableNameAndValues;\r\n        this.targetDirectives = targetDirectives;\r\n    }\r\n    return DirectiveContext;\r\n})();\r\nfunction keyValueArrayToStringMap(keyValueArray) {\r\n    var stringMap = {};\r\n    for (var i = 0; i < keyValueArray.length; i++) {\r\n        var entry = keyValueArray[i];\r\n        stringMap[entry[0]] = entry[1];\r\n    }\r\n    return stringMap;\r\n}\r\nfunction codeGenDirectivesArray(directives) {\r\n    var expressions = directives.map(function (directiveType) { return typeRef(directiveType.type); });\r\n    return \"[\" + expressions.join(',') + \"]\";\r\n}\r\nfunction codeGenTypesArray(types) {\r\n    var expressions = types.map(typeRef);\r\n    return \"[\" + expressions.join(',') + \"]\";\r\n}\r\nfunction codeGenViewType(value) {\r\n    if (lang_1.IS_DART) {\r\n        return \"\" + exports.VIEW_TYPE_MODULE_REF + value;\r\n    }\r\n    else {\r\n        return \"\" + value;\r\n    }\r\n}\r\nfunction typeRef(type) {\r\n    return \"\" + source_module_1.moduleRef(type.moduleUrl) + type.name;\r\n}\r\nfunction getViewType(component, embeddedTemplateIndex) {\r\n    if (embeddedTemplateIndex > 0) {\r\n        return view_type_1.ViewType.EMBEDDED;\r\n    }\r\n    else if (component.type.isHost) {\r\n        return view_type_1.ViewType.HOST;\r\n    }\r\n    else {\r\n        return view_type_1.ViewType.COMPONENT;\r\n    }\r\n}\r\n},{\"./source_module\":68,\"./template_ast\":71,\"./util\":77,\"angular2/src/core/di\":117,\"angular2/src/core/linker/element\":132,\"angular2/src/core/linker/view\":139,\"angular2/src/core/linker/view_type\":145,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],62:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar compiler_1 = require('angular2/src/core/linker/compiler');\r\nvar view_ref_1 = require('angular2/src/core/linker/view_ref');\r\nvar template_compiler_1 = require('./template_compiler');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar RuntimeCompiler = (function (_super) {\r\n    __extends(RuntimeCompiler, _super);\r\n    function RuntimeCompiler() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    return RuntimeCompiler;\r\n})(compiler_1.Compiler);\r\nexports.RuntimeCompiler = RuntimeCompiler;\r\nvar RuntimeCompiler_ = (function (_super) {\r\n    __extends(RuntimeCompiler_, _super);\r\n    function RuntimeCompiler_(_templateCompiler) {\r\n        _super.call(this);\r\n        this._templateCompiler = _templateCompiler;\r\n    }\r\n    RuntimeCompiler_.prototype.compileInHost = function (componentType) {\r\n        return this._templateCompiler.compileHostComponentRuntime(componentType)\r\n            .then(function (hostViewFactory) { return new view_ref_1.HostViewFactoryRef_(hostViewFactory); });\r\n    };\r\n    RuntimeCompiler_.prototype.clearCache = function () {\r\n        _super.prototype.clearCache.call(this);\r\n        this._templateCompiler.clearCache();\r\n    };\r\n    RuntimeCompiler_ = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [template_compiler_1.TemplateCompiler])\r\n    ], RuntimeCompiler_);\r\n    return RuntimeCompiler_;\r\n})(compiler_1.Compiler_);\r\nexports.RuntimeCompiler_ = RuntimeCompiler_;\r\n},{\"./template_compiler\":72,\"angular2/src/core/di\":117,\"angular2/src/core/linker/compiler\":128,\"angular2/src/core/linker/view_ref\":143}],63:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar cpl = require('./directive_metadata');\r\nvar md = require('angular2/src/core/metadata/directives');\r\nvar directive_resolver_1 = require('angular2/src/core/linker/directive_resolver');\r\nvar pipe_resolver_1 = require('angular2/src/core/linker/pipe_resolver');\r\nvar view_resolver_1 = require('angular2/src/core/linker/view_resolver');\r\nvar directive_lifecycle_reflector_1 = require('angular2/src/core/linker/directive_lifecycle_reflector');\r\nvar interfaces_1 = require('angular2/src/core/linker/interfaces');\r\nvar reflection_1 = require('angular2/src/core/reflection/reflection');\r\nvar di_2 = require('angular2/src/core/di');\r\nvar platform_directives_and_pipes_1 = require('angular2/src/core/platform_directives_and_pipes');\r\nvar util_1 = require('./util');\r\nvar url_resolver_1 = require('angular2/src/compiler/url_resolver');\r\nvar RuntimeMetadataResolver = (function () {\r\n    function RuntimeMetadataResolver(_directiveResolver, _pipeResolver, _viewResolver, _platformDirectives, _platformPipes) {\r\n        this._directiveResolver = _directiveResolver;\r\n        this._pipeResolver = _pipeResolver;\r\n        this._viewResolver = _viewResolver;\r\n        this._platformDirectives = _platformDirectives;\r\n        this._platformPipes = _platformPipes;\r\n        this._directiveCache = new Map();\r\n        this._pipeCache = new Map();\r\n    }\r\n    RuntimeMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {\r\n        var meta = this._directiveCache.get(directiveType);\r\n        if (lang_1.isBlank(meta)) {\r\n            var dirMeta = this._directiveResolver.resolve(directiveType);\r\n            var moduleUrl = null;\r\n            var templateMeta = null;\r\n            var changeDetectionStrategy = null;\r\n            if (dirMeta instanceof md.ComponentMetadata) {\r\n                var cmpMeta = dirMeta;\r\n                moduleUrl = calcModuleUrl(directiveType, cmpMeta);\r\n                var viewMeta = this._viewResolver.resolve(directiveType);\r\n                templateMeta = new cpl.CompileTemplateMetadata({\r\n                    encapsulation: viewMeta.encapsulation,\r\n                    template: viewMeta.template,\r\n                    templateUrl: viewMeta.templateUrl,\r\n                    styles: viewMeta.styles,\r\n                    styleUrls: viewMeta.styleUrls\r\n                });\r\n                changeDetectionStrategy = cmpMeta.changeDetection;\r\n            }\r\n            meta = cpl.CompileDirectiveMetadata.create({\r\n                selector: dirMeta.selector,\r\n                exportAs: dirMeta.exportAs,\r\n                isComponent: lang_1.isPresent(templateMeta),\r\n                dynamicLoadable: true,\r\n                type: new cpl.CompileTypeMetadata({ name: lang_1.stringify(directiveType), moduleUrl: moduleUrl, runtime: directiveType }),\r\n                template: templateMeta,\r\n                changeDetection: changeDetectionStrategy,\r\n                inputs: dirMeta.inputs,\r\n                outputs: dirMeta.outputs,\r\n                host: dirMeta.host,\r\n                lifecycleHooks: interfaces_1.LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return directive_lifecycle_reflector_1.hasLifecycleHook(hook, directiveType); })\r\n            });\r\n            this._directiveCache.set(directiveType, meta);\r\n        }\r\n        return meta;\r\n    };\r\n    RuntimeMetadataResolver.prototype.getPipeMetadata = function (pipeType) {\r\n        var meta = this._pipeCache.get(pipeType);\r\n        if (lang_1.isBlank(meta)) {\r\n            var pipeMeta = this._pipeResolver.resolve(pipeType);\r\n            var moduleUrl = reflection_1.reflector.importUri(pipeType);\r\n            meta = new cpl.CompilePipeMetadata({\r\n                type: new cpl.CompileTypeMetadata({ name: lang_1.stringify(pipeType), moduleUrl: moduleUrl, runtime: pipeType }),\r\n                name: pipeMeta.name,\r\n                pure: pipeMeta.pure\r\n            });\r\n            this._pipeCache.set(pipeType, meta);\r\n        }\r\n        return meta;\r\n    };\r\n    RuntimeMetadataResolver.prototype.getViewDirectivesMetadata = function (component) {\r\n        var _this = this;\r\n        var view = this._viewResolver.resolve(component);\r\n        var directives = flattenDirectives(view, this._platformDirectives);\r\n        for (var i = 0; i < directives.length; i++) {\r\n            if (!isValidType(directives[i])) {\r\n                throw new exceptions_1.BaseException(\"Unexpected directive value '\" + lang_1.stringify(directives[i]) + \"' on the View of component '\" + lang_1.stringify(component) + \"'\");\r\n            }\r\n        }\r\n        return directives.map(function (type) { return _this.getDirectiveMetadata(type); });\r\n    };\r\n    RuntimeMetadataResolver.prototype.getViewPipesMetadata = function (component) {\r\n        var _this = this;\r\n        var view = this._viewResolver.resolve(component);\r\n        var pipes = flattenPipes(view, this._platformPipes);\r\n        for (var i = 0; i < pipes.length; i++) {\r\n            if (!isValidType(pipes[i])) {\r\n                throw new exceptions_1.BaseException(\"Unexpected piped value '\" + lang_1.stringify(pipes[i]) + \"' on the View of component '\" + lang_1.stringify(component) + \"'\");\r\n            }\r\n        }\r\n        return pipes.map(function (type) { return _this.getPipeMetadata(type); });\r\n    };\r\n    RuntimeMetadataResolver = __decorate([\r\n        di_2.Injectable(),\r\n        __param(3, di_2.Optional()),\r\n        __param(3, di_2.Inject(platform_directives_and_pipes_1.PLATFORM_DIRECTIVES)),\r\n        __param(4, di_2.Optional()),\r\n        __param(4, di_2.Inject(platform_directives_and_pipes_1.PLATFORM_PIPES)), \r\n        __metadata('design:paramtypes', [directive_resolver_1.DirectiveResolver, pipe_resolver_1.PipeResolver, view_resolver_1.ViewResolver, Array, Array])\r\n    ], RuntimeMetadataResolver);\r\n    return RuntimeMetadataResolver;\r\n})();\r\nexports.RuntimeMetadataResolver = RuntimeMetadataResolver;\r\nfunction flattenDirectives(view, platformDirectives) {\r\n    var directives = [];\r\n    if (lang_1.isPresent(platformDirectives)) {\r\n        flattenArray(platformDirectives, directives);\r\n    }\r\n    if (lang_1.isPresent(view.directives)) {\r\n        flattenArray(view.directives, directives);\r\n    }\r\n    return directives;\r\n}\r\nfunction flattenPipes(view, platformPipes) {\r\n    var pipes = [];\r\n    if (lang_1.isPresent(platformPipes)) {\r\n        flattenArray(platformPipes, pipes);\r\n    }\r\n    if (lang_1.isPresent(view.pipes)) {\r\n        flattenArray(view.pipes, pipes);\r\n    }\r\n    return pipes;\r\n}\r\nfunction flattenArray(tree, out) {\r\n    for (var i = 0; i < tree.length; i++) {\r\n        var item = di_1.resolveForwardRef(tree[i]);\r\n        if (lang_1.isArray(item)) {\r\n            flattenArray(item, out);\r\n        }\r\n        else {\r\n            out.push(item);\r\n        }\r\n    }\r\n}\r\nfunction isValidType(value) {\r\n    return lang_1.isPresent(value) && (value instanceof lang_1.Type);\r\n}\r\nfunction calcModuleUrl(type, cmpMetadata) {\r\n    var moduleId = cmpMetadata.moduleId;\r\n    if (lang_1.isPresent(moduleId)) {\r\n        var scheme = url_resolver_1.getUrlScheme(moduleId);\r\n        return lang_1.isPresent(scheme) && scheme.length > 0 ? moduleId :\r\n            \"package:\" + moduleId + util_1.MODULE_SUFFIX;\r\n    }\r\n    else {\r\n        return reflection_1.reflector.importUri(type);\r\n    }\r\n}\r\n},{\"./directive_metadata\":55,\"./util\":77,\"angular2/src/compiler/url_resolver\":76,\"angular2/src/core/di\":117,\"angular2/src/core/linker/directive_lifecycle_reflector\":129,\"angular2/src/core/linker/directive_resolver\":130,\"angular2/src/core/linker/interfaces\":134,\"angular2/src/core/linker/pipe_resolver\":135,\"angular2/src/core/linker/view_resolver\":144,\"angular2/src/core/metadata/directives\":148,\"angular2/src/core/platform_directives_and_pipes\":153,\"angular2/src/core/reflection/reflection\":158,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],64:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar html_tags_1 = require('angular2/src/compiler/html_tags');\r\nvar element_schema_registry_1 = require('./element_schema_registry');\r\nvar NAMESPACE_URIS = lang_1.CONST_EXPR({ 'xlink': 'http://www.w3.org/1999/xlink', 'svg': 'http://www.w3.org/2000/svg' });\r\nvar DomElementSchemaRegistry = (function (_super) {\r\n    __extends(DomElementSchemaRegistry, _super);\r\n    function DomElementSchemaRegistry() {\r\n        _super.apply(this, arguments);\r\n        this._protoElements = new Map();\r\n    }\r\n    DomElementSchemaRegistry.prototype._getProtoElement = function (tagName) {\r\n        var element = this._protoElements.get(tagName);\r\n        if (lang_1.isBlank(element)) {\r\n            var nsAndName = html_tags_1.splitNsName(tagName);\r\n            element = lang_1.isPresent(nsAndName[0]) ?\r\n                dom_adapter_1.DOM.createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) :\r\n                dom_adapter_1.DOM.createElement(nsAndName[1]);\r\n            this._protoElements.set(tagName, element);\r\n        }\r\n        return element;\r\n    };\r\n    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName) {\r\n        if (tagName.indexOf('-') !== -1) {\r\n            // can't tell now as we don't know which properties a custom element will get\r\n            // once it is instantiated\r\n            return true;\r\n        }\r\n        else {\r\n            var elm = this._getProtoElement(tagName);\r\n            return dom_adapter_1.DOM.hasProperty(elm, propName);\r\n        }\r\n    };\r\n    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) {\r\n        var mappedPropName = collection_1.StringMapWrapper.get(dom_adapter_1.DOM.attrToPropMap, propName);\r\n        return lang_1.isPresent(mappedPropName) ? mappedPropName : propName;\r\n    };\r\n    DomElementSchemaRegistry = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], DomElementSchemaRegistry);\r\n    return DomElementSchemaRegistry;\r\n})(element_schema_registry_1.ElementSchemaRegistry);\r\nexports.DomElementSchemaRegistry = DomElementSchemaRegistry;\r\n},{\"./element_schema_registry\":65,\"angular2/src/compiler/html_tags\":59,\"angular2/src/core/di\":117,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176,\"angular2/src/platform/dom/dom_adapter\":189}],65:[function(require,module,exports){\n'use strict';var ElementSchemaRegistry = (function () {\r\n    function ElementSchemaRegistry() {\r\n    }\r\n    ElementSchemaRegistry.prototype.hasProperty = function (tagName, propName) { return true; };\r\n    ElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return propName; };\r\n    return ElementSchemaRegistry;\r\n})();\r\nexports.ElementSchemaRegistry = ElementSchemaRegistry;\r\n},{}],66:[function(require,module,exports){\n'use strict';var collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar _EMPTY_ATTR_VALUE = '';\r\n// TODO: Can't use `const` here as\r\n// in Dart this is not transpiled into `final` yet...\r\nvar _SELECTOR_REGEXP = lang_1.RegExpWrapper.create('(\\\\:not\\\\()|' +\r\n    '([-\\\\w]+)|' +\r\n    '(?:\\\\.([-\\\\w]+))|' +\r\n    '(?:\\\\[([-\\\\w*]+)(?:=([^\\\\]]*))?\\\\])|' +\r\n    '(\\\\))|' +\r\n    '(\\\\s*,\\\\s*)'); // \",\"\r\n/**\r\n * A css selector contains an element name,\r\n * css classes and attribute/value pairs with the purpose\r\n * of selecting subsets out of them.\r\n */\r\nvar CssSelector = (function () {\r\n    function CssSelector() {\r\n        this.element = null;\r\n        this.classNames = [];\r\n        this.attrs = [];\r\n        this.notSelectors = [];\r\n    }\r\n    CssSelector.parse = function (selector) {\r\n        var results = [];\r\n        var _addResult = function (res, cssSel) {\r\n            if (cssSel.notSelectors.length > 0 && lang_1.isBlank(cssSel.element) &&\r\n                collection_1.ListWrapper.isEmpty(cssSel.classNames) && collection_1.ListWrapper.isEmpty(cssSel.attrs)) {\r\n                cssSel.element = \"*\";\r\n            }\r\n            res.push(cssSel);\r\n        };\r\n        var cssSelector = new CssSelector();\r\n        var matcher = lang_1.RegExpWrapper.matcher(_SELECTOR_REGEXP, selector);\r\n        var match;\r\n        var current = cssSelector;\r\n        var inNot = false;\r\n        while (lang_1.isPresent(match = lang_1.RegExpMatcherWrapper.next(matcher))) {\r\n            if (lang_1.isPresent(match[1])) {\r\n                if (inNot) {\r\n                    throw new exceptions_1.BaseException('Nesting :not is not allowed in a selector');\r\n                }\r\n                inNot = true;\r\n                current = new CssSelector();\r\n                cssSelector.notSelectors.push(current);\r\n            }\r\n            if (lang_1.isPresent(match[2])) {\r\n                current.setElement(match[2]);\r\n            }\r\n            if (lang_1.isPresent(match[3])) {\r\n                current.addClassName(match[3]);\r\n            }\r\n            if (lang_1.isPresent(match[4])) {\r\n                current.addAttribute(match[4], match[5]);\r\n            }\r\n            if (lang_1.isPresent(match[6])) {\r\n                inNot = false;\r\n                current = cssSelector;\r\n            }\r\n            if (lang_1.isPresent(match[7])) {\r\n                if (inNot) {\r\n                    throw new exceptions_1.BaseException('Multiple selectors in :not are not supported');\r\n                }\r\n                _addResult(results, cssSelector);\r\n                cssSelector = current = new CssSelector();\r\n            }\r\n        }\r\n        _addResult(results, cssSelector);\r\n        return results;\r\n    };\r\n    CssSelector.prototype.isElementSelector = function () {\r\n        return lang_1.isPresent(this.element) && collection_1.ListWrapper.isEmpty(this.classNames) &&\r\n            collection_1.ListWrapper.isEmpty(this.attrs) && this.notSelectors.length === 0;\r\n    };\r\n    CssSelector.prototype.setElement = function (element) {\r\n        if (element === void 0) { element = null; }\r\n        this.element = element;\r\n    };\r\n    /** Gets a template string for an element that matches the selector. */\r\n    CssSelector.prototype.getMatchingElementTemplate = function () {\r\n        var tagName = lang_1.isPresent(this.element) ? this.element : 'div';\r\n        var classAttr = this.classNames.length > 0 ? \" class=\\\"\" + this.classNames.join(' ') + \"\\\"\" : '';\r\n        var attrs = '';\r\n        for (var i = 0; i < this.attrs.length; i += 2) {\r\n            var attrName = this.attrs[i];\r\n            var attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\" + this.attrs[i + 1] + \"\\\"\" : '';\r\n            attrs += \" \" + attrName + attrValue;\r\n        }\r\n        return \"<\" + tagName + classAttr + attrs + \"></\" + tagName + \">\";\r\n    };\r\n    CssSelector.prototype.addAttribute = function (name, value) {\r\n        if (value === void 0) { value = _EMPTY_ATTR_VALUE; }\r\n        this.attrs.push(name);\r\n        if (lang_1.isPresent(value)) {\r\n            value = value.toLowerCase();\r\n        }\r\n        else {\r\n            value = _EMPTY_ATTR_VALUE;\r\n        }\r\n        this.attrs.push(value);\r\n    };\r\n    CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };\r\n    CssSelector.prototype.toString = function () {\r\n        var res = '';\r\n        if (lang_1.isPresent(this.element)) {\r\n            res += this.element;\r\n        }\r\n        if (lang_1.isPresent(this.classNames)) {\r\n            for (var i = 0; i < this.classNames.length; i++) {\r\n                res += '.' + this.classNames[i];\r\n            }\r\n        }\r\n        if (lang_1.isPresent(this.attrs)) {\r\n            for (var i = 0; i < this.attrs.length;) {\r\n                var attrName = this.attrs[i++];\r\n                var attrValue = this.attrs[i++];\r\n                res += '[' + attrName;\r\n                if (attrValue.length > 0) {\r\n                    res += '=' + attrValue;\r\n                }\r\n                res += ']';\r\n            }\r\n        }\r\n        this.notSelectors.forEach(function (notSelector) { return res += \":not(\" + notSelector + \")\"; });\r\n        return res;\r\n    };\r\n    return CssSelector;\r\n})();\r\nexports.CssSelector = CssSelector;\r\n/**\r\n * Reads a list of CssSelectors and allows to calculate which ones\r\n * are contained in a given CssSelector.\r\n */\r\nvar SelectorMatcher = (function () {\r\n    function SelectorMatcher() {\r\n        this._elementMap = new collection_1.Map();\r\n        this._elementPartialMap = new collection_1.Map();\r\n        this._classMap = new collection_1.Map();\r\n        this._classPartialMap = new collection_1.Map();\r\n        this._attrValueMap = new collection_1.Map();\r\n        this._attrValuePartialMap = new collection_1.Map();\r\n        this._listContexts = [];\r\n    }\r\n    SelectorMatcher.createNotMatcher = function (notSelectors) {\r\n        var notMatcher = new SelectorMatcher();\r\n        notMatcher.addSelectables(notSelectors, null);\r\n        return notMatcher;\r\n    };\r\n    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {\r\n        var listContext = null;\r\n        if (cssSelectors.length > 1) {\r\n            listContext = new SelectorListContext(cssSelectors);\r\n            this._listContexts.push(listContext);\r\n        }\r\n        for (var i = 0; i < cssSelectors.length; i++) {\r\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\r\n        }\r\n    };\r\n    /**\r\n     * Add an object that can be found later on by calling `match`.\r\n     * @param cssSelector A css selector\r\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\r\n     */\r\n    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {\r\n        var matcher = this;\r\n        var element = cssSelector.element;\r\n        var classNames = cssSelector.classNames;\r\n        var attrs = cssSelector.attrs;\r\n        var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\r\n        if (lang_1.isPresent(element)) {\r\n            var isTerminal = attrs.length === 0 && classNames.length === 0;\r\n            if (isTerminal) {\r\n                this._addTerminal(matcher._elementMap, element, selectable);\r\n            }\r\n            else {\r\n                matcher = this._addPartial(matcher._elementPartialMap, element);\r\n            }\r\n        }\r\n        if (lang_1.isPresent(classNames)) {\r\n            for (var index = 0; index < classNames.length; index++) {\r\n                var isTerminal = attrs.length === 0 && index === classNames.length - 1;\r\n                var className = classNames[index];\r\n                if (isTerminal) {\r\n                    this._addTerminal(matcher._classMap, className, selectable);\r\n                }\r\n                else {\r\n                    matcher = this._addPartial(matcher._classPartialMap, className);\r\n                }\r\n            }\r\n        }\r\n        if (lang_1.isPresent(attrs)) {\r\n            for (var index = 0; index < attrs.length;) {\r\n                var isTerminal = index === attrs.length - 2;\r\n                var attrName = attrs[index++];\r\n                var attrValue = attrs[index++];\r\n                if (isTerminal) {\r\n                    var terminalMap = matcher._attrValueMap;\r\n                    var terminalValuesMap = terminalMap.get(attrName);\r\n                    if (lang_1.isBlank(terminalValuesMap)) {\r\n                        terminalValuesMap = new collection_1.Map();\r\n                        terminalMap.set(attrName, terminalValuesMap);\r\n                    }\r\n                    this._addTerminal(terminalValuesMap, attrValue, selectable);\r\n                }\r\n                else {\r\n                    var parttialMap = matcher._attrValuePartialMap;\r\n                    var partialValuesMap = parttialMap.get(attrName);\r\n                    if (lang_1.isBlank(partialValuesMap)) {\r\n                        partialValuesMap = new collection_1.Map();\r\n                        parttialMap.set(attrName, partialValuesMap);\r\n                    }\r\n                    matcher = this._addPartial(partialValuesMap, attrValue);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {\r\n        var terminalList = map.get(name);\r\n        if (lang_1.isBlank(terminalList)) {\r\n            terminalList = [];\r\n            map.set(name, terminalList);\r\n        }\r\n        terminalList.push(selectable);\r\n    };\r\n    SelectorMatcher.prototype._addPartial = function (map, name) {\r\n        var matcher = map.get(name);\r\n        if (lang_1.isBlank(matcher)) {\r\n            matcher = new SelectorMatcher();\r\n            map.set(name, matcher);\r\n        }\r\n        return matcher;\r\n    };\r\n    /**\r\n     * Find the objects that have been added via `addSelectable`\r\n     * whose css selector is contained in the given css selector.\r\n     * @param cssSelector A css selector\r\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\r\n     * @return boolean true if a match was found\r\n    */\r\n    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {\r\n        var result = false;\r\n        var element = cssSelector.element;\r\n        var classNames = cssSelector.classNames;\r\n        var attrs = cssSelector.attrs;\r\n        for (var i = 0; i < this._listContexts.length; i++) {\r\n            this._listContexts[i].alreadyMatched = false;\r\n        }\r\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\r\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\r\n            result;\r\n        if (lang_1.isPresent(classNames)) {\r\n            for (var index = 0; index < classNames.length; index++) {\r\n                var className = classNames[index];\r\n                result =\r\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\r\n                result =\r\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\r\n                        result;\r\n            }\r\n        }\r\n        if (lang_1.isPresent(attrs)) {\r\n            for (var index = 0; index < attrs.length;) {\r\n                var attrName = attrs[index++];\r\n                var attrValue = attrs[index++];\r\n                var terminalValuesMap = this._attrValueMap.get(attrName);\r\n                if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {\r\n                    result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) ||\r\n                        result;\r\n                }\r\n                result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) ||\r\n                    result;\r\n                var partialValuesMap = this._attrValuePartialMap.get(attrName);\r\n                if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {\r\n                    result = this._matchPartial(partialValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) ||\r\n                        result;\r\n                }\r\n                result =\r\n                    this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    /** @internal */\r\n    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {\r\n        if (lang_1.isBlank(map) || lang_1.isBlank(name)) {\r\n            return false;\r\n        }\r\n        var selectables = map.get(name);\r\n        var starSelectables = map.get(\"*\");\r\n        if (lang_1.isPresent(starSelectables)) {\r\n            selectables = selectables.concat(starSelectables);\r\n        }\r\n        if (lang_1.isBlank(selectables)) {\r\n            return false;\r\n        }\r\n        var selectable;\r\n        var result = false;\r\n        for (var index = 0; index < selectables.length; index++) {\r\n            selectable = selectables[index];\r\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\r\n        }\r\n        return result;\r\n    };\r\n    /** @internal */\r\n    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback /*: (c: CssSelector, a: any) => void*/) {\r\n        if (lang_1.isBlank(map) || lang_1.isBlank(name)) {\r\n            return false;\r\n        }\r\n        var nestedSelector = map.get(name);\r\n        if (lang_1.isBlank(nestedSelector)) {\r\n            return false;\r\n        }\r\n        // TODO(perf): get rid of recursion and measure again\r\n        // TODO(perf): don't pass the whole selector into the recursion,\r\n        // but only the not processed parts\r\n        return nestedSelector.match(cssSelector, matchedCallback);\r\n    };\r\n    return SelectorMatcher;\r\n})();\r\nexports.SelectorMatcher = SelectorMatcher;\r\nvar SelectorListContext = (function () {\r\n    function SelectorListContext(selectors) {\r\n        this.selectors = selectors;\r\n        this.alreadyMatched = false;\r\n    }\r\n    return SelectorListContext;\r\n})();\r\nexports.SelectorListContext = SelectorListContext;\r\n// Store context to pass back selector and context when a selector is matched\r\nvar SelectorContext = (function () {\r\n    function SelectorContext(selector, cbContext, listContext) {\r\n        this.selector = selector;\r\n        this.cbContext = cbContext;\r\n        this.listContext = listContext;\r\n        this.notSelectors = selector.notSelectors;\r\n    }\r\n    SelectorContext.prototype.finalize = function (cssSelector, callback) {\r\n        var result = true;\r\n        if (this.notSelectors.length > 0 &&\r\n            (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {\r\n            var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\r\n            result = !notMatcher.match(cssSelector, null);\r\n        }\r\n        if (result && lang_1.isPresent(callback) &&\r\n            (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {\r\n            if (lang_1.isPresent(this.listContext)) {\r\n                this.listContext.alreadyMatched = true;\r\n            }\r\n            callback(this.selector, this.cbContext);\r\n        }\r\n        return result;\r\n    };\r\n    return SelectorContext;\r\n})();\r\nexports.SelectorContext = SelectorContext;\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],67:[function(require,module,exports){\n'use strict';var collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\r\n *\r\n * Please make sure to keep to edits in sync with the source file.\r\n *\r\n * Source:\r\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\r\n *\r\n * The original file level comment is reproduced below\r\n */\r\n/*\r\n  This is a limited shim for ShadowDOM css styling.\r\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\r\n\r\n  The intention here is to support only the styling features which can be\r\n  relatively simply implemented. The goal is to allow users to avoid the\r\n  most obvious pitfalls and do so without compromising performance significantly.\r\n  For ShadowDOM styling that's not covered here, a set of best practices\r\n  can be provided that should allow users to accomplish more complex styling.\r\n\r\n  The following is a list of specific ShadowDOM styling features and a brief\r\n  discussion of the approach used to shim.\r\n\r\n  Shimmed features:\r\n\r\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\r\n  element using the :host rule. To shim this feature, the :host styles are\r\n  reformatted and prefixed with a given scope name and promoted to a\r\n  document level stylesheet.\r\n  For example, given a scope name of .foo, a rule like this:\r\n\r\n    :host {\r\n        background: red;\r\n      }\r\n    }\r\n\r\n  becomes:\r\n\r\n    .foo {\r\n      background: red;\r\n    }\r\n\r\n  * encapsultion: Styles defined within ShadowDOM, apply only to\r\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\r\n  this feature.\r\n\r\n  By default, rules are prefixed with the host element tag name\r\n  as a descendant selector. This ensures styling does not leak out of the 'top'\r\n  of the element's ShadowDOM. For example,\r\n\r\n  div {\r\n      font-weight: bold;\r\n    }\r\n\r\n  becomes:\r\n\r\n  x-foo div {\r\n      font-weight: bold;\r\n    }\r\n\r\n  becomes:\r\n\r\n\r\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\r\n  selectors are scoped by adding an attribute selector suffix to each\r\n  simple selector that contains the host element tag name. Each element\r\n  in the element's ShadowDOM template is also given the scope attribute.\r\n  Thus, these rules match only elements that have the scope attribute.\r\n  For example, given a scope name of x-foo, a rule like this:\r\n\r\n    div {\r\n      font-weight: bold;\r\n    }\r\n\r\n  becomes:\r\n\r\n    div[x-foo] {\r\n      font-weight: bold;\r\n    }\r\n\r\n  Note that elements that are dynamically added to a scope must have the scope\r\n  selector added to them manually.\r\n\r\n  * upper/lower bound encapsulation: Styles which are defined outside a\r\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\r\n  inside a shadowRoot.\r\n\r\n  This styling behavior is not emulated. Some possible ways to do this that\r\n  were rejected due to complexity and/or performance concerns include: (1) reset\r\n  every possible property for every possible selector for a given scope name;\r\n  (2) re-implement css in javascript.\r\n\r\n  As an alternative, users should make sure to use selectors\r\n  specific to the scope in which they are working.\r\n\r\n  * ::distributed: This behavior is not emulated. It's often not necessary\r\n  to style the contents of a specific insertion point and instead, descendants\r\n  of the host element can be styled selectively. Users can also create an\r\n  extra node around an insertion point and style that node's contents\r\n  via descendent selectors. For example, with a shadowRoot like this:\r\n\r\n    <style>\r\n      ::content(div) {\r\n        background: red;\r\n      }\r\n    </style>\r\n    <content></content>\r\n\r\n  could become:\r\n\r\n    <style>\r\n      / *@polyfill .content-container div * /\r\n      ::content(div) {\r\n        background: red;\r\n      }\r\n    </style>\r\n    <div class=\"content-container\">\r\n      <content></content>\r\n    </div>\r\n\r\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\r\n  declaration. This is a directive to the styling shim to use the selector\r\n  in comments in lieu of the next selector when running under polyfill.\r\n*/\r\nvar ShadowCss = (function () {\r\n    function ShadowCss() {\r\n        this.strictStyling = true;\r\n    }\r\n    /*\r\n    * Shim some cssText with the given selector. Returns cssText that can\r\n    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\r\n    *\r\n    * When strictStyling is true:\r\n    * - selector is the attribute added to all elements inside the host,\r\n    * - hostSelector is the attribute added to the host itself.\r\n    */\r\n    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {\r\n        if (hostSelector === void 0) { hostSelector = ''; }\r\n        cssText = stripComments(cssText);\r\n        cssText = this._insertDirectives(cssText);\r\n        return this._scopeCssText(cssText, selector, hostSelector);\r\n    };\r\n    ShadowCss.prototype._insertDirectives = function (cssText) {\r\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\r\n        return this._insertPolyfillRulesInCssText(cssText);\r\n    };\r\n    /*\r\n     * Process styles to convert native ShadowDOM rules that will trip\r\n     * up the css parser; we rely on decorating the stylesheet with inert rules.\r\n     *\r\n     * For example, we convert this rule:\r\n     *\r\n     * polyfill-next-selector { content: ':host menu-item'; }\r\n     * ::content menu-item {\r\n     *\r\n     * to this:\r\n     *\r\n     * scopeName menu-item {\r\n     *\r\n    **/\r\n    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {\r\n        // Difference with webcomponents.js: does not handle comments\r\n        return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function (m) { return m[1] + '{'; });\r\n    };\r\n    /*\r\n     * Process styles to add rules which will only apply under the polyfill\r\n     *\r\n     * For example, we convert this rule:\r\n     *\r\n     * polyfill-rule {\r\n     *   content: ':host menu-item';\r\n     * ...\r\n     * }\r\n     *\r\n     * to this:\r\n     *\r\n     * scopeName menu-item {...}\r\n     *\r\n    **/\r\n    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {\r\n        // Difference with webcomponents.js: does not handle comments\r\n        return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function (m) {\r\n            var rule = m[0];\r\n            rule = lang_1.StringWrapper.replace(rule, m[1], '');\r\n            rule = lang_1.StringWrapper.replace(rule, m[2], '');\r\n            return m[3] + rule;\r\n        });\r\n    };\r\n    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\r\n     *\r\n     *  .foo {... }\r\n     *\r\n     *  and converts this to\r\n     *\r\n     *  scopeName .foo { ... }\r\n    */\r\n    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {\r\n        var unscoped = this._extractUnscopedRulesFromCssText(cssText);\r\n        cssText = this._insertPolyfillHostInCssText(cssText);\r\n        cssText = this._convertColonHost(cssText);\r\n        cssText = this._convertColonHostContext(cssText);\r\n        cssText = this._convertShadowDOMSelectors(cssText);\r\n        if (lang_1.isPresent(scopeSelector)) {\r\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\r\n        }\r\n        cssText = cssText + '\\n' + unscoped;\r\n        return cssText.trim();\r\n    };\r\n    /*\r\n     * Process styles to add rules which will only apply under the polyfill\r\n     * and do not process via CSSOM. (CSSOM is destructive to rules on rare\r\n     * occasions, e.g. -webkit-calc on Safari.)\r\n     * For example, we convert this rule:\r\n     *\r\n     * @polyfill-unscoped-rule {\r\n     *   content: 'menu-item';\r\n     * ... }\r\n     *\r\n     * to this:\r\n     *\r\n     * menu-item {...}\r\n     *\r\n    **/\r\n    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {\r\n        // Difference with webcomponents.js: does not handle comments\r\n        var r = '', m;\r\n        var matcher = lang_1.RegExpWrapper.matcher(_cssContentUnscopedRuleRe, cssText);\r\n        while (lang_1.isPresent(m = lang_1.RegExpMatcherWrapper.next(matcher))) {\r\n            var rule = m[0];\r\n            rule = lang_1.StringWrapper.replace(rule, m[2], '');\r\n            rule = lang_1.StringWrapper.replace(rule, m[1], m[3]);\r\n            r += rule + '\\n\\n';\r\n        }\r\n        return r;\r\n    };\r\n    /*\r\n     * convert a rule like :host(.foo) > .bar { }\r\n     *\r\n     * to\r\n     *\r\n     * scopeName.foo > .bar\r\n    */\r\n    ShadowCss.prototype._convertColonHost = function (cssText) {\r\n        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\r\n    };\r\n    /*\r\n     * convert a rule like :host-context(.foo) > .bar { }\r\n     *\r\n     * to\r\n     *\r\n     * scopeName.foo > .bar, .foo scopeName > .bar { }\r\n     *\r\n     * and\r\n     *\r\n     * :host-context(.foo:host) .bar { ... }\r\n     *\r\n     * to\r\n     *\r\n     * scopeName.foo .bar { ... }\r\n    */\r\n    ShadowCss.prototype._convertColonHostContext = function (cssText) {\r\n        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\r\n    };\r\n    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {\r\n        // p1 = :host, p2 = contents of (), p3 rest of rule\r\n        return lang_1.StringWrapper.replaceAllMapped(cssText, regExp, function (m) {\r\n            if (lang_1.isPresent(m[2])) {\r\n                var parts = m[2].split(','), r = [];\r\n                for (var i = 0; i < parts.length; i++) {\r\n                    var p = parts[i];\r\n                    if (lang_1.isBlank(p))\r\n                        break;\r\n                    p = p.trim();\r\n                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\r\n                }\r\n                return r.join(',');\r\n            }\r\n            else {\r\n                return _polyfillHostNoCombinator + m[3];\r\n            }\r\n        });\r\n    };\r\n    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {\r\n        if (lang_1.StringWrapper.contains(part, _polyfillHost)) {\r\n            return this._colonHostPartReplacer(host, part, suffix);\r\n        }\r\n        else {\r\n            return host + part + suffix + ', ' + part + ' ' + host + suffix;\r\n        }\r\n    };\r\n    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {\r\n        return host + lang_1.StringWrapper.replace(part, _polyfillHost, '') + suffix;\r\n    };\r\n    /*\r\n     * Convert combinators like ::shadow and pseudo-elements like ::content\r\n     * by replacing with space.\r\n    */\r\n    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {\r\n        for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {\r\n            cssText = lang_1.StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');\r\n        }\r\n        return cssText;\r\n    };\r\n    // change a selector like 'div' to 'name div'\r\n    ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {\r\n        var _this = this;\r\n        return processRules(cssText, function (rule) {\r\n            var selector = rule.selector;\r\n            var content = rule.content;\r\n            if (rule.selector[0] != '@' || rule.selector.startsWith('@page')) {\r\n                selector =\r\n                    _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);\r\n            }\r\n            else if (rule.selector.startsWith('@media')) {\r\n                content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);\r\n            }\r\n            return new CssRule(selector, content);\r\n        });\r\n    };\r\n    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {\r\n        var r = [], parts = selector.split(',');\r\n        for (var i = 0; i < parts.length; i++) {\r\n            var p = parts[i];\r\n            p = p.trim();\r\n            if (this._selectorNeedsScoping(p, scopeSelector)) {\r\n                p = strict && !lang_1.StringWrapper.contains(p, _polyfillHostNoCombinator) ?\r\n                    this._applyStrictSelectorScope(p, scopeSelector) :\r\n                    this._applySelectorScope(p, scopeSelector, hostSelector);\r\n            }\r\n            r.push(p);\r\n        }\r\n        return r.join(', ');\r\n    };\r\n    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {\r\n        var re = this._makeScopeMatcher(scopeSelector);\r\n        return !lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(re, selector));\r\n    };\r\n    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {\r\n        var lre = /\\[/g;\r\n        var rre = /\\]/g;\r\n        scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, lre, '\\\\[');\r\n        scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, rre, '\\\\]');\r\n        return lang_1.RegExpWrapper.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\r\n    };\r\n    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {\r\n        // Difference from webcomponentsjs: scopeSelector could not be an array\r\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\r\n    };\r\n    // scope via name and [is=name]\r\n    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {\r\n        if (lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(_polyfillHostRe, selector))) {\r\n            var replaceBy = this.strictStyling ? \"[\" + hostSelector + \"]\" : scopeSelector;\r\n            selector = lang_1.StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);\r\n            return lang_1.StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');\r\n        }\r\n        else {\r\n            return scopeSelector + ' ' + selector;\r\n        }\r\n    };\r\n    // return a selector with [name] suffix on each simple selector\r\n    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\r\n    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector) {\r\n        var isRe = /\\[is=([^\\]]*)\\]/g;\r\n        scopeSelector = lang_1.StringWrapper.replaceAllMapped(scopeSelector, isRe, function (m) { return m[1]; });\r\n        var splits = [' ', '>', '+', '~'], scoped = selector, attrName = '[' + scopeSelector + ']';\r\n        for (var i = 0; i < splits.length; i++) {\r\n            var sep = splits[i];\r\n            var parts = scoped.split(sep);\r\n            scoped = parts.map(function (p) {\r\n                // remove :host since it should be unnecessary\r\n                var t = lang_1.StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');\r\n                if (t.length > 0 && !collection_1.ListWrapper.contains(splits, t) &&\r\n                    !lang_1.StringWrapper.contains(t, attrName)) {\r\n                    var re = /([^:]*)(:*)(.*)/g;\r\n                    var m = lang_1.RegExpWrapper.firstMatch(re, t);\r\n                    if (lang_1.isPresent(m)) {\r\n                        p = m[1] + attrName + m[2] + m[3];\r\n                    }\r\n                }\r\n                return p;\r\n            })\r\n                .join(sep);\r\n        }\r\n        return scoped;\r\n    };\r\n    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {\r\n        selector = lang_1.StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);\r\n        selector = lang_1.StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);\r\n        return selector;\r\n    };\r\n    return ShadowCss;\r\n})();\r\nexports.ShadowCss = ShadowCss;\r\nvar _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?['\"](.*?)['\"][;\\s]*}([^{]*?){/gim;\r\nvar _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim;\r\nvar _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim;\r\nvar _polyfillHost = '-shadowcsshost';\r\n// note: :host-context pre-processed to -shadowcsshostcontext.\r\nvar _polyfillHostContext = '-shadowcsscontext';\r\nvar _parenSuffix = ')(?:\\\\((' +\r\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\r\n    ')\\\\))?([^,{]*)';\r\nvar _cssColonHostRe = lang_1.RegExpWrapper.create('(' + _polyfillHost + _parenSuffix, 'im');\r\nvar _cssColonHostContextRe = lang_1.RegExpWrapper.create('(' + _polyfillHostContext + _parenSuffix, 'im');\r\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\r\nvar _shadowDOMSelectorsRe = [\r\n    />>>/g,\r\n    /::shadow/g,\r\n    /::content/g,\r\n    // Deprecated selectors\r\n    // TODO(vicb): see https://github.com/angular/clang-format/issues/16\r\n    // clang-format off\r\n    /\\/deep\\//g,\r\n    /\\/shadow-deep\\//g,\r\n    /\\/shadow\\//g,\r\n];\r\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\r\nvar _polyfillHostRe = lang_1.RegExpWrapper.create(_polyfillHost, 'im');\r\nvar _colonHostRe = /:host/gim;\r\nvar _colonHostContextRe = /:host-context/gim;\r\nvar _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\r\nfunction stripComments(input) {\r\n    return lang_1.StringWrapper.replaceAllMapped(input, _commentRe, function (_) { return ''; });\r\n}\r\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\r\nvar _curlyRe = /([{}])/g;\r\nvar OPEN_CURLY = '{';\r\nvar CLOSE_CURLY = '}';\r\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\r\nvar CssRule = (function () {\r\n    function CssRule(selector, content) {\r\n        this.selector = selector;\r\n        this.content = content;\r\n    }\r\n    return CssRule;\r\n})();\r\nexports.CssRule = CssRule;\r\nfunction processRules(input, ruleCallback) {\r\n    var inputWithEscapedBlocks = escapeBlocks(input);\r\n    var nextBlockIndex = 0;\r\n    return lang_1.StringWrapper.replaceAllMapped(inputWithEscapedBlocks.escapedString, _ruleRe, function (m) {\r\n        var selector = m[2];\r\n        var content = '';\r\n        var suffix = m[4];\r\n        var contentPrefix = '';\r\n        if (lang_1.isPresent(m[4]) && m[4].startsWith('{' + BLOCK_PLACEHOLDER)) {\r\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\r\n            suffix = m[4].substring(BLOCK_PLACEHOLDER.length + 1);\r\n            contentPrefix = '{';\r\n        }\r\n        var rule = ruleCallback(new CssRule(selector, content));\r\n        return \"\" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;\r\n    });\r\n}\r\nexports.processRules = processRules;\r\nvar StringWithEscapedBlocks = (function () {\r\n    function StringWithEscapedBlocks(escapedString, blocks) {\r\n        this.escapedString = escapedString;\r\n        this.blocks = blocks;\r\n    }\r\n    return StringWithEscapedBlocks;\r\n})();\r\nfunction escapeBlocks(input) {\r\n    var inputParts = lang_1.StringWrapper.split(input, _curlyRe);\r\n    var resultParts = [];\r\n    var escapedBlocks = [];\r\n    var bracketCount = 0;\r\n    var currentBlockParts = [];\r\n    for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {\r\n        var part = inputParts[partIndex];\r\n        if (part == CLOSE_CURLY) {\r\n            bracketCount--;\r\n        }\r\n        if (bracketCount > 0) {\r\n            currentBlockParts.push(part);\r\n        }\r\n        else {\r\n            if (currentBlockParts.length > 0) {\r\n                escapedBlocks.push(currentBlockParts.join(''));\r\n                resultParts.push(BLOCK_PLACEHOLDER);\r\n                currentBlockParts = [];\r\n            }\r\n            resultParts.push(part);\r\n        }\r\n        if (part == OPEN_CURLY) {\r\n            bracketCount++;\r\n        }\r\n    }\r\n    if (currentBlockParts.length > 0) {\r\n        escapedBlocks.push(currentBlockParts.join(''));\r\n        resultParts.push(BLOCK_PLACEHOLDER);\r\n    }\r\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\r\n}\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],68:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar MODULE_REGEXP = /#MODULE\\[([^\\]]*)\\]/g;\r\nfunction moduleRef(moduleUrl) {\r\n    return \"#MODULE[\" + moduleUrl + \"]\";\r\n}\r\nexports.moduleRef = moduleRef;\r\n/**\r\n * Represents generated source code with module references. Internal to the Angular compiler.\r\n */\r\nvar SourceModule = (function () {\r\n    function SourceModule(moduleUrl, sourceWithModuleRefs) {\r\n        this.moduleUrl = moduleUrl;\r\n        this.sourceWithModuleRefs = sourceWithModuleRefs;\r\n    }\r\n    SourceModule.getSourceWithoutImports = function (sourceWithModuleRefs) {\r\n        return lang_1.StringWrapper.replaceAllMapped(sourceWithModuleRefs, MODULE_REGEXP, function (match) { return ''; });\r\n    };\r\n    SourceModule.prototype.getSourceWithImports = function () {\r\n        var _this = this;\r\n        var moduleAliases = {};\r\n        var imports = [];\r\n        var newSource = lang_1.StringWrapper.replaceAllMapped(this.sourceWithModuleRefs, MODULE_REGEXP, function (match) {\r\n            var moduleUrl = match[1];\r\n            var alias = moduleAliases[moduleUrl];\r\n            if (lang_1.isBlank(alias)) {\r\n                if (moduleUrl == _this.moduleUrl) {\r\n                    alias = '';\r\n                }\r\n                else {\r\n                    alias = \"import\" + imports.length;\r\n                    imports.push([moduleUrl, alias]);\r\n                }\r\n                moduleAliases[moduleUrl] = alias;\r\n            }\r\n            return alias.length > 0 ? alias + \".\" : '';\r\n        });\r\n        return new SourceWithImports(newSource, imports);\r\n    };\r\n    return SourceModule;\r\n})();\r\nexports.SourceModule = SourceModule;\r\nvar SourceExpression = (function () {\r\n    function SourceExpression(declarations, expression) {\r\n        this.declarations = declarations;\r\n        this.expression = expression;\r\n    }\r\n    return SourceExpression;\r\n})();\r\nexports.SourceExpression = SourceExpression;\r\nvar SourceExpressions = (function () {\r\n    function SourceExpressions(declarations, expressions) {\r\n        this.declarations = declarations;\r\n        this.expressions = expressions;\r\n    }\r\n    return SourceExpressions;\r\n})();\r\nexports.SourceExpressions = SourceExpressions;\r\n/**\r\n * Represents generated source code with imports. Internal to the Angular compiler.\r\n */\r\nvar SourceWithImports = (function () {\r\n    function SourceWithImports(source, imports) {\r\n        this.source = source;\r\n        this.imports = imports;\r\n    }\r\n    return SourceWithImports;\r\n})();\r\nexports.SourceWithImports = SourceWithImports;\r\n},{\"angular2/src/facade/lang\":176}],69:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar source_module_1 = require('./source_module');\r\nvar view_1 = require('angular2/src/core/metadata/view');\r\nvar xhr_1 = require('angular2/src/compiler/xhr');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar shadow_css_1 = require('angular2/src/compiler/shadow_css');\r\nvar url_resolver_1 = require('angular2/src/compiler/url_resolver');\r\nvar style_url_resolver_1 = require('./style_url_resolver');\r\nvar util_1 = require('./util');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar COMPONENT_VARIABLE = '%COMP%';\r\nvar HOST_ATTR = \"_nghost-\" + COMPONENT_VARIABLE;\r\nvar CONTENT_ATTR = \"_ngcontent-\" + COMPONENT_VARIABLE;\r\nvar StyleCompiler = (function () {\r\n    function StyleCompiler(_xhr, _urlResolver) {\r\n        this._xhr = _xhr;\r\n        this._urlResolver = _urlResolver;\r\n        this._styleCache = new Map();\r\n        this._shadowCss = new shadow_css_1.ShadowCss();\r\n    }\r\n    StyleCompiler.prototype.compileComponentRuntime = function (template) {\r\n        var styles = template.styles;\r\n        var styleAbsUrls = template.styleUrls;\r\n        return this._loadStyles(styles, styleAbsUrls, template.encapsulation === view_1.ViewEncapsulation.Emulated);\r\n    };\r\n    StyleCompiler.prototype.compileComponentCodeGen = function (template) {\r\n        var shim = template.encapsulation === view_1.ViewEncapsulation.Emulated;\r\n        return this._styleCodeGen(template.styles, template.styleUrls, shim);\r\n    };\r\n    StyleCompiler.prototype.compileStylesheetCodeGen = function (stylesheetUrl, cssText) {\r\n        var styleWithImports = style_url_resolver_1.extractStyleUrls(this._urlResolver, stylesheetUrl, cssText);\r\n        return [\r\n            this._styleModule(stylesheetUrl, false, this._styleCodeGen([styleWithImports.style], styleWithImports.styleUrls, false)),\r\n            this._styleModule(stylesheetUrl, true, this._styleCodeGen([styleWithImports.style], styleWithImports.styleUrls, true))\r\n        ];\r\n    };\r\n    StyleCompiler.prototype.clearCache = function () { this._styleCache.clear(); };\r\n    StyleCompiler.prototype._loadStyles = function (plainStyles, absUrls, encapsulate) {\r\n        var _this = this;\r\n        var promises = absUrls.map(function (absUrl) {\r\n            var cacheKey = \"\" + absUrl + (encapsulate ? '.shim' : '');\r\n            var result = _this._styleCache.get(cacheKey);\r\n            if (lang_1.isBlank(result)) {\r\n                result = _this._xhr.get(absUrl).then(function (style) {\r\n                    var styleWithImports = style_url_resolver_1.extractStyleUrls(_this._urlResolver, absUrl, style);\r\n                    return _this._loadStyles([styleWithImports.style], styleWithImports.styleUrls, encapsulate);\r\n                });\r\n                _this._styleCache.set(cacheKey, result);\r\n            }\r\n            return result;\r\n        });\r\n        return async_1.PromiseWrapper.all(promises).then(function (nestedStyles) {\r\n            var result = plainStyles.map(function (plainStyle) { return _this._shimIfNeeded(plainStyle, encapsulate); });\r\n            nestedStyles.forEach(function (styles) { return result.push(styles); });\r\n            return result;\r\n        });\r\n    };\r\n    StyleCompiler.prototype._styleCodeGen = function (plainStyles, absUrls, shim) {\r\n        var _this = this;\r\n        var arrayPrefix = lang_1.IS_DART ? \"const\" : '';\r\n        var styleExpressions = plainStyles.map(function (plainStyle) { return util_1.escapeSingleQuoteString(_this._shimIfNeeded(plainStyle, shim)); });\r\n        for (var i = 0; i < absUrls.length; i++) {\r\n            var moduleUrl = this._createModuleUrl(absUrls[i], shim);\r\n            styleExpressions.push(source_module_1.moduleRef(moduleUrl) + \"STYLES\");\r\n        }\r\n        var expressionSource = arrayPrefix + \" [\" + styleExpressions.join(',') + \"]\";\r\n        return new source_module_1.SourceExpression([], expressionSource);\r\n    };\r\n    StyleCompiler.prototype._styleModule = function (stylesheetUrl, shim, expression) {\r\n        var moduleSource = \"\\n      \" + expression.declarations.join('\\n') + \"\\n      \" + util_1.codeGenExportVariable('STYLES') + expression.expression + \";\\n    \";\r\n        return new source_module_1.SourceModule(this._createModuleUrl(stylesheetUrl, shim), moduleSource);\r\n    };\r\n    StyleCompiler.prototype._shimIfNeeded = function (style, shim) {\r\n        return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;\r\n    };\r\n    StyleCompiler.prototype._createModuleUrl = function (stylesheetUrl, shim) {\r\n        return shim ? stylesheetUrl + \".shim\" + util_1.MODULE_SUFFIX : \"\" + stylesheetUrl + util_1.MODULE_SUFFIX;\r\n    };\r\n    StyleCompiler = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [xhr_1.XHR, url_resolver_1.UrlResolver])\r\n    ], StyleCompiler);\r\n    return StyleCompiler;\r\n})();\r\nexports.StyleCompiler = StyleCompiler;\r\n},{\"./source_module\":68,\"./style_url_resolver\":70,\"./util\":77,\"angular2/src/compiler/shadow_css\":67,\"angular2/src/compiler/url_resolver\":76,\"angular2/src/compiler/xhr\":79,\"angular2/src/core/di\":117,\"angular2/src/core/metadata/view\":149,\"angular2/src/facade/async\":169,\"angular2/src/facade/lang\":176}],70:[function(require,module,exports){\n'use strict';// Some of the code comes from WebComponents.JS\r\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar StyleWithImports = (function () {\r\n    function StyleWithImports(style, styleUrls) {\r\n        this.style = style;\r\n        this.styleUrls = styleUrls;\r\n    }\r\n    return StyleWithImports;\r\n})();\r\nexports.StyleWithImports = StyleWithImports;\r\nfunction isStyleUrlResolvable(url) {\r\n    if (lang_1.isBlank(url) || url.length === 0 || url[0] == '/')\r\n        return false;\r\n    var schemeMatch = lang_1.RegExpWrapper.firstMatch(_urlWithSchemaRe, url);\r\n    return lang_1.isBlank(schemeMatch) || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\r\n}\r\nexports.isStyleUrlResolvable = isStyleUrlResolvable;\r\n/**\r\n * Rewrites stylesheets by resolving and removing the @import urls that\r\n * are either relative or don't have a `package:` scheme\r\n */\r\nfunction extractStyleUrls(resolver, baseUrl, cssText) {\r\n    var foundUrls = [];\r\n    var modifiedCssText = lang_1.StringWrapper.replaceAllMapped(cssText, _cssImportRe, function (m) {\r\n        var url = lang_1.isPresent(m[1]) ? m[1] : m[2];\r\n        if (!isStyleUrlResolvable(url)) {\r\n            // Do not attempt to resolve non-package absolute URLs with URI scheme\r\n            return m[0];\r\n        }\r\n        foundUrls.push(resolver.resolve(baseUrl, url));\r\n        return '';\r\n    });\r\n    return new StyleWithImports(modifiedCssText, foundUrls);\r\n}\r\nexports.extractStyleUrls = extractStyleUrls;\r\nvar _cssImportRe = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\r\n// TODO: can't use /^[^:/?#.]+:/g due to clang-format bug:\r\n//       https://github.com/angular/angular/issues/4596\r\nvar _urlWithSchemaRe = /^([a-zA-Z\\-\\+\\.]+):/g;\r\n},{\"angular2/src/facade/lang\":176}],71:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * A segment of text within the template.\r\n */\r\nvar TextAst = (function () {\r\n    function TextAst(value, ngContentIndex, sourceSpan) {\r\n        this.value = value;\r\n        this.ngContentIndex = ngContentIndex;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\r\n    return TextAst;\r\n})();\r\nexports.TextAst = TextAst;\r\n/**\r\n * A bound expression within the text of a template.\r\n */\r\nvar BoundTextAst = (function () {\r\n    function BoundTextAst(value, ngContentIndex, sourceSpan) {\r\n        this.value = value;\r\n        this.ngContentIndex = ngContentIndex;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    BoundTextAst.prototype.visit = function (visitor, context) {\r\n        return visitor.visitBoundText(this, context);\r\n    };\r\n    return BoundTextAst;\r\n})();\r\nexports.BoundTextAst = BoundTextAst;\r\n/**\r\n * A plain attribute on an element.\r\n */\r\nvar AttrAst = (function () {\r\n    function AttrAst(name, value, sourceSpan) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };\r\n    return AttrAst;\r\n})();\r\nexports.AttrAst = AttrAst;\r\n/**\r\n * A binding for an element property (e.g. `[property]=\"expression\"`).\r\n */\r\nvar BoundElementPropertyAst = (function () {\r\n    function BoundElementPropertyAst(name, type, value, unit, sourceSpan) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.value = value;\r\n        this.unit = unit;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    BoundElementPropertyAst.prototype.visit = function (visitor, context) {\r\n        return visitor.visitElementProperty(this, context);\r\n    };\r\n    return BoundElementPropertyAst;\r\n})();\r\nexports.BoundElementPropertyAst = BoundElementPropertyAst;\r\n/**\r\n * A binding for an element event (e.g. `(event)=\"handler()\"`).\r\n */\r\nvar BoundEventAst = (function () {\r\n    function BoundEventAst(name, target, handler, sourceSpan) {\r\n        this.name = name;\r\n        this.target = target;\r\n        this.handler = handler;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    BoundEventAst.prototype.visit = function (visitor, context) {\r\n        return visitor.visitEvent(this, context);\r\n    };\r\n    Object.defineProperty(BoundEventAst.prototype, \"fullName\", {\r\n        get: function () {\r\n            if (lang_1.isPresent(this.target)) {\r\n                return this.target + \":\" + this.name;\r\n            }\r\n            else {\r\n                return this.name;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return BoundEventAst;\r\n})();\r\nexports.BoundEventAst = BoundEventAst;\r\n/**\r\n * A variable declaration on an element (e.g. `#var=\"expression\"`).\r\n */\r\nvar VariableAst = (function () {\r\n    function VariableAst(name, value, sourceSpan) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    VariableAst.prototype.visit = function (visitor, context) {\r\n        return visitor.visitVariable(this, context);\r\n    };\r\n    return VariableAst;\r\n})();\r\nexports.VariableAst = VariableAst;\r\n/**\r\n * An element declaration in a template.\r\n */\r\nvar ElementAst = (function () {\r\n    function ElementAst(name, attrs, inputs, outputs, exportAsVars, directives, children, ngContentIndex, sourceSpan) {\r\n        this.name = name;\r\n        this.attrs = attrs;\r\n        this.inputs = inputs;\r\n        this.outputs = outputs;\r\n        this.exportAsVars = exportAsVars;\r\n        this.directives = directives;\r\n        this.children = children;\r\n        this.ngContentIndex = ngContentIndex;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    ElementAst.prototype.visit = function (visitor, context) {\r\n        return visitor.visitElement(this, context);\r\n    };\r\n    /**\r\n     * Whether the element has any active bindings (inputs, outputs, vars, or directives).\r\n     */\r\n    ElementAst.prototype.isBound = function () {\r\n        return (this.inputs.length > 0 || this.outputs.length > 0 || this.exportAsVars.length > 0 ||\r\n            this.directives.length > 0);\r\n    };\r\n    /**\r\n     * Get the component associated with this element, if any.\r\n     */\r\n    ElementAst.prototype.getComponent = function () {\r\n        return this.directives.length > 0 && this.directives[0].directive.isComponent ?\r\n            this.directives[0].directive :\r\n            null;\r\n    };\r\n    return ElementAst;\r\n})();\r\nexports.ElementAst = ElementAst;\r\n/**\r\n * A `<template>` element included in an Angular template.\r\n */\r\nvar EmbeddedTemplateAst = (function () {\r\n    function EmbeddedTemplateAst(attrs, outputs, vars, directives, children, ngContentIndex, sourceSpan) {\r\n        this.attrs = attrs;\r\n        this.outputs = outputs;\r\n        this.vars = vars;\r\n        this.directives = directives;\r\n        this.children = children;\r\n        this.ngContentIndex = ngContentIndex;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {\r\n        return visitor.visitEmbeddedTemplate(this, context);\r\n    };\r\n    return EmbeddedTemplateAst;\r\n})();\r\nexports.EmbeddedTemplateAst = EmbeddedTemplateAst;\r\n/**\r\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\r\n */\r\nvar BoundDirectivePropertyAst = (function () {\r\n    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\r\n        this.directiveName = directiveName;\r\n        this.templateName = templateName;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {\r\n        return visitor.visitDirectiveProperty(this, context);\r\n    };\r\n    return BoundDirectivePropertyAst;\r\n})();\r\nexports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;\r\n/**\r\n * A directive declared on an element.\r\n */\r\nvar DirectiveAst = (function () {\r\n    function DirectiveAst(directive, inputs, hostProperties, hostEvents, exportAsVars, sourceSpan) {\r\n        this.directive = directive;\r\n        this.inputs = inputs;\r\n        this.hostProperties = hostProperties;\r\n        this.hostEvents = hostEvents;\r\n        this.exportAsVars = exportAsVars;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    DirectiveAst.prototype.visit = function (visitor, context) {\r\n        return visitor.visitDirective(this, context);\r\n    };\r\n    return DirectiveAst;\r\n})();\r\nexports.DirectiveAst = DirectiveAst;\r\n/**\r\n * Position where content is to be projected (instance of `<ng-content>` in a template).\r\n */\r\nvar NgContentAst = (function () {\r\n    function NgContentAst(index, ngContentIndex, sourceSpan) {\r\n        this.index = index;\r\n        this.ngContentIndex = ngContentIndex;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    NgContentAst.prototype.visit = function (visitor, context) {\r\n        return visitor.visitNgContent(this, context);\r\n    };\r\n    return NgContentAst;\r\n})();\r\nexports.NgContentAst = NgContentAst;\r\n/**\r\n * Enumeration of types of property bindings.\r\n */\r\n(function (PropertyBindingType) {\r\n    /**\r\n     * A normal binding to a property (e.g. `[property]=\"expression\"`).\r\n     */\r\n    PropertyBindingType[PropertyBindingType[\"Property\"] = 0] = \"Property\";\r\n    /**\r\n     * A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\r\n     */\r\n    PropertyBindingType[PropertyBindingType[\"Attribute\"] = 1] = \"Attribute\";\r\n    /**\r\n     * A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\r\n     */\r\n    PropertyBindingType[PropertyBindingType[\"Class\"] = 2] = \"Class\";\r\n    /**\r\n     * A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\r\n     */\r\n    PropertyBindingType[PropertyBindingType[\"Style\"] = 3] = \"Style\";\r\n})(exports.PropertyBindingType || (exports.PropertyBindingType = {}));\r\nvar PropertyBindingType = exports.PropertyBindingType;\r\n/**\r\n * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\r\n */\r\nfunction templateVisitAll(visitor, asts, context) {\r\n    if (context === void 0) { context = null; }\r\n    var result = [];\r\n    asts.forEach(function (ast) {\r\n        var astResult = ast.visit(visitor, context);\r\n        if (lang_1.isPresent(astResult)) {\r\n            result.push(astResult);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nexports.templateVisitAll = templateVisitAll;\r\n},{\"angular2/src/facade/lang\":176}],72:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar directive_metadata_1 = require('./directive_metadata');\r\nvar template_ast_1 = require('./template_ast');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar source_module_1 = require('./source_module');\r\nvar change_detector_compiler_1 = require('./change_detector_compiler');\r\nvar style_compiler_1 = require('./style_compiler');\r\nvar view_compiler_1 = require('./view_compiler');\r\nvar proto_view_compiler_1 = require('./proto_view_compiler');\r\nvar template_parser_1 = require('./template_parser');\r\nvar template_normalizer_1 = require('./template_normalizer');\r\nvar runtime_metadata_1 = require('./runtime_metadata');\r\nvar view_1 = require('angular2/src/core/linker/view');\r\nvar change_detection_1 = require('angular2/src/core/change_detection/change_detection');\r\nvar resolved_metadata_cache_1 = require('angular2/src/core/linker/resolved_metadata_cache');\r\nvar util_1 = require('./util');\r\nexports.METADATA_CACHE_MODULE_REF = source_module_1.moduleRef('package:angular2/src/core/linker/resolved_metadata_cache' + util_1.MODULE_SUFFIX);\r\n/**\r\n * An internal module of the Angular compiler that begins with component types,\r\n * extracts templates, and eventually produces a compiled version of the component\r\n * ready for linking into an application.\r\n */\r\nvar TemplateCompiler = (function () {\r\n    function TemplateCompiler(_runtimeMetadataResolver, _templateNormalizer, _templateParser, _styleCompiler, _cdCompiler, _protoViewCompiler, _viewCompiler, _resolvedMetadataCache, _genConfig) {\r\n        this._runtimeMetadataResolver = _runtimeMetadataResolver;\r\n        this._templateNormalizer = _templateNormalizer;\r\n        this._templateParser = _templateParser;\r\n        this._styleCompiler = _styleCompiler;\r\n        this._cdCompiler = _cdCompiler;\r\n        this._protoViewCompiler = _protoViewCompiler;\r\n        this._viewCompiler = _viewCompiler;\r\n        this._resolvedMetadataCache = _resolvedMetadataCache;\r\n        this._genConfig = _genConfig;\r\n        this._hostCacheKeys = new Map();\r\n        this._compiledTemplateCache = new Map();\r\n        this._compiledTemplateDone = new Map();\r\n    }\r\n    TemplateCompiler.prototype.normalizeDirectiveMetadata = function (directive) {\r\n        if (!directive.isComponent) {\r\n            // For non components there is nothing to be normalized yet.\r\n            return async_1.PromiseWrapper.resolve(directive);\r\n        }\r\n        return this._templateNormalizer.normalizeTemplate(directive.type, directive.template)\r\n            .then(function (normalizedTemplate) { return new directive_metadata_1.CompileDirectiveMetadata({\r\n            type: directive.type,\r\n            isComponent: directive.isComponent,\r\n            dynamicLoadable: directive.dynamicLoadable,\r\n            selector: directive.selector,\r\n            exportAs: directive.exportAs,\r\n            changeDetection: directive.changeDetection,\r\n            inputs: directive.inputs,\r\n            outputs: directive.outputs,\r\n            hostListeners: directive.hostListeners,\r\n            hostProperties: directive.hostProperties,\r\n            hostAttributes: directive.hostAttributes,\r\n            lifecycleHooks: directive.lifecycleHooks,\r\n            template: normalizedTemplate\r\n        }); });\r\n    };\r\n    TemplateCompiler.prototype.compileHostComponentRuntime = function (type) {\r\n        var compMeta = this._runtimeMetadataResolver.getDirectiveMetadata(type);\r\n        var hostCacheKey = this._hostCacheKeys.get(type);\r\n        if (lang_1.isBlank(hostCacheKey)) {\r\n            hostCacheKey = new Object();\r\n            this._hostCacheKeys.set(type, hostCacheKey);\r\n            assertComponent(compMeta);\r\n            var hostMeta = directive_metadata_1.createHostComponentMeta(compMeta.type, compMeta.selector);\r\n            this._compileComponentRuntime(hostCacheKey, hostMeta, [compMeta], [], new Set());\r\n        }\r\n        return this._compiledTemplateDone.get(hostCacheKey)\r\n            .then(function (compiledTemplate) {\r\n            return new view_1.HostViewFactory(compMeta.selector, compiledTemplate.viewFactory);\r\n        });\r\n    };\r\n    TemplateCompiler.prototype.clearCache = function () {\r\n        this._styleCompiler.clearCache();\r\n        this._compiledTemplateCache.clear();\r\n        this._compiledTemplateDone.clear();\r\n        this._hostCacheKeys.clear();\r\n    };\r\n    TemplateCompiler.prototype.compileTemplatesCodeGen = function (components) {\r\n        var _this = this;\r\n        if (components.length === 0) {\r\n            throw new exceptions_1.BaseException('No components given');\r\n        }\r\n        var declarations = [];\r\n        components.forEach(function (componentWithDirs) {\r\n            var compMeta = componentWithDirs.component;\r\n            assertComponent(compMeta);\r\n            _this._compileComponentCodeGen(compMeta, componentWithDirs.directives, componentWithDirs.pipes, declarations);\r\n            if (compMeta.dynamicLoadable) {\r\n                var hostMeta = directive_metadata_1.createHostComponentMeta(compMeta.type, compMeta.selector);\r\n                var viewFactoryExpression = _this._compileComponentCodeGen(hostMeta, [compMeta], [], declarations);\r\n                var constructionKeyword = lang_1.IS_DART ? 'const' : 'new';\r\n                var compiledTemplateExpr = constructionKeyword + \" \" + proto_view_compiler_1.APP_VIEW_MODULE_REF + \"HostViewFactory('\" + compMeta.selector + \"',\" + viewFactoryExpression + \")\";\r\n                var varName = codeGenHostViewFactoryName(compMeta.type);\r\n                declarations.push(\"\" + util_1.codeGenExportVariable(varName) + compiledTemplateExpr + \";\");\r\n            }\r\n        });\r\n        var moduleUrl = components[0].component.type.moduleUrl;\r\n        return new source_module_1.SourceModule(\"\" + templateModuleUrl(moduleUrl), declarations.join('\\n'));\r\n    };\r\n    TemplateCompiler.prototype.compileStylesheetCodeGen = function (stylesheetUrl, cssText) {\r\n        return this._styleCompiler.compileStylesheetCodeGen(stylesheetUrl, cssText);\r\n    };\r\n    TemplateCompiler.prototype._compileComponentRuntime = function (cacheKey, compMeta, viewDirectives, pipes, compilingComponentCacheKeys) {\r\n        var _this = this;\r\n        var uniqViewDirectives = removeDuplicates(viewDirectives);\r\n        var uniqViewPipes = removeDuplicates(pipes);\r\n        var compiledTemplate = this._compiledTemplateCache.get(cacheKey);\r\n        var done = this._compiledTemplateDone.get(cacheKey);\r\n        if (lang_1.isBlank(compiledTemplate)) {\r\n            compiledTemplate = new CompiledTemplate();\r\n            this._compiledTemplateCache.set(cacheKey, compiledTemplate);\r\n            compilingComponentCacheKeys.add(cacheKey);\r\n            done = async_1.PromiseWrapper\r\n                .all([this._styleCompiler.compileComponentRuntime(compMeta.template)].concat(uniqViewDirectives.map(function (dirMeta) { return _this.normalizeDirectiveMetadata(dirMeta); })))\r\n                .then(function (stylesAndNormalizedViewDirMetas) {\r\n                var normalizedViewDirMetas = stylesAndNormalizedViewDirMetas.slice(1);\r\n                var styles = stylesAndNormalizedViewDirMetas[0];\r\n                var parsedTemplate = _this._templateParser.parse(compMeta.template.template, normalizedViewDirMetas, uniqViewPipes, compMeta.type.name);\r\n                var childPromises = [];\r\n                var usedDirectives = DirectiveCollector.findUsedDirectives(parsedTemplate);\r\n                usedDirectives.components.forEach(function (component) { return _this._compileNestedComponentRuntime(component, compilingComponentCacheKeys, childPromises); });\r\n                return async_1.PromiseWrapper.all(childPromises)\r\n                    .then(function (_) {\r\n                    var filteredPipes = filterPipes(parsedTemplate, uniqViewPipes);\r\n                    compiledTemplate.init(_this._createViewFactoryRuntime(compMeta, parsedTemplate, usedDirectives.directives, styles, filteredPipes));\r\n                    collection_1.SetWrapper.delete(compilingComponentCacheKeys, cacheKey);\r\n                    return compiledTemplate;\r\n                });\r\n            });\r\n            this._compiledTemplateDone.set(cacheKey, done);\r\n        }\r\n        return compiledTemplate;\r\n    };\r\n    TemplateCompiler.prototype._compileNestedComponentRuntime = function (childComponentDir, compilingComponentCacheKeys, childPromises) {\r\n        var childCacheKey = childComponentDir.type.runtime;\r\n        var childViewDirectives = this._runtimeMetadataResolver.getViewDirectivesMetadata(childComponentDir.type.runtime);\r\n        var childViewPipes = this._runtimeMetadataResolver.getViewPipesMetadata(childComponentDir.type.runtime);\r\n        var childIsRecursive = collection_1.SetWrapper.has(compilingComponentCacheKeys, childCacheKey);\r\n        this._compileComponentRuntime(childCacheKey, childComponentDir, childViewDirectives, childViewPipes, compilingComponentCacheKeys);\r\n        if (!childIsRecursive) {\r\n            // Only wait for a child if it is not a cycle\r\n            childPromises.push(this._compiledTemplateDone.get(childCacheKey));\r\n        }\r\n    };\r\n    TemplateCompiler.prototype._createViewFactoryRuntime = function (compMeta, parsedTemplate, directives, styles, pipes) {\r\n        var _this = this;\r\n        if (lang_1.IS_DART || !this._genConfig.useJit) {\r\n            var changeDetectorFactories = this._cdCompiler.compileComponentRuntime(compMeta.type, compMeta.changeDetection, parsedTemplate);\r\n            var protoViews = this._protoViewCompiler.compileProtoViewRuntime(this._resolvedMetadataCache, compMeta, parsedTemplate, pipes);\r\n            return this._viewCompiler.compileComponentRuntime(compMeta, parsedTemplate, styles, protoViews.protoViews, changeDetectorFactories, function (compMeta) { return _this._getNestedComponentViewFactory(compMeta); });\r\n        }\r\n        else {\r\n            var declarations = [];\r\n            var viewFactoryExpr = this._createViewFactoryCodeGen('resolvedMetadataCache', compMeta, new source_module_1.SourceExpression([], 'styles'), parsedTemplate, pipes, declarations);\r\n            var vars = { 'exports': {}, 'styles': styles, 'resolvedMetadataCache': this._resolvedMetadataCache };\r\n            directives.forEach(function (dirMeta) {\r\n                vars[dirMeta.type.name] = dirMeta.type.runtime;\r\n                if (dirMeta.isComponent && dirMeta.type.runtime !== compMeta.type.runtime) {\r\n                    vars[(\"viewFactory_\" + dirMeta.type.name + \"0\")] = _this._getNestedComponentViewFactory(dirMeta);\r\n                }\r\n            });\r\n            pipes.forEach(function (pipeMeta) { return vars[pipeMeta.type.name] = pipeMeta.type.runtime; });\r\n            var declarationsWithoutImports = source_module_1.SourceModule.getSourceWithoutImports(declarations.join('\\n'));\r\n            return lang_1.evalExpression(\"viewFactory_\" + compMeta.type.name, viewFactoryExpr, declarationsWithoutImports, mergeStringMaps([vars, change_detector_compiler_1.CHANGE_DETECTION_JIT_IMPORTS, proto_view_compiler_1.PROTO_VIEW_JIT_IMPORTS, view_compiler_1.VIEW_JIT_IMPORTS]));\r\n        }\r\n    };\r\n    TemplateCompiler.prototype._getNestedComponentViewFactory = function (compMeta) {\r\n        return this._compiledTemplateCache.get(compMeta.type.runtime).viewFactory;\r\n    };\r\n    TemplateCompiler.prototype._compileComponentCodeGen = function (compMeta, directives, pipes, targetDeclarations) {\r\n        var uniqueDirectives = removeDuplicates(directives);\r\n        var uniqPipes = removeDuplicates(pipes);\r\n        var styleExpr = this._styleCompiler.compileComponentCodeGen(compMeta.template);\r\n        var parsedTemplate = this._templateParser.parse(compMeta.template.template, uniqueDirectives, uniqPipes, compMeta.type.name);\r\n        var filteredPipes = filterPipes(parsedTemplate, uniqPipes);\r\n        return this._createViewFactoryCodeGen(exports.METADATA_CACHE_MODULE_REF + \"CODEGEN_RESOLVED_METADATA_CACHE\", compMeta, styleExpr, parsedTemplate, filteredPipes, targetDeclarations);\r\n    };\r\n    TemplateCompiler.prototype._createViewFactoryCodeGen = function (resolvedMetadataCacheExpr, compMeta, styleExpr, parsedTemplate, pipes, targetDeclarations) {\r\n        var changeDetectorsExprs = this._cdCompiler.compileComponentCodeGen(compMeta.type, compMeta.changeDetection, parsedTemplate);\r\n        var protoViewExprs = this._protoViewCompiler.compileProtoViewCodeGen(new util_1.Expression(resolvedMetadataCacheExpr), compMeta, parsedTemplate, pipes);\r\n        var viewFactoryExpr = this._viewCompiler.compileComponentCodeGen(compMeta, parsedTemplate, styleExpr, protoViewExprs.protoViews, changeDetectorsExprs, codeGenComponentViewFactoryName);\r\n        util_1.addAll(changeDetectorsExprs.declarations, targetDeclarations);\r\n        util_1.addAll(protoViewExprs.declarations, targetDeclarations);\r\n        util_1.addAll(viewFactoryExpr.declarations, targetDeclarations);\r\n        return viewFactoryExpr.expression;\r\n    };\r\n    TemplateCompiler = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [runtime_metadata_1.RuntimeMetadataResolver, template_normalizer_1.TemplateNormalizer, template_parser_1.TemplateParser, style_compiler_1.StyleCompiler, change_detector_compiler_1.ChangeDetectionCompiler, proto_view_compiler_1.ProtoViewCompiler, view_compiler_1.ViewCompiler, resolved_metadata_cache_1.ResolvedMetadataCache, change_detection_1.ChangeDetectorGenConfig])\r\n    ], TemplateCompiler);\r\n    return TemplateCompiler;\r\n})();\r\nexports.TemplateCompiler = TemplateCompiler;\r\nvar NormalizedComponentWithViewDirectives = (function () {\r\n    function NormalizedComponentWithViewDirectives(component, directives, pipes) {\r\n        this.component = component;\r\n        this.directives = directives;\r\n        this.pipes = pipes;\r\n    }\r\n    return NormalizedComponentWithViewDirectives;\r\n})();\r\nexports.NormalizedComponentWithViewDirectives = NormalizedComponentWithViewDirectives;\r\nvar CompiledTemplate = (function () {\r\n    function CompiledTemplate() {\r\n        this.viewFactory = null;\r\n    }\r\n    CompiledTemplate.prototype.init = function (viewFactory) { this.viewFactory = viewFactory; };\r\n    return CompiledTemplate;\r\n})();\r\nfunction assertComponent(meta) {\r\n    if (!meta.isComponent) {\r\n        throw new exceptions_1.BaseException(\"Could not compile '\" + meta.type.name + \"' because it is not a component.\");\r\n    }\r\n}\r\nfunction templateModuleUrl(moduleUrl) {\r\n    var urlWithoutSuffix = moduleUrl.substring(0, moduleUrl.length - util_1.MODULE_SUFFIX.length);\r\n    return urlWithoutSuffix + \".template\" + util_1.MODULE_SUFFIX;\r\n}\r\nfunction codeGenHostViewFactoryName(type) {\r\n    return \"hostViewFactory_\" + type.name;\r\n}\r\nfunction codeGenComponentViewFactoryName(nestedCompType) {\r\n    return source_module_1.moduleRef(templateModuleUrl(nestedCompType.type.moduleUrl)) + \"viewFactory_\" + nestedCompType.type.name + \"0\";\r\n}\r\nfunction mergeStringMaps(maps) {\r\n    var result = {};\r\n    maps.forEach(function (map) { collection_1.StringMapWrapper.forEach(map, function (value, key) { result[key] = value; }); });\r\n    return result;\r\n}\r\nfunction removeDuplicates(items) {\r\n    var res = [];\r\n    items.forEach(function (item) {\r\n        var hasMatch = res.filter(function (r) { return r.type.name == item.type.name && r.type.moduleUrl == item.type.moduleUrl &&\r\n            r.type.runtime == item.type.runtime; })\r\n            .length > 0;\r\n        if (!hasMatch) {\r\n            res.push(item);\r\n        }\r\n    });\r\n    return res;\r\n}\r\nvar DirectiveCollector = (function () {\r\n    function DirectiveCollector() {\r\n        this.directives = [];\r\n        this.components = [];\r\n    }\r\n    DirectiveCollector.findUsedDirectives = function (parsedTemplate) {\r\n        var collector = new DirectiveCollector();\r\n        template_ast_1.templateVisitAll(collector, parsedTemplate);\r\n        return collector;\r\n    };\r\n    DirectiveCollector.prototype.visitBoundText = function (ast, context) { return null; };\r\n    DirectiveCollector.prototype.visitText = function (ast, context) { return null; };\r\n    DirectiveCollector.prototype.visitNgContent = function (ast, context) { return null; };\r\n    DirectiveCollector.prototype.visitElement = function (ast, context) {\r\n        template_ast_1.templateVisitAll(this, ast.directives);\r\n        template_ast_1.templateVisitAll(this, ast.children);\r\n        return null;\r\n    };\r\n    DirectiveCollector.prototype.visitEmbeddedTemplate = function (ast, context) {\r\n        template_ast_1.templateVisitAll(this, ast.directives);\r\n        template_ast_1.templateVisitAll(this, ast.children);\r\n        return null;\r\n    };\r\n    DirectiveCollector.prototype.visitVariable = function (ast, ctx) { return null; };\r\n    DirectiveCollector.prototype.visitAttr = function (ast, attrNameAndValues) { return null; };\r\n    DirectiveCollector.prototype.visitDirective = function (ast, ctx) {\r\n        if (ast.directive.isComponent) {\r\n            this.components.push(ast.directive);\r\n        }\r\n        this.directives.push(ast.directive);\r\n        return null;\r\n    };\r\n    DirectiveCollector.prototype.visitEvent = function (ast, eventTargetAndNames) {\r\n        return null;\r\n    };\r\n    DirectiveCollector.prototype.visitDirectiveProperty = function (ast, context) { return null; };\r\n    DirectiveCollector.prototype.visitElementProperty = function (ast, context) { return null; };\r\n    return DirectiveCollector;\r\n})();\r\nfunction filterPipes(template, allPipes) {\r\n    var visitor = new PipeVisitor();\r\n    template_ast_1.templateVisitAll(visitor, template);\r\n    return allPipes.filter(function (pipeMeta) { return collection_1.SetWrapper.has(visitor.collector.pipes, pipeMeta.name); });\r\n}\r\nvar PipeVisitor = (function () {\r\n    function PipeVisitor() {\r\n        this.collector = new template_parser_1.PipeCollector();\r\n    }\r\n    PipeVisitor.prototype.visitBoundText = function (ast, context) {\r\n        ast.value.visit(this.collector);\r\n        return null;\r\n    };\r\n    PipeVisitor.prototype.visitText = function (ast, context) { return null; };\r\n    PipeVisitor.prototype.visitNgContent = function (ast, context) { return null; };\r\n    PipeVisitor.prototype.visitElement = function (ast, context) {\r\n        template_ast_1.templateVisitAll(this, ast.inputs);\r\n        template_ast_1.templateVisitAll(this, ast.outputs);\r\n        template_ast_1.templateVisitAll(this, ast.directives);\r\n        template_ast_1.templateVisitAll(this, ast.children);\r\n        return null;\r\n    };\r\n    PipeVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {\r\n        template_ast_1.templateVisitAll(this, ast.outputs);\r\n        template_ast_1.templateVisitAll(this, ast.directives);\r\n        template_ast_1.templateVisitAll(this, ast.children);\r\n        return null;\r\n    };\r\n    PipeVisitor.prototype.visitVariable = function (ast, ctx) { return null; };\r\n    PipeVisitor.prototype.visitAttr = function (ast, attrNameAndValues) { return null; };\r\n    PipeVisitor.prototype.visitDirective = function (ast, ctx) {\r\n        template_ast_1.templateVisitAll(this, ast.inputs);\r\n        template_ast_1.templateVisitAll(this, ast.hostEvents);\r\n        template_ast_1.templateVisitAll(this, ast.hostProperties);\r\n        return null;\r\n    };\r\n    PipeVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {\r\n        ast.handler.visit(this.collector);\r\n        return null;\r\n    };\r\n    PipeVisitor.prototype.visitDirectiveProperty = function (ast, context) {\r\n        ast.value.visit(this.collector);\r\n        return null;\r\n    };\r\n    PipeVisitor.prototype.visitElementProperty = function (ast, context) {\r\n        ast.value.visit(this.collector);\r\n        return null;\r\n    };\r\n    return PipeVisitor;\r\n})();\r\n},{\"./change_detector_compiler\":53,\"./directive_metadata\":55,\"./proto_view_compiler\":61,\"./runtime_metadata\":63,\"./source_module\":68,\"./style_compiler\":69,\"./template_ast\":71,\"./template_normalizer\":73,\"./template_parser\":74,\"./util\":77,\"./view_compiler\":78,\"angular2/src/core/change_detection/change_detection\":87,\"angular2/src/core/di\":117,\"angular2/src/core/linker/resolved_metadata_cache\":137,\"angular2/src/core/linker/view\":139,\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],73:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar directive_metadata_1 = require('./directive_metadata');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar xhr_1 = require('angular2/src/compiler/xhr');\r\nvar url_resolver_1 = require('angular2/src/compiler/url_resolver');\r\nvar style_url_resolver_1 = require('./style_url_resolver');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar view_1 = require('angular2/src/core/metadata/view');\r\nvar html_ast_1 = require('./html_ast');\r\nvar html_parser_1 = require('./html_parser');\r\nvar template_preparser_1 = require('./template_preparser');\r\nvar TemplateNormalizer = (function () {\r\n    function TemplateNormalizer(_xhr, _urlResolver, _htmlParser) {\r\n        this._xhr = _xhr;\r\n        this._urlResolver = _urlResolver;\r\n        this._htmlParser = _htmlParser;\r\n    }\r\n    TemplateNormalizer.prototype.normalizeTemplate = function (directiveType, template) {\r\n        var _this = this;\r\n        if (lang_1.isPresent(template.template)) {\r\n            return async_1.PromiseWrapper.resolve(this.normalizeLoadedTemplate(directiveType, template, template.template, directiveType.moduleUrl));\r\n        }\r\n        else if (lang_1.isPresent(template.templateUrl)) {\r\n            var sourceAbsUrl = this._urlResolver.resolve(directiveType.moduleUrl, template.templateUrl);\r\n            return this._xhr.get(sourceAbsUrl)\r\n                .then(function (templateContent) { return _this.normalizeLoadedTemplate(directiveType, template, templateContent, sourceAbsUrl); });\r\n        }\r\n        else {\r\n            throw new exceptions_1.BaseException(\"No template specified for component \" + directiveType.name);\r\n        }\r\n    };\r\n    TemplateNormalizer.prototype.normalizeLoadedTemplate = function (directiveType, templateMeta, template, templateAbsUrl) {\r\n        var _this = this;\r\n        var rootNodesAndErrors = this._htmlParser.parse(template, directiveType.name);\r\n        if (rootNodesAndErrors.errors.length > 0) {\r\n            var errorString = rootNodesAndErrors.errors.join('\\n');\r\n            throw new exceptions_1.BaseException(\"Template parse errors:\\n\" + errorString);\r\n        }\r\n        var visitor = new TemplatePreparseVisitor();\r\n        html_ast_1.htmlVisitAll(visitor, rootNodesAndErrors.rootNodes);\r\n        var allStyles = templateMeta.styles.concat(visitor.styles);\r\n        var allStyleAbsUrls = visitor.styleUrls.filter(style_url_resolver_1.isStyleUrlResolvable)\r\n            .map(function (url) { return _this._urlResolver.resolve(templateAbsUrl, url); })\r\n            .concat(templateMeta.styleUrls.filter(style_url_resolver_1.isStyleUrlResolvable)\r\n            .map(function (url) { return _this._urlResolver.resolve(directiveType.moduleUrl, url); }));\r\n        var allResolvedStyles = allStyles.map(function (style) {\r\n            var styleWithImports = style_url_resolver_1.extractStyleUrls(_this._urlResolver, templateAbsUrl, style);\r\n            styleWithImports.styleUrls.forEach(function (styleUrl) { return allStyleAbsUrls.push(styleUrl); });\r\n            return styleWithImports.style;\r\n        });\r\n        var encapsulation = templateMeta.encapsulation;\r\n        if (encapsulation === view_1.ViewEncapsulation.Emulated && allResolvedStyles.length === 0 &&\r\n            allStyleAbsUrls.length === 0) {\r\n            encapsulation = view_1.ViewEncapsulation.None;\r\n        }\r\n        return new directive_metadata_1.CompileTemplateMetadata({\r\n            encapsulation: encapsulation,\r\n            template: template,\r\n            templateUrl: templateAbsUrl,\r\n            styles: allResolvedStyles,\r\n            styleUrls: allStyleAbsUrls,\r\n            ngContentSelectors: visitor.ngContentSelectors\r\n        });\r\n    };\r\n    TemplateNormalizer = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [xhr_1.XHR, url_resolver_1.UrlResolver, html_parser_1.HtmlParser])\r\n    ], TemplateNormalizer);\r\n    return TemplateNormalizer;\r\n})();\r\nexports.TemplateNormalizer = TemplateNormalizer;\r\nvar TemplatePreparseVisitor = (function () {\r\n    function TemplatePreparseVisitor() {\r\n        this.ngContentSelectors = [];\r\n        this.styles = [];\r\n        this.styleUrls = [];\r\n        this.ngNonBindableStackCount = 0;\r\n    }\r\n    TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {\r\n        var preparsedElement = template_preparser_1.preparseElement(ast);\r\n        switch (preparsedElement.type) {\r\n            case template_preparser_1.PreparsedElementType.NG_CONTENT:\r\n                if (this.ngNonBindableStackCount === 0) {\r\n                    this.ngContentSelectors.push(preparsedElement.selectAttr);\r\n                }\r\n                break;\r\n            case template_preparser_1.PreparsedElementType.STYLE:\r\n                var textContent = '';\r\n                ast.children.forEach(function (child) {\r\n                    if (child instanceof html_ast_1.HtmlTextAst) {\r\n                        textContent += child.value;\r\n                    }\r\n                });\r\n                this.styles.push(textContent);\r\n                break;\r\n            case template_preparser_1.PreparsedElementType.STYLESHEET:\r\n                this.styleUrls.push(preparsedElement.hrefAttr);\r\n                break;\r\n        }\r\n        if (preparsedElement.nonBindable) {\r\n            this.ngNonBindableStackCount++;\r\n        }\r\n        html_ast_1.htmlVisitAll(this, ast.children);\r\n        if (preparsedElement.nonBindable) {\r\n            this.ngNonBindableStackCount--;\r\n        }\r\n        return null;\r\n    };\r\n    TemplatePreparseVisitor.prototype.visitAttr = function (ast, context) { return null; };\r\n    TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };\r\n    return TemplatePreparseVisitor;\r\n})();\r\n},{\"./directive_metadata\":55,\"./html_ast\":56,\"./html_parser\":58,\"./style_url_resolver\":70,\"./template_preparser\":75,\"angular2/src/compiler/url_resolver\":76,\"angular2/src/compiler/xhr\":79,\"angular2/src/core/di\":117,\"angular2/src/core/metadata/view\":149,\"angular2/src/facade/async\":169,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],74:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar core_1 = require('angular2/core');\r\nvar lang_2 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar change_detection_1 = require('angular2/src/core/change_detection/change_detection');\r\nvar html_parser_1 = require('./html_parser');\r\nvar html_tags_1 = require('./html_tags');\r\nvar parse_util_1 = require('./parse_util');\r\nvar ast_1 = require('angular2/src/core/change_detection/parser/ast');\r\nvar template_ast_1 = require('./template_ast');\r\nvar selector_1 = require('angular2/src/compiler/selector');\r\nvar element_schema_registry_1 = require('angular2/src/compiler/schema/element_schema_registry');\r\nvar template_preparser_1 = require('./template_preparser');\r\nvar style_url_resolver_1 = require('./style_url_resolver');\r\nvar html_ast_1 = require('./html_ast');\r\nvar util_1 = require('./util');\r\n// Group 1 = \"bind-\"\r\n// Group 2 = \"var-\" or \"#\"\r\n// Group 3 = \"on-\"\r\n// Group 4 = \"bindon-\"\r\n// Group 5 = the identifier after \"bind-\", \"var-/#\", or \"on-\"\r\n// Group 6 = identifer inside [()]\r\n// Group 7 = identifer inside []\r\n// Group 8 = identifier inside ()\r\nvar BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(var-|#)|(on-)|(bindon-))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/g;\r\nvar TEMPLATE_ELEMENT = 'template';\r\nvar TEMPLATE_ATTR = 'template';\r\nvar TEMPLATE_ATTR_PREFIX = '*';\r\nvar CLASS_ATTR = 'class';\r\nvar PROPERTY_PARTS_SEPARATOR = '.';\r\nvar ATTRIBUTE_PREFIX = 'attr';\r\nvar CLASS_PREFIX = 'class';\r\nvar STYLE_PREFIX = 'style';\r\nvar TEXT_CSS_SELECTOR = selector_1.CssSelector.parse('*')[0];\r\n/**\r\n * Provides an array of {@link TemplateAstVisitor}s which will be used to transform\r\n * parsed templates before compilation is invoked, allowing custom expression syntax\r\n * and other advanced transformations.\r\n *\r\n * This is currently an internal-only feature and not meant for general use.\r\n */\r\nexports.TEMPLATE_TRANSFORMS = lang_2.CONST_EXPR(new core_1.OpaqueToken('TemplateTransforms'));\r\nvar TemplateParseError = (function (_super) {\r\n    __extends(TemplateParseError, _super);\r\n    function TemplateParseError(message, location) {\r\n        _super.call(this, location, message);\r\n    }\r\n    return TemplateParseError;\r\n})(parse_util_1.ParseError);\r\nexports.TemplateParseError = TemplateParseError;\r\nvar TemplateParser = (function () {\r\n    function TemplateParser(_exprParser, _schemaRegistry, _htmlParser, transforms) {\r\n        this._exprParser = _exprParser;\r\n        this._schemaRegistry = _schemaRegistry;\r\n        this._htmlParser = _htmlParser;\r\n        this.transforms = transforms;\r\n    }\r\n    TemplateParser.prototype.parse = function (template, directives, pipes, templateUrl) {\r\n        var parseVisitor = new TemplateParseVisitor(directives, pipes, this._exprParser, this._schemaRegistry);\r\n        var htmlAstWithErrors = this._htmlParser.parse(template, templateUrl);\r\n        var result = html_ast_1.htmlVisitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_COMPONENT);\r\n        var errors = htmlAstWithErrors.errors.concat(parseVisitor.errors);\r\n        if (errors.length > 0) {\r\n            var errorString = errors.join('\\n');\r\n            throw new exceptions_1.BaseException(\"Template parse errors:\\n\" + errorString);\r\n        }\r\n        if (lang_1.isPresent(this.transforms)) {\r\n            this.transforms.forEach(function (transform) { result = template_ast_1.templateVisitAll(transform, result); });\r\n        }\r\n        return result;\r\n    };\r\n    TemplateParser = __decorate([\r\n        core_1.Injectable(),\r\n        __param(3, core_1.Optional()),\r\n        __param(3, core_1.Inject(exports.TEMPLATE_TRANSFORMS)), \r\n        __metadata('design:paramtypes', [change_detection_1.Parser, element_schema_registry_1.ElementSchemaRegistry, html_parser_1.HtmlParser, Array])\r\n    ], TemplateParser);\r\n    return TemplateParser;\r\n})();\r\nexports.TemplateParser = TemplateParser;\r\nvar TemplateParseVisitor = (function () {\r\n    function TemplateParseVisitor(directives, pipes, _exprParser, _schemaRegistry) {\r\n        var _this = this;\r\n        this._exprParser = _exprParser;\r\n        this._schemaRegistry = _schemaRegistry;\r\n        this.errors = [];\r\n        this.directivesIndex = new Map();\r\n        this.ngContentCount = 0;\r\n        this.selectorMatcher = new selector_1.SelectorMatcher();\r\n        collection_1.ListWrapper.forEachWithIndex(directives, function (directive, index) {\r\n            var selector = selector_1.CssSelector.parse(directive.selector);\r\n            _this.selectorMatcher.addSelectables(selector, directive);\r\n            _this.directivesIndex.set(directive, index);\r\n        });\r\n        this.pipesByName = new Map();\r\n        pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });\r\n    }\r\n    TemplateParseVisitor.prototype._reportError = function (message, sourceSpan) {\r\n        this.errors.push(new TemplateParseError(message, sourceSpan.start));\r\n    };\r\n    TemplateParseVisitor.prototype._parseInterpolation = function (value, sourceSpan) {\r\n        var sourceInfo = sourceSpan.start.toString();\r\n        try {\r\n            var ast = this._exprParser.parseInterpolation(value, sourceInfo);\r\n            this._checkPipes(ast, sourceSpan);\r\n            return ast;\r\n        }\r\n        catch (e) {\r\n            this._reportError(\"\" + e, sourceSpan);\r\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\r\n        }\r\n    };\r\n    TemplateParseVisitor.prototype._parseAction = function (value, sourceSpan) {\r\n        var sourceInfo = sourceSpan.start.toString();\r\n        try {\r\n            var ast = this._exprParser.parseAction(value, sourceInfo);\r\n            this._checkPipes(ast, sourceSpan);\r\n            return ast;\r\n        }\r\n        catch (e) {\r\n            this._reportError(\"\" + e, sourceSpan);\r\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\r\n        }\r\n    };\r\n    TemplateParseVisitor.prototype._parseBinding = function (value, sourceSpan) {\r\n        var sourceInfo = sourceSpan.start.toString();\r\n        try {\r\n            var ast = this._exprParser.parseBinding(value, sourceInfo);\r\n            this._checkPipes(ast, sourceSpan);\r\n            return ast;\r\n        }\r\n        catch (e) {\r\n            this._reportError(\"\" + e, sourceSpan);\r\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\r\n        }\r\n    };\r\n    TemplateParseVisitor.prototype._parseTemplateBindings = function (value, sourceSpan) {\r\n        var _this = this;\r\n        var sourceInfo = sourceSpan.start.toString();\r\n        try {\r\n            var bindings = this._exprParser.parseTemplateBindings(value, sourceInfo);\r\n            bindings.forEach(function (binding) {\r\n                if (lang_1.isPresent(binding.expression)) {\r\n                    _this._checkPipes(binding.expression, sourceSpan);\r\n                }\r\n            });\r\n            return bindings;\r\n        }\r\n        catch (e) {\r\n            this._reportError(\"\" + e, sourceSpan);\r\n            return [];\r\n        }\r\n    };\r\n    TemplateParseVisitor.prototype._checkPipes = function (ast, sourceSpan) {\r\n        var _this = this;\r\n        if (lang_1.isPresent(ast)) {\r\n            var collector = new PipeCollector();\r\n            ast.visit(collector);\r\n            collector.pipes.forEach(function (pipeName) {\r\n                if (!_this.pipesByName.has(pipeName)) {\r\n                    _this._reportError(\"The pipe '\" + pipeName + \"' could not be found\", sourceSpan);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    TemplateParseVisitor.prototype.visitText = function (ast, component) {\r\n        var ngContentIndex = component.findNgContentIndex(TEXT_CSS_SELECTOR);\r\n        var expr = this._parseInterpolation(ast.value, ast.sourceSpan);\r\n        if (lang_1.isPresent(expr)) {\r\n            return new template_ast_1.BoundTextAst(expr, ngContentIndex, ast.sourceSpan);\r\n        }\r\n        else {\r\n            return new template_ast_1.TextAst(ast.value, ngContentIndex, ast.sourceSpan);\r\n        }\r\n    };\r\n    TemplateParseVisitor.prototype.visitAttr = function (ast, contex) {\r\n        return new template_ast_1.AttrAst(ast.name, ast.value, ast.sourceSpan);\r\n    };\r\n    TemplateParseVisitor.prototype.visitElement = function (element, component) {\r\n        var _this = this;\r\n        var nodeName = element.name;\r\n        var preparsedElement = template_preparser_1.preparseElement(element);\r\n        if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT ||\r\n            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE) {\r\n            // Skipping <script> for security reasons\r\n            // Skipping <style> as we already processed them\r\n            // in the StyleCompiler\r\n            return null;\r\n        }\r\n        if (preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET &&\r\n            style_url_resolver_1.isStyleUrlResolvable(preparsedElement.hrefAttr)) {\r\n            // Skipping stylesheets with either relative urls or package scheme as we already processed\r\n            // them in the StyleCompiler\r\n            return null;\r\n        }\r\n        var matchableAttrs = [];\r\n        var elementOrDirectiveProps = [];\r\n        var vars = [];\r\n        var events = [];\r\n        var templateElementOrDirectiveProps = [];\r\n        var templateVars = [];\r\n        var templateMatchableAttrs = [];\r\n        var hasInlineTemplates = false;\r\n        var attrs = [];\r\n        element.attrs.forEach(function (attr) {\r\n            var hasBinding = _this._parseAttr(attr, matchableAttrs, elementOrDirectiveProps, events, vars);\r\n            var hasTemplateBinding = _this._parseInlineTemplateBinding(attr, templateMatchableAttrs, templateElementOrDirectiveProps, templateVars);\r\n            if (!hasBinding && !hasTemplateBinding) {\r\n                // don't include the bindings as attributes as well in the AST\r\n                attrs.push(_this.visitAttr(attr, null));\r\n                matchableAttrs.push([attr.name, attr.value]);\r\n            }\r\n            if (hasTemplateBinding) {\r\n                hasInlineTemplates = true;\r\n            }\r\n        });\r\n        var lcElName = html_tags_1.splitNsName(nodeName.toLowerCase())[1];\r\n        var isTemplateElement = lcElName == TEMPLATE_ELEMENT;\r\n        var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);\r\n        var directives = this._createDirectiveAsts(element.name, this._parseDirectives(this.selectorMatcher, elementCssSelector), elementOrDirectiveProps, isTemplateElement ? [] : vars, element.sourceSpan);\r\n        var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directives);\r\n        var children = html_ast_1.htmlVisitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, Component.create(directives));\r\n        var elementNgContentIndex = hasInlineTemplates ? null : component.findNgContentIndex(elementCssSelector);\r\n        var parsedElement;\r\n        if (preparsedElement.type === template_preparser_1.PreparsedElementType.NG_CONTENT) {\r\n            if (lang_1.isPresent(element.children) && element.children.length > 0) {\r\n                this._reportError(\"<ng-content> element cannot have content. <ng-content> must be immediately followed by </ng-content>\", element.sourceSpan);\r\n            }\r\n            parsedElement =\r\n                new template_ast_1.NgContentAst(this.ngContentCount++, elementNgContentIndex, element.sourceSpan);\r\n        }\r\n        else if (isTemplateElement) {\r\n            this._assertAllEventsPublishedByDirectives(directives, events);\r\n            this._assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, element.sourceSpan);\r\n            parsedElement = new template_ast_1.EmbeddedTemplateAst(attrs, events, vars, directives, children, elementNgContentIndex, element.sourceSpan);\r\n        }\r\n        else {\r\n            this._assertOnlyOneComponent(directives, element.sourceSpan);\r\n            var elementExportAsVars = vars.filter(function (varAst) { return varAst.value.length === 0; });\r\n            parsedElement =\r\n                new template_ast_1.ElementAst(nodeName, attrs, elementProps, events, elementExportAsVars, directives, children, elementNgContentIndex, element.sourceSpan);\r\n        }\r\n        if (hasInlineTemplates) {\r\n            var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);\r\n            var templateDirectives = this._createDirectiveAsts(element.name, this._parseDirectives(this.selectorMatcher, templateCssSelector), templateElementOrDirectiveProps, [], element.sourceSpan);\r\n            var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectives);\r\n            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectives, templateElementProps, element.sourceSpan);\r\n            parsedElement = new template_ast_1.EmbeddedTemplateAst([], [], templateVars, templateDirectives, [parsedElement], component.findNgContentIndex(templateCssSelector), element.sourceSpan);\r\n        }\r\n        return parsedElement;\r\n    };\r\n    TemplateParseVisitor.prototype._parseInlineTemplateBinding = function (attr, targetMatchableAttrs, targetProps, targetVars) {\r\n        var templateBindingsSource = null;\r\n        if (attr.name == TEMPLATE_ATTR) {\r\n            templateBindingsSource = attr.value;\r\n        }\r\n        else if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {\r\n            var key = attr.name.substring(TEMPLATE_ATTR_PREFIX.length); // remove the star\r\n            templateBindingsSource = (attr.value.length == 0) ? key : key + ' ' + attr.value;\r\n        }\r\n        if (lang_1.isPresent(templateBindingsSource)) {\r\n            var bindings = this._parseTemplateBindings(templateBindingsSource, attr.sourceSpan);\r\n            for (var i = 0; i < bindings.length; i++) {\r\n                var binding = bindings[i];\r\n                if (binding.keyIsVar) {\r\n                    targetVars.push(new template_ast_1.VariableAst(binding.key, binding.name, attr.sourceSpan));\r\n                    targetMatchableAttrs.push([binding.key, binding.name]);\r\n                }\r\n                else if (lang_1.isPresent(binding.expression)) {\r\n                    this._parsePropertyAst(binding.key, binding.expression, attr.sourceSpan, targetMatchableAttrs, targetProps);\r\n                }\r\n                else {\r\n                    targetMatchableAttrs.push([binding.key, '']);\r\n                    this._parseLiteralAttr(binding.key, null, attr.sourceSpan, targetProps);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    TemplateParseVisitor.prototype._parseAttr = function (attr, targetMatchableAttrs, targetProps, targetEvents, targetVars) {\r\n        var attrName = this._normalizeAttributeName(attr.name);\r\n        var attrValue = attr.value;\r\n        var bindParts = lang_1.RegExpWrapper.firstMatch(BIND_NAME_REGEXP, attrName);\r\n        var hasBinding = false;\r\n        if (lang_1.isPresent(bindParts)) {\r\n            hasBinding = true;\r\n            if (lang_1.isPresent(bindParts[1])) {\r\n                this._parseProperty(bindParts[5], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);\r\n            }\r\n            else if (lang_1.isPresent(bindParts[2])) {\r\n                var identifier = bindParts[5];\r\n                this._parseVariable(identifier, attrValue, attr.sourceSpan, targetVars);\r\n            }\r\n            else if (lang_1.isPresent(bindParts[3])) {\r\n                this._parseEvent(bindParts[5], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);\r\n            }\r\n            else if (lang_1.isPresent(bindParts[4])) {\r\n                this._parseProperty(bindParts[5], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);\r\n                this._parseAssignmentEvent(bindParts[5], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);\r\n            }\r\n            else if (lang_1.isPresent(bindParts[6])) {\r\n                this._parseProperty(bindParts[6], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);\r\n                this._parseAssignmentEvent(bindParts[6], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);\r\n            }\r\n            else if (lang_1.isPresent(bindParts[7])) {\r\n                this._parseProperty(bindParts[7], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);\r\n            }\r\n            else if (lang_1.isPresent(bindParts[8])) {\r\n                this._parseEvent(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);\r\n            }\r\n        }\r\n        else {\r\n            hasBinding = this._parsePropertyInterpolation(attrName, attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);\r\n        }\r\n        if (!hasBinding) {\r\n            this._parseLiteralAttr(attrName, attrValue, attr.sourceSpan, targetProps);\r\n        }\r\n        return hasBinding;\r\n    };\r\n    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {\r\n        return attrName.toLowerCase().startsWith('data-') ? attrName.substring(5) : attrName;\r\n    };\r\n    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {\r\n        if (identifier.indexOf('-') > -1) {\r\n            this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\r\n        }\r\n        targetVars.push(new template_ast_1.VariableAst(identifier, value, sourceSpan));\r\n    };\r\n    TemplateParseVisitor.prototype._parseProperty = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps) {\r\n        this._parsePropertyAst(name, this._parseBinding(expression, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);\r\n    };\r\n    TemplateParseVisitor.prototype._parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\r\n        var expr = this._parseInterpolation(value, sourceSpan);\r\n        if (lang_1.isPresent(expr)) {\r\n            this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    TemplateParseVisitor.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {\r\n        targetMatchableAttrs.push([name, ast.source]);\r\n        targetProps.push(new BoundElementOrDirectiveProperty(name, ast, false, sourceSpan));\r\n    };\r\n    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\r\n        this._parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, targetMatchableAttrs, targetEvents);\r\n    };\r\n    TemplateParseVisitor.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\r\n        // long format: 'target: eventName'\r\n        var parts = util_1.splitAtColon(name, [null, name]);\r\n        var target = parts[0];\r\n        var eventName = parts[1];\r\n        targetEvents.push(new template_ast_1.BoundEventAst(eventName, target, this._parseAction(expression, sourceSpan), sourceSpan));\r\n        // Don't detect directives for event names for now,\r\n        // so don't add the event name to the matchableAttrs\r\n    };\r\n    TemplateParseVisitor.prototype._parseLiteralAttr = function (name, value, sourceSpan, targetProps) {\r\n        targetProps.push(new BoundElementOrDirectiveProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), true, sourceSpan));\r\n    };\r\n    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {\r\n        var _this = this;\r\n        var directives = [];\r\n        selectorMatcher.match(elementCssSelector, function (selector, directive) { directives.push(directive); });\r\n        // Need to sort the directives so that we get consistent results throughout,\r\n        // as selectorMatcher uses Maps inside.\r\n        // Also need to make components the first directive in the array\r\n        collection_1.ListWrapper.sort(directives, function (dir1, dir2) {\r\n            var dir1Comp = dir1.isComponent;\r\n            var dir2Comp = dir2.isComponent;\r\n            if (dir1Comp && !dir2Comp) {\r\n                return -1;\r\n            }\r\n            else if (!dir1Comp && dir2Comp) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return _this.directivesIndex.get(dir1) - _this.directivesIndex.get(dir2);\r\n            }\r\n        });\r\n        return directives;\r\n    };\r\n    TemplateParseVisitor.prototype._createDirectiveAsts = function (elementName, directives, props, possibleExportAsVars, sourceSpan) {\r\n        var _this = this;\r\n        var matchedVariables = new Set();\r\n        var directiveAsts = directives.map(function (directive) {\r\n            var hostProperties = [];\r\n            var hostEvents = [];\r\n            var directiveProperties = [];\r\n            _this._createDirectiveHostPropertyAsts(elementName, directive.hostProperties, sourceSpan, hostProperties);\r\n            _this._createDirectiveHostEventAsts(directive.hostListeners, sourceSpan, hostEvents);\r\n            _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);\r\n            var exportAsVars = [];\r\n            possibleExportAsVars.forEach(function (varAst) {\r\n                if ((varAst.value.length === 0 && directive.isComponent) ||\r\n                    (directive.exportAs == varAst.value)) {\r\n                    exportAsVars.push(varAst);\r\n                    matchedVariables.add(varAst.name);\r\n                }\r\n            });\r\n            return new template_ast_1.DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, exportAsVars, sourceSpan);\r\n        });\r\n        possibleExportAsVars.forEach(function (varAst) {\r\n            if (varAst.value.length > 0 && !collection_1.SetWrapper.has(matchedVariables, varAst.name)) {\r\n                _this._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\" + varAst.value + \"\\\"\", varAst.sourceSpan);\r\n            }\r\n        });\r\n        return directiveAsts;\r\n    };\r\n    TemplateParseVisitor.prototype._createDirectiveHostPropertyAsts = function (elementName, hostProps, sourceSpan, targetPropertyAsts) {\r\n        var _this = this;\r\n        if (lang_1.isPresent(hostProps)) {\r\n            collection_1.StringMapWrapper.forEach(hostProps, function (expression, propName) {\r\n                var exprAst = _this._parseBinding(expression, sourceSpan);\r\n                targetPropertyAsts.push(_this._createElementPropertyAst(elementName, propName, exprAst, sourceSpan));\r\n            });\r\n        }\r\n    };\r\n    TemplateParseVisitor.prototype._createDirectiveHostEventAsts = function (hostListeners, sourceSpan, targetEventAsts) {\r\n        var _this = this;\r\n        if (lang_1.isPresent(hostListeners)) {\r\n            collection_1.StringMapWrapper.forEach(hostListeners, function (expression, propName) {\r\n                _this._parseEvent(propName, expression, sourceSpan, [], targetEventAsts);\r\n            });\r\n        }\r\n    };\r\n    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps) {\r\n        if (lang_1.isPresent(directiveProperties)) {\r\n            var boundPropsByName = new Map();\r\n            boundProps.forEach(function (boundProp) {\r\n                var prevValue = boundPropsByName.get(boundProp.name);\r\n                if (lang_1.isBlank(prevValue) || prevValue.isLiteral) {\r\n                    // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\r\n                    boundPropsByName.set(boundProp.name, boundProp);\r\n                }\r\n            });\r\n            collection_1.StringMapWrapper.forEach(directiveProperties, function (elProp, dirProp) {\r\n                var boundProp = boundPropsByName.get(elProp);\r\n                // Bindings are optional, so this binding only needs to be set up if an expression is given.\r\n                if (lang_1.isPresent(boundProp)) {\r\n                    targetBoundDirectiveProps.push(new template_ast_1.BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\r\n                }\r\n            });\r\n        }\r\n    };\r\n    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, directives) {\r\n        var _this = this;\r\n        var boundElementProps = [];\r\n        var boundDirectivePropsIndex = new Map();\r\n        directives.forEach(function (directive) {\r\n            directive.inputs.forEach(function (prop) {\r\n                boundDirectivePropsIndex.set(prop.templateName, prop);\r\n            });\r\n        });\r\n        props.forEach(function (prop) {\r\n            if (!prop.isLiteral && lang_1.isBlank(boundDirectivePropsIndex.get(prop.name))) {\r\n                boundElementProps.push(_this._createElementPropertyAst(elementName, prop.name, prop.expression, prop.sourceSpan));\r\n            }\r\n        });\r\n        return boundElementProps;\r\n    };\r\n    TemplateParseVisitor.prototype._createElementPropertyAst = function (elementName, name, ast, sourceSpan) {\r\n        var unit = null;\r\n        var bindingType;\r\n        var boundPropertyName;\r\n        var parts = name.split(PROPERTY_PARTS_SEPARATOR);\r\n        if (parts.length === 1) {\r\n            boundPropertyName = this._schemaRegistry.getMappedPropName(parts[0]);\r\n            bindingType = template_ast_1.PropertyBindingType.Property;\r\n            if (!this._schemaRegistry.hasProperty(elementName, boundPropertyName)) {\r\n                this._reportError(\"Can't bind to '\" + boundPropertyName + \"' since it isn't a known native property\", sourceSpan);\r\n            }\r\n        }\r\n        else {\r\n            if (parts[0] == ATTRIBUTE_PREFIX) {\r\n                boundPropertyName = parts[1];\r\n                bindingType = template_ast_1.PropertyBindingType.Attribute;\r\n            }\r\n            else if (parts[0] == CLASS_PREFIX) {\r\n                boundPropertyName = parts[1];\r\n                bindingType = template_ast_1.PropertyBindingType.Class;\r\n            }\r\n            else if (parts[0] == STYLE_PREFIX) {\r\n                unit = parts.length > 2 ? parts[2] : null;\r\n                boundPropertyName = parts[1];\r\n                bindingType = template_ast_1.PropertyBindingType.Style;\r\n            }\r\n            else {\r\n                this._reportError(\"Invalid property name '\" + name + \"'\", sourceSpan);\r\n                bindingType = null;\r\n            }\r\n        }\r\n        return new template_ast_1.BoundElementPropertyAst(boundPropertyName, bindingType, ast, unit, sourceSpan);\r\n    };\r\n    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {\r\n        var componentTypeNames = [];\r\n        directives.forEach(function (directive) {\r\n            var typeName = directive.directive.type.name;\r\n            if (directive.directive.isComponent) {\r\n                componentTypeNames.push(typeName);\r\n            }\r\n        });\r\n        return componentTypeNames;\r\n    };\r\n    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {\r\n        var componentTypeNames = this._findComponentDirectiveNames(directives);\r\n        if (componentTypeNames.length > 1) {\r\n            this._reportError(\"More than one component: \" + componentTypeNames.join(','), sourceSpan);\r\n        }\r\n    };\r\n    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {\r\n        var _this = this;\r\n        var componentTypeNames = this._findComponentDirectiveNames(directives);\r\n        if (componentTypeNames.length > 0) {\r\n            this._reportError(\"Components on an embedded template: \" + componentTypeNames.join(','), sourceSpan);\r\n        }\r\n        elementProps.forEach(function (prop) {\r\n            _this._reportError(\"Property binding \" + prop.name + \" not used by any directive on an embedded template\", sourceSpan);\r\n        });\r\n    };\r\n    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {\r\n        var _this = this;\r\n        var allDirectiveEvents = new Set();\r\n        directives.forEach(function (directive) {\r\n            collection_1.StringMapWrapper.forEach(directive.directive.outputs, function (eventName, _) { allDirectiveEvents.add(eventName); });\r\n        });\r\n        events.forEach(function (event) {\r\n            if (lang_1.isPresent(event.target) || !collection_1.SetWrapper.has(allDirectiveEvents, event.name)) {\r\n                _this._reportError(\"Event binding \" + event.fullName + \" not emitted by any directive on an embedded template\", event.sourceSpan);\r\n            }\r\n        });\r\n    };\r\n    return TemplateParseVisitor;\r\n})();\r\nvar NonBindableVisitor = (function () {\r\n    function NonBindableVisitor() {\r\n    }\r\n    NonBindableVisitor.prototype.visitElement = function (ast, component) {\r\n        var preparsedElement = template_preparser_1.preparseElement(ast);\r\n        if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT ||\r\n            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE ||\r\n            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET) {\r\n            // Skipping <script> for security reasons\r\n            // Skipping <style> and stylesheets as we already processed them\r\n            // in the StyleCompiler\r\n            return null;\r\n        }\r\n        var attrNameAndValues = ast.attrs.map(function (attrAst) { return [attrAst.name, attrAst.value]; });\r\n        var selector = createElementCssSelector(ast.name, attrNameAndValues);\r\n        var ngContentIndex = component.findNgContentIndex(selector);\r\n        var children = html_ast_1.htmlVisitAll(this, ast.children, EMPTY_COMPONENT);\r\n        return new template_ast_1.ElementAst(ast.name, html_ast_1.htmlVisitAll(this, ast.attrs), [], [], [], [], children, ngContentIndex, ast.sourceSpan);\r\n    };\r\n    NonBindableVisitor.prototype.visitAttr = function (ast, context) {\r\n        return new template_ast_1.AttrAst(ast.name, ast.value, ast.sourceSpan);\r\n    };\r\n    NonBindableVisitor.prototype.visitText = function (ast, component) {\r\n        var ngContentIndex = component.findNgContentIndex(TEXT_CSS_SELECTOR);\r\n        return new template_ast_1.TextAst(ast.value, ngContentIndex, ast.sourceSpan);\r\n    };\r\n    return NonBindableVisitor;\r\n})();\r\nvar BoundElementOrDirectiveProperty = (function () {\r\n    function BoundElementOrDirectiveProperty(name, expression, isLiteral, sourceSpan) {\r\n        this.name = name;\r\n        this.expression = expression;\r\n        this.isLiteral = isLiteral;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    return BoundElementOrDirectiveProperty;\r\n})();\r\nfunction splitClasses(classAttrValue) {\r\n    return lang_1.StringWrapper.split(classAttrValue.trim(), /\\s+/g);\r\n}\r\nexports.splitClasses = splitClasses;\r\nvar Component = (function () {\r\n    function Component(ngContentIndexMatcher, wildcardNgContentIndex) {\r\n        this.ngContentIndexMatcher = ngContentIndexMatcher;\r\n        this.wildcardNgContentIndex = wildcardNgContentIndex;\r\n    }\r\n    Component.create = function (directives) {\r\n        if (directives.length === 0 || !directives[0].directive.isComponent) {\r\n            return EMPTY_COMPONENT;\r\n        }\r\n        var matcher = new selector_1.SelectorMatcher();\r\n        var ngContentSelectors = directives[0].directive.template.ngContentSelectors;\r\n        var wildcardNgContentIndex = null;\r\n        for (var i = 0; i < ngContentSelectors.length; i++) {\r\n            var selector = ngContentSelectors[i];\r\n            if (lang_1.StringWrapper.equals(selector, '*')) {\r\n                wildcardNgContentIndex = i;\r\n            }\r\n            else {\r\n                matcher.addSelectables(selector_1.CssSelector.parse(ngContentSelectors[i]), i);\r\n            }\r\n        }\r\n        return new Component(matcher, wildcardNgContentIndex);\r\n    };\r\n    Component.prototype.findNgContentIndex = function (selector) {\r\n        var ngContentIndices = [];\r\n        this.ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });\r\n        collection_1.ListWrapper.sort(ngContentIndices);\r\n        if (lang_1.isPresent(this.wildcardNgContentIndex)) {\r\n            ngContentIndices.push(this.wildcardNgContentIndex);\r\n        }\r\n        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\r\n    };\r\n    return Component;\r\n})();\r\nfunction createElementCssSelector(elementName, matchableAttrs) {\r\n    var cssSelector = new selector_1.CssSelector();\r\n    var elNameNoNs = html_tags_1.splitNsName(elementName)[1];\r\n    cssSelector.setElement(elNameNoNs);\r\n    for (var i = 0; i < matchableAttrs.length; i++) {\r\n        var attrName = matchableAttrs[i][0];\r\n        var attrNameNoNs = html_tags_1.splitNsName(attrName)[1];\r\n        var attrValue = matchableAttrs[i][1];\r\n        cssSelector.addAttribute(attrNameNoNs, attrValue);\r\n        if (attrName.toLowerCase() == CLASS_ATTR) {\r\n            var classes = splitClasses(attrValue);\r\n            classes.forEach(function (className) { return cssSelector.addClassName(className); });\r\n        }\r\n    }\r\n    return cssSelector;\r\n}\r\nvar EMPTY_COMPONENT = new Component(new selector_1.SelectorMatcher(), null);\r\nvar NON_BINDABLE_VISITOR = new NonBindableVisitor();\r\nvar PipeCollector = (function (_super) {\r\n    __extends(PipeCollector, _super);\r\n    function PipeCollector() {\r\n        _super.apply(this, arguments);\r\n        this.pipes = new Set();\r\n    }\r\n    PipeCollector.prototype.visitPipe = function (ast) {\r\n        this.pipes.add(ast.name);\r\n        ast.exp.visit(this);\r\n        this.visitAll(ast.args);\r\n        return null;\r\n    };\r\n    return PipeCollector;\r\n})(ast_1.RecursiveAstVisitor);\r\nexports.PipeCollector = PipeCollector;\r\n},{\"./html_ast\":56,\"./html_parser\":58,\"./html_tags\":59,\"./parse_util\":60,\"./style_url_resolver\":70,\"./template_ast\":71,\"./template_preparser\":75,\"./util\":77,\"angular2/core\":3,\"angular2/src/compiler/schema/element_schema_registry\":65,\"angular2/src/compiler/selector\":66,\"angular2/src/core/change_detection/change_detection\":87,\"angular2/src/core/change_detection/parser/ast\":107,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],75:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar html_tags_1 = require('./html_tags');\r\nvar NG_CONTENT_SELECT_ATTR = 'select';\r\nvar NG_CONTENT_ELEMENT = 'ng-content';\r\nvar LINK_ELEMENT = 'link';\r\nvar LINK_STYLE_REL_ATTR = 'rel';\r\nvar LINK_STYLE_HREF_ATTR = 'href';\r\nvar LINK_STYLE_REL_VALUE = 'stylesheet';\r\nvar STYLE_ELEMENT = 'style';\r\nvar SCRIPT_ELEMENT = 'script';\r\nvar NG_NON_BINDABLE_ATTR = 'ngNonBindable';\r\nfunction preparseElement(ast) {\r\n    var selectAttr = null;\r\n    var hrefAttr = null;\r\n    var relAttr = null;\r\n    var nonBindable = false;\r\n    ast.attrs.forEach(function (attr) {\r\n        var lcAttrName = attr.name.toLowerCase();\r\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\r\n            selectAttr = attr.value;\r\n        }\r\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\r\n            hrefAttr = attr.value;\r\n        }\r\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\r\n            relAttr = attr.value;\r\n        }\r\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\r\n            nonBindable = true;\r\n        }\r\n    });\r\n    selectAttr = normalizeNgContentSelect(selectAttr);\r\n    var nodeName = ast.name.toLowerCase();\r\n    var type = PreparsedElementType.OTHER;\r\n    if (html_tags_1.splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {\r\n        type = PreparsedElementType.NG_CONTENT;\r\n    }\r\n    else if (nodeName == STYLE_ELEMENT) {\r\n        type = PreparsedElementType.STYLE;\r\n    }\r\n    else if (nodeName == SCRIPT_ELEMENT) {\r\n        type = PreparsedElementType.SCRIPT;\r\n    }\r\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\r\n        type = PreparsedElementType.STYLESHEET;\r\n    }\r\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable);\r\n}\r\nexports.preparseElement = preparseElement;\r\n(function (PreparsedElementType) {\r\n    PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\r\n    PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\r\n    PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\r\n    PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\r\n    PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\r\n})(exports.PreparsedElementType || (exports.PreparsedElementType = {}));\r\nvar PreparsedElementType = exports.PreparsedElementType;\r\nvar PreparsedElement = (function () {\r\n    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable) {\r\n        this.type = type;\r\n        this.selectAttr = selectAttr;\r\n        this.hrefAttr = hrefAttr;\r\n        this.nonBindable = nonBindable;\r\n    }\r\n    return PreparsedElement;\r\n})();\r\nexports.PreparsedElement = PreparsedElement;\r\nfunction normalizeNgContentSelect(selectAttr) {\r\n    if (lang_1.isBlank(selectAttr) || selectAttr.length === 0) {\r\n        return '*';\r\n    }\r\n    return selectAttr;\r\n}\r\n},{\"./html_tags\":59,\"angular2/src/facade/lang\":176}],76:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar application_tokens_1 = require('angular2/src/core/application_tokens');\r\nvar di_2 = require('angular2/src/core/di');\r\n/**\r\n * Create a {@link UrlResolver} with no package prefix.\r\n */\r\nfunction createWithoutPackagePrefix() {\r\n    return new UrlResolver();\r\n}\r\nexports.createWithoutPackagePrefix = createWithoutPackagePrefix;\r\n/**\r\n * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.\r\n */\r\nexports.DEFAULT_PACKAGE_URL_PROVIDER = new di_2.Provider(application_tokens_1.PACKAGE_ROOT_URL, { useValue: \"/\" });\r\n/**\r\n * Used by the {@link Compiler} when resolving HTML and CSS template URLs.\r\n *\r\n * This class can be overridden by the application developer to create custom behavior.\r\n *\r\n * See {@link Compiler}\r\n *\r\n * ## Example\r\n *\r\n * {@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}\r\n */\r\nvar UrlResolver = (function () {\r\n    function UrlResolver(packagePrefix) {\r\n        if (packagePrefix === void 0) { packagePrefix = null; }\r\n        if (lang_1.isPresent(packagePrefix)) {\r\n            this._packagePrefix = lang_1.StringWrapper.stripRight(packagePrefix, \"/\") + \"/\";\r\n        }\r\n    }\r\n    /**\r\n     * Resolves the `url` given the `baseUrl`:\r\n     * - when the `url` is null, the `baseUrl` is returned,\r\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\r\n     * `baseUrl` and `url`,\r\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\r\n     * returned as is (ignoring the `baseUrl`)\r\n     *\r\n     * @param {string} baseUrl\r\n     * @param {string} url\r\n     * @returns {string} the resolved URL\r\n     */\r\n    UrlResolver.prototype.resolve = function (baseUrl, url) {\r\n        var resolvedUrl = url;\r\n        if (lang_1.isPresent(baseUrl) && baseUrl.length > 0) {\r\n            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\r\n        }\r\n        if (lang_1.isPresent(this._packagePrefix) && getUrlScheme(resolvedUrl) == \"package\") {\r\n            resolvedUrl = resolvedUrl.replace(\"package:\", this._packagePrefix);\r\n        }\r\n        return resolvedUrl;\r\n    };\r\n    UrlResolver = __decorate([\r\n        di_1.Injectable(),\r\n        __param(0, di_1.Inject(application_tokens_1.PACKAGE_ROOT_URL)), \r\n        __metadata('design:paramtypes', [String])\r\n    ], UrlResolver);\r\n    return UrlResolver;\r\n})();\r\nexports.UrlResolver = UrlResolver;\r\n/**\r\n * Extract the scheme of a URL.\r\n */\r\nfunction getUrlScheme(url) {\r\n    var match = _split(url);\r\n    return (match && match[_ComponentIndex.Scheme]) || \"\";\r\n}\r\nexports.getUrlScheme = getUrlScheme;\r\n// The code below is adapted from Traceur:\r\n// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js\r\n/**\r\n * Builds a URI string from already-encoded parts.\r\n *\r\n * No encoding is performed.  Any component may be omitted as either null or\r\n * undefined.\r\n *\r\n * @param {?string=} opt_scheme The scheme such as 'http'.\r\n * @param {?string=} opt_userInfo The user name before the '@'.\r\n * @param {?string=} opt_domain The domain such as 'www.google.com', already\r\n *     URI-encoded.\r\n * @param {(string|null)=} opt_port The port number.\r\n * @param {?string=} opt_path The path, already URI-encoded.  If it is not\r\n *     empty, it must begin with a slash.\r\n * @param {?string=} opt_queryData The URI-encoded query data.\r\n * @param {?string=} opt_fragment The URI-encoded fragment identifier.\r\n * @return {string} The fully combined URI.\r\n */\r\nfunction _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\r\n    var out = [];\r\n    if (lang_1.isPresent(opt_scheme)) {\r\n        out.push(opt_scheme + ':');\r\n    }\r\n    if (lang_1.isPresent(opt_domain)) {\r\n        out.push('//');\r\n        if (lang_1.isPresent(opt_userInfo)) {\r\n            out.push(opt_userInfo + '@');\r\n        }\r\n        out.push(opt_domain);\r\n        if (lang_1.isPresent(opt_port)) {\r\n            out.push(':' + opt_port);\r\n        }\r\n    }\r\n    if (lang_1.isPresent(opt_path)) {\r\n        out.push(opt_path);\r\n    }\r\n    if (lang_1.isPresent(opt_queryData)) {\r\n        out.push('?' + opt_queryData);\r\n    }\r\n    if (lang_1.isPresent(opt_fragment)) {\r\n        out.push('#' + opt_fragment);\r\n    }\r\n    return out.join('');\r\n}\r\n/**\r\n * A regular expression for breaking a URI into its component parts.\r\n *\r\n * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says\r\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\r\n * disambiguation method used by POSIX regular expressions, it is natural and\r\n * commonplace to use a regular expression for parsing the potential five\r\n * components of a URI reference.\r\n *\r\n * The following line is the regular expression for breaking-down a\r\n * well-formed URI reference into its components.\r\n *\r\n * <pre>\r\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\r\n *  12            3  4          5       6  7        8 9\r\n * </pre>\r\n *\r\n * The numbers in the second line above are only to assist readability; they\r\n * indicate the reference points for each subexpression (i.e., each paired\r\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\r\n * For example, matching the above expression to\r\n * <pre>\r\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\r\n * </pre>\r\n * results in the following subexpression matches:\r\n * <pre>\r\n *    $1 = http:\r\n *    $2 = http\r\n *    $3 = //www.ics.uci.edu\r\n *    $4 = www.ics.uci.edu\r\n *    $5 = /pub/ietf/uri/\r\n *    $6 = <undefined>\r\n *    $7 = <undefined>\r\n *    $8 = #Related\r\n *    $9 = Related\r\n * </pre>\r\n * where <undefined> indicates that the component is not present, as is the\r\n * case for the query component in the above example. Therefore, we can\r\n * determine the value of the five components as\r\n * <pre>\r\n *    scheme    = $2\r\n *    authority = $4\r\n *    path      = $5\r\n *    query     = $7\r\n *    fragment  = $9\r\n * </pre>\r\n *\r\n * The regular expression has been modified slightly to expose the\r\n * userInfo, domain, and port separately from the authority.\r\n * The modified version yields\r\n * <pre>\r\n *    $1 = http              scheme\r\n *    $2 = <undefined>       userInfo -\\\r\n *    $3 = www.ics.uci.edu   domain     | authority\r\n *    $4 = <undefined>       port     -/\r\n *    $5 = /pub/ietf/uri/    path\r\n *    $6 = <undefined>       query without ?\r\n *    $7 = Related           fragment without #\r\n * </pre>\r\n * @type {!RegExp}\r\n * @internal\r\n */\r\nvar _splitRe = lang_1.RegExpWrapper.create('^' +\r\n    '(?:' +\r\n    '([^:/?#.]+)' +\r\n    // used by other URL parts such as :,\r\n    // ?, /, #, and .\r\n    ':)?' +\r\n    '(?://' +\r\n    '(?:([^/?#]*)@)?' +\r\n    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' +\r\n    // digits, dashes, dots, percent\r\n    // escapes, and unicode characters.\r\n    '(?::([0-9]+))?' +\r\n    ')?' +\r\n    '([^?#]+)?' +\r\n    '(?:\\\\?([^#]*))?' +\r\n    '(?:#(.*))?' +\r\n    '$');\r\n/**\r\n * The index of each URI component in the return value of goog.uri.utils.split.\r\n * @enum {number}\r\n */\r\nvar _ComponentIndex;\r\n(function (_ComponentIndex) {\r\n    _ComponentIndex[_ComponentIndex[\"Scheme\"] = 1] = \"Scheme\";\r\n    _ComponentIndex[_ComponentIndex[\"UserInfo\"] = 2] = \"UserInfo\";\r\n    _ComponentIndex[_ComponentIndex[\"Domain\"] = 3] = \"Domain\";\r\n    _ComponentIndex[_ComponentIndex[\"Port\"] = 4] = \"Port\";\r\n    _ComponentIndex[_ComponentIndex[\"Path\"] = 5] = \"Path\";\r\n    _ComponentIndex[_ComponentIndex[\"QueryData\"] = 6] = \"QueryData\";\r\n    _ComponentIndex[_ComponentIndex[\"Fragment\"] = 7] = \"Fragment\";\r\n})(_ComponentIndex || (_ComponentIndex = {}));\r\n/**\r\n * Splits a URI into its component parts.\r\n *\r\n * Each component can be accessed via the component indices; for example:\r\n * <pre>\r\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\r\n * </pre>\r\n *\r\n * @param {string} uri The URI string to examine.\r\n * @return {!Array.<string|undefined>} Each component still URI-encoded.\r\n *     Each component that is present will contain the encoded value, whereas\r\n *     components that are not present will be undefined or empty, depending\r\n *     on the browser's regular expression implementation.  Never null, since\r\n *     arbitrary strings may still look like path names.\r\n */\r\nfunction _split(uri) {\r\n    return lang_1.RegExpWrapper.firstMatch(_splitRe, uri);\r\n}\r\n/**\r\n  * Removes dot segments in given path component, as described in\r\n  * RFC 3986, section 5.2.4.\r\n  *\r\n  * @param {string} path A non-empty path component.\r\n  * @return {string} Path component with removed dot segments.\r\n  */\r\nfunction _removeDotSegments(path) {\r\n    if (path == '/')\r\n        return '/';\r\n    var leadingSlash = path[0] == '/' ? '/' : '';\r\n    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';\r\n    var segments = path.split('/');\r\n    var out = [];\r\n    var up = 0;\r\n    for (var pos = 0; pos < segments.length; pos++) {\r\n        var segment = segments[pos];\r\n        switch (segment) {\r\n            case '':\r\n            case '.':\r\n                break;\r\n            case '..':\r\n                if (out.length > 0) {\r\n                    out.pop();\r\n                }\r\n                else {\r\n                    up++;\r\n                }\r\n                break;\r\n            default:\r\n                out.push(segment);\r\n        }\r\n    }\r\n    if (leadingSlash == '') {\r\n        while (up-- > 0) {\r\n            out.unshift('..');\r\n        }\r\n        if (out.length === 0)\r\n            out.push('.');\r\n    }\r\n    return leadingSlash + out.join('/') + trailingSlash;\r\n}\r\n/**\r\n * Takes an array of the parts from split and canonicalizes the path part\r\n * and then joins all the parts.\r\n * @param {Array.<string?>} parts\r\n * @return {string}\r\n */\r\nfunction _joinAndCanonicalizePath(parts) {\r\n    var path = parts[_ComponentIndex.Path];\r\n    path = lang_1.isBlank(path) ? '' : _removeDotSegments(path);\r\n    parts[_ComponentIndex.Path] = path;\r\n    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\r\n}\r\n/**\r\n * Resolves a URL.\r\n * @param {string} base The URL acting as the base URL.\r\n * @param {string} to The URL to resolve.\r\n * @return {string}\r\n */\r\nfunction _resolveUrl(base, url) {\r\n    var parts = _split(encodeURI(url));\r\n    var baseParts = _split(base);\r\n    if (lang_1.isPresent(parts[_ComponentIndex.Scheme])) {\r\n        return _joinAndCanonicalizePath(parts);\r\n    }\r\n    else {\r\n        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\r\n    }\r\n    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\r\n        if (lang_1.isBlank(parts[i])) {\r\n            parts[i] = baseParts[i];\r\n        }\r\n    }\r\n    if (parts[_ComponentIndex.Path][0] == '/') {\r\n        return _joinAndCanonicalizePath(parts);\r\n    }\r\n    var path = baseParts[_ComponentIndex.Path];\r\n    if (lang_1.isBlank(path))\r\n        path = '/';\r\n    var index = path.lastIndexOf('/');\r\n    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\r\n    parts[_ComponentIndex.Path] = path;\r\n    return _joinAndCanonicalizePath(parts);\r\n}\r\n},{\"angular2/src/core/application_tokens\":83,\"angular2/src/core/di\":117,\"angular2/src/facade/lang\":176}],77:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar CAMEL_CASE_REGEXP = /([A-Z])/g;\r\nvar DASH_CASE_REGEXP = /-([a-z])/g;\r\nvar SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\r\nvar DOUBLE_QUOTE_ESCAPE_STRING_RE = /\"|\\\\|\\n|\\r|\\$/g;\r\nexports.MODULE_SUFFIX = lang_1.IS_DART ? '.dart' : '.js';\r\nexports.CONST_VAR = lang_1.IS_DART ? 'const' : 'var';\r\nfunction camelCaseToDashCase(input) {\r\n    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });\r\n}\r\nexports.camelCaseToDashCase = camelCaseToDashCase;\r\nfunction dashCaseToCamelCase(input) {\r\n    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });\r\n}\r\nexports.dashCaseToCamelCase = dashCaseToCamelCase;\r\nfunction escapeSingleQuoteString(input) {\r\n    if (lang_1.isBlank(input)) {\r\n        return null;\r\n    }\r\n    return \"'\" + escapeString(input, SINGLE_QUOTE_ESCAPE_STRING_RE) + \"'\";\r\n}\r\nexports.escapeSingleQuoteString = escapeSingleQuoteString;\r\nfunction escapeDoubleQuoteString(input) {\r\n    if (lang_1.isBlank(input)) {\r\n        return null;\r\n    }\r\n    return \"\\\"\" + escapeString(input, DOUBLE_QUOTE_ESCAPE_STRING_RE) + \"\\\"\";\r\n}\r\nexports.escapeDoubleQuoteString = escapeDoubleQuoteString;\r\nfunction escapeString(input, re) {\r\n    return lang_1.StringWrapper.replaceAllMapped(input, re, function (match) {\r\n        if (match[0] == '$') {\r\n            return lang_1.IS_DART ? '\\\\$' : '$';\r\n        }\r\n        else if (match[0] == '\\n') {\r\n            return '\\\\n';\r\n        }\r\n        else if (match[0] == '\\r') {\r\n            return '\\\\r';\r\n        }\r\n        else {\r\n            return \"\\\\\" + match[0];\r\n        }\r\n    });\r\n}\r\nfunction codeGenExportVariable(name) {\r\n    if (lang_1.IS_DART) {\r\n        return \"const \" + name + \" = \";\r\n    }\r\n    else {\r\n        return \"var \" + name + \" = exports['\" + name + \"'] = \";\r\n    }\r\n}\r\nexports.codeGenExportVariable = codeGenExportVariable;\r\nfunction codeGenConstConstructorCall(name) {\r\n    if (lang_1.IS_DART) {\r\n        return \"const \" + name;\r\n    }\r\n    else {\r\n        return \"new \" + name;\r\n    }\r\n}\r\nexports.codeGenConstConstructorCall = codeGenConstConstructorCall;\r\nfunction codeGenValueFn(params, value, fnName) {\r\n    if (fnName === void 0) { fnName = ''; }\r\n    if (lang_1.IS_DART) {\r\n        return codeGenFnHeader(params, fnName) + \" => \" + value;\r\n    }\r\n    else {\r\n        return codeGenFnHeader(params, fnName) + \" { return \" + value + \"; }\";\r\n    }\r\n}\r\nexports.codeGenValueFn = codeGenValueFn;\r\nfunction codeGenFnHeader(params, fnName) {\r\n    if (fnName === void 0) { fnName = ''; }\r\n    if (lang_1.IS_DART) {\r\n        return fnName + \"(\" + params.join(',') + \")\";\r\n    }\r\n    else {\r\n        return \"function \" + fnName + \"(\" + params.join(',') + \")\";\r\n    }\r\n}\r\nexports.codeGenFnHeader = codeGenFnHeader;\r\nfunction codeGenToString(expr) {\r\n    if (lang_1.IS_DART) {\r\n        return \"'${\" + expr + \"}'\";\r\n    }\r\n    else {\r\n        // JS automatically converts to string...\r\n        return expr;\r\n    }\r\n}\r\nexports.codeGenToString = codeGenToString;\r\nfunction splitAtColon(input, defaultValues) {\r\n    var parts = lang_1.StringWrapper.split(input.trim(), /\\s*:\\s*/g);\r\n    if (parts.length > 1) {\r\n        return parts;\r\n    }\r\n    else {\r\n        return defaultValues;\r\n    }\r\n}\r\nexports.splitAtColon = splitAtColon;\r\nvar Statement = (function () {\r\n    function Statement(statement) {\r\n        this.statement = statement;\r\n    }\r\n    return Statement;\r\n})();\r\nexports.Statement = Statement;\r\nvar Expression = (function () {\r\n    function Expression(expression, isArray) {\r\n        if (isArray === void 0) { isArray = false; }\r\n        this.expression = expression;\r\n        this.isArray = isArray;\r\n    }\r\n    return Expression;\r\n})();\r\nexports.Expression = Expression;\r\nfunction escapeValue(value) {\r\n    if (value instanceof Expression) {\r\n        return value.expression;\r\n    }\r\n    else if (lang_1.isString(value)) {\r\n        return escapeSingleQuoteString(value);\r\n    }\r\n    else if (lang_1.isBlank(value)) {\r\n        return 'null';\r\n    }\r\n    else {\r\n        return \"\" + value;\r\n    }\r\n}\r\nexports.escapeValue = escapeValue;\r\nfunction codeGenArray(data) {\r\n    return \"[\" + data.map(escapeValue).join(',') + \"]\";\r\n}\r\nexports.codeGenArray = codeGenArray;\r\nfunction codeGenFlatArray(values) {\r\n    var result = '([';\r\n    var isFirstArrayEntry = true;\r\n    var concatFn = lang_1.IS_DART ? '.addAll' : 'concat';\r\n    for (var i = 0; i < values.length; i++) {\r\n        var value = values[i];\r\n        if (value instanceof Expression && value.isArray) {\r\n            result += \"]).\" + concatFn + \"(\" + value.expression + \").\" + concatFn + \"([\";\r\n            isFirstArrayEntry = true;\r\n        }\r\n        else {\r\n            if (!isFirstArrayEntry) {\r\n                result += ',';\r\n            }\r\n            isFirstArrayEntry = false;\r\n            result += escapeValue(value);\r\n        }\r\n    }\r\n    result += '])';\r\n    return result;\r\n}\r\nexports.codeGenFlatArray = codeGenFlatArray;\r\nfunction codeGenStringMap(keyValueArray) {\r\n    return \"{\" + keyValueArray.map(codeGenKeyValue).join(',') + \"}\";\r\n}\r\nexports.codeGenStringMap = codeGenStringMap;\r\nfunction codeGenKeyValue(keyValue) {\r\n    return escapeValue(keyValue[0]) + \":\" + escapeValue(keyValue[1]);\r\n}\r\nfunction addAll(source, target) {\r\n    for (var i = 0; i < source.length; i++) {\r\n        target.push(source[i]);\r\n    }\r\n}\r\nexports.addAll = addAll;\r\nfunction flattenArray(source, target) {\r\n    if (lang_1.isPresent(source)) {\r\n        for (var i = 0; i < source.length; i++) {\r\n            var item = source[i];\r\n            if (lang_1.isArray(item)) {\r\n                flattenArray(item, target);\r\n            }\r\n            else {\r\n                target.push(item);\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}\r\nexports.flattenArray = flattenArray;\r\n},{\"angular2/src/facade/lang\":176}],78:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar template_ast_1 = require('./template_ast');\r\nvar source_module_1 = require('./source_module');\r\nvar view_1 = require('angular2/src/core/linker/view');\r\nvar view_type_1 = require('angular2/src/core/linker/view_type');\r\nvar element_1 = require('angular2/src/core/linker/element');\r\nvar view_2 = require('angular2/src/core/metadata/view');\r\nvar util_1 = require('./util');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar proto_view_compiler_1 = require('./proto_view_compiler');\r\nexports.VIEW_JIT_IMPORTS = lang_1.CONST_EXPR({\r\n    'AppView': view_1.AppView,\r\n    'AppElement': element_1.AppElement,\r\n    'flattenNestedViewRenderNodes': view_1.flattenNestedViewRenderNodes,\r\n    'checkSlotCount': view_1.checkSlotCount\r\n});\r\nvar ViewCompiler = (function () {\r\n    function ViewCompiler() {\r\n    }\r\n    ViewCompiler.prototype.compileComponentRuntime = function (component, template, styles, protoViews, changeDetectorFactories, componentViewFactory) {\r\n        var viewFactory = new RuntimeViewFactory(component, styles, protoViews, changeDetectorFactories, componentViewFactory);\r\n        return viewFactory.createViewFactory(template, 0, []);\r\n    };\r\n    ViewCompiler.prototype.compileComponentCodeGen = function (component, template, styles, protoViews, changeDetectorFactoryExpressions, componentViewFactory) {\r\n        var viewFactory = new CodeGenViewFactory(component, styles, protoViews, changeDetectorFactoryExpressions, componentViewFactory);\r\n        var targetStatements = [];\r\n        var viewFactoryExpression = viewFactory.createViewFactory(template, 0, targetStatements);\r\n        return new source_module_1.SourceExpression(targetStatements.map(function (stmt) { return stmt.statement; }), viewFactoryExpression.expression);\r\n    };\r\n    ViewCompiler = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], ViewCompiler);\r\n    return ViewCompiler;\r\n})();\r\nexports.ViewCompiler = ViewCompiler;\r\nvar CodeGenViewFactory = (function () {\r\n    function CodeGenViewFactory(component, styles, protoViews, changeDetectorExpressions, componentViewFactory) {\r\n        this.component = component;\r\n        this.styles = styles;\r\n        this.protoViews = protoViews;\r\n        this.changeDetectorExpressions = changeDetectorExpressions;\r\n        this.componentViewFactory = componentViewFactory;\r\n        this._nextVarId = 0;\r\n    }\r\n    CodeGenViewFactory.prototype._nextVar = function (prefix) {\r\n        return \"\" + prefix + this._nextVarId++ + \"_\" + this.component.type.name;\r\n    };\r\n    CodeGenViewFactory.prototype._nextRenderVar = function () { return this._nextVar('render'); };\r\n    CodeGenViewFactory.prototype._nextAppVar = function () { return this._nextVar('app'); };\r\n    CodeGenViewFactory.prototype._nextDisposableVar = function () {\r\n        return \"disposable\" + this._nextVarId++ + \"_\" + this.component.type.name;\r\n    };\r\n    CodeGenViewFactory.prototype.createText = function (renderer, parent, text, targetStatements) {\r\n        var varName = this._nextRenderVar();\r\n        var statement = \"var \" + varName + \" = \" + renderer.expression + \".createText(\" + (lang_1.isPresent(parent) ? parent.expression : null) + \", \" + util_1.escapeSingleQuoteString(text) + \");\";\r\n        targetStatements.push(new util_1.Statement(statement));\r\n        return new util_1.Expression(varName);\r\n    };\r\n    CodeGenViewFactory.prototype.createElement = function (renderer, parentRenderNode, name, rootSelector, targetStatements) {\r\n        var varName = this._nextRenderVar();\r\n        var valueExpr;\r\n        if (lang_1.isPresent(rootSelector)) {\r\n            valueExpr = rootSelector.expression + \" == null ?\\n        \" + renderer.expression + \".createElement(\" + (lang_1.isPresent(parentRenderNode) ? parentRenderNode.expression : null) + \", \" + util_1.escapeSingleQuoteString(name) + \") :\\n        \" + renderer.expression + \".selectRootElement(\" + rootSelector.expression + \");\";\r\n        }\r\n        else {\r\n            valueExpr =\r\n                renderer.expression + \".createElement(\" + (lang_1.isPresent(parentRenderNode) ? parentRenderNode.expression : null) + \", \" + util_1.escapeSingleQuoteString(name) + \")\";\r\n        }\r\n        var statement = \"var \" + varName + \" = \" + valueExpr + \";\";\r\n        targetStatements.push(new util_1.Statement(statement));\r\n        return new util_1.Expression(varName);\r\n    };\r\n    CodeGenViewFactory.prototype.createTemplateAnchor = function (renderer, parentRenderNode, targetStatements) {\r\n        var varName = this._nextRenderVar();\r\n        var valueExpr = renderer.expression + \".createTemplateAnchor(\" + (lang_1.isPresent(parentRenderNode) ? parentRenderNode.expression : null) + \");\";\r\n        targetStatements.push(new util_1.Statement(\"var \" + varName + \" = \" + valueExpr));\r\n        return new util_1.Expression(varName);\r\n    };\r\n    CodeGenViewFactory.prototype.createGlobalEventListener = function (renderer, appView, boundElementIndex, eventAst, targetStatements) {\r\n        var disposableVar = this._nextDisposableVar();\r\n        var eventHandlerExpr = codeGenEventHandler(appView, boundElementIndex, eventAst.fullName);\r\n        targetStatements.push(new util_1.Statement(\"var \" + disposableVar + \" = \" + renderer.expression + \".listenGlobal(\" + util_1.escapeValue(eventAst.target) + \", \" + util_1.escapeValue(eventAst.name) + \", \" + eventHandlerExpr + \");\"));\r\n        return new util_1.Expression(disposableVar);\r\n    };\r\n    CodeGenViewFactory.prototype.createElementEventListener = function (renderer, appView, boundElementIndex, renderNode, eventAst, targetStatements) {\r\n        var eventHandlerExpr = codeGenEventHandler(appView, boundElementIndex, eventAst.fullName);\r\n        targetStatements.push(new util_1.Statement(renderer.expression + \".listen(\" + renderNode.expression + \", \" + util_1.escapeValue(eventAst.name) + \", \" + eventHandlerExpr + \");\"));\r\n    };\r\n    CodeGenViewFactory.prototype.setElementAttribute = function (renderer, renderNode, attrName, attrValue, targetStatements) {\r\n        targetStatements.push(new util_1.Statement(renderer.expression + \".setElementAttribute(\" + renderNode.expression + \", \" + util_1.escapeSingleQuoteString(attrName) + \", \" + util_1.escapeSingleQuoteString(attrValue) + \");\"));\r\n    };\r\n    CodeGenViewFactory.prototype.createAppElement = function (appProtoEl, appView, renderNode, parentAppEl, embeddedViewFactory, targetStatements) {\r\n        var appVar = this._nextAppVar();\r\n        var varValue = \"new \" + proto_view_compiler_1.APP_EL_MODULE_REF + \"AppElement(\" + appProtoEl.expression + \", \" + appView.expression + \",\\n      \" + (lang_1.isPresent(parentAppEl) ? parentAppEl.expression : null) + \", \" + renderNode.expression + \", \" + (lang_1.isPresent(embeddedViewFactory) ? embeddedViewFactory.expression : null) + \")\";\r\n        targetStatements.push(new util_1.Statement(\"var \" + appVar + \" = \" + varValue + \";\"));\r\n        return new util_1.Expression(appVar);\r\n    };\r\n    CodeGenViewFactory.prototype.createAndSetComponentView = function (renderer, viewManager, view, appEl, component, contentNodesByNgContentIndex, targetStatements) {\r\n        var codeGenContentNodes;\r\n        if (this.component.type.isHost) {\r\n            codeGenContentNodes = view.expression + \".projectableNodes\";\r\n        }\r\n        else {\r\n            codeGenContentNodes =\r\n                \"[\" + contentNodesByNgContentIndex.map(function (nodes) { return util_1.codeGenFlatArray(nodes); }).join(',') + \"]\";\r\n        }\r\n        targetStatements.push(new util_1.Statement(this.componentViewFactory(component) + \"(\" + renderer.expression + \", \" + viewManager.expression + \", \" + appEl.expression + \", \" + codeGenContentNodes + \", null, null, null);\"));\r\n    };\r\n    CodeGenViewFactory.prototype.getProjectedNodes = function (projectableNodes, ngContentIndex) {\r\n        return new util_1.Expression(projectableNodes.expression + \"[\" + ngContentIndex + \"]\", true);\r\n    };\r\n    CodeGenViewFactory.prototype.appendProjectedNodes = function (renderer, parent, nodes, targetStatements) {\r\n        targetStatements.push(new util_1.Statement(renderer.expression + \".projectNodes(\" + parent.expression + \", \" + proto_view_compiler_1.APP_VIEW_MODULE_REF + \"flattenNestedViewRenderNodes(\" + nodes.expression + \"));\"));\r\n    };\r\n    CodeGenViewFactory.prototype.createViewFactory = function (asts, embeddedTemplateIndex, targetStatements) {\r\n        var compileProtoView = this.protoViews[embeddedTemplateIndex];\r\n        var isHostView = this.component.type.isHost;\r\n        var isComponentView = embeddedTemplateIndex === 0 && !isHostView;\r\n        var visitor = new ViewBuilderVisitor(new util_1.Expression('renderer'), new util_1.Expression('viewManager'), new util_1.Expression('projectableNodes'), isHostView ? new util_1.Expression('rootSelector') : null, new util_1.Expression('view'), compileProtoView, targetStatements, this);\r\n        template_ast_1.templateVisitAll(visitor, asts, new ParentElement(isComponentView ? new util_1.Expression('parentRenderNode') : null, null, null));\r\n        var appProtoView = compileProtoView.protoView.expression;\r\n        var viewFactoryName = codeGenViewFactoryName(this.component, embeddedTemplateIndex);\r\n        var changeDetectorFactory = this.changeDetectorExpressions.expressions[embeddedTemplateIndex];\r\n        var factoryArgs = [\r\n            'parentRenderer',\r\n            'viewManager',\r\n            'containerEl',\r\n            'projectableNodes',\r\n            'rootSelector',\r\n            'dynamicallyCreatedProviders',\r\n            'rootInjector'\r\n        ];\r\n        var initRendererStmts = [];\r\n        var rendererExpr = \"parentRenderer\";\r\n        if (embeddedTemplateIndex === 0) {\r\n            var renderCompTypeVar = this._nextVar('renderType');\r\n            targetStatements.push(new util_1.Statement(\"var \" + renderCompTypeVar + \" = null;\"));\r\n            var stylesVar = this._nextVar('styles');\r\n            targetStatements.push(new util_1.Statement(util_1.CONST_VAR + \" \" + stylesVar + \" = \" + this.styles.expression + \";\"));\r\n            var encapsulation = this.component.template.encapsulation;\r\n            initRendererStmts.push(\"if (\" + renderCompTypeVar + \" == null) {\\n        \" + renderCompTypeVar + \" = viewManager.createRenderComponentType(\" + codeGenViewEncapsulation(encapsulation) + \", \" + stylesVar + \");\\n      }\");\r\n            rendererExpr = \"parentRenderer.renderComponent(\" + renderCompTypeVar + \")\";\r\n        }\r\n        var statement = \"\\n\" + util_1.codeGenFnHeader(factoryArgs, viewFactoryName) + \"{\\n  \" + initRendererStmts.join('\\n') + \"\\n  var renderer = \" + rendererExpr + \";\\n  var view = new \" + proto_view_compiler_1.APP_VIEW_MODULE_REF + \"AppView(\\n    \" + appProtoView + \", renderer, viewManager,\\n    projectableNodes,\\n    containerEl,\\n    dynamicallyCreatedProviders, rootInjector,\\n    \" + changeDetectorFactory + \"()\\n  );\\n  \" + proto_view_compiler_1.APP_VIEW_MODULE_REF + \"checkSlotCount(\" + util_1.escapeValue(this.component.type.name) + \", \" + this.component.template.ngContentSelectors.length + \", projectableNodes);\\n  \" + (isComponentView ? 'var parentRenderNode = renderer.createViewRoot(view.containerAppElement.nativeElement);' : '') + \"\\n  \" + visitor.renderStmts.map(function (stmt) { return stmt.statement; }).join('\\n') + \"\\n  \" + visitor.appStmts.map(function (stmt) { return stmt.statement; }).join('\\n') + \"\\n\\n  view.init(\" + util_1.codeGenFlatArray(visitor.rootNodesOrAppElements) + \", \" + util_1.codeGenArray(visitor.renderNodes) + \", \" + util_1.codeGenArray(visitor.appDisposables) + \",\\n            \" + util_1.codeGenArray(visitor.appElements) + \");\\n  return view;\\n}\";\r\n        targetStatements.push(new util_1.Statement(statement));\r\n        return new util_1.Expression(viewFactoryName);\r\n    };\r\n    return CodeGenViewFactory;\r\n})();\r\nvar RuntimeViewFactory = (function () {\r\n    function RuntimeViewFactory(component, styles, protoViews, changeDetectorFactories, componentViewFactory) {\r\n        this.component = component;\r\n        this.styles = styles;\r\n        this.protoViews = protoViews;\r\n        this.changeDetectorFactories = changeDetectorFactories;\r\n        this.componentViewFactory = componentViewFactory;\r\n    }\r\n    RuntimeViewFactory.prototype.createText = function (renderer, parent, text, targetStatements) {\r\n        return renderer.createText(parent, text);\r\n    };\r\n    RuntimeViewFactory.prototype.createElement = function (renderer, parent, name, rootSelector, targetStatements) {\r\n        var el;\r\n        if (lang_1.isPresent(rootSelector)) {\r\n            el = renderer.selectRootElement(rootSelector);\r\n        }\r\n        else {\r\n            el = renderer.createElement(parent, name);\r\n        }\r\n        return el;\r\n    };\r\n    RuntimeViewFactory.prototype.createTemplateAnchor = function (renderer, parent, targetStatements) {\r\n        return renderer.createTemplateAnchor(parent);\r\n    };\r\n    RuntimeViewFactory.prototype.createGlobalEventListener = function (renderer, appView, boundElementIndex, eventAst, targetStatements) {\r\n        return renderer.listenGlobal(eventAst.target, eventAst.name, function (event) { return appView.triggerEventHandlers(eventAst.fullName, event, boundElementIndex); });\r\n    };\r\n    RuntimeViewFactory.prototype.createElementEventListener = function (renderer, appView, boundElementIndex, renderNode, eventAst, targetStatements) {\r\n        renderer.listen(renderNode, eventAst.name, function (event) { return appView.triggerEventHandlers(eventAst.fullName, event, boundElementIndex); });\r\n    };\r\n    RuntimeViewFactory.prototype.setElementAttribute = function (renderer, renderNode, attrName, attrValue, targetStatements) {\r\n        renderer.setElementAttribute(renderNode, attrName, attrValue);\r\n    };\r\n    RuntimeViewFactory.prototype.createAppElement = function (appProtoEl, appView, renderNode, parentAppEl, embeddedViewFactory, targetStatements) {\r\n        return new element_1.AppElement(appProtoEl, appView, parentAppEl, renderNode, embeddedViewFactory);\r\n    };\r\n    RuntimeViewFactory.prototype.createAndSetComponentView = function (renderer, viewManager, appView, appEl, component, contentNodesByNgContentIndex, targetStatements) {\r\n        var flattenedContentNodes;\r\n        if (this.component.type.isHost) {\r\n            flattenedContentNodes = appView.projectableNodes;\r\n        }\r\n        else {\r\n            flattenedContentNodes = collection_1.ListWrapper.createFixedSize(contentNodesByNgContentIndex.length);\r\n            for (var i = 0; i < contentNodesByNgContentIndex.length; i++) {\r\n                flattenedContentNodes[i] = util_1.flattenArray(contentNodesByNgContentIndex[i], []);\r\n            }\r\n        }\r\n        this.componentViewFactory(component)(renderer, viewManager, appEl, flattenedContentNodes);\r\n    };\r\n    RuntimeViewFactory.prototype.getProjectedNodes = function (projectableNodes, ngContentIndex) {\r\n        return projectableNodes[ngContentIndex];\r\n    };\r\n    RuntimeViewFactory.prototype.appendProjectedNodes = function (renderer, parent, nodes, targetStatements) {\r\n        renderer.projectNodes(parent, view_1.flattenNestedViewRenderNodes(nodes));\r\n    };\r\n    RuntimeViewFactory.prototype.createViewFactory = function (asts, embeddedTemplateIndex, targetStatements) {\r\n        var _this = this;\r\n        var compileProtoView = this.protoViews[embeddedTemplateIndex];\r\n        var isComponentView = compileProtoView.protoView.type === view_type_1.ViewType.COMPONENT;\r\n        var renderComponentType = null;\r\n        return function (parentRenderer, viewManager, containerEl, projectableNodes, rootSelector, dynamicallyCreatedProviders, rootInjector) {\r\n            if (rootSelector === void 0) { rootSelector = null; }\r\n            if (dynamicallyCreatedProviders === void 0) { dynamicallyCreatedProviders = null; }\r\n            if (rootInjector === void 0) { rootInjector = null; }\r\n            view_1.checkSlotCount(_this.component.type.name, _this.component.template.ngContentSelectors.length, projectableNodes);\r\n            var renderer;\r\n            if (embeddedTemplateIndex === 0) {\r\n                if (lang_1.isBlank(renderComponentType)) {\r\n                    renderComponentType = viewManager.createRenderComponentType(_this.component.template.encapsulation, _this.styles);\r\n                }\r\n                renderer = parentRenderer.renderComponent(renderComponentType);\r\n            }\r\n            else {\r\n                renderer = parentRenderer;\r\n            }\r\n            var changeDetector = _this.changeDetectorFactories[embeddedTemplateIndex]();\r\n            var view = new view_1.AppView(compileProtoView.protoView, renderer, viewManager, projectableNodes, containerEl, dynamicallyCreatedProviders, rootInjector, changeDetector);\r\n            var visitor = new ViewBuilderVisitor(renderer, viewManager, projectableNodes, rootSelector, view, compileProtoView, [], _this);\r\n            var parentRenderNode = isComponentView ? renderer.createViewRoot(containerEl.nativeElement) : null;\r\n            template_ast_1.templateVisitAll(visitor, asts, new ParentElement(parentRenderNode, null, null));\r\n            view.init(util_1.flattenArray(visitor.rootNodesOrAppElements, []), visitor.renderNodes, visitor.appDisposables, visitor.appElements);\r\n            return view;\r\n        };\r\n    };\r\n    return RuntimeViewFactory;\r\n})();\r\nvar ParentElement = (function () {\r\n    function ParentElement(renderNode, appEl, component) {\r\n        this.renderNode = renderNode;\r\n        this.appEl = appEl;\r\n        this.component = component;\r\n        if (lang_1.isPresent(component)) {\r\n            this.contentNodesByNgContentIndex =\r\n                collection_1.ListWrapper.createFixedSize(component.template.ngContentSelectors.length);\r\n            for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {\r\n                this.contentNodesByNgContentIndex[i] = [];\r\n            }\r\n        }\r\n        else {\r\n            this.contentNodesByNgContentIndex = null;\r\n        }\r\n    }\r\n    ParentElement.prototype.addContentNode = function (ngContentIndex, nodeExpr) {\r\n        this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);\r\n    };\r\n    return ParentElement;\r\n})();\r\nvar ViewBuilderVisitor = (function () {\r\n    function ViewBuilderVisitor(renderer, viewManager, projectableNodes, rootSelector, view, protoView, targetStatements, factory) {\r\n        this.renderer = renderer;\r\n        this.viewManager = viewManager;\r\n        this.projectableNodes = projectableNodes;\r\n        this.rootSelector = rootSelector;\r\n        this.view = view;\r\n        this.protoView = protoView;\r\n        this.targetStatements = targetStatements;\r\n        this.factory = factory;\r\n        this.renderStmts = [];\r\n        this.renderNodes = [];\r\n        this.appStmts = [];\r\n        this.appElements = [];\r\n        this.appDisposables = [];\r\n        this.rootNodesOrAppElements = [];\r\n        this.elementCount = 0;\r\n    }\r\n    ViewBuilderVisitor.prototype._addRenderNode = function (renderNode, appEl, ngContentIndex, parent) {\r\n        this.renderNodes.push(renderNode);\r\n        if (lang_1.isPresent(parent.component)) {\r\n            if (lang_1.isPresent(ngContentIndex)) {\r\n                parent.addContentNode(ngContentIndex, lang_1.isPresent(appEl) ? appEl : renderNode);\r\n            }\r\n        }\r\n        else if (lang_1.isBlank(parent.renderNode)) {\r\n            this.rootNodesOrAppElements.push(lang_1.isPresent(appEl) ? appEl : renderNode);\r\n        }\r\n    };\r\n    ViewBuilderVisitor.prototype._getParentRenderNode = function (ngContentIndex, parent) {\r\n        return lang_1.isPresent(parent.component) &&\r\n            parent.component.template.encapsulation !== view_2.ViewEncapsulation.Native ?\r\n            null :\r\n            parent.renderNode;\r\n    };\r\n    ViewBuilderVisitor.prototype.visitBoundText = function (ast, parent) {\r\n        return this._visitText('', ast.ngContentIndex, parent);\r\n    };\r\n    ViewBuilderVisitor.prototype.visitText = function (ast, parent) {\r\n        return this._visitText(ast.value, ast.ngContentIndex, parent);\r\n    };\r\n    ViewBuilderVisitor.prototype._visitText = function (value, ngContentIndex, parent) {\r\n        var renderNode = this.factory.createText(this.renderer, this._getParentRenderNode(ngContentIndex, parent), value, this.renderStmts);\r\n        this._addRenderNode(renderNode, null, ngContentIndex, parent);\r\n        return null;\r\n    };\r\n    ViewBuilderVisitor.prototype.visitNgContent = function (ast, parent) {\r\n        var nodesExpression = this.factory.getProjectedNodes(this.projectableNodes, ast.index);\r\n        if (lang_1.isPresent(parent.component)) {\r\n            if (lang_1.isPresent(ast.ngContentIndex)) {\r\n                parent.addContentNode(ast.ngContentIndex, nodesExpression);\r\n            }\r\n        }\r\n        else {\r\n            if (lang_1.isPresent(parent.renderNode)) {\r\n                this.factory.appendProjectedNodes(this.renderer, parent.renderNode, nodesExpression, this.renderStmts);\r\n            }\r\n            else {\r\n                this.rootNodesOrAppElements.push(nodesExpression);\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    ViewBuilderVisitor.prototype.visitElement = function (ast, parent) {\r\n        var _this = this;\r\n        var renderNode = this.factory.createElement(this.renderer, this._getParentRenderNode(ast.ngContentIndex, parent), ast.name, this.rootSelector, this.renderStmts);\r\n        var component = ast.getComponent();\r\n        var elementIndex = this.elementCount++;\r\n        var protoEl = this.protoView.protoElements[elementIndex];\r\n        protoEl.renderEvents.forEach(function (eventAst) {\r\n            if (lang_1.isPresent(eventAst.target)) {\r\n                var disposable = _this.factory.createGlobalEventListener(_this.renderer, _this.view, protoEl.boundElementIndex, eventAst, _this.renderStmts);\r\n                _this.appDisposables.push(disposable);\r\n            }\r\n            else {\r\n                _this.factory.createElementEventListener(_this.renderer, _this.view, protoEl.boundElementIndex, renderNode, eventAst, _this.renderStmts);\r\n            }\r\n        });\r\n        for (var i = 0; i < protoEl.attrNameAndValues.length; i++) {\r\n            var attrName = protoEl.attrNameAndValues[i][0];\r\n            var attrValue = protoEl.attrNameAndValues[i][1];\r\n            this.factory.setElementAttribute(this.renderer, renderNode, attrName, attrValue, this.renderStmts);\r\n        }\r\n        var appEl = null;\r\n        if (lang_1.isPresent(protoEl.appProtoEl)) {\r\n            appEl = this.factory.createAppElement(protoEl.appProtoEl, this.view, renderNode, parent.appEl, null, this.appStmts);\r\n            this.appElements.push(appEl);\r\n        }\r\n        this._addRenderNode(renderNode, appEl, ast.ngContentIndex, parent);\r\n        var newParent = new ParentElement(renderNode, lang_1.isPresent(appEl) ? appEl : parent.appEl, component);\r\n        template_ast_1.templateVisitAll(this, ast.children, newParent);\r\n        if (lang_1.isPresent(appEl) && lang_1.isPresent(component)) {\r\n            this.factory.createAndSetComponentView(this.renderer, this.viewManager, this.view, appEl, component, newParent.contentNodesByNgContentIndex, this.appStmts);\r\n        }\r\n        return null;\r\n    };\r\n    ViewBuilderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {\r\n        var renderNode = this.factory.createTemplateAnchor(this.renderer, this._getParentRenderNode(ast.ngContentIndex, parent), this.renderStmts);\r\n        var elementIndex = this.elementCount++;\r\n        var protoEl = this.protoView.protoElements[elementIndex];\r\n        var embeddedViewFactory = this.factory.createViewFactory(ast.children, protoEl.embeddedTemplateIndex, this.targetStatements);\r\n        var appEl = this.factory.createAppElement(protoEl.appProtoEl, this.view, renderNode, parent.appEl, embeddedViewFactory, this.appStmts);\r\n        this._addRenderNode(renderNode, appEl, ast.ngContentIndex, parent);\r\n        this.appElements.push(appEl);\r\n        return null;\r\n    };\r\n    ViewBuilderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };\r\n    ViewBuilderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };\r\n    ViewBuilderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };\r\n    ViewBuilderVisitor.prototype.visitEvent = function (ast, ctx) { return null; };\r\n    ViewBuilderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };\r\n    ViewBuilderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };\r\n    return ViewBuilderVisitor;\r\n})();\r\nfunction codeGenEventHandler(view, boundElementIndex, eventName) {\r\n    return util_1.codeGenValueFn(['event'], view.expression + \".triggerEventHandlers(\" + util_1.escapeValue(eventName) + \", event, \" + boundElementIndex + \")\");\r\n}\r\nfunction codeGenViewFactoryName(component, embeddedTemplateIndex) {\r\n    return \"viewFactory_\" + component.type.name + embeddedTemplateIndex;\r\n}\r\nfunction codeGenViewEncapsulation(value) {\r\n    if (lang_1.IS_DART) {\r\n        return \"\" + proto_view_compiler_1.METADATA_MODULE_REF + value;\r\n    }\r\n    else {\r\n        return \"\" + value;\r\n    }\r\n}\r\n},{\"./proto_view_compiler\":61,\"./source_module\":68,\"./template_ast\":71,\"./util\":77,\"angular2/src/core/di\":117,\"angular2/src/core/linker/element\":132,\"angular2/src/core/linker/view\":139,\"angular2/src/core/linker/view_type\":145,\"angular2/src/core/metadata/view\":149,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],79:[function(require,module,exports){\n'use strict';// TODO: vsavkin rename it into TemplateLoader\r\n/**\r\n * An interface for retrieving documents by URL that the compiler uses\r\n * to load templates.\r\n */\r\nvar XHR = (function () {\r\n    function XHR() {\r\n    }\r\n    XHR.prototype.get = function (url) { return null; };\r\n    return XHR;\r\n})();\r\nexports.XHR = XHR;\r\n},{}],80:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * Marks a function or method as an Angular 2 entrypoint. Only necessary in Dart code.\r\n *\r\n * The optional `name` parameter will be reflected in logs when the entry point is processed.\r\n *\r\n * See [the wiki][] for detailed documentation.\r\n * [the wiki]: https://github.com/angular/angular/wiki/Angular-2-Dart-Transformer#entry_points\r\n *\r\n * ## Example\r\n *\r\n * ```\r\n * @AngularEntrypoint(\"name-for-debug\")\r\n * void main() {\r\n *   bootstrap(MyComponent);\r\n * }\r\n * ```\r\n */\r\nvar AngularEntrypoint = (function () {\r\n    function AngularEntrypoint(name) {\r\n        this.name = name;\r\n    }\r\n    AngularEntrypoint = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [String])\r\n    ], AngularEntrypoint);\r\n    return AngularEntrypoint;\r\n})();\r\nexports.AngularEntrypoint = AngularEntrypoint;\r\n},{\"angular2/src/facade/lang\":176}],81:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar application_tokens_1 = require('./application_tokens');\r\nvar change_detection_1 = require('./change_detection/change_detection');\r\nvar resolved_metadata_cache_1 = require('angular2/src/core/linker/resolved_metadata_cache');\r\nvar view_manager_1 = require('./linker/view_manager');\r\nvar view_manager_2 = require(\"./linker/view_manager\");\r\nvar view_resolver_1 = require('./linker/view_resolver');\r\nvar view_listener_1 = require('./linker/view_listener');\r\nvar directive_resolver_1 = require('./linker/directive_resolver');\r\nvar pipe_resolver_1 = require('./linker/pipe_resolver');\r\nvar compiler_1 = require('./linker/compiler');\r\nvar compiler_2 = require(\"./linker/compiler\");\r\nvar dynamic_component_loader_1 = require('./linker/dynamic_component_loader');\r\nvar dynamic_component_loader_2 = require(\"./linker/dynamic_component_loader\");\r\n/**\r\n * A default set of providers which should be included in any Angular\r\n * application, regardless of the platform it runs onto.\r\n */\r\nexports.APPLICATION_COMMON_PROVIDERS = lang_1.CONST_EXPR([\r\n    new di_1.Provider(compiler_1.Compiler, { useClass: compiler_2.Compiler_ }),\r\n    application_tokens_1.APP_ID_RANDOM_PROVIDER,\r\n    resolved_metadata_cache_1.ResolvedMetadataCache,\r\n    new di_1.Provider(view_manager_1.AppViewManager, { useClass: view_manager_2.AppViewManager_ }),\r\n    view_listener_1.AppViewListener,\r\n    view_resolver_1.ViewResolver,\r\n    new di_1.Provider(change_detection_1.IterableDiffers, { useValue: change_detection_1.defaultIterableDiffers }),\r\n    new di_1.Provider(change_detection_1.KeyValueDiffers, { useValue: change_detection_1.defaultKeyValueDiffers }),\r\n    directive_resolver_1.DirectiveResolver,\r\n    pipe_resolver_1.PipeResolver,\r\n    new di_1.Provider(dynamic_component_loader_1.DynamicComponentLoader, { useClass: dynamic_component_loader_2.DynamicComponentLoader_ })\r\n]);\r\n},{\"./application_tokens\":83,\"./change_detection/change_detection\":87,\"./linker/compiler\":128,\"./linker/directive_resolver\":130,\"./linker/dynamic_component_loader\":131,\"./linker/pipe_resolver\":135,\"./linker/view_listener\":141,\"./linker/view_manager\":142,\"./linker/view_resolver\":144,\"angular2/src/core/di\":117,\"angular2/src/core/linker/resolved_metadata_cache\":137,\"angular2/src/facade/lang\":176}],82:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar ng_zone_1 = require('angular2/src/core/zone/ng_zone');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar application_tokens_1 = require('./application_tokens');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar testability_1 = require('angular2/src/core/testability/testability');\r\nvar dynamic_component_loader_1 = require('angular2/src/core/linker/dynamic_component_loader');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar console_1 = require('angular2/src/core/console');\r\nvar profile_1 = require('./profile/profile');\r\nvar lang_2 = require('angular2/src/facade/lang');\r\n/**\r\n * Construct providers specific to an individual root component.\r\n */\r\nfunction _componentProviders(appComponentType) {\r\n    return [\r\n        di_1.provide(application_tokens_1.APP_COMPONENT, { useValue: appComponentType }),\r\n        di_1.provide(application_tokens_1.APP_COMPONENT_REF_PROMISE, {\r\n            useFactory: function (dynamicComponentLoader, appRef, injector) {\r\n                // Save the ComponentRef for disposal later.\r\n                var ref;\r\n                // TODO(rado): investigate whether to support providers on root component.\r\n                return dynamicComponentLoader.loadAsRoot(appComponentType, null, injector, function () { appRef._unloadComponent(ref); })\r\n                    .then(function (componentRef) {\r\n                    ref = componentRef;\r\n                    var testability = injector.getOptional(testability_1.Testability);\r\n                    if (lang_1.isPresent(testability)) {\r\n                        injector.get(testability_1.TestabilityRegistry)\r\n                            .registerApplication(componentRef.location.nativeElement, testability);\r\n                    }\r\n                    return componentRef;\r\n                });\r\n            },\r\n            deps: [dynamic_component_loader_1.DynamicComponentLoader, ApplicationRef, di_1.Injector]\r\n        }),\r\n        di_1.provide(appComponentType, {\r\n            useFactory: function (p) { return p.then(function (ref) { return ref.instance; }); },\r\n            deps: [application_tokens_1.APP_COMPONENT_REF_PROMISE]\r\n        }),\r\n    ];\r\n}\r\n/**\r\n * Create an Angular zone.\r\n */\r\nfunction createNgZone() {\r\n    return new ng_zone_1.NgZone({ enableLongStackTrace: lang_1.assertionsEnabled() });\r\n}\r\nexports.createNgZone = createNgZone;\r\nvar _platform;\r\nvar _platformProviders;\r\n/**\r\n * Initialize the Angular 'platform' on the page.\r\n *\r\n * See {@link PlatformRef} for details on the Angular platform.\r\n *\r\n * It is also possible to specify providers to be made in the new platform. These providers\r\n * will be shared between all applications on the page. For example, an abstraction for\r\n * the browser cookie jar should be bound at the platform level, because there is only one\r\n * cookie jar regardless of how many applications on the page will be accessing it.\r\n *\r\n * The platform function can be called multiple times as long as the same list of providers\r\n * is passed into each call. If the platform function is called with a different set of\r\n * provides, Angular will throw an exception.\r\n */\r\nfunction platform(providers) {\r\n    lang_2.lockMode();\r\n    if (lang_1.isPresent(_platform)) {\r\n        if (collection_1.ListWrapper.equals(_platformProviders, providers)) {\r\n            return _platform;\r\n        }\r\n        else {\r\n            throw new exceptions_1.BaseException(\"platform cannot be initialized with different sets of providers.\");\r\n        }\r\n    }\r\n    else {\r\n        return _createPlatform(providers);\r\n    }\r\n}\r\nexports.platform = platform;\r\n/**\r\n * Dispose the existing platform.\r\n */\r\nfunction disposePlatform() {\r\n    if (lang_1.isPresent(_platform)) {\r\n        _platform.dispose();\r\n        _platform = null;\r\n    }\r\n}\r\nexports.disposePlatform = disposePlatform;\r\nfunction _createPlatform(providers) {\r\n    _platformProviders = providers;\r\n    var injector = di_1.Injector.resolveAndCreate(providers);\r\n    _platform = new PlatformRef_(injector, function () {\r\n        _platform = null;\r\n        _platformProviders = null;\r\n    });\r\n    _runPlatformInitializers(injector);\r\n    return _platform;\r\n}\r\nfunction _runPlatformInitializers(injector) {\r\n    var inits = injector.getOptional(application_tokens_1.PLATFORM_INITIALIZER);\r\n    if (lang_1.isPresent(inits))\r\n        inits.forEach(function (init) { return init(); });\r\n}\r\n/**\r\n * The Angular platform is the entry point for Angular on a web page. Each page\r\n * has exactly one platform, and services (such as reflection) which are common\r\n * to every Angular application running on the page are bound in its scope.\r\n *\r\n * A page's platform is initialized implicitly when {@link bootstrap}() is called, or\r\n * explicitly by calling {@link platform}().\r\n */\r\nvar PlatformRef = (function () {\r\n    function PlatformRef() {\r\n    }\r\n    Object.defineProperty(PlatformRef.prototype, \"injector\", {\r\n        /**\r\n         * Retrieve the platform {@link Injector}, which is the parent injector for\r\n         * every Angular application on the page and provides singleton providers.\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    return PlatformRef;\r\n})();\r\nexports.PlatformRef = PlatformRef;\r\nvar PlatformRef_ = (function (_super) {\r\n    __extends(PlatformRef_, _super);\r\n    function PlatformRef_(_injector, _dispose) {\r\n        _super.call(this);\r\n        this._injector = _injector;\r\n        this._dispose = _dispose;\r\n        /** @internal */\r\n        this._applications = [];\r\n        /** @internal */\r\n        this._disposeListeners = [];\r\n    }\r\n    PlatformRef_.prototype.registerDisposeListener = function (dispose) { this._disposeListeners.push(dispose); };\r\n    Object.defineProperty(PlatformRef_.prototype, \"injector\", {\r\n        get: function () { return this._injector; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    PlatformRef_.prototype.application = function (providers) {\r\n        var app = this._initApp(createNgZone(), providers);\r\n        return app;\r\n    };\r\n    PlatformRef_.prototype.asyncApplication = function (bindingFn, additionalProviders) {\r\n        var _this = this;\r\n        var zone = createNgZone();\r\n        var completer = async_1.PromiseWrapper.completer();\r\n        zone.run(function () {\r\n            async_1.PromiseWrapper.then(bindingFn(zone), function (providers) {\r\n                if (lang_1.isPresent(additionalProviders)) {\r\n                    providers = collection_1.ListWrapper.concat(providers, additionalProviders);\r\n                }\r\n                completer.resolve(_this._initApp(zone, providers));\r\n            });\r\n        });\r\n        return completer.promise;\r\n    };\r\n    PlatformRef_.prototype._initApp = function (zone, providers) {\r\n        var _this = this;\r\n        var injector;\r\n        var app;\r\n        zone.run(function () {\r\n            providers = collection_1.ListWrapper.concat(providers, [\r\n                di_1.provide(ng_zone_1.NgZone, { useValue: zone }),\r\n                di_1.provide(ApplicationRef, { useFactory: function () { return app; }, deps: [] })\r\n            ]);\r\n            var exceptionHandler;\r\n            try {\r\n                injector = _this.injector.resolveAndCreateChild(providers);\r\n                exceptionHandler = injector.get(exceptions_1.ExceptionHandler);\r\n                zone.overrideOnErrorHandler(function (e, s) { return exceptionHandler.call(e, s); });\r\n            }\r\n            catch (e) {\r\n                if (lang_1.isPresent(exceptionHandler)) {\r\n                    exceptionHandler.call(e, e.stack);\r\n                }\r\n                else {\r\n                    lang_1.print(e.toString());\r\n                }\r\n            }\r\n        });\r\n        app = new ApplicationRef_(this, zone, injector);\r\n        this._applications.push(app);\r\n        _runAppInitializers(injector);\r\n        return app;\r\n    };\r\n    PlatformRef_.prototype.dispose = function () {\r\n        collection_1.ListWrapper.clone(this._applications).forEach(function (app) { return app.dispose(); });\r\n        this._disposeListeners.forEach(function (dispose) { return dispose(); });\r\n        this._dispose();\r\n    };\r\n    /** @internal */\r\n    PlatformRef_.prototype._applicationDisposed = function (app) { collection_1.ListWrapper.remove(this._applications, app); };\r\n    return PlatformRef_;\r\n})(PlatformRef);\r\nexports.PlatformRef_ = PlatformRef_;\r\nfunction _runAppInitializers(injector) {\r\n    var inits = injector.getOptional(application_tokens_1.APP_INITIALIZER);\r\n    if (lang_1.isPresent(inits))\r\n        inits.forEach(function (init) { return init(); });\r\n}\r\n/**\r\n * A reference to an Angular application running on a page.\r\n *\r\n * For more about Angular applications, see the documentation for {@link bootstrap}.\r\n */\r\nvar ApplicationRef = (function () {\r\n    function ApplicationRef() {\r\n    }\r\n    Object.defineProperty(ApplicationRef.prototype, \"injector\", {\r\n        /**\r\n         * Retrieve the application {@link Injector}.\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    Object.defineProperty(ApplicationRef.prototype, \"zone\", {\r\n        /**\r\n         * Retrieve the application {@link NgZone}.\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    Object.defineProperty(ApplicationRef.prototype, \"componentTypes\", {\r\n        /**\r\n         * Get a list of component types registered to this application.\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    return ApplicationRef;\r\n})();\r\nexports.ApplicationRef = ApplicationRef;\r\nvar ApplicationRef_ = (function (_super) {\r\n    __extends(ApplicationRef_, _super);\r\n    function ApplicationRef_(_platform, _zone, _injector) {\r\n        var _this = this;\r\n        _super.call(this);\r\n        this._platform = _platform;\r\n        this._zone = _zone;\r\n        this._injector = _injector;\r\n        /** @internal */\r\n        this._bootstrapListeners = [];\r\n        /** @internal */\r\n        this._disposeListeners = [];\r\n        /** @internal */\r\n        this._rootComponents = [];\r\n        /** @internal */\r\n        this._rootComponentTypes = [];\r\n        /** @internal */\r\n        this._changeDetectorRefs = [];\r\n        /** @internal */\r\n        this._runningTick = false;\r\n        /** @internal */\r\n        this._enforceNoNewChanges = false;\r\n        if (lang_1.isPresent(this._zone)) {\r\n            async_1.ObservableWrapper.subscribe(this._zone.onTurnDone, function (_) { _this._zone.run(function () { _this.tick(); }); });\r\n        }\r\n        this._enforceNoNewChanges = lang_1.assertionsEnabled();\r\n    }\r\n    ApplicationRef_.prototype.registerBootstrapListener = function (listener) {\r\n        this._bootstrapListeners.push(listener);\r\n    };\r\n    ApplicationRef_.prototype.registerDisposeListener = function (dispose) { this._disposeListeners.push(dispose); };\r\n    ApplicationRef_.prototype.registerChangeDetector = function (changeDetector) {\r\n        this._changeDetectorRefs.push(changeDetector);\r\n    };\r\n    ApplicationRef_.prototype.unregisterChangeDetector = function (changeDetector) {\r\n        collection_1.ListWrapper.remove(this._changeDetectorRefs, changeDetector);\r\n    };\r\n    ApplicationRef_.prototype.bootstrap = function (componentType, providers) {\r\n        var _this = this;\r\n        var completer = async_1.PromiseWrapper.completer();\r\n        this._zone.run(function () {\r\n            var componentProviders = _componentProviders(componentType);\r\n            if (lang_1.isPresent(providers)) {\r\n                componentProviders.push(providers);\r\n            }\r\n            var exceptionHandler = _this._injector.get(exceptions_1.ExceptionHandler);\r\n            _this._rootComponentTypes.push(componentType);\r\n            try {\r\n                var injector = _this._injector.resolveAndCreateChild(componentProviders);\r\n                var compRefToken = injector.get(application_tokens_1.APP_COMPONENT_REF_PROMISE);\r\n                var tick = function (componentRef) {\r\n                    _this._loadComponent(componentRef);\r\n                    completer.resolve(componentRef);\r\n                };\r\n                var tickResult = async_1.PromiseWrapper.then(compRefToken, tick);\r\n                // THIS MUST ONLY RUN IN DART.\r\n                // This is required to report an error when no components with a matching selector found.\r\n                // Otherwise the promise will never be completed.\r\n                // Doing this in JS causes an extra error message to appear.\r\n                if (lang_1.IS_DART) {\r\n                    async_1.PromiseWrapper.then(tickResult, function (_) { });\r\n                }\r\n                async_1.PromiseWrapper.then(tickResult, null, function (err, stackTrace) { return completer.reject(err, stackTrace); });\r\n            }\r\n            catch (e) {\r\n                exceptionHandler.call(e, e.stack);\r\n                completer.reject(e, e.stack);\r\n            }\r\n        });\r\n        return completer.promise.then(function (_) {\r\n            var c = _this._injector.get(console_1.Console);\r\n            var modeDescription = lang_1.assertionsEnabled() ?\r\n                \"in the development mode. Call enableProdMode() to enable the production mode.\" :\r\n                \"in the production mode. Call enableDevMode() to enable the development mode.\";\r\n            c.log(\"Angular 2 is running \" + modeDescription);\r\n            return _;\r\n        });\r\n    };\r\n    /** @internal */\r\n    ApplicationRef_.prototype._loadComponent = function (ref) {\r\n        var appChangeDetector = ref.location.internalElement.parentView.changeDetector;\r\n        this._changeDetectorRefs.push(appChangeDetector.ref);\r\n        this.tick();\r\n        this._rootComponents.push(ref);\r\n        this._bootstrapListeners.forEach(function (listener) { return listener(ref); });\r\n    };\r\n    /** @internal */\r\n    ApplicationRef_.prototype._unloadComponent = function (ref) {\r\n        if (!collection_1.ListWrapper.contains(this._rootComponents, ref)) {\r\n            return;\r\n        }\r\n        this.unregisterChangeDetector(ref.location.internalElement.parentView.changeDetector.ref);\r\n        collection_1.ListWrapper.remove(this._rootComponents, ref);\r\n    };\r\n    Object.defineProperty(ApplicationRef_.prototype, \"injector\", {\r\n        get: function () { return this._injector; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ApplicationRef_.prototype, \"zone\", {\r\n        get: function () { return this._zone; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ApplicationRef_.prototype.tick = function () {\r\n        if (this._runningTick) {\r\n            throw new exceptions_1.BaseException(\"ApplicationRef.tick is called recursively\");\r\n        }\r\n        var s = ApplicationRef_._tickScope();\r\n        try {\r\n            this._runningTick = true;\r\n            this._changeDetectorRefs.forEach(function (detector) { return detector.detectChanges(); });\r\n            if (this._enforceNoNewChanges) {\r\n                this._changeDetectorRefs.forEach(function (detector) { return detector.checkNoChanges(); });\r\n            }\r\n        }\r\n        finally {\r\n            this._runningTick = false;\r\n            profile_1.wtfLeave(s);\r\n        }\r\n    };\r\n    ApplicationRef_.prototype.dispose = function () {\r\n        // TODO(alxhub): Dispose of the NgZone.\r\n        collection_1.ListWrapper.clone(this._rootComponents).forEach(function (ref) { return ref.dispose(); });\r\n        this._disposeListeners.forEach(function (dispose) { return dispose(); });\r\n        this._platform._applicationDisposed(this);\r\n    };\r\n    Object.defineProperty(ApplicationRef_.prototype, \"componentTypes\", {\r\n        get: function () { return this._rootComponentTypes; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @internal */\r\n    ApplicationRef_._tickScope = profile_1.wtfCreateScope('ApplicationRef#tick()');\r\n    return ApplicationRef_;\r\n})(ApplicationRef);\r\nexports.ApplicationRef_ = ApplicationRef_;\r\n},{\"./application_tokens\":83,\"./profile/profile\":155,\"angular2/src/core/console\":115,\"angular2/src/core/di\":117,\"angular2/src/core/linker/dynamic_component_loader\":131,\"angular2/src/core/testability/testability\":164,\"angular2/src/core/zone/ng_zone\":168,\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],83:[function(require,module,exports){\n'use strict';var di_1 = require('angular2/src/core/di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n *  @internal\r\n */\r\nexports.APP_COMPONENT_REF_PROMISE = lang_1.CONST_EXPR(new di_1.OpaqueToken('Promise<ComponentRef>'));\r\n/**\r\n * An {@link angular2/di/OpaqueToken} representing the application root type in the {@link\r\n * Injector}.\r\n *\r\n * ```\r\n * @Component(...)\r\n * class MyApp {\r\n *   ...\r\n * }\r\n *\r\n * bootstrap(MyApp).then((appRef:ApplicationRef) {\r\n *   expect(appRef.injector.get(appComponentTypeToken)).toEqual(MyApp);\r\n * });\r\n *\r\n * ```\r\n */\r\nexports.APP_COMPONENT = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppComponent'));\r\n/**\r\n * A DI Token representing a unique string id assigned to the application by Angular and used\r\n * primarily for prefixing application attributes and CSS styles when\r\n * {@link ViewEncapsulation#Emulated} is being used.\r\n *\r\n * If you need to avoid randomly generated value to be used as an application id, you can provide\r\n * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}\r\n * using this token.\r\n */\r\nexports.APP_ID = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppId'));\r\nfunction _appIdRandomProviderFactory() {\r\n    return \"\" + _randomChar() + _randomChar() + _randomChar();\r\n}\r\n/**\r\n * Providers that will generate a random APP_ID_TOKEN.\r\n */\r\nexports.APP_ID_RANDOM_PROVIDER = lang_1.CONST_EXPR(new di_1.Provider(exports.APP_ID, { useFactory: _appIdRandomProviderFactory, deps: [] }));\r\nfunction _randomChar() {\r\n    return lang_1.StringWrapper.fromCharCode(97 + lang_1.Math.floor(lang_1.Math.random() * 25));\r\n}\r\n/**\r\n * A function that will be executed when a platform is initialized.\r\n */\r\nexports.PLATFORM_INITIALIZER = lang_1.CONST_EXPR(new di_1.OpaqueToken(\"Platform Initializer\"));\r\n/**\r\n * A function that will be executed when an application is initialized.\r\n */\r\nexports.APP_INITIALIZER = lang_1.CONST_EXPR(new di_1.OpaqueToken(\"Application Initializer\"));\r\n/**\r\n * A token which indicates the root directory of the application\r\n */\r\nexports.PACKAGE_ROOT_URL = lang_1.CONST_EXPR(new di_1.OpaqueToken(\"Application Packages Root URL\"));\r\n},{\"angular2/src/core/di\":117,\"angular2/src/facade/lang\":176}],84:[function(require,module,exports){\n'use strict';/**\r\n * @module\r\n * @description\r\n * Change detection enables data binding in Angular.\r\n */\r\nvar change_detection_1 = require('./change_detection/change_detection');\r\nexports.ChangeDetectionStrategy = change_detection_1.ChangeDetectionStrategy;\r\nexports.ExpressionChangedAfterItHasBeenCheckedException = change_detection_1.ExpressionChangedAfterItHasBeenCheckedException;\r\nexports.ChangeDetectionError = change_detection_1.ChangeDetectionError;\r\nexports.ChangeDetectorRef = change_detection_1.ChangeDetectorRef;\r\nexports.WrappedValue = change_detection_1.WrappedValue;\r\nexports.SimpleChange = change_detection_1.SimpleChange;\r\nexports.IterableDiffers = change_detection_1.IterableDiffers;\r\nexports.KeyValueDiffers = change_detection_1.KeyValueDiffers;\r\n},{\"./change_detection/change_detection\":87}],85:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar change_detection_util_1 = require('./change_detection_util');\r\nvar change_detector_ref_1 = require('./change_detector_ref');\r\nvar exceptions_1 = require('./exceptions');\r\nvar locals_1 = require('./parser/locals');\r\nvar constants_1 = require('./constants');\r\nvar profile_1 = require('../profile/profile');\r\nvar observable_facade_1 = require('./observable_facade');\r\nvar _scope_check = profile_1.wtfCreateScope(\"ChangeDetector#check(ascii id, bool throwOnChange)\");\r\nvar _Context = (function () {\r\n    function _Context(element, componentElement, context, locals, injector, expression) {\r\n        this.element = element;\r\n        this.componentElement = componentElement;\r\n        this.context = context;\r\n        this.locals = locals;\r\n        this.injector = injector;\r\n        this.expression = expression;\r\n    }\r\n    return _Context;\r\n})();\r\nvar AbstractChangeDetector = (function () {\r\n    function AbstractChangeDetector(id, numberOfPropertyProtoRecords, bindingTargets, directiveIndices, strategy) {\r\n        this.id = id;\r\n        this.numberOfPropertyProtoRecords = numberOfPropertyProtoRecords;\r\n        this.bindingTargets = bindingTargets;\r\n        this.directiveIndices = directiveIndices;\r\n        this.strategy = strategy;\r\n        this.contentChildren = [];\r\n        this.viewChildren = [];\r\n        // The names of the below fields must be kept in sync with codegen_name_util.ts or\r\n        // change detection will fail.\r\n        this.state = constants_1.ChangeDetectorState.NeverChecked;\r\n        this.locals = null;\r\n        this.mode = null;\r\n        this.pipes = null;\r\n        this.ref = new change_detector_ref_1.ChangeDetectorRef_(this);\r\n    }\r\n    AbstractChangeDetector.prototype.addContentChild = function (cd) {\r\n        this.contentChildren.push(cd);\r\n        cd.parent = this;\r\n    };\r\n    AbstractChangeDetector.prototype.removeContentChild = function (cd) { collection_1.ListWrapper.remove(this.contentChildren, cd); };\r\n    AbstractChangeDetector.prototype.addViewChild = function (cd) {\r\n        this.viewChildren.push(cd);\r\n        cd.parent = this;\r\n    };\r\n    AbstractChangeDetector.prototype.removeViewChild = function (cd) { collection_1.ListWrapper.remove(this.viewChildren, cd); };\r\n    AbstractChangeDetector.prototype.remove = function () { this.parent.removeContentChild(this); };\r\n    AbstractChangeDetector.prototype.handleEvent = function (eventName, elIndex, event) {\r\n        if (!this.hydrated()) {\r\n            return true;\r\n        }\r\n        try {\r\n            var locals = new Map();\r\n            locals.set('$event', event);\r\n            var res = !this.handleEventInternal(eventName, elIndex, new locals_1.Locals(this.locals, locals));\r\n            this.markPathToRootAsCheckOnce();\r\n            return res;\r\n        }\r\n        catch (e) {\r\n            var c = this.dispatcher.getDebugContext(null, elIndex, null);\r\n            var context = lang_1.isPresent(c) ?\r\n                new exceptions_1.EventEvaluationErrorContext(c.element, c.componentElement, c.context, c.locals, c.injector) :\r\n                null;\r\n            throw new exceptions_1.EventEvaluationError(eventName, e, e.stack, context);\r\n        }\r\n    };\r\n    AbstractChangeDetector.prototype.handleEventInternal = function (eventName, elIndex, locals) { return false; };\r\n    AbstractChangeDetector.prototype.detectChanges = function () { this.runDetectChanges(false); };\r\n    AbstractChangeDetector.prototype.checkNoChanges = function () {\r\n        if (lang_1.assertionsEnabled()) {\r\n            this.runDetectChanges(true);\r\n        }\r\n    };\r\n    AbstractChangeDetector.prototype.runDetectChanges = function (throwOnChange) {\r\n        if (this.mode === constants_1.ChangeDetectionStrategy.Detached ||\r\n            this.mode === constants_1.ChangeDetectionStrategy.Checked || this.state === constants_1.ChangeDetectorState.Errored)\r\n            return;\r\n        var s = _scope_check(this.id, throwOnChange);\r\n        this.detectChangesInRecords(throwOnChange);\r\n        this._detectChangesContentChildren(throwOnChange);\r\n        if (!throwOnChange)\r\n            this.afterContentLifecycleCallbacks();\r\n        this._detectChangesInViewChildren(throwOnChange);\r\n        if (!throwOnChange)\r\n            this.afterViewLifecycleCallbacks();\r\n        if (this.mode === constants_1.ChangeDetectionStrategy.CheckOnce)\r\n            this.mode = constants_1.ChangeDetectionStrategy.Checked;\r\n        this.state = constants_1.ChangeDetectorState.CheckedBefore;\r\n        profile_1.wtfLeave(s);\r\n    };\r\n    // This method is not intended to be overridden. Subclasses should instead provide an\r\n    // implementation of `detectChangesInRecordsInternal` which does the work of detecting changes\r\n    // and which this method will call.\r\n    // This method expects that `detectChangesInRecordsInternal` will set the property\r\n    // `this.propertyBindingIndex` to the propertyBindingIndex of the first proto record. This is to\r\n    // facilitate error reporting.\r\n    AbstractChangeDetector.prototype.detectChangesInRecords = function (throwOnChange) {\r\n        if (!this.hydrated()) {\r\n            this.throwDehydratedError();\r\n        }\r\n        try {\r\n            this.detectChangesInRecordsInternal(throwOnChange);\r\n        }\r\n        catch (e) {\r\n            // throwOnChange errors aren't counted as fatal errors.\r\n            if (!(e instanceof exceptions_1.ExpressionChangedAfterItHasBeenCheckedException)) {\r\n                this.state = constants_1.ChangeDetectorState.Errored;\r\n            }\r\n            this._throwError(e, e.stack);\r\n        }\r\n    };\r\n    // Subclasses should override this method to perform any work necessary to detect and report\r\n    // changes. For example, changes should be reported via `ChangeDetectionUtil.addChange`, lifecycle\r\n    // methods should be called, etc.\r\n    // This implementation should also set `this.propertyBindingIndex` to the propertyBindingIndex of\r\n    // the\r\n    // first proto record to facilitate error reporting. See {@link #detectChangesInRecords}.\r\n    AbstractChangeDetector.prototype.detectChangesInRecordsInternal = function (throwOnChange) { };\r\n    // This method is not intended to be overridden. Subclasses should instead provide an\r\n    // implementation of `hydrateDirectives`.\r\n    AbstractChangeDetector.prototype.hydrate = function (context, locals, dispatcher, pipes) {\r\n        this.dispatcher = dispatcher;\r\n        this.mode = change_detection_util_1.ChangeDetectionUtil.changeDetectionMode(this.strategy);\r\n        this.context = context;\r\n        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {\r\n            this.observeComponent(context);\r\n        }\r\n        this.locals = locals;\r\n        this.pipes = pipes;\r\n        this.hydrateDirectives(dispatcher);\r\n        this.state = constants_1.ChangeDetectorState.NeverChecked;\r\n    };\r\n    // Subclasses should override this method to hydrate any directives.\r\n    AbstractChangeDetector.prototype.hydrateDirectives = function (dispatcher) { };\r\n    // This method is not intended to be overridden. Subclasses should instead provide an\r\n    // implementation of `dehydrateDirectives`.\r\n    AbstractChangeDetector.prototype.dehydrate = function () {\r\n        this.dehydrateDirectives(true);\r\n        // This is an experimental feature. Works only in Dart.\r\n        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {\r\n            this._unsubsribeFromObservables();\r\n        }\r\n        this.dispatcher = null;\r\n        this.context = null;\r\n        this.locals = null;\r\n        this.pipes = null;\r\n    };\r\n    // Subclasses should override this method to dehydrate any directives. This method should reverse\r\n    // any work done in `hydrateDirectives`.\r\n    AbstractChangeDetector.prototype.dehydrateDirectives = function (destroyPipes) { };\r\n    AbstractChangeDetector.prototype.hydrated = function () { return lang_1.isPresent(this.context); };\r\n    AbstractChangeDetector.prototype.destroyRecursive = function () {\r\n        this.dispatcher.notifyOnDestroy();\r\n        this.dehydrate();\r\n        var children = this.contentChildren;\r\n        for (var i = 0; i < children.length; i++) {\r\n            children[i].destroyRecursive();\r\n        }\r\n        children = this.viewChildren;\r\n        for (var i = 0; i < children.length; i++) {\r\n            children[i].destroyRecursive();\r\n        }\r\n    };\r\n    AbstractChangeDetector.prototype.afterContentLifecycleCallbacks = function () {\r\n        this.dispatcher.notifyAfterContentChecked();\r\n        this.afterContentLifecycleCallbacksInternal();\r\n    };\r\n    AbstractChangeDetector.prototype.afterContentLifecycleCallbacksInternal = function () { };\r\n    AbstractChangeDetector.prototype.afterViewLifecycleCallbacks = function () {\r\n        this.dispatcher.notifyAfterViewChecked();\r\n        this.afterViewLifecycleCallbacksInternal();\r\n    };\r\n    AbstractChangeDetector.prototype.afterViewLifecycleCallbacksInternal = function () { };\r\n    /** @internal */\r\n    AbstractChangeDetector.prototype._detectChangesContentChildren = function (throwOnChange) {\r\n        var c = this.contentChildren;\r\n        for (var i = 0; i < c.length; ++i) {\r\n            c[i].runDetectChanges(throwOnChange);\r\n        }\r\n    };\r\n    /** @internal */\r\n    AbstractChangeDetector.prototype._detectChangesInViewChildren = function (throwOnChange) {\r\n        var c = this.viewChildren;\r\n        for (var i = 0; i < c.length; ++i) {\r\n            c[i].runDetectChanges(throwOnChange);\r\n        }\r\n    };\r\n    AbstractChangeDetector.prototype.markAsCheckOnce = function () { this.mode = constants_1.ChangeDetectionStrategy.CheckOnce; };\r\n    AbstractChangeDetector.prototype.markPathToRootAsCheckOnce = function () {\r\n        var c = this;\r\n        while (lang_1.isPresent(c) && c.mode !== constants_1.ChangeDetectionStrategy.Detached) {\r\n            if (c.mode === constants_1.ChangeDetectionStrategy.Checked)\r\n                c.mode = constants_1.ChangeDetectionStrategy.CheckOnce;\r\n            c = c.parent;\r\n        }\r\n    };\r\n    // This is an experimental feature. Works only in Dart.\r\n    AbstractChangeDetector.prototype._unsubsribeFromObservables = function () {\r\n        if (lang_1.isPresent(this.subscriptions)) {\r\n            for (var i = 0; i < this.subscriptions.length; ++i) {\r\n                var s = this.subscriptions[i];\r\n                if (lang_1.isPresent(this.subscriptions[i])) {\r\n                    s.cancel();\r\n                    this.subscriptions[i] = null;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // This is an experimental feature. Works only in Dart.\r\n    AbstractChangeDetector.prototype.observeValue = function (value, index) {\r\n        var _this = this;\r\n        if (observable_facade_1.isObservable(value)) {\r\n            this._createArrayToStoreObservables();\r\n            if (lang_1.isBlank(this.subscriptions[index])) {\r\n                this.streams[index] = value.changes;\r\n                this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });\r\n            }\r\n            else if (this.streams[index] !== value.changes) {\r\n                this.subscriptions[index].cancel();\r\n                this.streams[index] = value.changes;\r\n                this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n    // This is an experimental feature. Works only in Dart.\r\n    AbstractChangeDetector.prototype.observeDirective = function (value, index) {\r\n        var _this = this;\r\n        if (observable_facade_1.isObservable(value)) {\r\n            this._createArrayToStoreObservables();\r\n            var arrayIndex = this.numberOfPropertyProtoRecords + index + 2; // +1 is component\r\n            this.streams[arrayIndex] = value.changes;\r\n            this.subscriptions[arrayIndex] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });\r\n        }\r\n        return value;\r\n    };\r\n    // This is an experimental feature. Works only in Dart.\r\n    AbstractChangeDetector.prototype.observeComponent = function (value) {\r\n        var _this = this;\r\n        if (observable_facade_1.isObservable(value)) {\r\n            this._createArrayToStoreObservables();\r\n            var index = this.numberOfPropertyProtoRecords + 1;\r\n            this.streams[index] = value.changes;\r\n            this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });\r\n        }\r\n        return value;\r\n    };\r\n    AbstractChangeDetector.prototype._createArrayToStoreObservables = function () {\r\n        if (lang_1.isBlank(this.subscriptions)) {\r\n            this.subscriptions = collection_1.ListWrapper.createFixedSize(this.numberOfPropertyProtoRecords +\r\n                this.directiveIndices.length + 2);\r\n            this.streams = collection_1.ListWrapper.createFixedSize(this.numberOfPropertyProtoRecords +\r\n                this.directiveIndices.length + 2);\r\n        }\r\n    };\r\n    AbstractChangeDetector.prototype.getDirectiveFor = function (directives, index) {\r\n        return directives.getDirectiveFor(this.directiveIndices[index]);\r\n    };\r\n    AbstractChangeDetector.prototype.getDetectorFor = function (directives, index) {\r\n        return directives.getDetectorFor(this.directiveIndices[index]);\r\n    };\r\n    AbstractChangeDetector.prototype.notifyDispatcher = function (value) {\r\n        this.dispatcher.notifyOnBinding(this._currentBinding(), value);\r\n    };\r\n    AbstractChangeDetector.prototype.logBindingUpdate = function (value) {\r\n        this.dispatcher.logBindingUpdate(this._currentBinding(), value);\r\n    };\r\n    AbstractChangeDetector.prototype.addChange = function (changes, oldValue, newValue) {\r\n        if (lang_1.isBlank(changes)) {\r\n            changes = {};\r\n        }\r\n        changes[this._currentBinding().name] = change_detection_util_1.ChangeDetectionUtil.simpleChange(oldValue, newValue);\r\n        return changes;\r\n    };\r\n    AbstractChangeDetector.prototype._throwError = function (exception, stack) {\r\n        var error;\r\n        try {\r\n            var c = this.dispatcher.getDebugContext(null, this._currentBinding().elementIndex, null);\r\n            var context = lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals, c.injector, this._currentBinding().debug) :\r\n                null;\r\n            error = new exceptions_1.ChangeDetectionError(this._currentBinding().debug, exception, stack, context);\r\n        }\r\n        catch (e) {\r\n            // if an error happens during getting the debug context, we throw a ChangeDetectionError\r\n            // without the extra information.\r\n            error = new exceptions_1.ChangeDetectionError(null, exception, stack, null);\r\n        }\r\n        throw error;\r\n    };\r\n    AbstractChangeDetector.prototype.throwOnChangeError = function (oldValue, newValue) {\r\n        throw new exceptions_1.ExpressionChangedAfterItHasBeenCheckedException(this._currentBinding().debug, oldValue, newValue, null);\r\n    };\r\n    AbstractChangeDetector.prototype.throwDehydratedError = function () { throw new exceptions_1.DehydratedException(); };\r\n    AbstractChangeDetector.prototype._currentBinding = function () {\r\n        return this.bindingTargets[this.propertyBindingIndex];\r\n    };\r\n    return AbstractChangeDetector;\r\n})();\r\nexports.AbstractChangeDetector = AbstractChangeDetector;\r\n},{\"../profile/profile\":155,\"./change_detection_util\":89,\"./change_detector_ref\":90,\"./constants\":95,\"./exceptions\":103,\"./observable_facade\":106,\"./parser/locals\":109,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],86:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar DIRECTIVE_LIFECYCLE = \"directiveLifecycle\";\r\nvar BINDING = \"native\";\r\nvar DIRECTIVE = \"directive\";\r\nvar ELEMENT_PROPERTY = \"elementProperty\";\r\nvar ELEMENT_ATTRIBUTE = \"elementAttribute\";\r\nvar ELEMENT_CLASS = \"elementClass\";\r\nvar ELEMENT_STYLE = \"elementStyle\";\r\nvar TEXT_NODE = \"textNode\";\r\nvar EVENT = \"event\";\r\nvar HOST_EVENT = \"hostEvent\";\r\nvar BindingTarget = (function () {\r\n    function BindingTarget(mode, elementIndex, name, unit, debug) {\r\n        this.mode = mode;\r\n        this.elementIndex = elementIndex;\r\n        this.name = name;\r\n        this.unit = unit;\r\n        this.debug = debug;\r\n    }\r\n    BindingTarget.prototype.isDirective = function () { return this.mode === DIRECTIVE; };\r\n    BindingTarget.prototype.isElementProperty = function () { return this.mode === ELEMENT_PROPERTY; };\r\n    BindingTarget.prototype.isElementAttribute = function () { return this.mode === ELEMENT_ATTRIBUTE; };\r\n    BindingTarget.prototype.isElementClass = function () { return this.mode === ELEMENT_CLASS; };\r\n    BindingTarget.prototype.isElementStyle = function () { return this.mode === ELEMENT_STYLE; };\r\n    BindingTarget.prototype.isTextNode = function () { return this.mode === TEXT_NODE; };\r\n    return BindingTarget;\r\n})();\r\nexports.BindingTarget = BindingTarget;\r\nvar BindingRecord = (function () {\r\n    function BindingRecord(mode, target, implicitReceiver, ast, setter, lifecycleEvent, directiveRecord) {\r\n        this.mode = mode;\r\n        this.target = target;\r\n        this.implicitReceiver = implicitReceiver;\r\n        this.ast = ast;\r\n        this.setter = setter;\r\n        this.lifecycleEvent = lifecycleEvent;\r\n        this.directiveRecord = directiveRecord;\r\n    }\r\n    BindingRecord.prototype.isDirectiveLifecycle = function () { return this.mode === DIRECTIVE_LIFECYCLE; };\r\n    BindingRecord.prototype.callOnChanges = function () {\r\n        return lang_1.isPresent(this.directiveRecord) && this.directiveRecord.callOnChanges;\r\n    };\r\n    BindingRecord.prototype.isDefaultChangeDetection = function () {\r\n        return lang_1.isBlank(this.directiveRecord) || this.directiveRecord.isDefaultChangeDetection();\r\n    };\r\n    BindingRecord.createDirectiveDoCheck = function (directiveRecord) {\r\n        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, \"DoCheck\", directiveRecord);\r\n    };\r\n    BindingRecord.createDirectiveOnInit = function (directiveRecord) {\r\n        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, \"OnInit\", directiveRecord);\r\n    };\r\n    BindingRecord.createDirectiveOnChanges = function (directiveRecord) {\r\n        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, \"OnChanges\", directiveRecord);\r\n    };\r\n    BindingRecord.createForDirective = function (ast, propertyName, setter, directiveRecord) {\r\n        var elementIndex = directiveRecord.directiveIndex.elementIndex;\r\n        var t = new BindingTarget(DIRECTIVE, elementIndex, propertyName, null, ast.toString());\r\n        return new BindingRecord(DIRECTIVE, t, 0, ast, setter, null, directiveRecord);\r\n    };\r\n    BindingRecord.createForElementProperty = function (ast, elementIndex, propertyName) {\r\n        var t = new BindingTarget(ELEMENT_PROPERTY, elementIndex, propertyName, null, ast.toString());\r\n        return new BindingRecord(BINDING, t, 0, ast, null, null, null);\r\n    };\r\n    BindingRecord.createForElementAttribute = function (ast, elementIndex, attributeName) {\r\n        var t = new BindingTarget(ELEMENT_ATTRIBUTE, elementIndex, attributeName, null, ast.toString());\r\n        return new BindingRecord(BINDING, t, 0, ast, null, null, null);\r\n    };\r\n    BindingRecord.createForElementClass = function (ast, elementIndex, className) {\r\n        var t = new BindingTarget(ELEMENT_CLASS, elementIndex, className, null, ast.toString());\r\n        return new BindingRecord(BINDING, t, 0, ast, null, null, null);\r\n    };\r\n    BindingRecord.createForElementStyle = function (ast, elementIndex, styleName, unit) {\r\n        var t = new BindingTarget(ELEMENT_STYLE, elementIndex, styleName, unit, ast.toString());\r\n        return new BindingRecord(BINDING, t, 0, ast, null, null, null);\r\n    };\r\n    BindingRecord.createForHostProperty = function (directiveIndex, ast, propertyName) {\r\n        var t = new BindingTarget(ELEMENT_PROPERTY, directiveIndex.elementIndex, propertyName, null, ast.toString());\r\n        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);\r\n    };\r\n    BindingRecord.createForHostAttribute = function (directiveIndex, ast, attributeName) {\r\n        var t = new BindingTarget(ELEMENT_ATTRIBUTE, directiveIndex.elementIndex, attributeName, null, ast.toString());\r\n        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);\r\n    };\r\n    BindingRecord.createForHostClass = function (directiveIndex, ast, className) {\r\n        var t = new BindingTarget(ELEMENT_CLASS, directiveIndex.elementIndex, className, null, ast.toString());\r\n        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);\r\n    };\r\n    BindingRecord.createForHostStyle = function (directiveIndex, ast, styleName, unit) {\r\n        var t = new BindingTarget(ELEMENT_STYLE, directiveIndex.elementIndex, styleName, unit, ast.toString());\r\n        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);\r\n    };\r\n    BindingRecord.createForTextNode = function (ast, elementIndex) {\r\n        var t = new BindingTarget(TEXT_NODE, elementIndex, null, null, ast.toString());\r\n        return new BindingRecord(BINDING, t, 0, ast, null, null, null);\r\n    };\r\n    BindingRecord.createForEvent = function (ast, eventName, elementIndex) {\r\n        var t = new BindingTarget(EVENT, elementIndex, eventName, null, ast.toString());\r\n        return new BindingRecord(EVENT, t, 0, ast, null, null, null);\r\n    };\r\n    BindingRecord.createForHostEvent = function (ast, eventName, directiveRecord) {\r\n        var directiveIndex = directiveRecord.directiveIndex;\r\n        var t = new BindingTarget(HOST_EVENT, directiveIndex.elementIndex, eventName, null, ast.toString());\r\n        return new BindingRecord(HOST_EVENT, t, directiveIndex, ast, null, null, directiveRecord);\r\n    };\r\n    return BindingRecord;\r\n})();\r\nexports.BindingRecord = BindingRecord;\r\n},{\"angular2/src/facade/lang\":176}],87:[function(require,module,exports){\n'use strict';var iterable_differs_1 = require('./differs/iterable_differs');\r\nvar default_iterable_differ_1 = require('./differs/default_iterable_differ');\r\nvar keyvalue_differs_1 = require('./differs/keyvalue_differs');\r\nvar default_keyvalue_differ_1 = require('./differs/default_keyvalue_differ');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar ast_1 = require('./parser/ast');\r\nexports.ASTWithSource = ast_1.ASTWithSource;\r\nexports.AST = ast_1.AST;\r\nexports.AstTransformer = ast_1.AstTransformer;\r\nexports.PropertyRead = ast_1.PropertyRead;\r\nexports.LiteralArray = ast_1.LiteralArray;\r\nexports.ImplicitReceiver = ast_1.ImplicitReceiver;\r\nvar lexer_1 = require('./parser/lexer');\r\nexports.Lexer = lexer_1.Lexer;\r\nvar parser_1 = require('./parser/parser');\r\nexports.Parser = parser_1.Parser;\r\nvar locals_1 = require('./parser/locals');\r\nexports.Locals = locals_1.Locals;\r\nvar exceptions_1 = require('./exceptions');\r\nexports.DehydratedException = exceptions_1.DehydratedException;\r\nexports.ExpressionChangedAfterItHasBeenCheckedException = exceptions_1.ExpressionChangedAfterItHasBeenCheckedException;\r\nexports.ChangeDetectionError = exceptions_1.ChangeDetectionError;\r\nvar interfaces_1 = require('./interfaces');\r\nexports.ChangeDetectorDefinition = interfaces_1.ChangeDetectorDefinition;\r\nexports.DebugContext = interfaces_1.DebugContext;\r\nexports.ChangeDetectorGenConfig = interfaces_1.ChangeDetectorGenConfig;\r\nvar constants_1 = require('./constants');\r\nexports.ChangeDetectionStrategy = constants_1.ChangeDetectionStrategy;\r\nexports.CHANGE_DETECTION_STRATEGY_VALUES = constants_1.CHANGE_DETECTION_STRATEGY_VALUES;\r\nvar proto_change_detector_1 = require('./proto_change_detector');\r\nexports.DynamicProtoChangeDetector = proto_change_detector_1.DynamicProtoChangeDetector;\r\nvar jit_proto_change_detector_1 = require('./jit_proto_change_detector');\r\nexports.JitProtoChangeDetector = jit_proto_change_detector_1.JitProtoChangeDetector;\r\nvar binding_record_1 = require('./binding_record');\r\nexports.BindingRecord = binding_record_1.BindingRecord;\r\nexports.BindingTarget = binding_record_1.BindingTarget;\r\nvar directive_record_1 = require('./directive_record');\r\nexports.DirectiveIndex = directive_record_1.DirectiveIndex;\r\nexports.DirectiveRecord = directive_record_1.DirectiveRecord;\r\nvar dynamic_change_detector_1 = require('./dynamic_change_detector');\r\nexports.DynamicChangeDetector = dynamic_change_detector_1.DynamicChangeDetector;\r\nvar change_detector_ref_1 = require('./change_detector_ref');\r\nexports.ChangeDetectorRef = change_detector_ref_1.ChangeDetectorRef;\r\nvar iterable_differs_2 = require('./differs/iterable_differs');\r\nexports.IterableDiffers = iterable_differs_2.IterableDiffers;\r\nvar keyvalue_differs_2 = require('./differs/keyvalue_differs');\r\nexports.KeyValueDiffers = keyvalue_differs_2.KeyValueDiffers;\r\nvar change_detection_util_1 = require('./change_detection_util');\r\nexports.WrappedValue = change_detection_util_1.WrappedValue;\r\nexports.SimpleChange = change_detection_util_1.SimpleChange;\r\n/**\r\n * Structural diffing for `Object`s and `Map`s.\r\n */\r\nexports.keyValDiff = lang_1.CONST_EXPR([lang_1.CONST_EXPR(new default_keyvalue_differ_1.DefaultKeyValueDifferFactory())]);\r\n/**\r\n * Structural diffing for `Iterable` types such as `Array`s.\r\n */\r\nexports.iterableDiff = lang_1.CONST_EXPR([lang_1.CONST_EXPR(new default_iterable_differ_1.DefaultIterableDifferFactory())]);\r\nexports.defaultIterableDiffers = lang_1.CONST_EXPR(new iterable_differs_1.IterableDiffers(exports.iterableDiff));\r\nexports.defaultKeyValueDiffers = lang_1.CONST_EXPR(new keyvalue_differs_1.KeyValueDiffers(exports.keyValDiff));\r\n},{\"./binding_record\":86,\"./change_detection_util\":89,\"./change_detector_ref\":90,\"./constants\":95,\"./differs/default_iterable_differ\":96,\"./differs/default_keyvalue_differ\":97,\"./differs/iterable_differs\":98,\"./differs/keyvalue_differs\":99,\"./directive_record\":100,\"./dynamic_change_detector\":101,\"./exceptions\":103,\"./interfaces\":104,\"./jit_proto_change_detector\":105,\"./parser/ast\":107,\"./parser/lexer\":108,\"./parser/locals\":109,\"./parser/parser\":110,\"./proto_change_detector\":113,\"angular2/src/facade/lang\":176}],88:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar abstract_change_detector_1 = require('./abstract_change_detector');\r\nvar change_detection_util_1 = require('./change_detection_util');\r\nvar proto_record_1 = require('./proto_record');\r\nvar codegen_name_util_1 = require('./codegen_name_util');\r\nvar codegen_logic_util_1 = require('./codegen_logic_util');\r\nvar codegen_facade_1 = require('./codegen_facade');\r\nvar constants_1 = require('./constants');\r\nvar proto_change_detector_1 = require('./proto_change_detector');\r\n/**\r\n * The code generator takes a list of proto records and creates a function/class\r\n * that \"emulates\" what the developer would write by hand to implement the same\r\n * kind of behaviour.\r\n *\r\n * This code should be kept in sync with the Dart transformer's\r\n * `angular2.transform.template_compiler.change_detector_codegen` library. If you make updates\r\n * here, please make equivalent changes there.\r\n*/\r\nvar IS_CHANGED_LOCAL = \"isChanged\";\r\nvar CHANGES_LOCAL = \"changes\";\r\nvar ChangeDetectorJITGenerator = (function () {\r\n    function ChangeDetectorJITGenerator(definition, changeDetectionUtilVarName, abstractChangeDetectorVarName, changeDetectorStateVarName) {\r\n        this.changeDetectionUtilVarName = changeDetectionUtilVarName;\r\n        this.abstractChangeDetectorVarName = abstractChangeDetectorVarName;\r\n        this.changeDetectorStateVarName = changeDetectorStateVarName;\r\n        var propertyBindingRecords = proto_change_detector_1.createPropertyRecords(definition);\r\n        var eventBindingRecords = proto_change_detector_1.createEventRecords(definition);\r\n        var propertyBindingTargets = definition.bindingRecords.map(function (b) { return b.target; });\r\n        this.id = definition.id;\r\n        this.changeDetectionStrategy = definition.strategy;\r\n        this.genConfig = definition.genConfig;\r\n        this.records = propertyBindingRecords;\r\n        this.propertyBindingTargets = propertyBindingTargets;\r\n        this.eventBindings = eventBindingRecords;\r\n        this.directiveRecords = definition.directiveRecords;\r\n        this._names = new codegen_name_util_1.CodegenNameUtil(this.records, this.eventBindings, this.directiveRecords, this.changeDetectionUtilVarName);\r\n        this._logic =\r\n            new codegen_logic_util_1.CodegenLogicUtil(this._names, this.changeDetectionUtilVarName, this.changeDetectorStateVarName, this.changeDetectionStrategy);\r\n        this.typeName = codegen_name_util_1.sanitizeName(\"ChangeDetector_\" + this.id);\r\n    }\r\n    ChangeDetectorJITGenerator.prototype.generate = function () {\r\n        var factorySource = \"\\n      \" + this.generateSource() + \"\\n      return function() {\\n        return new \" + this.typeName + \"();\\n      }\\n    \";\r\n        return new Function(this.abstractChangeDetectorVarName, this.changeDetectionUtilVarName, this.changeDetectorStateVarName, factorySource)(abstract_change_detector_1.AbstractChangeDetector, change_detection_util_1.ChangeDetectionUtil, constants_1.ChangeDetectorState);\r\n    };\r\n    ChangeDetectorJITGenerator.prototype.generateSource = function () {\r\n        return \"\\n      var \" + this.typeName + \" = function \" + this.typeName + \"() {\\n        \" + this.abstractChangeDetectorVarName + \".call(\\n            this, \" + JSON.stringify(this.id) + \", \" + this.records.length + \",\\n            \" + this.typeName + \".gen_propertyBindingTargets, \" + this.typeName + \".gen_directiveIndices,\\n            \" + codegen_facade_1.codify(this.changeDetectionStrategy) + \");\\n        this.dehydrateDirectives(false);\\n      }\\n\\n      \" + this.typeName + \".prototype = Object.create(\" + this.abstractChangeDetectorVarName + \".prototype);\\n\\n      \" + this.typeName + \".prototype.detectChangesInRecordsInternal = function(throwOnChange) {\\n        \" + this._names.genInitLocals() + \"\\n        var \" + IS_CHANGED_LOCAL + \" = false;\\n        var \" + CHANGES_LOCAL + \" = null;\\n\\n        \" + this._genAllRecords(this.records) + \"\\n      }\\n\\n      \" + this._maybeGenHandleEventInternal() + \"\\n\\n      \" + this._maybeGenAfterContentLifecycleCallbacks() + \"\\n\\n      \" + this._maybeGenAfterViewLifecycleCallbacks() + \"\\n\\n      \" + this._maybeGenHydrateDirectives() + \"\\n\\n      \" + this._maybeGenDehydrateDirectives() + \"\\n\\n      \" + this._genPropertyBindingTargets() + \"\\n\\n      \" + this._genDirectiveIndices() + \"\\n    \";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genPropertyBindingTargets = function () {\r\n        var targets = this._logic.genPropertyBindingTargets(this.propertyBindingTargets, this.genConfig.genDebugInfo);\r\n        return this.typeName + \".gen_propertyBindingTargets = \" + targets + \";\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genDirectiveIndices = function () {\r\n        var indices = this._logic.genDirectiveIndices(this.directiveRecords);\r\n        return this.typeName + \".gen_directiveIndices = \" + indices + \";\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._maybeGenHandleEventInternal = function () {\r\n        var _this = this;\r\n        if (this.eventBindings.length > 0) {\r\n            var handlers = this.eventBindings.map(function (eb) { return _this._genEventBinding(eb); }).join(\"\\n\");\r\n            return \"\\n        \" + this.typeName + \".prototype.handleEventInternal = function(eventName, elIndex, locals) {\\n          var \" + this._names.getPreventDefaultAccesor() + \" = false;\\n          \" + this._names.genInitEventLocals() + \"\\n          \" + handlers + \"\\n          return \" + this._names.getPreventDefaultAccesor() + \";\\n        }\\n      \";\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genEventBinding = function (eb) {\r\n        var _this = this;\r\n        var codes = [];\r\n        this._endOfBlockIdxs = [];\r\n        collection_1.ListWrapper.forEachWithIndex(eb.records, function (r, i) {\r\n            var code;\r\n            if (r.isConditionalSkipRecord()) {\r\n                code = _this._genConditionalSkip(r, _this._names.getEventLocalName(eb, i));\r\n            }\r\n            else if (r.isUnconditionalSkipRecord()) {\r\n                code = _this._genUnconditionalSkip(r);\r\n            }\r\n            else {\r\n                code = _this._genEventBindingEval(eb, r);\r\n            }\r\n            code += _this._genEndOfSkipBlock(i);\r\n            codes.push(code);\r\n        });\r\n        return \"\\n    if (eventName === \\\"\" + eb.eventName + \"\\\" && elIndex === \" + eb.elIndex + \") {\\n      \" + codes.join(\"\\n\") + \"\\n    }\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genEventBindingEval = function (eb, r) {\r\n        if (r.lastInBinding) {\r\n            var evalRecord = this._logic.genEventBindingEvalValue(eb, r);\r\n            var markPath = this._genMarkPathToRootAsCheckOnce(r);\r\n            var prevDefault = this._genUpdatePreventDefault(eb, r);\r\n            return evalRecord + \"\\n\" + markPath + \"\\n\" + prevDefault;\r\n        }\r\n        else {\r\n            return this._logic.genEventBindingEvalValue(eb, r);\r\n        }\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genMarkPathToRootAsCheckOnce = function (r) {\r\n        var br = r.bindingRecord;\r\n        if (br.isDefaultChangeDetection()) {\r\n            return \"\";\r\n        }\r\n        else {\r\n            return this._names.getDetectorName(br.directiveRecord.directiveIndex) + \".markPathToRootAsCheckOnce();\";\r\n        }\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genUpdatePreventDefault = function (eb, r) {\r\n        var local = this._names.getEventLocalName(eb, r.selfIndex);\r\n        return \"if (\" + local + \" === false) { \" + this._names.getPreventDefaultAccesor() + \" = true};\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._maybeGenDehydrateDirectives = function () {\r\n        var destroyPipesCode = this._names.genPipeOnDestroy();\r\n        var destroyDirectivesCode = this._logic.genDirectivesOnDestroy(this.directiveRecords);\r\n        var dehydrateFieldsCode = this._names.genDehydrateFields();\r\n        if (!destroyPipesCode && !destroyDirectivesCode && !dehydrateFieldsCode)\r\n            return '';\r\n        return this.typeName + \".prototype.dehydrateDirectives = function(destroyPipes) {\\n        if (destroyPipes) {\\n          \" + destroyPipesCode + \"\\n          \" + destroyDirectivesCode + \"\\n        }\\n        \" + dehydrateFieldsCode + \"\\n    }\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._maybeGenHydrateDirectives = function () {\r\n        var hydrateDirectivesCode = this._logic.genHydrateDirectives(this.directiveRecords);\r\n        var hydrateDetectorsCode = this._logic.genHydrateDetectors(this.directiveRecords);\r\n        if (!hydrateDirectivesCode && !hydrateDetectorsCode)\r\n            return '';\r\n        return this.typeName + \".prototype.hydrateDirectives = function(directives) {\\n      \" + hydrateDirectivesCode + \"\\n      \" + hydrateDetectorsCode + \"\\n    }\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._maybeGenAfterContentLifecycleCallbacks = function () {\r\n        var notifications = this._logic.genContentLifecycleCallbacks(this.directiveRecords);\r\n        if (notifications.length > 0) {\r\n            var directiveNotifications = notifications.join(\"\\n\");\r\n            return \"\\n        \" + this.typeName + \".prototype.afterContentLifecycleCallbacksInternal = function() {\\n          \" + directiveNotifications + \"\\n        }\\n      \";\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._maybeGenAfterViewLifecycleCallbacks = function () {\r\n        var notifications = this._logic.genViewLifecycleCallbacks(this.directiveRecords);\r\n        if (notifications.length > 0) {\r\n            var directiveNotifications = notifications.join(\"\\n\");\r\n            return \"\\n        \" + this.typeName + \".prototype.afterViewLifecycleCallbacksInternal = function() {\\n          \" + directiveNotifications + \"\\n        }\\n      \";\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genAllRecords = function (rs) {\r\n        var codes = [];\r\n        this._endOfBlockIdxs = [];\r\n        for (var i = 0; i < rs.length; i++) {\r\n            var code = void 0;\r\n            var r = rs[i];\r\n            if (r.isLifeCycleRecord()) {\r\n                code = this._genDirectiveLifecycle(r);\r\n            }\r\n            else if (r.isPipeRecord()) {\r\n                code = this._genPipeCheck(r);\r\n            }\r\n            else if (r.isConditionalSkipRecord()) {\r\n                code = this._genConditionalSkip(r, this._names.getLocalName(r.contextIndex));\r\n            }\r\n            else if (r.isUnconditionalSkipRecord()) {\r\n                code = this._genUnconditionalSkip(r);\r\n            }\r\n            else {\r\n                code = this._genReferenceCheck(r);\r\n            }\r\n            code = \"\\n        \" + this._maybeFirstInBinding(r) + \"\\n        \" + code + \"\\n        \" + this._maybeGenLastInDirective(r) + \"\\n        \" + this._genEndOfSkipBlock(i) + \"\\n      \";\r\n            codes.push(code);\r\n        }\r\n        return codes.join(\"\\n\");\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genConditionalSkip = function (r, condition) {\r\n        var maybeNegate = r.mode === proto_record_1.RecordType.SkipRecordsIf ? '!' : '';\r\n        this._endOfBlockIdxs.push(r.fixedArgs[0] - 1);\r\n        return \"if (\" + maybeNegate + condition + \") {\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genUnconditionalSkip = function (r) {\r\n        this._endOfBlockIdxs.pop();\r\n        this._endOfBlockIdxs.push(r.fixedArgs[0] - 1);\r\n        return \"} else {\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genEndOfSkipBlock = function (protoIndex) {\r\n        if (!collection_1.ListWrapper.isEmpty(this._endOfBlockIdxs)) {\r\n            var endOfBlock = collection_1.ListWrapper.last(this._endOfBlockIdxs);\r\n            if (protoIndex === endOfBlock) {\r\n                this._endOfBlockIdxs.pop();\r\n                return '}';\r\n            }\r\n        }\r\n        return '';\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genDirectiveLifecycle = function (r) {\r\n        if (r.name === \"DoCheck\") {\r\n            return this._genOnCheck(r);\r\n        }\r\n        else if (r.name === \"OnInit\") {\r\n            return this._genOnInit(r);\r\n        }\r\n        else if (r.name === \"OnChanges\") {\r\n            return this._genOnChange(r);\r\n        }\r\n        else {\r\n            throw new exceptions_1.BaseException(\"Unknown lifecycle event '\" + r.name + \"'\");\r\n        }\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genPipeCheck = function (r) {\r\n        var _this = this;\r\n        var context = this._names.getLocalName(r.contextIndex);\r\n        var argString = r.args.map(function (arg) { return _this._names.getLocalName(arg); }).join(\", \");\r\n        var oldValue = this._names.getFieldName(r.selfIndex);\r\n        var newValue = this._names.getLocalName(r.selfIndex);\r\n        var pipe = this._names.getPipeName(r.selfIndex);\r\n        var pipeName = r.name;\r\n        var init = \"\\n      if (\" + pipe + \" === \" + this.changeDetectionUtilVarName + \".uninitialized) {\\n        \" + pipe + \" = \" + this._names.getPipesAccessorName() + \".get('\" + pipeName + \"');\\n      }\\n    \";\r\n        var read = newValue + \" = \" + pipe + \".pipe.transform(\" + context + \", [\" + argString + \"]);\";\r\n        var contexOrArgCheck = r.args.map(function (a) { return _this._names.getChangeName(a); });\r\n        contexOrArgCheck.push(this._names.getChangeName(r.contextIndex));\r\n        var condition = \"!\" + pipe + \".pure || (\" + contexOrArgCheck.join(\" || \") + \")\";\r\n        var check = \"\\n      if (\" + this.changeDetectionUtilVarName + \".looseNotIdentical(\" + oldValue + \", \" + newValue + \")) {\\n        \" + newValue + \" = \" + this.changeDetectionUtilVarName + \".unwrapValue(\" + newValue + \")\\n        \" + this._genChangeMarker(r) + \"\\n        \" + this._genUpdateDirectiveOrElement(r) + \"\\n        \" + this._genAddToChanges(r) + \"\\n        \" + oldValue + \" = \" + newValue + \";\\n      }\\n    \";\r\n        var genCode = r.shouldBeChecked() ? \"\" + read + check : read;\r\n        if (r.isUsedByOtherRecord()) {\r\n            return init + \" if (\" + condition + \") { \" + genCode + \" } else { \" + newValue + \" = \" + oldValue + \"; }\";\r\n        }\r\n        else {\r\n            return init + \" if (\" + condition + \") { \" + genCode + \" }\";\r\n        }\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genReferenceCheck = function (r) {\r\n        var _this = this;\r\n        var oldValue = this._names.getFieldName(r.selfIndex);\r\n        var newValue = this._names.getLocalName(r.selfIndex);\r\n        var read = \"\\n      \" + this._logic.genPropertyBindingEvalValue(r) + \"\\n    \";\r\n        var check = \"\\n      if (\" + this.changeDetectionUtilVarName + \".looseNotIdentical(\" + oldValue + \", \" + newValue + \")) {\\n        \" + this._genChangeMarker(r) + \"\\n        \" + this._genUpdateDirectiveOrElement(r) + \"\\n        \" + this._genAddToChanges(r) + \"\\n        \" + oldValue + \" = \" + newValue + \";\\n      }\\n    \";\r\n        var genCode = r.shouldBeChecked() ? \"\" + read + check : read;\r\n        if (r.isPureFunction()) {\r\n            var condition = r.args.map(function (a) { return _this._names.getChangeName(a); }).join(\" || \");\r\n            if (r.isUsedByOtherRecord()) {\r\n                return \"if (\" + condition + \") { \" + genCode + \" } else { \" + newValue + \" = \" + oldValue + \"; }\";\r\n            }\r\n            else {\r\n                return \"if (\" + condition + \") { \" + genCode + \" }\";\r\n            }\r\n        }\r\n        else {\r\n            return genCode;\r\n        }\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genChangeMarker = function (r) {\r\n        return r.argumentToPureFunction ? this._names.getChangeName(r.selfIndex) + \" = true\" : \"\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genUpdateDirectiveOrElement = function (r) {\r\n        if (!r.lastInBinding)\r\n            return \"\";\r\n        var newValue = this._names.getLocalName(r.selfIndex);\r\n        var oldValue = this._names.getFieldName(r.selfIndex);\r\n        var notifyDebug = this.genConfig.logBindingUpdate ? \"this.logBindingUpdate(\" + newValue + \");\" : \"\";\r\n        var br = r.bindingRecord;\r\n        if (br.target.isDirective()) {\r\n            var directiveProperty = this._names.getDirectiveName(br.directiveRecord.directiveIndex) + \".\" + br.target.name;\r\n            return \"\\n        \" + this._genThrowOnChangeCheck(oldValue, newValue) + \"\\n        \" + directiveProperty + \" = \" + newValue + \";\\n        \" + notifyDebug + \"\\n        \" + IS_CHANGED_LOCAL + \" = true;\\n      \";\r\n        }\r\n        else {\r\n            return \"\\n        \" + this._genThrowOnChangeCheck(oldValue, newValue) + \"\\n        this.notifyDispatcher(\" + newValue + \");\\n        \" + notifyDebug + \"\\n      \";\r\n        }\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genThrowOnChangeCheck = function (oldValue, newValue) {\r\n        if (lang_1.assertionsEnabled()) {\r\n            return \"\\n        if(throwOnChange) {\\n          this.throwOnChangeError(\" + oldValue + \", \" + newValue + \");\\n        }\\n        \";\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genAddToChanges = function (r) {\r\n        var newValue = this._names.getLocalName(r.selfIndex);\r\n        var oldValue = this._names.getFieldName(r.selfIndex);\r\n        if (!r.bindingRecord.callOnChanges())\r\n            return \"\";\r\n        return CHANGES_LOCAL + \" = this.addChange(\" + CHANGES_LOCAL + \", \" + oldValue + \", \" + newValue + \");\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._maybeFirstInBinding = function (r) {\r\n        var prev = change_detection_util_1.ChangeDetectionUtil.protoByIndex(this.records, r.selfIndex - 1);\r\n        var firstInBinding = lang_1.isBlank(prev) || prev.bindingRecord !== r.bindingRecord;\r\n        return firstInBinding && !r.bindingRecord.isDirectiveLifecycle() ?\r\n            this._names.getPropertyBindingIndex() + \" = \" + r.propertyBindingIndex + \";\" :\r\n            '';\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._maybeGenLastInDirective = function (r) {\r\n        if (!r.lastInDirective)\r\n            return \"\";\r\n        return \"\\n      \" + CHANGES_LOCAL + \" = null;\\n      \" + this._genNotifyOnPushDetectors(r) + \"\\n      \" + IS_CHANGED_LOCAL + \" = false;\\n    \";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genOnCheck = function (r) {\r\n        var br = r.bindingRecord;\r\n        return \"if (!throwOnChange) \" + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + \".ngDoCheck();\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genOnInit = function (r) {\r\n        var br = r.bindingRecord;\r\n        return \"if (!throwOnChange && \" + this._names.getStateName() + \" === \" + this.changeDetectorStateVarName + \".NeverChecked) \" + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + \".ngOnInit();\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genOnChange = function (r) {\r\n        var br = r.bindingRecord;\r\n        return \"if (!throwOnChange && \" + CHANGES_LOCAL + \") \" + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + \".ngOnChanges(\" + CHANGES_LOCAL + \");\";\r\n    };\r\n    /** @internal */\r\n    ChangeDetectorJITGenerator.prototype._genNotifyOnPushDetectors = function (r) {\r\n        var br = r.bindingRecord;\r\n        if (!r.lastInDirective || br.isDefaultChangeDetection())\r\n            return \"\";\r\n        var retVal = \"\\n      if(\" + IS_CHANGED_LOCAL + \") {\\n        \" + this._names.getDetectorName(br.directiveRecord.directiveIndex) + \".markAsCheckOnce();\\n      }\\n    \";\r\n        return retVal;\r\n    };\r\n    return ChangeDetectorJITGenerator;\r\n})();\r\nexports.ChangeDetectorJITGenerator = ChangeDetectorJITGenerator;\r\n},{\"./abstract_change_detector\":85,\"./change_detection_util\":89,\"./codegen_facade\":92,\"./codegen_logic_util\":93,\"./codegen_name_util\":94,\"./constants\":95,\"./proto_change_detector\":113,\"./proto_record\":114,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],89:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar constants_1 = require('./constants');\r\nvar pipe_lifecycle_reflector_1 = require('./pipe_lifecycle_reflector');\r\nvar binding_record_1 = require('./binding_record');\r\nvar directive_record_1 = require('./directive_record');\r\n/**\r\n * Indicates that the result of a {@link PipeMetadata} transformation has changed even though the\r\n * reference\r\n * has not changed.\r\n *\r\n * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * if (this._latestValue === this._latestReturnedValue) {\r\n *    return this._latestReturnedValue;\r\n *  } else {\r\n *    this._latestReturnedValue = this._latestValue;\r\n *    return WrappedValue.wrap(this._latestValue); // this will force update\r\n *  }\r\n * ```\r\n */\r\nvar WrappedValue = (function () {\r\n    function WrappedValue(wrapped) {\r\n        this.wrapped = wrapped;\r\n    }\r\n    WrappedValue.wrap = function (value) {\r\n        var w = _wrappedValues[_wrappedIndex++ % 5];\r\n        w.wrapped = value;\r\n        return w;\r\n    };\r\n    return WrappedValue;\r\n})();\r\nexports.WrappedValue = WrappedValue;\r\nvar _wrappedValues = [\r\n    new WrappedValue(null),\r\n    new WrappedValue(null),\r\n    new WrappedValue(null),\r\n    new WrappedValue(null),\r\n    new WrappedValue(null)\r\n];\r\nvar _wrappedIndex = 0;\r\n/**\r\n * Represents a basic change from a previous to a new value.\r\n */\r\nvar SimpleChange = (function () {\r\n    function SimpleChange(previousValue, currentValue) {\r\n        this.previousValue = previousValue;\r\n        this.currentValue = currentValue;\r\n    }\r\n    /**\r\n     * Check whether the new value is the first value assigned.\r\n     */\r\n    SimpleChange.prototype.isFirstChange = function () { return this.previousValue === ChangeDetectionUtil.uninitialized; };\r\n    return SimpleChange;\r\n})();\r\nexports.SimpleChange = SimpleChange;\r\nvar _simpleChangesIndex = 0;\r\nvar _simpleChanges = [\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null),\r\n    new SimpleChange(null, null)\r\n];\r\nfunction _simpleChange(previousValue, currentValue) {\r\n    var index = _simpleChangesIndex++ % 20;\r\n    var s = _simpleChanges[index];\r\n    s.previousValue = previousValue;\r\n    s.currentValue = currentValue;\r\n    return s;\r\n}\r\n/* tslint:disable:requireParameterType */\r\nvar ChangeDetectionUtil = (function () {\r\n    function ChangeDetectionUtil() {\r\n    }\r\n    ChangeDetectionUtil.arrayFn0 = function () { return []; };\r\n    ChangeDetectionUtil.arrayFn1 = function (a1) { return [a1]; };\r\n    ChangeDetectionUtil.arrayFn2 = function (a1, a2) { return [a1, a2]; };\r\n    ChangeDetectionUtil.arrayFn3 = function (a1, a2, a3) { return [a1, a2, a3]; };\r\n    ChangeDetectionUtil.arrayFn4 = function (a1, a2, a3, a4) { return [a1, a2, a3, a4]; };\r\n    ChangeDetectionUtil.arrayFn5 = function (a1, a2, a3, a4, a5) { return [a1, a2, a3, a4, a5]; };\r\n    ChangeDetectionUtil.arrayFn6 = function (a1, a2, a3, a4, a5, a6) { return [a1, a2, a3, a4, a5, a6]; };\r\n    ChangeDetectionUtil.arrayFn7 = function (a1, a2, a3, a4, a5, a6, a7) { return [a1, a2, a3, a4, a5, a6, a7]; };\r\n    ChangeDetectionUtil.arrayFn8 = function (a1, a2, a3, a4, a5, a6, a7, a8) {\r\n        return [a1, a2, a3, a4, a5, a6, a7, a8];\r\n    };\r\n    ChangeDetectionUtil.arrayFn9 = function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {\r\n        return [a1, a2, a3, a4, a5, a6, a7, a8, a9];\r\n    };\r\n    ChangeDetectionUtil.operation_negate = function (value) { return !value; };\r\n    ChangeDetectionUtil.operation_add = function (left, right) { return left + right; };\r\n    ChangeDetectionUtil.operation_subtract = function (left, right) { return left - right; };\r\n    ChangeDetectionUtil.operation_multiply = function (left, right) { return left * right; };\r\n    ChangeDetectionUtil.operation_divide = function (left, right) { return left / right; };\r\n    ChangeDetectionUtil.operation_remainder = function (left, right) { return left % right; };\r\n    ChangeDetectionUtil.operation_equals = function (left, right) { return left == right; };\r\n    ChangeDetectionUtil.operation_not_equals = function (left, right) { return left != right; };\r\n    ChangeDetectionUtil.operation_identical = function (left, right) { return left === right; };\r\n    ChangeDetectionUtil.operation_not_identical = function (left, right) { return left !== right; };\r\n    ChangeDetectionUtil.operation_less_then = function (left, right) { return left < right; };\r\n    ChangeDetectionUtil.operation_greater_then = function (left, right) { return left > right; };\r\n    ChangeDetectionUtil.operation_less_or_equals_then = function (left, right) { return left <= right; };\r\n    ChangeDetectionUtil.operation_greater_or_equals_then = function (left, right) { return left >= right; };\r\n    ChangeDetectionUtil.cond = function (cond, trueVal, falseVal) { return cond ? trueVal : falseVal; };\r\n    ChangeDetectionUtil.mapFn = function (keys) {\r\n        function buildMap(values) {\r\n            var res = collection_1.StringMapWrapper.create();\r\n            for (var i = 0; i < keys.length; ++i) {\r\n                collection_1.StringMapWrapper.set(res, keys[i], values[i]);\r\n            }\r\n            return res;\r\n        }\r\n        switch (keys.length) {\r\n            case 0:\r\n                return function () { return []; };\r\n            case 1:\r\n                return function (a1) { return buildMap([a1]); };\r\n            case 2:\r\n                return function (a1, a2) { return buildMap([a1, a2]); };\r\n            case 3:\r\n                return function (a1, a2, a3) { return buildMap([a1, a2, a3]); };\r\n            case 4:\r\n                return function (a1, a2, a3, a4) { return buildMap([a1, a2, a3, a4]); };\r\n            case 5:\r\n                return function (a1, a2, a3, a4, a5) { return buildMap([a1, a2, a3, a4, a5]); };\r\n            case 6:\r\n                return function (a1, a2, a3, a4, a5, a6) { return buildMap([a1, a2, a3, a4, a5, a6]); };\r\n            case 7:\r\n                return function (a1, a2, a3, a4, a5, a6, a7) { return buildMap([a1, a2, a3, a4, a5, a6, a7]); };\r\n            case 8:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8) { return buildMap([a1, a2, a3, a4, a5, a6, a7, a8]); };\r\n            case 9:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {\r\n                    return buildMap([a1, a2, a3, a4, a5, a6, a7, a8, a9]);\r\n                };\r\n            default:\r\n                throw new exceptions_1.BaseException(\"Does not support literal maps with more than 9 elements\");\r\n        }\r\n    };\r\n    ChangeDetectionUtil.keyedAccess = function (obj, args) { return obj[args[0]]; };\r\n    ChangeDetectionUtil.unwrapValue = function (value) {\r\n        if (value instanceof WrappedValue) {\r\n            return value.wrapped;\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    };\r\n    ChangeDetectionUtil.changeDetectionMode = function (strategy) {\r\n        return constants_1.isDefaultChangeDetectionStrategy(strategy) ? constants_1.ChangeDetectionStrategy.CheckAlways :\r\n            constants_1.ChangeDetectionStrategy.CheckOnce;\r\n    };\r\n    ChangeDetectionUtil.simpleChange = function (previousValue, currentValue) {\r\n        return _simpleChange(previousValue, currentValue);\r\n    };\r\n    ChangeDetectionUtil.isValueBlank = function (value) { return lang_1.isBlank(value); };\r\n    ChangeDetectionUtil.s = function (value) { return lang_1.isPresent(value) ? \"\" + value : ''; };\r\n    ChangeDetectionUtil.protoByIndex = function (protos, selfIndex) {\r\n        return selfIndex < 1 ?\r\n            null :\r\n            protos[selfIndex - 1]; // self index is shifted by one because of context\r\n    };\r\n    ChangeDetectionUtil.callPipeOnDestroy = function (selectedPipe) {\r\n        if (pipe_lifecycle_reflector_1.implementsOnDestroy(selectedPipe.pipe)) {\r\n            selectedPipe.pipe.ngOnDestroy();\r\n        }\r\n    };\r\n    ChangeDetectionUtil.bindingTarget = function (mode, elementIndex, name, unit, debug) {\r\n        return new binding_record_1.BindingTarget(mode, elementIndex, name, unit, debug);\r\n    };\r\n    ChangeDetectionUtil.directiveIndex = function (elementIndex, directiveIndex) {\r\n        return new directive_record_1.DirectiveIndex(elementIndex, directiveIndex);\r\n    };\r\n    ChangeDetectionUtil.looseNotIdentical = function (a, b) { return !lang_1.looseIdentical(a, b); };\r\n    ChangeDetectionUtil.uninitialized = lang_1.CONST_EXPR(new Object());\r\n    return ChangeDetectionUtil;\r\n})();\r\nexports.ChangeDetectionUtil = ChangeDetectionUtil;\r\n},{\"./binding_record\":86,\"./constants\":95,\"./directive_record\":100,\"./pipe_lifecycle_reflector\":111,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],90:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar constants_1 = require('./constants');\r\nvar ChangeDetectorRef = (function () {\r\n    function ChangeDetectorRef() {\r\n    }\r\n    return ChangeDetectorRef;\r\n})();\r\nexports.ChangeDetectorRef = ChangeDetectorRef;\r\nvar ChangeDetectorRef_ = (function (_super) {\r\n    __extends(ChangeDetectorRef_, _super);\r\n    function ChangeDetectorRef_(_cd) {\r\n        _super.call(this);\r\n        this._cd = _cd;\r\n    }\r\n    ChangeDetectorRef_.prototype.markForCheck = function () { this._cd.markPathToRootAsCheckOnce(); };\r\n    ChangeDetectorRef_.prototype.detach = function () { this._cd.mode = constants_1.ChangeDetectionStrategy.Detached; };\r\n    ChangeDetectorRef_.prototype.detectChanges = function () { this._cd.detectChanges(); };\r\n    ChangeDetectorRef_.prototype.checkNoChanges = function () { this._cd.checkNoChanges(); };\r\n    ChangeDetectorRef_.prototype.reattach = function () {\r\n        this._cd.mode = constants_1.ChangeDetectionStrategy.CheckAlways;\r\n        this.markForCheck();\r\n    };\r\n    return ChangeDetectorRef_;\r\n})(ChangeDetectorRef);\r\nexports.ChangeDetectorRef_ = ChangeDetectorRef_;\r\n},{\"./constants\":95}],91:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar proto_record_1 = require('./proto_record');\r\n/**\r\n * Removes \"duplicate\" records. It assumes that record evaluation does not have side-effects.\r\n *\r\n * Records that are not last in bindings are removed and all the indices of the records that depend\r\n * on them are updated.\r\n *\r\n * Records that are last in bindings CANNOT be removed, and instead are replaced with very cheap\r\n * SELF records.\r\n *\r\n * @internal\r\n */\r\nfunction coalesce(srcRecords) {\r\n    var dstRecords = [];\r\n    var excludedIdxs = [];\r\n    var indexMap = new collection_1.Map();\r\n    var skipDepth = 0;\r\n    var skipSources = collection_1.ListWrapper.createFixedSize(srcRecords.length);\r\n    for (var protoIndex = 0; protoIndex < srcRecords.length; protoIndex++) {\r\n        var skipRecord = skipSources[protoIndex];\r\n        if (lang_1.isPresent(skipRecord)) {\r\n            skipDepth--;\r\n            skipRecord.fixedArgs[0] = dstRecords.length;\r\n        }\r\n        var src = srcRecords[protoIndex];\r\n        var dst = _cloneAndUpdateIndexes(src, dstRecords, indexMap);\r\n        if (dst.isSkipRecord()) {\r\n            dstRecords.push(dst);\r\n            skipDepth++;\r\n            skipSources[dst.fixedArgs[0]] = dst;\r\n        }\r\n        else {\r\n            var record = _mayBeAddRecord(dst, dstRecords, excludedIdxs, skipDepth > 0);\r\n            indexMap.set(src.selfIndex, record.selfIndex);\r\n        }\r\n    }\r\n    return _optimizeSkips(dstRecords);\r\n}\r\nexports.coalesce = coalesce;\r\n/**\r\n * - Conditional skip of 1 record followed by an unconditional skip of N are replaced by  a\r\n *   conditional skip of N with the negated condition,\r\n * - Skips of 0 records are removed\r\n */\r\nfunction _optimizeSkips(srcRecords) {\r\n    var dstRecords = [];\r\n    var skipSources = collection_1.ListWrapper.createFixedSize(srcRecords.length);\r\n    var indexMap = new collection_1.Map();\r\n    for (var protoIndex = 0; protoIndex < srcRecords.length; protoIndex++) {\r\n        var skipRecord = skipSources[protoIndex];\r\n        if (lang_1.isPresent(skipRecord)) {\r\n            skipRecord.fixedArgs[0] = dstRecords.length;\r\n        }\r\n        var src = srcRecords[protoIndex];\r\n        if (src.isSkipRecord()) {\r\n            if (src.isConditionalSkipRecord() && src.fixedArgs[0] === protoIndex + 2 &&\r\n                protoIndex < srcRecords.length - 1 &&\r\n                srcRecords[protoIndex + 1].mode === proto_record_1.RecordType.SkipRecords) {\r\n                src.mode = src.mode === proto_record_1.RecordType.SkipRecordsIf ? proto_record_1.RecordType.SkipRecordsIfNot :\r\n                    proto_record_1.RecordType.SkipRecordsIf;\r\n                src.fixedArgs[0] = srcRecords[protoIndex + 1].fixedArgs[0];\r\n                protoIndex++;\r\n            }\r\n            if (src.fixedArgs[0] > protoIndex + 1) {\r\n                var dst = _cloneAndUpdateIndexes(src, dstRecords, indexMap);\r\n                dstRecords.push(dst);\r\n                skipSources[dst.fixedArgs[0]] = dst;\r\n            }\r\n        }\r\n        else {\r\n            var dst = _cloneAndUpdateIndexes(src, dstRecords, indexMap);\r\n            dstRecords.push(dst);\r\n            indexMap.set(src.selfIndex, dst.selfIndex);\r\n        }\r\n    }\r\n    return dstRecords;\r\n}\r\n/**\r\n * Add a new record or re-use one of the existing records.\r\n */\r\nfunction _mayBeAddRecord(record, dstRecords, excludedIdxs, excluded) {\r\n    var match = _findFirstMatch(record, dstRecords, excludedIdxs);\r\n    if (lang_1.isPresent(match)) {\r\n        if (record.lastInBinding) {\r\n            dstRecords.push(_createSelfRecord(record, match.selfIndex, dstRecords.length + 1));\r\n            match.referencedBySelf = true;\r\n        }\r\n        else {\r\n            if (record.argumentToPureFunction) {\r\n                match.argumentToPureFunction = true;\r\n            }\r\n        }\r\n        return match;\r\n    }\r\n    if (excluded) {\r\n        excludedIdxs.push(record.selfIndex);\r\n    }\r\n    dstRecords.push(record);\r\n    return record;\r\n}\r\n/**\r\n * Returns the first `ProtoRecord` that matches the record.\r\n */\r\nfunction _findFirstMatch(record, dstRecords, excludedIdxs) {\r\n    return dstRecords.find(\r\n    // TODO(vicb): optimize excludedIdxs.indexOf (sorted array)\r\n    function (rr) { return excludedIdxs.indexOf(rr.selfIndex) == -1 && rr.mode !== proto_record_1.RecordType.DirectiveLifecycle &&\r\n        _haveSameDirIndex(rr, record) && rr.mode === record.mode &&\r\n        lang_1.looseIdentical(rr.funcOrValue, record.funcOrValue) &&\r\n        rr.contextIndex === record.contextIndex && lang_1.looseIdentical(rr.name, record.name) &&\r\n        collection_1.ListWrapper.equals(rr.args, record.args); });\r\n}\r\n/**\r\n * Clone the `ProtoRecord` and changes the indexes for the ones in the destination array for:\r\n * - the arguments,\r\n * - the context,\r\n * - self\r\n */\r\nfunction _cloneAndUpdateIndexes(record, dstRecords, indexMap) {\r\n    var args = record.args.map(function (src) { return _srcToDstSelfIndex(indexMap, src); });\r\n    var contextIndex = _srcToDstSelfIndex(indexMap, record.contextIndex);\r\n    var selfIndex = dstRecords.length + 1;\r\n    return new proto_record_1.ProtoRecord(record.mode, record.name, record.funcOrValue, args, record.fixedArgs, contextIndex, record.directiveIndex, selfIndex, record.bindingRecord, record.lastInBinding, record.lastInDirective, record.argumentToPureFunction, record.referencedBySelf, record.propertyBindingIndex);\r\n}\r\n/**\r\n * Returns the index in the destination array corresponding to the index in the src array.\r\n * When the element is not present in the destination array, return the source index.\r\n */\r\nfunction _srcToDstSelfIndex(indexMap, srcIdx) {\r\n    var dstIdx = indexMap.get(srcIdx);\r\n    return lang_1.isPresent(dstIdx) ? dstIdx : srcIdx;\r\n}\r\nfunction _createSelfRecord(r, contextIndex, selfIndex) {\r\n    return new proto_record_1.ProtoRecord(proto_record_1.RecordType.Self, \"self\", null, [], r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.lastInBinding, r.lastInDirective, false, false, r.propertyBindingIndex);\r\n}\r\nfunction _haveSameDirIndex(a, b) {\r\n    var di1 = lang_1.isBlank(a.directiveIndex) ? null : a.directiveIndex.directiveIndex;\r\n    var ei1 = lang_1.isBlank(a.directiveIndex) ? null : a.directiveIndex.elementIndex;\r\n    var di2 = lang_1.isBlank(b.directiveIndex) ? null : b.directiveIndex.directiveIndex;\r\n    var ei2 = lang_1.isBlank(b.directiveIndex) ? null : b.directiveIndex.elementIndex;\r\n    return di1 === di2 && ei1 === ei2;\r\n}\r\n},{\"./proto_record\":114,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],92:[function(require,module,exports){\n'use strict';/**\r\n * Converts `funcOrValue` to a string which can be used in generated code.\r\n */\r\nfunction codify(obj) {\r\n    return JSON.stringify(obj);\r\n}\r\nexports.codify = codify;\r\nfunction rawString(str) {\r\n    return \"'\" + str + \"'\";\r\n}\r\nexports.rawString = rawString;\r\n/**\r\n * Combine the strings of generated code into a single interpolated string.\r\n * Each element of `vals` is expected to be a string literal or a codegen'd\r\n * call to a method returning a string.\r\n */\r\nfunction combineGeneratedStrings(vals) {\r\n    return vals.join(' + ');\r\n}\r\nexports.combineGeneratedStrings = combineGeneratedStrings;\r\n},{}],93:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar codegen_facade_1 = require('./codegen_facade');\r\nvar proto_record_1 = require('./proto_record');\r\nvar constants_1 = require('./constants');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\n/**\r\n * Class responsible for providing change detection logic for change detector classes.\r\n */\r\nvar CodegenLogicUtil = (function () {\r\n    function CodegenLogicUtil(_names, _utilName, _changeDetectorStateName, _changeDetection) {\r\n        this._names = _names;\r\n        this._utilName = _utilName;\r\n        this._changeDetectorStateName = _changeDetectorStateName;\r\n        this._changeDetection = _changeDetection;\r\n    }\r\n    /**\r\n     * Generates a statement which updates the local variable representing `protoRec` with the current\r\n     * value of the record. Used by property bindings.\r\n     */\r\n    CodegenLogicUtil.prototype.genPropertyBindingEvalValue = function (protoRec) {\r\n        var _this = this;\r\n        return this._genEvalValue(protoRec, function (idx) { return _this._names.getLocalName(idx); }, this._names.getLocalsAccessorName());\r\n    };\r\n    /**\r\n     * Generates a statement which updates the local variable representing `protoRec` with the current\r\n     * value of the record. Used by event bindings.\r\n     */\r\n    CodegenLogicUtil.prototype.genEventBindingEvalValue = function (eventRecord, protoRec) {\r\n        var _this = this;\r\n        return this._genEvalValue(protoRec, function (idx) { return _this._names.getEventLocalName(eventRecord, idx); }, \"locals\");\r\n    };\r\n    CodegenLogicUtil.prototype._genEvalValue = function (protoRec, getLocalName, localsAccessor) {\r\n        var context = (protoRec.contextIndex == -1) ?\r\n            this._names.getDirectiveName(protoRec.directiveIndex) :\r\n            getLocalName(protoRec.contextIndex);\r\n        var argString = protoRec.args.map(function (arg) { return getLocalName(arg); }).join(\", \");\r\n        var rhs;\r\n        switch (protoRec.mode) {\r\n            case proto_record_1.RecordType.Self:\r\n                rhs = context;\r\n                break;\r\n            case proto_record_1.RecordType.Const:\r\n                rhs = codegen_facade_1.codify(protoRec.funcOrValue);\r\n                break;\r\n            case proto_record_1.RecordType.PropertyRead:\r\n                rhs = this._observe(context + \".\" + protoRec.name, protoRec);\r\n                break;\r\n            case proto_record_1.RecordType.SafeProperty:\r\n                var read = this._observe(context + \".\" + protoRec.name, protoRec);\r\n                rhs =\r\n                    this._utilName + \".isValueBlank(\" + context + \") ? null : \" + this._observe(read, protoRec);\r\n                break;\r\n            case proto_record_1.RecordType.PropertyWrite:\r\n                rhs = context + \".\" + protoRec.name + \" = \" + getLocalName(protoRec.args[0]);\r\n                break;\r\n            case proto_record_1.RecordType.Local:\r\n                rhs = this._observe(localsAccessor + \".get(\" + codegen_facade_1.rawString(protoRec.name) + \")\", protoRec);\r\n                break;\r\n            case proto_record_1.RecordType.InvokeMethod:\r\n                rhs = this._observe(context + \".\" + protoRec.name + \"(\" + argString + \")\", protoRec);\r\n                break;\r\n            case proto_record_1.RecordType.SafeMethodInvoke:\r\n                var invoke = context + \".\" + protoRec.name + \"(\" + argString + \")\";\r\n                rhs =\r\n                    this._utilName + \".isValueBlank(\" + context + \") ? null : \" + this._observe(invoke, protoRec);\r\n                break;\r\n            case proto_record_1.RecordType.InvokeClosure:\r\n                rhs = context + \"(\" + argString + \")\";\r\n                break;\r\n            case proto_record_1.RecordType.PrimitiveOp:\r\n                rhs = this._utilName + \".\" + protoRec.name + \"(\" + argString + \")\";\r\n                break;\r\n            case proto_record_1.RecordType.CollectionLiteral:\r\n                rhs = this._utilName + \".\" + protoRec.name + \"(\" + argString + \")\";\r\n                break;\r\n            case proto_record_1.RecordType.Interpolate:\r\n                rhs = this._genInterpolation(protoRec);\r\n                break;\r\n            case proto_record_1.RecordType.KeyedRead:\r\n                rhs = this._observe(context + \"[\" + getLocalName(protoRec.args[0]) + \"]\", protoRec);\r\n                break;\r\n            case proto_record_1.RecordType.KeyedWrite:\r\n                rhs = context + \"[\" + getLocalName(protoRec.args[0]) + \"] = \" + getLocalName(protoRec.args[1]);\r\n                break;\r\n            case proto_record_1.RecordType.Chain:\r\n                rhs = 'null';\r\n                break;\r\n            default:\r\n                throw new exceptions_1.BaseException(\"Unknown operation \" + protoRec.mode);\r\n        }\r\n        return getLocalName(protoRec.selfIndex) + \" = \" + rhs + \";\";\r\n    };\r\n    /** @internal */\r\n    CodegenLogicUtil.prototype._observe = function (exp, rec) {\r\n        // This is an experimental feature. Works only in Dart.\r\n        if (this._changeDetection === constants_1.ChangeDetectionStrategy.OnPushObserve) {\r\n            return \"this.observeValue(\" + exp + \", \" + rec.selfIndex + \")\";\r\n        }\r\n        else {\r\n            return exp;\r\n        }\r\n    };\r\n    CodegenLogicUtil.prototype.genPropertyBindingTargets = function (propertyBindingTargets, genDebugInfo) {\r\n        var _this = this;\r\n        var bs = propertyBindingTargets.map(function (b) {\r\n            if (lang_1.isBlank(b))\r\n                return \"null\";\r\n            var debug = genDebugInfo ? codegen_facade_1.codify(b.debug) : \"null\";\r\n            return _this._utilName + \".bindingTarget(\" + codegen_facade_1.codify(b.mode) + \", \" + b.elementIndex + \", \" + codegen_facade_1.codify(b.name) + \", \" + codegen_facade_1.codify(b.unit) + \", \" + debug + \")\";\r\n        });\r\n        return \"[\" + bs.join(\", \") + \"]\";\r\n    };\r\n    CodegenLogicUtil.prototype.genDirectiveIndices = function (directiveRecords) {\r\n        var _this = this;\r\n        var bs = directiveRecords.map(function (b) {\r\n            return (_this._utilName + \".directiveIndex(\" + b.directiveIndex.elementIndex + \", \" + b.directiveIndex.directiveIndex + \")\");\r\n        });\r\n        return \"[\" + bs.join(\", \") + \"]\";\r\n    };\r\n    /** @internal */\r\n    CodegenLogicUtil.prototype._genInterpolation = function (protoRec) {\r\n        var iVals = [];\r\n        for (var i = 0; i < protoRec.args.length; ++i) {\r\n            iVals.push(codegen_facade_1.codify(protoRec.fixedArgs[i]));\r\n            iVals.push(this._utilName + \".s(\" + this._names.getLocalName(protoRec.args[i]) + \")\");\r\n        }\r\n        iVals.push(codegen_facade_1.codify(protoRec.fixedArgs[protoRec.args.length]));\r\n        return codegen_facade_1.combineGeneratedStrings(iVals);\r\n    };\r\n    CodegenLogicUtil.prototype.genHydrateDirectives = function (directiveRecords) {\r\n        var _this = this;\r\n        var res = [];\r\n        for (var i = 0; i < directiveRecords.length; ++i) {\r\n            var r = directiveRecords[i];\r\n            var dirVarName = this._names.getDirectiveName(r.directiveIndex);\r\n            res.push(dirVarName + \" = \" + this._genReadDirective(i) + \";\");\r\n            if (lang_1.isPresent(r.outputs)) {\r\n                r.outputs.forEach(function (output) {\r\n                    var eventHandlerExpr = _this._genEventHandler(r.directiveIndex.elementIndex, output[1]);\r\n                    if (lang_1.IS_DART) {\r\n                        res.push(dirVarName + \".\" + output[0] + \".listen(\" + eventHandlerExpr + \");\");\r\n                    }\r\n                    else {\r\n                        res.push(dirVarName + \".\" + output[0] + \".subscribe({next: \" + eventHandlerExpr + \"});\");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return res.join(\"\\n\");\r\n    };\r\n    CodegenLogicUtil.prototype.genDirectivesOnDestroy = function (directiveRecords) {\r\n        var res = [];\r\n        for (var i = 0; i < directiveRecords.length; ++i) {\r\n            var r = directiveRecords[i];\r\n            if (r.callOnDestroy) {\r\n                var dirVarName = this._names.getDirectiveName(r.directiveIndex);\r\n                res.push(dirVarName + \".ngOnDestroy();\");\r\n            }\r\n        }\r\n        return res.join(\"\\n\");\r\n    };\r\n    CodegenLogicUtil.prototype._genEventHandler = function (boundElementIndex, eventName) {\r\n        if (lang_1.IS_DART) {\r\n            return \"(event) => this.handleEvent('\" + eventName + \"', \" + boundElementIndex + \", event)\";\r\n        }\r\n        else {\r\n            return \"(function(event) { return this.handleEvent('\" + eventName + \"', \" + boundElementIndex + \", event); }).bind(this)\";\r\n        }\r\n    };\r\n    CodegenLogicUtil.prototype._genReadDirective = function (index) {\r\n        var directiveExpr = \"this.getDirectiveFor(directives, \" + index + \")\";\r\n        // This is an experimental feature. Works only in Dart.\r\n        if (this._changeDetection === constants_1.ChangeDetectionStrategy.OnPushObserve) {\r\n            return \"this.observeDirective(\" + directiveExpr + \", \" + index + \")\";\r\n        }\r\n        else {\r\n            return directiveExpr;\r\n        }\r\n    };\r\n    CodegenLogicUtil.prototype.genHydrateDetectors = function (directiveRecords) {\r\n        var res = [];\r\n        for (var i = 0; i < directiveRecords.length; ++i) {\r\n            var r = directiveRecords[i];\r\n            if (!r.isDefaultChangeDetection()) {\r\n                res.push(this._names.getDetectorName(r.directiveIndex) + \" = this.getDetectorFor(directives, \" + i + \");\");\r\n            }\r\n        }\r\n        return res.join(\"\\n\");\r\n    };\r\n    CodegenLogicUtil.prototype.genContentLifecycleCallbacks = function (directiveRecords) {\r\n        var res = [];\r\n        var eq = lang_1.IS_DART ? '==' : '===';\r\n        // NOTE(kegluneq): Order is important!\r\n        for (var i = directiveRecords.length - 1; i >= 0; --i) {\r\n            var dir = directiveRecords[i];\r\n            if (dir.callAfterContentInit) {\r\n                res.push(\"if(\" + this._names.getStateName() + \" \" + eq + \" \" + this._changeDetectorStateName + \".NeverChecked) \" + this._names.getDirectiveName(dir.directiveIndex) + \".ngAfterContentInit();\");\r\n            }\r\n            if (dir.callAfterContentChecked) {\r\n                res.push(this._names.getDirectiveName(dir.directiveIndex) + \".ngAfterContentChecked();\");\r\n            }\r\n        }\r\n        return res;\r\n    };\r\n    CodegenLogicUtil.prototype.genViewLifecycleCallbacks = function (directiveRecords) {\r\n        var res = [];\r\n        var eq = lang_1.IS_DART ? '==' : '===';\r\n        // NOTE(kegluneq): Order is important!\r\n        for (var i = directiveRecords.length - 1; i >= 0; --i) {\r\n            var dir = directiveRecords[i];\r\n            if (dir.callAfterViewInit) {\r\n                res.push(\"if(\" + this._names.getStateName() + \" \" + eq + \" \" + this._changeDetectorStateName + \".NeverChecked) \" + this._names.getDirectiveName(dir.directiveIndex) + \".ngAfterViewInit();\");\r\n            }\r\n            if (dir.callAfterViewChecked) {\r\n                res.push(this._names.getDirectiveName(dir.directiveIndex) + \".ngAfterViewChecked();\");\r\n            }\r\n        }\r\n        return res;\r\n    };\r\n    return CodegenLogicUtil;\r\n})();\r\nexports.CodegenLogicUtil = CodegenLogicUtil;\r\n},{\"./codegen_facade\":92,\"./constants\":95,\"./proto_record\":114,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],94:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\n// The names of these fields must be kept in sync with abstract_change_detector.ts or change\r\n// detection will fail.\r\nvar _STATE_ACCESSOR = \"state\";\r\nvar _CONTEXT_ACCESSOR = \"context\";\r\nvar _PROP_BINDING_INDEX = \"propertyBindingIndex\";\r\nvar _DIRECTIVES_ACCESSOR = \"directiveIndices\";\r\nvar _DISPATCHER_ACCESSOR = \"dispatcher\";\r\nvar _LOCALS_ACCESSOR = \"locals\";\r\nvar _MODE_ACCESSOR = \"mode\";\r\nvar _PIPES_ACCESSOR = \"pipes\";\r\nvar _PROTOS_ACCESSOR = \"protos\";\r\nexports.CONTEXT_ACCESSOR = \"context\";\r\n// `context` is always first.\r\nexports.CONTEXT_INDEX = 0;\r\nvar _FIELD_PREFIX = 'this.';\r\nvar _whiteSpaceRegExp = /\\W/g;\r\n/**\r\n * Returns `s` with all non-identifier characters removed.\r\n */\r\nfunction sanitizeName(s) {\r\n    return lang_1.StringWrapper.replaceAll(s, _whiteSpaceRegExp, '');\r\n}\r\nexports.sanitizeName = sanitizeName;\r\n/**\r\n * Class responsible for providing field and local variable names for change detector classes.\r\n * Also provides some convenience functions, for example, declaring variables, destroying pipes,\r\n * and dehydrating the detector.\r\n */\r\nvar CodegenNameUtil = (function () {\r\n    function CodegenNameUtil(_records, _eventBindings, _directiveRecords, _utilName) {\r\n        this._records = _records;\r\n        this._eventBindings = _eventBindings;\r\n        this._directiveRecords = _directiveRecords;\r\n        this._utilName = _utilName;\r\n        /** @internal */\r\n        this._sanitizedEventNames = new collection_1.Map();\r\n        this._sanitizedNames = collection_1.ListWrapper.createFixedSize(this._records.length + 1);\r\n        this._sanitizedNames[exports.CONTEXT_INDEX] = exports.CONTEXT_ACCESSOR;\r\n        for (var i = 0, iLen = this._records.length; i < iLen; ++i) {\r\n            this._sanitizedNames[i + 1] = sanitizeName(\"\" + this._records[i].name + i);\r\n        }\r\n        for (var ebIndex = 0; ebIndex < _eventBindings.length; ++ebIndex) {\r\n            var eb = _eventBindings[ebIndex];\r\n            var names = [exports.CONTEXT_ACCESSOR];\r\n            for (var i = 0, iLen = eb.records.length; i < iLen; ++i) {\r\n                names.push(sanitizeName(\"\" + eb.records[i].name + i + \"_\" + ebIndex));\r\n            }\r\n            this._sanitizedEventNames.set(eb, names);\r\n        }\r\n    }\r\n    /** @internal */\r\n    CodegenNameUtil.prototype._addFieldPrefix = function (name) { return \"\" + _FIELD_PREFIX + name; };\r\n    CodegenNameUtil.prototype.getDispatcherName = function () { return this._addFieldPrefix(_DISPATCHER_ACCESSOR); };\r\n    CodegenNameUtil.prototype.getPipesAccessorName = function () { return this._addFieldPrefix(_PIPES_ACCESSOR); };\r\n    CodegenNameUtil.prototype.getProtosName = function () { return this._addFieldPrefix(_PROTOS_ACCESSOR); };\r\n    CodegenNameUtil.prototype.getDirectivesAccessorName = function () { return this._addFieldPrefix(_DIRECTIVES_ACCESSOR); };\r\n    CodegenNameUtil.prototype.getLocalsAccessorName = function () { return this._addFieldPrefix(_LOCALS_ACCESSOR); };\r\n    CodegenNameUtil.prototype.getStateName = function () { return this._addFieldPrefix(_STATE_ACCESSOR); };\r\n    CodegenNameUtil.prototype.getModeName = function () { return this._addFieldPrefix(_MODE_ACCESSOR); };\r\n    CodegenNameUtil.prototype.getPropertyBindingIndex = function () { return this._addFieldPrefix(_PROP_BINDING_INDEX); };\r\n    CodegenNameUtil.prototype.getLocalName = function (idx) { return \"l_\" + this._sanitizedNames[idx]; };\r\n    CodegenNameUtil.prototype.getEventLocalName = function (eb, idx) {\r\n        return \"l_\" + this._sanitizedEventNames.get(eb)[idx];\r\n    };\r\n    CodegenNameUtil.prototype.getChangeName = function (idx) { return \"c_\" + this._sanitizedNames[idx]; };\r\n    /**\r\n     * Generate a statement initializing local variables used when detecting changes.\r\n     */\r\n    CodegenNameUtil.prototype.genInitLocals = function () {\r\n        var declarations = [];\r\n        var assignments = [];\r\n        for (var i = 0, iLen = this.getFieldCount(); i < iLen; ++i) {\r\n            if (i == exports.CONTEXT_INDEX) {\r\n                declarations.push(this.getLocalName(i) + \" = \" + this.getFieldName(i));\r\n            }\r\n            else {\r\n                var rec = this._records[i - 1];\r\n                if (rec.argumentToPureFunction) {\r\n                    var changeName = this.getChangeName(i);\r\n                    declarations.push(this.getLocalName(i) + \",\" + changeName);\r\n                    assignments.push(changeName);\r\n                }\r\n                else {\r\n                    declarations.push(\"\" + this.getLocalName(i));\r\n                }\r\n            }\r\n        }\r\n        var assignmentsCode = collection_1.ListWrapper.isEmpty(assignments) ? '' : assignments.join('=') + \" = false;\";\r\n        return \"var \" + declarations.join(',') + \";\" + assignmentsCode;\r\n    };\r\n    /**\r\n     * Generate a statement initializing local variables for event handlers.\r\n     */\r\n    CodegenNameUtil.prototype.genInitEventLocals = function () {\r\n        var _this = this;\r\n        var res = [(this.getLocalName(exports.CONTEXT_INDEX) + \" = \" + this.getFieldName(exports.CONTEXT_INDEX))];\r\n        this._sanitizedEventNames.forEach(function (names, eb) {\r\n            for (var i = 0; i < names.length; ++i) {\r\n                if (i !== exports.CONTEXT_INDEX) {\r\n                    res.push(\"\" + _this.getEventLocalName(eb, i));\r\n                }\r\n            }\r\n        });\r\n        return res.length > 1 ? \"var \" + res.join(',') + \";\" : '';\r\n    };\r\n    CodegenNameUtil.prototype.getPreventDefaultAccesor = function () { return \"preventDefault\"; };\r\n    CodegenNameUtil.prototype.getFieldCount = function () { return this._sanitizedNames.length; };\r\n    CodegenNameUtil.prototype.getFieldName = function (idx) { return this._addFieldPrefix(this._sanitizedNames[idx]); };\r\n    CodegenNameUtil.prototype.getAllFieldNames = function () {\r\n        var fieldList = [];\r\n        for (var k = 0, kLen = this.getFieldCount(); k < kLen; ++k) {\r\n            if (k === 0 || this._records[k - 1].shouldBeChecked()) {\r\n                fieldList.push(this.getFieldName(k));\r\n            }\r\n        }\r\n        for (var i = 0, iLen = this._records.length; i < iLen; ++i) {\r\n            var rec = this._records[i];\r\n            if (rec.isPipeRecord()) {\r\n                fieldList.push(this.getPipeName(rec.selfIndex));\r\n            }\r\n        }\r\n        for (var j = 0, jLen = this._directiveRecords.length; j < jLen; ++j) {\r\n            var dRec = this._directiveRecords[j];\r\n            fieldList.push(this.getDirectiveName(dRec.directiveIndex));\r\n            if (!dRec.isDefaultChangeDetection()) {\r\n                fieldList.push(this.getDetectorName(dRec.directiveIndex));\r\n            }\r\n        }\r\n        return fieldList;\r\n    };\r\n    /**\r\n     * Generates statements which clear all fields so that the change detector is dehydrated.\r\n     */\r\n    CodegenNameUtil.prototype.genDehydrateFields = function () {\r\n        var fields = this.getAllFieldNames();\r\n        collection_1.ListWrapper.removeAt(fields, exports.CONTEXT_INDEX);\r\n        if (collection_1.ListWrapper.isEmpty(fields))\r\n            return '';\r\n        // At least one assignment.\r\n        fields.push(this._utilName + \".uninitialized;\");\r\n        return fields.join(' = ');\r\n    };\r\n    /**\r\n     * Generates statements destroying all pipe variables.\r\n     */\r\n    CodegenNameUtil.prototype.genPipeOnDestroy = function () {\r\n        var _this = this;\r\n        return this._records.filter(function (r) { return r.isPipeRecord(); })\r\n            .map(function (r) { return (_this._utilName + \".callPipeOnDestroy(\" + _this.getPipeName(r.selfIndex) + \");\"); })\r\n            .join('\\n');\r\n    };\r\n    CodegenNameUtil.prototype.getPipeName = function (idx) {\r\n        return this._addFieldPrefix(this._sanitizedNames[idx] + \"_pipe\");\r\n    };\r\n    CodegenNameUtil.prototype.getDirectiveName = function (d) {\r\n        return this._addFieldPrefix(\"directive_\" + d.name);\r\n    };\r\n    CodegenNameUtil.prototype.getDetectorName = function (d) { return this._addFieldPrefix(\"detector_\" + d.name); };\r\n    return CodegenNameUtil;\r\n})();\r\nexports.CodegenNameUtil = CodegenNameUtil;\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],95:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * Describes the current state of the change detector.\r\n */\r\n(function (ChangeDetectorState) {\r\n    /**\r\n     * `NeverChecked` means that the change detector has not been checked yet, and\r\n     * initialization methods should be called during detection.\r\n     */\r\n    ChangeDetectorState[ChangeDetectorState[\"NeverChecked\"] = 0] = \"NeverChecked\";\r\n    /**\r\n     * `CheckedBefore` means that the change detector has successfully completed at least\r\n     * one detection previously.\r\n     */\r\n    ChangeDetectorState[ChangeDetectorState[\"CheckedBefore\"] = 1] = \"CheckedBefore\";\r\n    /**\r\n     * `Errored` means that the change detector encountered an error checking a binding\r\n     * or calling a directive lifecycle method and is now in an inconsistent state. Change\r\n     * detectors in this state will no longer detect changes.\r\n     */\r\n    ChangeDetectorState[ChangeDetectorState[\"Errored\"] = 2] = \"Errored\";\r\n})(exports.ChangeDetectorState || (exports.ChangeDetectorState = {}));\r\nvar ChangeDetectorState = exports.ChangeDetectorState;\r\n/**\r\n * Describes within the change detector which strategy will be used the next time change\r\n * detection is triggered.\r\n */\r\n(function (ChangeDetectionStrategy) {\r\n    /**\r\n     * `CheckedOnce` means that after calling detectChanges the mode of the change detector\r\n     * will become `Checked`.\r\n     */\r\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"CheckOnce\"] = 0] = \"CheckOnce\";\r\n    /**\r\n     * `Checked` means that the change detector should be skipped until its mode changes to\r\n     * `CheckOnce`.\r\n     */\r\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Checked\"] = 1] = \"Checked\";\r\n    /**\r\n     * `CheckAlways` means that after calling detectChanges the mode of the change detector\r\n     * will remain `CheckAlways`.\r\n     */\r\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"CheckAlways\"] = 2] = \"CheckAlways\";\r\n    /**\r\n     * `Detached` means that the change detector sub tree is not a part of the main tree and\r\n     * should be skipped.\r\n     */\r\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Detached\"] = 3] = \"Detached\";\r\n    /**\r\n     * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.\r\n     */\r\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 4] = \"OnPush\";\r\n    /**\r\n     * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.\r\n     */\r\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 5] = \"Default\";\r\n    /**\r\n     * This is an experimental feature. Works only in Dart.\r\n     */\r\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPushObserve\"] = 6] = \"OnPushObserve\";\r\n})(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));\r\nvar ChangeDetectionStrategy = exports.ChangeDetectionStrategy;\r\n/**\r\n * List of possible {@link ChangeDetectionStrategy} values.\r\n */\r\nexports.CHANGE_DETECTION_STRATEGY_VALUES = [\r\n    ChangeDetectionStrategy.CheckOnce,\r\n    ChangeDetectionStrategy.Checked,\r\n    ChangeDetectionStrategy.CheckAlways,\r\n    ChangeDetectionStrategy.Detached,\r\n    ChangeDetectionStrategy.OnPush,\r\n    ChangeDetectionStrategy.Default,\r\n    ChangeDetectionStrategy.OnPushObserve\r\n];\r\n/**\r\n * List of possible {@link ChangeDetectorState} values.\r\n */\r\nexports.CHANGE_DETECTOR_STATE_VALUES = [\r\n    ChangeDetectorState.NeverChecked,\r\n    ChangeDetectorState.CheckedBefore,\r\n    ChangeDetectorState.Errored\r\n];\r\nfunction isDefaultChangeDetectionStrategy(changeDetectionStrategy) {\r\n    return lang_1.isBlank(changeDetectionStrategy) ||\r\n        changeDetectionStrategy === ChangeDetectionStrategy.Default;\r\n}\r\nexports.isDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;\r\n},{\"angular2/src/facade/lang\":176}],96:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar lang_2 = require('angular2/src/facade/lang');\r\nvar DefaultIterableDifferFactory = (function () {\r\n    function DefaultIterableDifferFactory() {\r\n    }\r\n    DefaultIterableDifferFactory.prototype.supports = function (obj) { return collection_1.isListLikeIterable(obj); };\r\n    DefaultIterableDifferFactory.prototype.create = function (cdRef) { return new DefaultIterableDiffer(); };\r\n    DefaultIterableDifferFactory = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [])\r\n    ], DefaultIterableDifferFactory);\r\n    return DefaultIterableDifferFactory;\r\n})();\r\nexports.DefaultIterableDifferFactory = DefaultIterableDifferFactory;\r\nvar DefaultIterableDiffer = (function () {\r\n    function DefaultIterableDiffer() {\r\n        this._collection = null;\r\n        this._length = null;\r\n        // Keeps track of the used records at any point in time (during & across `_check()` calls)\r\n        this._linkedRecords = null;\r\n        // Keeps track of the removed records at any point in time during `_check()` calls.\r\n        this._unlinkedRecords = null;\r\n        this._previousItHead = null;\r\n        this._itHead = null;\r\n        this._itTail = null;\r\n        this._additionsHead = null;\r\n        this._additionsTail = null;\r\n        this._movesHead = null;\r\n        this._movesTail = null;\r\n        this._removalsHead = null;\r\n        this._removalsTail = null;\r\n    }\r\n    Object.defineProperty(DefaultIterableDiffer.prototype, \"collection\", {\r\n        get: function () { return this._collection; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DefaultIterableDiffer.prototype, \"length\", {\r\n        get: function () { return this._length; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DefaultIterableDiffer.prototype.forEachItem = function (fn) {\r\n        var record;\r\n        for (record = this._itHead; record !== null; record = record._next) {\r\n            fn(record);\r\n        }\r\n    };\r\n    DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {\r\n        var record;\r\n        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\r\n            fn(record);\r\n        }\r\n    };\r\n    DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {\r\n        var record;\r\n        for (record = this._additionsHead; record !== null; record = record._nextAdded) {\r\n            fn(record);\r\n        }\r\n    };\r\n    DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {\r\n        var record;\r\n        for (record = this._movesHead; record !== null; record = record._nextMoved) {\r\n            fn(record);\r\n        }\r\n    };\r\n    DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {\r\n        var record;\r\n        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\r\n            fn(record);\r\n        }\r\n    };\r\n    DefaultIterableDiffer.prototype.diff = function (collection) {\r\n        if (lang_2.isBlank(collection))\r\n            collection = [];\r\n        if (!collection_1.isListLikeIterable(collection)) {\r\n            throw new exceptions_1.BaseException(\"Error trying to diff '\" + collection + \"'\");\r\n        }\r\n        if (this.check(collection)) {\r\n            return this;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    DefaultIterableDiffer.prototype.onDestroy = function () { };\r\n    // todo(vicb): optim for UnmodifiableListView (frozen arrays)\r\n    DefaultIterableDiffer.prototype.check = function (collection) {\r\n        var _this = this;\r\n        this._reset();\r\n        var record = this._itHead;\r\n        var mayBeDirty = false;\r\n        var index;\r\n        var item;\r\n        if (lang_2.isArray(collection)) {\r\n            var list = collection;\r\n            this._length = collection.length;\r\n            for (index = 0; index < this._length; index++) {\r\n                item = list[index];\r\n                if (record === null || !lang_2.looseIdentical(record.item, item)) {\r\n                    record = this._mismatch(record, item, index);\r\n                    mayBeDirty = true;\r\n                }\r\n                else if (mayBeDirty) {\r\n                    // TODO(misko): can we limit this to duplicates only?\r\n                    record = this._verifyReinsertion(record, item, index);\r\n                }\r\n                record = record._next;\r\n            }\r\n        }\r\n        else {\r\n            index = 0;\r\n            collection_1.iterateListLike(collection, function (item) {\r\n                if (record === null || !lang_2.looseIdentical(record.item, item)) {\r\n                    record = _this._mismatch(record, item, index);\r\n                    mayBeDirty = true;\r\n                }\r\n                else if (mayBeDirty) {\r\n                    // TODO(misko): can we limit this to duplicates only?\r\n                    record = _this._verifyReinsertion(record, item, index);\r\n                }\r\n                record = record._next;\r\n                index++;\r\n            });\r\n            this._length = index;\r\n        }\r\n        this._truncate(record);\r\n        this._collection = collection;\r\n        return this.isDirty;\r\n    };\r\n    Object.defineProperty(DefaultIterableDiffer.prototype, \"isDirty\", {\r\n        // CollectionChanges is considered dirty if it has any additions, moves or removals.\r\n        get: function () {\r\n            return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Reset the state of the change objects to show no changes. This means set previousKey to\r\n     * currentKey, and clear all of the queues (additions, moves, removals).\r\n     * Set the previousIndexes of moved and added items to their currentIndexes\r\n     * Reset the list of additions, moves and removals\r\n     *\r\n     * @internal\r\n     */\r\n    DefaultIterableDiffer.prototype._reset = function () {\r\n        if (this.isDirty) {\r\n            var record;\r\n            var nextRecord;\r\n            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\r\n                record._nextPrevious = record._next;\r\n            }\r\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\r\n                record.previousIndex = record.currentIndex;\r\n            }\r\n            this._additionsHead = this._additionsTail = null;\r\n            for (record = this._movesHead; record !== null; record = nextRecord) {\r\n                record.previousIndex = record.currentIndex;\r\n                nextRecord = record._nextMoved;\r\n            }\r\n            this._movesHead = this._movesTail = null;\r\n            this._removalsHead = this._removalsTail = null;\r\n        }\r\n    };\r\n    /**\r\n     * This is the core function which handles differences between collections.\r\n     *\r\n     * - `record` is the record which we saw at this position last time. If null then it is a new\r\n     *   item.\r\n     * - `item` is the current item in the collection\r\n     * - `index` is the position of the item in the collection\r\n     *\r\n     * @internal\r\n     */\r\n    DefaultIterableDiffer.prototype._mismatch = function (record, item, index) {\r\n        // The previous record after which we will append the current one.\r\n        var previousRecord;\r\n        if (record === null) {\r\n            previousRecord = this._itTail;\r\n        }\r\n        else {\r\n            previousRecord = record._prev;\r\n            // Remove the record from the collection since we know it does not match the item.\r\n            this._remove(record);\r\n        }\r\n        // Attempt to see if we have seen the item before.\r\n        record = this._linkedRecords === null ? null : this._linkedRecords.get(item, index);\r\n        if (record !== null) {\r\n            // We have seen this before, we need to move it forward in the collection.\r\n            this._moveAfter(record, previousRecord, index);\r\n        }\r\n        else {\r\n            // Never seen it, check evicted list.\r\n            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);\r\n            if (record !== null) {\r\n                // It is an item which we have evicted earlier: reinsert it back into the list.\r\n                this._reinsertAfter(record, previousRecord, index);\r\n            }\r\n            else {\r\n                // It is a new item: add it.\r\n                record = this._addAfter(new CollectionChangeRecord(item), previousRecord, index);\r\n            }\r\n        }\r\n        return record;\r\n    };\r\n    /**\r\n     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\r\n     *\r\n     * Use case: `[a, a]` => `[b, a, a]`\r\n     *\r\n     * If we did not have this check then the insertion of `b` would:\r\n     *   1) evict first `a`\r\n     *   2) insert `b` at `0` index.\r\n     *   3) leave `a` at index `1` as is. <-- this is wrong!\r\n     *   3) reinsert `a` at index 2. <-- this is wrong!\r\n     *\r\n     * The correct behavior is:\r\n     *   1) evict first `a`\r\n     *   2) insert `b` at `0` index.\r\n     *   3) reinsert `a` at index 1.\r\n     *   3) move `a` at from `1` to `2`.\r\n     *\r\n     *\r\n     * Double check that we have not evicted a duplicate item. We need to check if the item type may\r\n     * have already been removed:\r\n     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\r\n     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\r\n     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\r\n     * at the end.\r\n     *\r\n     * @internal\r\n     */\r\n    DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, index) {\r\n        var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);\r\n        if (reinsertRecord !== null) {\r\n            record = this._reinsertAfter(reinsertRecord, record._prev, index);\r\n        }\r\n        else if (record.currentIndex != index) {\r\n            record.currentIndex = index;\r\n            this._addToMoves(record, index);\r\n        }\r\n        return record;\r\n    };\r\n    /**\r\n     * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection\r\n     *\r\n     * - `record` The first excess {@link CollectionChangeRecord}.\r\n     *\r\n     * @internal\r\n     */\r\n    DefaultIterableDiffer.prototype._truncate = function (record) {\r\n        // Anything after that needs to be removed;\r\n        while (record !== null) {\r\n            var nextRecord = record._next;\r\n            this._addToRemovals(this._unlink(record));\r\n            record = nextRecord;\r\n        }\r\n        if (this._unlinkedRecords !== null) {\r\n            this._unlinkedRecords.clear();\r\n        }\r\n        if (this._additionsTail !== null) {\r\n            this._additionsTail._nextAdded = null;\r\n        }\r\n        if (this._movesTail !== null) {\r\n            this._movesTail._nextMoved = null;\r\n        }\r\n        if (this._itTail !== null) {\r\n            this._itTail._next = null;\r\n        }\r\n        if (this._removalsTail !== null) {\r\n            this._removalsTail._nextRemoved = null;\r\n        }\r\n    };\r\n    /** @internal */\r\n    DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {\r\n        if (this._unlinkedRecords !== null) {\r\n            this._unlinkedRecords.remove(record);\r\n        }\r\n        var prev = record._prevRemoved;\r\n        var next = record._nextRemoved;\r\n        if (prev === null) {\r\n            this._removalsHead = next;\r\n        }\r\n        else {\r\n            prev._nextRemoved = next;\r\n        }\r\n        if (next === null) {\r\n            this._removalsTail = prev;\r\n        }\r\n        else {\r\n            next._prevRemoved = prev;\r\n        }\r\n        this._insertAfter(record, prevRecord, index);\r\n        this._addToMoves(record, index);\r\n        return record;\r\n    };\r\n    /** @internal */\r\n    DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {\r\n        this._unlink(record);\r\n        this._insertAfter(record, prevRecord, index);\r\n        this._addToMoves(record, index);\r\n        return record;\r\n    };\r\n    /** @internal */\r\n    DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {\r\n        this._insertAfter(record, prevRecord, index);\r\n        if (this._additionsTail === null) {\r\n            // todo(vicb)\r\n            // assert(this._additionsHead === null);\r\n            this._additionsTail = this._additionsHead = record;\r\n        }\r\n        else {\r\n            // todo(vicb)\r\n            // assert(_additionsTail._nextAdded === null);\r\n            // assert(record._nextAdded === null);\r\n            this._additionsTail = this._additionsTail._nextAdded = record;\r\n        }\r\n        return record;\r\n    };\r\n    /** @internal */\r\n    DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {\r\n        // todo(vicb)\r\n        // assert(record != prevRecord);\r\n        // assert(record._next === null);\r\n        // assert(record._prev === null);\r\n        var next = prevRecord === null ? this._itHead : prevRecord._next;\r\n        // todo(vicb)\r\n        // assert(next != record);\r\n        // assert(prevRecord != record);\r\n        record._next = next;\r\n        record._prev = prevRecord;\r\n        if (next === null) {\r\n            this._itTail = record;\r\n        }\r\n        else {\r\n            next._prev = record;\r\n        }\r\n        if (prevRecord === null) {\r\n            this._itHead = record;\r\n        }\r\n        else {\r\n            prevRecord._next = record;\r\n        }\r\n        if (this._linkedRecords === null) {\r\n            this._linkedRecords = new _DuplicateMap();\r\n        }\r\n        this._linkedRecords.put(record);\r\n        record.currentIndex = index;\r\n        return record;\r\n    };\r\n    /** @internal */\r\n    DefaultIterableDiffer.prototype._remove = function (record) {\r\n        return this._addToRemovals(this._unlink(record));\r\n    };\r\n    /** @internal */\r\n    DefaultIterableDiffer.prototype._unlink = function (record) {\r\n        if (this._linkedRecords !== null) {\r\n            this._linkedRecords.remove(record);\r\n        }\r\n        var prev = record._prev;\r\n        var next = record._next;\r\n        // todo(vicb)\r\n        // assert((record._prev = null) === null);\r\n        // assert((record._next = null) === null);\r\n        if (prev === null) {\r\n            this._itHead = next;\r\n        }\r\n        else {\r\n            prev._next = next;\r\n        }\r\n        if (next === null) {\r\n            this._itTail = prev;\r\n        }\r\n        else {\r\n            next._prev = prev;\r\n        }\r\n        return record;\r\n    };\r\n    /** @internal */\r\n    DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {\r\n        // todo(vicb)\r\n        // assert(record._nextMoved === null);\r\n        if (record.previousIndex === toIndex) {\r\n            return record;\r\n        }\r\n        if (this._movesTail === null) {\r\n            // todo(vicb)\r\n            // assert(_movesHead === null);\r\n            this._movesTail = this._movesHead = record;\r\n        }\r\n        else {\r\n            // todo(vicb)\r\n            // assert(_movesTail._nextMoved === null);\r\n            this._movesTail = this._movesTail._nextMoved = record;\r\n        }\r\n        return record;\r\n    };\r\n    /** @internal */\r\n    DefaultIterableDiffer.prototype._addToRemovals = function (record) {\r\n        if (this._unlinkedRecords === null) {\r\n            this._unlinkedRecords = new _DuplicateMap();\r\n        }\r\n        this._unlinkedRecords.put(record);\r\n        record.currentIndex = null;\r\n        record._nextRemoved = null;\r\n        if (this._removalsTail === null) {\r\n            // todo(vicb)\r\n            // assert(_removalsHead === null);\r\n            this._removalsTail = this._removalsHead = record;\r\n            record._prevRemoved = null;\r\n        }\r\n        else {\r\n            // todo(vicb)\r\n            // assert(_removalsTail._nextRemoved === null);\r\n            // assert(record._nextRemoved === null);\r\n            record._prevRemoved = this._removalsTail;\r\n            this._removalsTail = this._removalsTail._nextRemoved = record;\r\n        }\r\n        return record;\r\n    };\r\n    DefaultIterableDiffer.prototype.toString = function () {\r\n        var record;\r\n        var list = [];\r\n        for (record = this._itHead; record !== null; record = record._next) {\r\n            list.push(record);\r\n        }\r\n        var previous = [];\r\n        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\r\n            previous.push(record);\r\n        }\r\n        var additions = [];\r\n        for (record = this._additionsHead; record !== null; record = record._nextAdded) {\r\n            additions.push(record);\r\n        }\r\n        var moves = [];\r\n        for (record = this._movesHead; record !== null; record = record._nextMoved) {\r\n            moves.push(record);\r\n        }\r\n        var removals = [];\r\n        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\r\n            removals.push(record);\r\n        }\r\n        return \"collection: \" + list.join(', ') + \"\\n\" + \"previous: \" + previous.join(', ') + \"\\n\" +\r\n            \"additions: \" + additions.join(', ') + \"\\n\" + \"moves: \" + moves.join(', ') + \"\\n\" +\r\n            \"removals: \" + removals.join(', ') + \"\\n\";\r\n    };\r\n    return DefaultIterableDiffer;\r\n})();\r\nexports.DefaultIterableDiffer = DefaultIterableDiffer;\r\nvar CollectionChangeRecord = (function () {\r\n    function CollectionChangeRecord(item) {\r\n        this.item = item;\r\n        this.currentIndex = null;\r\n        this.previousIndex = null;\r\n        /** @internal */\r\n        this._nextPrevious = null;\r\n        /** @internal */\r\n        this._prev = null;\r\n        /** @internal */\r\n        this._next = null;\r\n        /** @internal */\r\n        this._prevDup = null;\r\n        /** @internal */\r\n        this._nextDup = null;\r\n        /** @internal */\r\n        this._prevRemoved = null;\r\n        /** @internal */\r\n        this._nextRemoved = null;\r\n        /** @internal */\r\n        this._nextAdded = null;\r\n        /** @internal */\r\n        this._nextMoved = null;\r\n    }\r\n    CollectionChangeRecord.prototype.toString = function () {\r\n        return this.previousIndex === this.currentIndex ?\r\n            lang_2.stringify(this.item) :\r\n            lang_2.stringify(this.item) + '[' + lang_2.stringify(this.previousIndex) + '->' +\r\n                lang_2.stringify(this.currentIndex) + ']';\r\n    };\r\n    return CollectionChangeRecord;\r\n})();\r\nexports.CollectionChangeRecord = CollectionChangeRecord;\r\n// A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item\r\nvar _DuplicateItemRecordList = (function () {\r\n    function _DuplicateItemRecordList() {\r\n        /** @internal */\r\n        this._head = null;\r\n        /** @internal */\r\n        this._tail = null;\r\n    }\r\n    /**\r\n     * Append the record to the list of duplicates.\r\n     *\r\n     * Note: by design all records in the list of duplicates hold the same value in record.item.\r\n     */\r\n    _DuplicateItemRecordList.prototype.add = function (record) {\r\n        if (this._head === null) {\r\n            this._head = this._tail = record;\r\n            record._nextDup = null;\r\n            record._prevDup = null;\r\n        }\r\n        else {\r\n            // todo(vicb)\r\n            // assert(record.item ==  _head.item ||\r\n            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);\r\n            this._tail._nextDup = record;\r\n            record._prevDup = this._tail;\r\n            record._nextDup = null;\r\n            this._tail = record;\r\n        }\r\n    };\r\n    // Returns a CollectionChangeRecord having CollectionChangeRecord.item == item and\r\n    // CollectionChangeRecord.currentIndex >= afterIndex\r\n    _DuplicateItemRecordList.prototype.get = function (item, afterIndex) {\r\n        var record;\r\n        for (record = this._head; record !== null; record = record._nextDup) {\r\n            if ((afterIndex === null || afterIndex < record.currentIndex) &&\r\n                lang_2.looseIdentical(record.item, item)) {\r\n                return record;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Remove one {@link CollectionChangeRecord} from the list of duplicates.\r\n     *\r\n     * Returns whether the list of duplicates is empty.\r\n     */\r\n    _DuplicateItemRecordList.prototype.remove = function (record) {\r\n        // todo(vicb)\r\n        // assert(() {\r\n        //  // verify that the record being removed is in the list.\r\n        //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {\r\n        //    if (identical(cursor, record)) return true;\r\n        //  }\r\n        //  return false;\r\n        //});\r\n        var prev = record._prevDup;\r\n        var next = record._nextDup;\r\n        if (prev === null) {\r\n            this._head = next;\r\n        }\r\n        else {\r\n            prev._nextDup = next;\r\n        }\r\n        if (next === null) {\r\n            this._tail = prev;\r\n        }\r\n        else {\r\n            next._prevDup = prev;\r\n        }\r\n        return this._head === null;\r\n    };\r\n    return _DuplicateItemRecordList;\r\n})();\r\nvar _DuplicateMap = (function () {\r\n    function _DuplicateMap() {\r\n        this.map = new Map();\r\n    }\r\n    _DuplicateMap.prototype.put = function (record) {\r\n        // todo(vicb) handle corner cases\r\n        var key = lang_2.getMapKey(record.item);\r\n        var duplicates = this.map.get(key);\r\n        if (!lang_2.isPresent(duplicates)) {\r\n            duplicates = new _DuplicateItemRecordList();\r\n            this.map.set(key, duplicates);\r\n        }\r\n        duplicates.add(record);\r\n    };\r\n    /**\r\n     * Retrieve the `value` using key. Because the CollectionChangeRecord value maybe one which we\r\n     * have already iterated over, we use the afterIndex to pretend it is not there.\r\n     *\r\n     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\r\n     * have any more `a`s needs to return the last `a` not the first or second.\r\n     */\r\n    _DuplicateMap.prototype.get = function (value, afterIndex) {\r\n        if (afterIndex === void 0) { afterIndex = null; }\r\n        var key = lang_2.getMapKey(value);\r\n        var recordList = this.map.get(key);\r\n        return lang_2.isBlank(recordList) ? null : recordList.get(value, afterIndex);\r\n    };\r\n    /**\r\n     * Removes a {@link CollectionChangeRecord} from the list of duplicates.\r\n     *\r\n     * The list of duplicates also is removed from the map if it gets empty.\r\n     */\r\n    _DuplicateMap.prototype.remove = function (record) {\r\n        var key = lang_2.getMapKey(record.item);\r\n        // todo(vicb)\r\n        // assert(this.map.containsKey(key));\r\n        var recordList = this.map.get(key);\r\n        // Remove the list of duplicates when it gets empty\r\n        if (recordList.remove(record)) {\r\n            this.map.delete(key);\r\n        }\r\n        return record;\r\n    };\r\n    Object.defineProperty(_DuplicateMap.prototype, \"isEmpty\", {\r\n        get: function () { return this.map.size === 0; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    _DuplicateMap.prototype.clear = function () { this.map.clear(); };\r\n    _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + lang_2.stringify(this.map) + ')'; };\r\n    return _DuplicateMap;\r\n})();\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],97:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar DefaultKeyValueDifferFactory = (function () {\r\n    function DefaultKeyValueDifferFactory() {\r\n    }\r\n    DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || lang_1.isJsObject(obj); };\r\n    DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };\r\n    DefaultKeyValueDifferFactory = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [])\r\n    ], DefaultKeyValueDifferFactory);\r\n    return DefaultKeyValueDifferFactory;\r\n})();\r\nexports.DefaultKeyValueDifferFactory = DefaultKeyValueDifferFactory;\r\nvar DefaultKeyValueDiffer = (function () {\r\n    function DefaultKeyValueDiffer() {\r\n        this._records = new Map();\r\n        this._mapHead = null;\r\n        this._previousMapHead = null;\r\n        this._changesHead = null;\r\n        this._changesTail = null;\r\n        this._additionsHead = null;\r\n        this._additionsTail = null;\r\n        this._removalsHead = null;\r\n        this._removalsTail = null;\r\n    }\r\n    Object.defineProperty(DefaultKeyValueDiffer.prototype, \"isDirty\", {\r\n        get: function () {\r\n            return this._additionsHead !== null || this._changesHead !== null ||\r\n                this._removalsHead !== null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {\r\n        var record;\r\n        for (record = this._mapHead; record !== null; record = record._next) {\r\n            fn(record);\r\n        }\r\n    };\r\n    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {\r\n        var record;\r\n        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\r\n            fn(record);\r\n        }\r\n    };\r\n    DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {\r\n        var record;\r\n        for (record = this._changesHead; record !== null; record = record._nextChanged) {\r\n            fn(record);\r\n        }\r\n    };\r\n    DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {\r\n        var record;\r\n        for (record = this._additionsHead; record !== null; record = record._nextAdded) {\r\n            fn(record);\r\n        }\r\n    };\r\n    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {\r\n        var record;\r\n        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\r\n            fn(record);\r\n        }\r\n    };\r\n    DefaultKeyValueDiffer.prototype.diff = function (map) {\r\n        if (lang_1.isBlank(map))\r\n            map = collection_1.MapWrapper.createFromPairs([]);\r\n        if (!(map instanceof Map || lang_1.isJsObject(map))) {\r\n            throw new exceptions_1.BaseException(\"Error trying to diff '\" + map + \"'\");\r\n        }\r\n        if (this.check(map)) {\r\n            return this;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    DefaultKeyValueDiffer.prototype.onDestroy = function () { };\r\n    DefaultKeyValueDiffer.prototype.check = function (map) {\r\n        var _this = this;\r\n        this._reset();\r\n        var records = this._records;\r\n        var oldSeqRecord = this._mapHead;\r\n        var lastOldSeqRecord = null;\r\n        var lastNewSeqRecord = null;\r\n        var seqChanged = false;\r\n        this._forEach(map, function (value, key) {\r\n            var newSeqRecord;\r\n            if (oldSeqRecord !== null && key === oldSeqRecord.key) {\r\n                newSeqRecord = oldSeqRecord;\r\n                if (!lang_1.looseIdentical(value, oldSeqRecord.currentValue)) {\r\n                    oldSeqRecord.previousValue = oldSeqRecord.currentValue;\r\n                    oldSeqRecord.currentValue = value;\r\n                    _this._addToChanges(oldSeqRecord);\r\n                }\r\n            }\r\n            else {\r\n                seqChanged = true;\r\n                if (oldSeqRecord !== null) {\r\n                    oldSeqRecord._next = null;\r\n                    _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);\r\n                    _this._addToRemovals(oldSeqRecord);\r\n                }\r\n                if (records.has(key)) {\r\n                    newSeqRecord = records.get(key);\r\n                }\r\n                else {\r\n                    newSeqRecord = new KVChangeRecord(key);\r\n                    records.set(key, newSeqRecord);\r\n                    newSeqRecord.currentValue = value;\r\n                    _this._addToAdditions(newSeqRecord);\r\n                }\r\n            }\r\n            if (seqChanged) {\r\n                if (_this._isInRemovals(newSeqRecord)) {\r\n                    _this._removeFromRemovals(newSeqRecord);\r\n                }\r\n                if (lastNewSeqRecord == null) {\r\n                    _this._mapHead = newSeqRecord;\r\n                }\r\n                else {\r\n                    lastNewSeqRecord._next = newSeqRecord;\r\n                }\r\n            }\r\n            lastOldSeqRecord = oldSeqRecord;\r\n            lastNewSeqRecord = newSeqRecord;\r\n            oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;\r\n        });\r\n        this._truncate(lastOldSeqRecord, oldSeqRecord);\r\n        return this.isDirty;\r\n    };\r\n    /** @internal */\r\n    DefaultKeyValueDiffer.prototype._reset = function () {\r\n        if (this.isDirty) {\r\n            var record;\r\n            // Record the state of the mapping\r\n            for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {\r\n                record._nextPrevious = record._next;\r\n            }\r\n            for (record = this._changesHead; record !== null; record = record._nextChanged) {\r\n                record.previousValue = record.currentValue;\r\n            }\r\n            for (record = this._additionsHead; record != null; record = record._nextAdded) {\r\n                record.previousValue = record.currentValue;\r\n            }\r\n            // todo(vicb) once assert is supported\r\n            // assert(() {\r\n            //  var r = _changesHead;\r\n            //  while (r != null) {\r\n            //    var nextRecord = r._nextChanged;\r\n            //    r._nextChanged = null;\r\n            //    r = nextRecord;\r\n            //  }\r\n            //\r\n            //  r = _additionsHead;\r\n            //  while (r != null) {\r\n            //    var nextRecord = r._nextAdded;\r\n            //    r._nextAdded = null;\r\n            //    r = nextRecord;\r\n            //  }\r\n            //\r\n            //  r = _removalsHead;\r\n            //  while (r != null) {\r\n            //    var nextRecord = r._nextRemoved;\r\n            //    r._nextRemoved = null;\r\n            //    r = nextRecord;\r\n            //  }\r\n            //\r\n            //  return true;\r\n            //});\r\n            this._changesHead = this._changesTail = null;\r\n            this._additionsHead = this._additionsTail = null;\r\n            this._removalsHead = this._removalsTail = null;\r\n        }\r\n    };\r\n    /** @internal */\r\n    DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {\r\n        while (record !== null) {\r\n            if (lastRecord === null) {\r\n                this._mapHead = null;\r\n            }\r\n            else {\r\n                lastRecord._next = null;\r\n            }\r\n            var nextRecord = record._next;\r\n            // todo(vicb) assert\r\n            // assert((() {\r\n            //  record._next = null;\r\n            //  return true;\r\n            //}));\r\n            this._addToRemovals(record);\r\n            lastRecord = record;\r\n            record = nextRecord;\r\n        }\r\n        for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {\r\n            rec.previousValue = rec.currentValue;\r\n            rec.currentValue = null;\r\n            this._records.delete(rec.key);\r\n        }\r\n    };\r\n    /** @internal */\r\n    DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {\r\n        return record === this._removalsHead || record._nextRemoved !== null ||\r\n            record._prevRemoved !== null;\r\n    };\r\n    /** @internal */\r\n    DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {\r\n        // todo(vicb) assert\r\n        // assert(record._next == null);\r\n        // assert(record._nextAdded == null);\r\n        // assert(record._nextChanged == null);\r\n        // assert(record._nextRemoved == null);\r\n        // assert(record._prevRemoved == null);\r\n        if (this._removalsHead === null) {\r\n            this._removalsHead = this._removalsTail = record;\r\n        }\r\n        else {\r\n            this._removalsTail._nextRemoved = record;\r\n            record._prevRemoved = this._removalsTail;\r\n            this._removalsTail = record;\r\n        }\r\n    };\r\n    /** @internal */\r\n    DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {\r\n        var next = record._next;\r\n        if (prev === null) {\r\n            this._mapHead = next;\r\n        }\r\n        else {\r\n            prev._next = next;\r\n        }\r\n        // todo(vicb) assert\r\n        // assert((() {\r\n        //  record._next = null;\r\n        //  return true;\r\n        //})());\r\n    };\r\n    /** @internal */\r\n    DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {\r\n        // todo(vicb) assert\r\n        // assert(record._next == null);\r\n        // assert(record._nextAdded == null);\r\n        // assert(record._nextChanged == null);\r\n        var prev = record._prevRemoved;\r\n        var next = record._nextRemoved;\r\n        if (prev === null) {\r\n            this._removalsHead = next;\r\n        }\r\n        else {\r\n            prev._nextRemoved = next;\r\n        }\r\n        if (next === null) {\r\n            this._removalsTail = prev;\r\n        }\r\n        else {\r\n            next._prevRemoved = prev;\r\n        }\r\n        record._prevRemoved = record._nextRemoved = null;\r\n    };\r\n    /** @internal */\r\n    DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {\r\n        // todo(vicb): assert\r\n        // assert(record._next == null);\r\n        // assert(record._nextAdded == null);\r\n        // assert(record._nextChanged == null);\r\n        // assert(record._nextRemoved == null);\r\n        // assert(record._prevRemoved == null);\r\n        if (this._additionsHead === null) {\r\n            this._additionsHead = this._additionsTail = record;\r\n        }\r\n        else {\r\n            this._additionsTail._nextAdded = record;\r\n            this._additionsTail = record;\r\n        }\r\n    };\r\n    /** @internal */\r\n    DefaultKeyValueDiffer.prototype._addToChanges = function (record) {\r\n        // todo(vicb) assert\r\n        // assert(record._nextAdded == null);\r\n        // assert(record._nextChanged == null);\r\n        // assert(record._nextRemoved == null);\r\n        // assert(record._prevRemoved == null);\r\n        if (this._changesHead === null) {\r\n            this._changesHead = this._changesTail = record;\r\n        }\r\n        else {\r\n            this._changesTail._nextChanged = record;\r\n            this._changesTail = record;\r\n        }\r\n    };\r\n    DefaultKeyValueDiffer.prototype.toString = function () {\r\n        var items = [];\r\n        var previous = [];\r\n        var changes = [];\r\n        var additions = [];\r\n        var removals = [];\r\n        var record;\r\n        for (record = this._mapHead; record !== null; record = record._next) {\r\n            items.push(lang_1.stringify(record));\r\n        }\r\n        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\r\n            previous.push(lang_1.stringify(record));\r\n        }\r\n        for (record = this._changesHead; record !== null; record = record._nextChanged) {\r\n            changes.push(lang_1.stringify(record));\r\n        }\r\n        for (record = this._additionsHead; record !== null; record = record._nextAdded) {\r\n            additions.push(lang_1.stringify(record));\r\n        }\r\n        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\r\n            removals.push(lang_1.stringify(record));\r\n        }\r\n        return \"map: \" + items.join(', ') + \"\\n\" + \"previous: \" + previous.join(', ') + \"\\n\" +\r\n            \"additions: \" + additions.join(', ') + \"\\n\" + \"changes: \" + changes.join(', ') + \"\\n\" +\r\n            \"removals: \" + removals.join(', ') + \"\\n\";\r\n    };\r\n    /** @internal */\r\n    DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {\r\n        if (obj instanceof Map) {\r\n            obj.forEach(fn);\r\n        }\r\n        else {\r\n            collection_1.StringMapWrapper.forEach(obj, fn);\r\n        }\r\n    };\r\n    return DefaultKeyValueDiffer;\r\n})();\r\nexports.DefaultKeyValueDiffer = DefaultKeyValueDiffer;\r\nvar KVChangeRecord = (function () {\r\n    function KVChangeRecord(key) {\r\n        this.key = key;\r\n        this.previousValue = null;\r\n        this.currentValue = null;\r\n        /** @internal */\r\n        this._nextPrevious = null;\r\n        /** @internal */\r\n        this._next = null;\r\n        /** @internal */\r\n        this._nextAdded = null;\r\n        /** @internal */\r\n        this._nextRemoved = null;\r\n        /** @internal */\r\n        this._prevRemoved = null;\r\n        /** @internal */\r\n        this._nextChanged = null;\r\n    }\r\n    KVChangeRecord.prototype.toString = function () {\r\n        return lang_1.looseIdentical(this.previousValue, this.currentValue) ?\r\n            lang_1.stringify(this.key) :\r\n            (lang_1.stringify(this.key) + '[' + lang_1.stringify(this.previousValue) + '->' +\r\n                lang_1.stringify(this.currentValue) + ']');\r\n    };\r\n    return KVChangeRecord;\r\n})();\r\nexports.KVChangeRecord = KVChangeRecord;\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],98:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar di_1 = require('angular2/src/core/di');\r\n/**\r\n * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\r\n */\r\nvar IterableDiffers = (function () {\r\n    function IterableDiffers(factories) {\r\n        this.factories = factories;\r\n    }\r\n    IterableDiffers.create = function (factories, parent) {\r\n        if (lang_1.isPresent(parent)) {\r\n            var copied = collection_1.ListWrapper.clone(parent.factories);\r\n            factories = factories.concat(copied);\r\n            return new IterableDiffers(factories);\r\n        }\r\n        else {\r\n            return new IterableDiffers(factories);\r\n        }\r\n    };\r\n    /**\r\n     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\r\n     * inherited {@link IterableDiffers} instance with the provided factories and return a new\r\n     * {@link IterableDiffers} instance.\r\n     *\r\n     * The following example shows how to extend an existing list of factories,\r\n           * which will only be applied to the injector for this component and its children.\r\n           * This step is all that's required to make a new {@link IterableDiffer} available.\r\n     *\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * @Component({\r\n     *   viewProviders: [\r\n     *     IterableDiffers.extend([new ImmutableListDiffer()])\r\n     *   ]\r\n     * })\r\n     * ```\r\n     */\r\n    IterableDiffers.extend = function (factories) {\r\n        return new di_1.Provider(IterableDiffers, {\r\n            useFactory: function (parent) {\r\n                if (lang_1.isBlank(parent)) {\r\n                    // Typically would occur when calling IterableDiffers.extend inside of dependencies passed\r\n                    // to\r\n                    // bootstrap(), which would override default pipes instead of extending them.\r\n                    throw new exceptions_1.BaseException('Cannot extend IterableDiffers without a parent injector');\r\n                }\r\n                return IterableDiffers.create(factories, parent);\r\n            },\r\n            // Dependency technically isn't optional, but we can provide a better error message this way.\r\n            deps: [[IterableDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]\r\n        });\r\n    };\r\n    IterableDiffers.prototype.find = function (iterable) {\r\n        var factory = this.factories.find(function (f) { return f.supports(iterable); });\r\n        if (lang_1.isPresent(factory)) {\r\n            return factory;\r\n        }\r\n        else {\r\n            throw new exceptions_1.BaseException(\"Cannot find a differ supporting object '\" + iterable + \"'\");\r\n        }\r\n    };\r\n    IterableDiffers = __decorate([\r\n        di_1.Injectable(),\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Array])\r\n    ], IterableDiffers);\r\n    return IterableDiffers;\r\n})();\r\nexports.IterableDiffers = IterableDiffers;\r\n},{\"angular2/src/core/di\":117,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],99:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar di_1 = require('angular2/src/core/di');\r\n/**\r\n * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\r\n */\r\nvar KeyValueDiffers = (function () {\r\n    function KeyValueDiffers(factories) {\r\n        this.factories = factories;\r\n    }\r\n    KeyValueDiffers.create = function (factories, parent) {\r\n        if (lang_1.isPresent(parent)) {\r\n            var copied = collection_1.ListWrapper.clone(parent.factories);\r\n            factories = factories.concat(copied);\r\n            return new KeyValueDiffers(factories);\r\n        }\r\n        else {\r\n            return new KeyValueDiffers(factories);\r\n        }\r\n    };\r\n    /**\r\n     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\r\n     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\r\n     * {@link KeyValueDiffers} instance.\r\n     *\r\n     * The following example shows how to extend an existing list of factories,\r\n           * which will only be applied to the injector for this component and its children.\r\n           * This step is all that's required to make a new {@link KeyValueDiffer} available.\r\n     *\r\n     * ### Example\r\n     *\r\n     * ```\r\n     * @Component({\r\n     *   viewProviders: [\r\n     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\r\n     *   ]\r\n     * })\r\n     * ```\r\n     */\r\n    KeyValueDiffers.extend = function (factories) {\r\n        return new di_1.Provider(KeyValueDiffers, {\r\n            useFactory: function (parent) {\r\n                if (lang_1.isBlank(parent)) {\r\n                    // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed\r\n                    // to\r\n                    // bootstrap(), which would override default pipes instead of extending them.\r\n                    throw new exceptions_1.BaseException('Cannot extend KeyValueDiffers without a parent injector');\r\n                }\r\n                return KeyValueDiffers.create(factories, parent);\r\n            },\r\n            // Dependency technically isn't optional, but we can provide a better error message this way.\r\n            deps: [[KeyValueDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]\r\n        });\r\n    };\r\n    KeyValueDiffers.prototype.find = function (kv) {\r\n        var factory = this.factories.find(function (f) { return f.supports(kv); });\r\n        if (lang_1.isPresent(factory)) {\r\n            return factory;\r\n        }\r\n        else {\r\n            throw new exceptions_1.BaseException(\"Cannot find a differ supporting object '\" + kv + \"'\");\r\n        }\r\n    };\r\n    KeyValueDiffers = __decorate([\r\n        di_1.Injectable(),\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Array])\r\n    ], KeyValueDiffers);\r\n    return KeyValueDiffers;\r\n})();\r\nexports.KeyValueDiffers = KeyValueDiffers;\r\n},{\"angular2/src/core/di\":117,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],100:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar constants_1 = require('./constants');\r\nvar DirectiveIndex = (function () {\r\n    function DirectiveIndex(elementIndex, directiveIndex) {\r\n        this.elementIndex = elementIndex;\r\n        this.directiveIndex = directiveIndex;\r\n    }\r\n    Object.defineProperty(DirectiveIndex.prototype, \"name\", {\r\n        get: function () { return this.elementIndex + \"_\" + this.directiveIndex; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return DirectiveIndex;\r\n})();\r\nexports.DirectiveIndex = DirectiveIndex;\r\nvar DirectiveRecord = (function () {\r\n    function DirectiveRecord(_a) {\r\n        var _b = _a === void 0 ? {} : _a, directiveIndex = _b.directiveIndex, callAfterContentInit = _b.callAfterContentInit, callAfterContentChecked = _b.callAfterContentChecked, callAfterViewInit = _b.callAfterViewInit, callAfterViewChecked = _b.callAfterViewChecked, callOnChanges = _b.callOnChanges, callDoCheck = _b.callDoCheck, callOnInit = _b.callOnInit, callOnDestroy = _b.callOnDestroy, changeDetection = _b.changeDetection, outputs = _b.outputs;\r\n        this.directiveIndex = directiveIndex;\r\n        this.callAfterContentInit = lang_1.normalizeBool(callAfterContentInit);\r\n        this.callAfterContentChecked = lang_1.normalizeBool(callAfterContentChecked);\r\n        this.callOnChanges = lang_1.normalizeBool(callOnChanges);\r\n        this.callAfterViewInit = lang_1.normalizeBool(callAfterViewInit);\r\n        this.callAfterViewChecked = lang_1.normalizeBool(callAfterViewChecked);\r\n        this.callDoCheck = lang_1.normalizeBool(callDoCheck);\r\n        this.callOnInit = lang_1.normalizeBool(callOnInit);\r\n        this.callOnDestroy = lang_1.normalizeBool(callOnDestroy);\r\n        this.changeDetection = changeDetection;\r\n        this.outputs = outputs;\r\n    }\r\n    DirectiveRecord.prototype.isDefaultChangeDetection = function () {\r\n        return constants_1.isDefaultChangeDetectionStrategy(this.changeDetection);\r\n    };\r\n    return DirectiveRecord;\r\n})();\r\nexports.DirectiveRecord = DirectiveRecord;\r\n},{\"./constants\":95,\"angular2/src/facade/lang\":176}],101:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar abstract_change_detector_1 = require('./abstract_change_detector');\r\nvar change_detection_util_1 = require('./change_detection_util');\r\nvar constants_1 = require('./constants');\r\nvar proto_record_1 = require('./proto_record');\r\nvar reflection_1 = require('angular2/src/core/reflection/reflection');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar DynamicChangeDetector = (function (_super) {\r\n    __extends(DynamicChangeDetector, _super);\r\n    function DynamicChangeDetector(id, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy, _records, _eventBindings, _directiveRecords, _genConfig) {\r\n        _super.call(this, id, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy);\r\n        this._records = _records;\r\n        this._eventBindings = _eventBindings;\r\n        this._directiveRecords = _directiveRecords;\r\n        this._genConfig = _genConfig;\r\n        var len = _records.length + 1;\r\n        this.values = collection_1.ListWrapper.createFixedSize(len);\r\n        this.localPipes = collection_1.ListWrapper.createFixedSize(len);\r\n        this.prevContexts = collection_1.ListWrapper.createFixedSize(len);\r\n        this.changes = collection_1.ListWrapper.createFixedSize(len);\r\n        this.dehydrateDirectives(false);\r\n    }\r\n    DynamicChangeDetector.prototype.handleEventInternal = function (eventName, elIndex, locals) {\r\n        var _this = this;\r\n        var preventDefault = false;\r\n        this._matchingEventBindings(eventName, elIndex)\r\n            .forEach(function (rec) {\r\n            var res = _this._processEventBinding(rec, locals);\r\n            if (res === false) {\r\n                preventDefault = true;\r\n            }\r\n        });\r\n        return preventDefault;\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._processEventBinding = function (eb, locals) {\r\n        var values = collection_1.ListWrapper.createFixedSize(eb.records.length);\r\n        values[0] = this.values[0];\r\n        for (var protoIdx = 0; protoIdx < eb.records.length; ++protoIdx) {\r\n            var proto = eb.records[protoIdx];\r\n            if (proto.isSkipRecord()) {\r\n                protoIdx += this._computeSkipLength(protoIdx, proto, values);\r\n            }\r\n            else {\r\n                var res = this._calculateCurrValue(proto, values, locals);\r\n                if (proto.lastInBinding) {\r\n                    this._markPathAsCheckOnce(proto);\r\n                    return res;\r\n                }\r\n                else {\r\n                    this._writeSelf(proto, res, values);\r\n                }\r\n            }\r\n        }\r\n        throw new exceptions_1.BaseException(\"Cannot be reached\");\r\n    };\r\n    DynamicChangeDetector.prototype._computeSkipLength = function (protoIndex, proto, values) {\r\n        if (proto.mode === proto_record_1.RecordType.SkipRecords) {\r\n            return proto.fixedArgs[0] - protoIndex - 1;\r\n        }\r\n        if (proto.mode === proto_record_1.RecordType.SkipRecordsIf) {\r\n            var condition = this._readContext(proto, values);\r\n            return condition ? proto.fixedArgs[0] - protoIndex - 1 : 0;\r\n        }\r\n        if (proto.mode === proto_record_1.RecordType.SkipRecordsIfNot) {\r\n            var condition = this._readContext(proto, values);\r\n            return condition ? 0 : proto.fixedArgs[0] - protoIndex - 1;\r\n        }\r\n        throw new exceptions_1.BaseException(\"Cannot be reached\");\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._markPathAsCheckOnce = function (proto) {\r\n        if (!proto.bindingRecord.isDefaultChangeDetection()) {\r\n            var dir = proto.bindingRecord.directiveRecord;\r\n            this._getDetectorFor(dir.directiveIndex).markPathToRootAsCheckOnce();\r\n        }\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._matchingEventBindings = function (eventName, elIndex) {\r\n        return this._eventBindings.filter(function (eb) { return eb.eventName == eventName && eb.elIndex === elIndex; });\r\n    };\r\n    DynamicChangeDetector.prototype.hydrateDirectives = function (dispatcher) {\r\n        var _this = this;\r\n        this.values[0] = this.context;\r\n        this.dispatcher = dispatcher;\r\n        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {\r\n            for (var i = 0; i < this.directiveIndices.length; ++i) {\r\n                var index = this.directiveIndices[i];\r\n                _super.prototype.observeDirective.call(this, this._getDirectiveFor(index), i);\r\n            }\r\n        }\r\n        for (var i = 0; i < this._directiveRecords.length; ++i) {\r\n            var r = this._directiveRecords[i];\r\n            if (lang_1.isPresent(r.outputs)) {\r\n                r.outputs.forEach(function (output) {\r\n                    var eventHandler = _this._createEventHandler(r.directiveIndex.elementIndex, output[1]);\r\n                    var directive = _this._getDirectiveFor(r.directiveIndex);\r\n                    var getter = reflection_1.reflector.getter(output[0]);\r\n                    async_1.ObservableWrapper.subscribe(getter(directive), eventHandler);\r\n                });\r\n            }\r\n        }\r\n    };\r\n    DynamicChangeDetector.prototype._createEventHandler = function (boundElementIndex, eventName) {\r\n        var _this = this;\r\n        return function (event) { return _this.handleEvent(eventName, boundElementIndex, event); };\r\n    };\r\n    DynamicChangeDetector.prototype.dehydrateDirectives = function (destroyPipes) {\r\n        if (destroyPipes) {\r\n            this._destroyPipes();\r\n            this._destroyDirectives();\r\n        }\r\n        this.values[0] = null;\r\n        collection_1.ListWrapper.fill(this.values, change_detection_util_1.ChangeDetectionUtil.uninitialized, 1);\r\n        collection_1.ListWrapper.fill(this.changes, false);\r\n        collection_1.ListWrapper.fill(this.localPipes, null);\r\n        collection_1.ListWrapper.fill(this.prevContexts, change_detection_util_1.ChangeDetectionUtil.uninitialized);\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._destroyPipes = function () {\r\n        for (var i = 0; i < this.localPipes.length; ++i) {\r\n            if (lang_1.isPresent(this.localPipes[i])) {\r\n                change_detection_util_1.ChangeDetectionUtil.callPipeOnDestroy(this.localPipes[i]);\r\n            }\r\n        }\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._destroyDirectives = function () {\r\n        for (var i = 0; i < this._directiveRecords.length; ++i) {\r\n            var record = this._directiveRecords[i];\r\n            if (record.callOnDestroy) {\r\n                this._getDirectiveFor(record.directiveIndex).ngOnDestroy();\r\n            }\r\n        }\r\n    };\r\n    DynamicChangeDetector.prototype.checkNoChanges = function () { this.runDetectChanges(true); };\r\n    DynamicChangeDetector.prototype.detectChangesInRecordsInternal = function (throwOnChange) {\r\n        var protos = this._records;\r\n        var changes = null;\r\n        var isChanged = false;\r\n        for (var protoIdx = 0; protoIdx < protos.length; ++protoIdx) {\r\n            var proto = protos[protoIdx];\r\n            var bindingRecord = proto.bindingRecord;\r\n            var directiveRecord = bindingRecord.directiveRecord;\r\n            if (this._firstInBinding(proto)) {\r\n                this.propertyBindingIndex = proto.propertyBindingIndex;\r\n            }\r\n            if (proto.isLifeCycleRecord()) {\r\n                if (proto.name === \"DoCheck\" && !throwOnChange) {\r\n                    this._getDirectiveFor(directiveRecord.directiveIndex).ngDoCheck();\r\n                }\r\n                else if (proto.name === \"OnInit\" && !throwOnChange &&\r\n                    this.state == constants_1.ChangeDetectorState.NeverChecked) {\r\n                    this._getDirectiveFor(directiveRecord.directiveIndex).ngOnInit();\r\n                }\r\n                else if (proto.name === \"OnChanges\" && lang_1.isPresent(changes) && !throwOnChange) {\r\n                    this._getDirectiveFor(directiveRecord.directiveIndex).ngOnChanges(changes);\r\n                }\r\n            }\r\n            else if (proto.isSkipRecord()) {\r\n                protoIdx += this._computeSkipLength(protoIdx, proto, this.values);\r\n            }\r\n            else {\r\n                var change = this._check(proto, throwOnChange, this.values, this.locals);\r\n                if (lang_1.isPresent(change)) {\r\n                    this._updateDirectiveOrElement(change, bindingRecord);\r\n                    isChanged = true;\r\n                    changes = this._addChange(bindingRecord, change, changes);\r\n                }\r\n            }\r\n            if (proto.lastInDirective) {\r\n                changes = null;\r\n                if (isChanged && !bindingRecord.isDefaultChangeDetection()) {\r\n                    this._getDetectorFor(directiveRecord.directiveIndex).markAsCheckOnce();\r\n                }\r\n                isChanged = false;\r\n            }\r\n        }\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._firstInBinding = function (r) {\r\n        var prev = change_detection_util_1.ChangeDetectionUtil.protoByIndex(this._records, r.selfIndex - 1);\r\n        return lang_1.isBlank(prev) || prev.bindingRecord !== r.bindingRecord;\r\n    };\r\n    DynamicChangeDetector.prototype.afterContentLifecycleCallbacksInternal = function () {\r\n        var dirs = this._directiveRecords;\r\n        for (var i = dirs.length - 1; i >= 0; --i) {\r\n            var dir = dirs[i];\r\n            if (dir.callAfterContentInit && this.state == constants_1.ChangeDetectorState.NeverChecked) {\r\n                this._getDirectiveFor(dir.directiveIndex).ngAfterContentInit();\r\n            }\r\n            if (dir.callAfterContentChecked) {\r\n                this._getDirectiveFor(dir.directiveIndex).ngAfterContentChecked();\r\n            }\r\n        }\r\n    };\r\n    DynamicChangeDetector.prototype.afterViewLifecycleCallbacksInternal = function () {\r\n        var dirs = this._directiveRecords;\r\n        for (var i = dirs.length - 1; i >= 0; --i) {\r\n            var dir = dirs[i];\r\n            if (dir.callAfterViewInit && this.state == constants_1.ChangeDetectorState.NeverChecked) {\r\n                this._getDirectiveFor(dir.directiveIndex).ngAfterViewInit();\r\n            }\r\n            if (dir.callAfterViewChecked) {\r\n                this._getDirectiveFor(dir.directiveIndex).ngAfterViewChecked();\r\n            }\r\n        }\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._updateDirectiveOrElement = function (change, bindingRecord) {\r\n        if (lang_1.isBlank(bindingRecord.directiveRecord)) {\r\n            _super.prototype.notifyDispatcher.call(this, change.currentValue);\r\n        }\r\n        else {\r\n            var directiveIndex = bindingRecord.directiveRecord.directiveIndex;\r\n            bindingRecord.setter(this._getDirectiveFor(directiveIndex), change.currentValue);\r\n        }\r\n        if (this._genConfig.logBindingUpdate) {\r\n            _super.prototype.logBindingUpdate.call(this, change.currentValue);\r\n        }\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._addChange = function (bindingRecord, change, changes) {\r\n        if (bindingRecord.callOnChanges()) {\r\n            return _super.prototype.addChange.call(this, changes, change.previousValue, change.currentValue);\r\n        }\r\n        else {\r\n            return changes;\r\n        }\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._getDirectiveFor = function (directiveIndex) {\r\n        return this.dispatcher.getDirectiveFor(directiveIndex);\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._getDetectorFor = function (directiveIndex) {\r\n        return this.dispatcher.getDetectorFor(directiveIndex);\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._check = function (proto, throwOnChange, values, locals) {\r\n        if (proto.isPipeRecord()) {\r\n            return this._pipeCheck(proto, throwOnChange, values);\r\n        }\r\n        else {\r\n            return this._referenceCheck(proto, throwOnChange, values, locals);\r\n        }\r\n    };\r\n    /** @internal */\r\n    DynamicChangeDetector.prototype._referenceCheck = function (proto, throwOnChange, values, locals) {\r\n        if (this._pureFuncAndArgsDidNotChange(proto)) {\r\n            this._setChanged(proto, false);\r\n            return null;\r\n        }\r\n        var currValue = this._calculateCurrValue(proto, values, locals);\r\n        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {\r\n            _super.prototype.observeValue.call(this, currValue, proto.selfIndex);\r\n        }\r\n        if (proto.shouldBeChecked()) {\r\n            var prevValue = this._readSelf(proto, values);\r\n            if (change_detection_util_1.ChangeDetectionUtil.looseNotIdentical(prevValue, currValue)) {\r\n                if (proto.lastInBinding) {\r\n                    var change = change_detection_util_1.ChangeDetectionUtil.simpleChange(prevValue, currValue);\r\n                    if (throwOnChange)\r\n                        this.throwOnChangeError(prevValue, currValue);\r\n                    this._writeSelf(proto, currValue, values);\r\n                    this._setChanged(proto, true);\r\n                    return change;\r\n                }\r\n                else {\r\n                    this._writeSelf(proto, currValue, values);\r\n                    this._setChanged(proto, true);\r\n                    return null;\r\n                }\r\n            }\r\n            else {\r\n                this._setChanged(proto, false);\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            this._writeSelf(proto, currValue, values);\r\n            this._setChanged(proto, true);\r\n            return null;\r\n        }\r\n    };\r\n    DynamicChangeDetector.prototype._calculateCurrValue = function (proto, values, locals) {\r\n        switch (proto.mode) {\r\n            case proto_record_1.RecordType.Self:\r\n                return this._readContext(proto, values);\r\n            case proto_record_1.RecordType.Const:\r\n                return proto.funcOrValue;\r\n            case proto_record_1.RecordType.PropertyRead:\r\n                var context = this._readContext(proto, values);\r\n                return proto.funcOrValue(context);\r\n            case proto_record_1.RecordType.SafeProperty:\r\n                var context = this._readContext(proto, values);\r\n                return lang_1.isBlank(context) ? null : proto.funcOrValue(context);\r\n            case proto_record_1.RecordType.PropertyWrite:\r\n                var context = this._readContext(proto, values);\r\n                var value = this._readArgs(proto, values)[0];\r\n                proto.funcOrValue(context, value);\r\n                return value;\r\n            case proto_record_1.RecordType.KeyedWrite:\r\n                var context = this._readContext(proto, values);\r\n                var key = this._readArgs(proto, values)[0];\r\n                var value = this._readArgs(proto, values)[1];\r\n                context[key] = value;\r\n                return value;\r\n            case proto_record_1.RecordType.Local:\r\n                return locals.get(proto.name);\r\n            case proto_record_1.RecordType.InvokeMethod:\r\n                var context = this._readContext(proto, values);\r\n                var args = this._readArgs(proto, values);\r\n                return proto.funcOrValue(context, args);\r\n            case proto_record_1.RecordType.SafeMethodInvoke:\r\n                var context = this._readContext(proto, values);\r\n                if (lang_1.isBlank(context)) {\r\n                    return null;\r\n                }\r\n                var args = this._readArgs(proto, values);\r\n                return proto.funcOrValue(context, args);\r\n            case proto_record_1.RecordType.KeyedRead:\r\n                var arg = this._readArgs(proto, values)[0];\r\n                return this._readContext(proto, values)[arg];\r\n            case proto_record_1.RecordType.Chain:\r\n                var args = this._readArgs(proto, values);\r\n                return args[args.length - 1];\r\n            case proto_record_1.RecordType.InvokeClosure:\r\n                return lang_1.FunctionWrapper.apply(this._readContext(proto, values), this._readArgs(proto, values));\r\n            case proto_record_1.RecordType.Interpolate:\r\n            case proto_record_1.RecordType.PrimitiveOp:\r\n            case proto_record_1.RecordType.CollectionLiteral:\r\n                return lang_1.FunctionWrapper.apply(proto.funcOrValue, this._readArgs(proto, values));\r\n            default:\r\n                throw new exceptions_1.BaseException(\"Unknown operation \" + proto.mode);\r\n        }\r\n    };\r\n    DynamicChangeDetector.prototype._pipeCheck = function (proto, throwOnChange, values) {\r\n        var context = this._readContext(proto, values);\r\n        var selectedPipe = this._pipeFor(proto, context);\r\n        if (!selectedPipe.pure || this._argsOrContextChanged(proto)) {\r\n            var args = this._readArgs(proto, values);\r\n            var currValue = selectedPipe.pipe.transform(context, args);\r\n            if (proto.shouldBeChecked()) {\r\n                var prevValue = this._readSelf(proto, values);\r\n                if (change_detection_util_1.ChangeDetectionUtil.looseNotIdentical(prevValue, currValue)) {\r\n                    currValue = change_detection_util_1.ChangeDetectionUtil.unwrapValue(currValue);\r\n                    if (proto.lastInBinding) {\r\n                        var change = change_detection_util_1.ChangeDetectionUtil.simpleChange(prevValue, currValue);\r\n                        if (throwOnChange)\r\n                            this.throwOnChangeError(prevValue, currValue);\r\n                        this._writeSelf(proto, currValue, values);\r\n                        this._setChanged(proto, true);\r\n                        return change;\r\n                    }\r\n                    else {\r\n                        this._writeSelf(proto, currValue, values);\r\n                        this._setChanged(proto, true);\r\n                        return null;\r\n                    }\r\n                }\r\n                else {\r\n                    this._setChanged(proto, false);\r\n                    return null;\r\n                }\r\n            }\r\n            else {\r\n                this._writeSelf(proto, currValue, values);\r\n                this._setChanged(proto, true);\r\n                return null;\r\n            }\r\n        }\r\n    };\r\n    DynamicChangeDetector.prototype._pipeFor = function (proto, context) {\r\n        var storedPipe = this._readPipe(proto);\r\n        if (lang_1.isPresent(storedPipe))\r\n            return storedPipe;\r\n        var pipe = this.pipes.get(proto.name);\r\n        this._writePipe(proto, pipe);\r\n        return pipe;\r\n    };\r\n    DynamicChangeDetector.prototype._readContext = function (proto, values) {\r\n        if (proto.contextIndex == -1) {\r\n            return this._getDirectiveFor(proto.directiveIndex);\r\n        }\r\n        return values[proto.contextIndex];\r\n    };\r\n    DynamicChangeDetector.prototype._readSelf = function (proto, values) { return values[proto.selfIndex]; };\r\n    DynamicChangeDetector.prototype._writeSelf = function (proto, value, values) { values[proto.selfIndex] = value; };\r\n    DynamicChangeDetector.prototype._readPipe = function (proto) { return this.localPipes[proto.selfIndex]; };\r\n    DynamicChangeDetector.prototype._writePipe = function (proto, value) { this.localPipes[proto.selfIndex] = value; };\r\n    DynamicChangeDetector.prototype._setChanged = function (proto, value) {\r\n        if (proto.argumentToPureFunction)\r\n            this.changes[proto.selfIndex] = value;\r\n    };\r\n    DynamicChangeDetector.prototype._pureFuncAndArgsDidNotChange = function (proto) {\r\n        return proto.isPureFunction() && !this._argsChanged(proto);\r\n    };\r\n    DynamicChangeDetector.prototype._argsChanged = function (proto) {\r\n        var args = proto.args;\r\n        for (var i = 0; i < args.length; ++i) {\r\n            if (this.changes[args[i]]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    DynamicChangeDetector.prototype._argsOrContextChanged = function (proto) {\r\n        return this._argsChanged(proto) || this.changes[proto.contextIndex];\r\n    };\r\n    DynamicChangeDetector.prototype._readArgs = function (proto, values) {\r\n        var res = collection_1.ListWrapper.createFixedSize(proto.args.length);\r\n        var args = proto.args;\r\n        for (var i = 0; i < args.length; ++i) {\r\n            res[i] = values[args[i]];\r\n        }\r\n        return res;\r\n    };\r\n    return DynamicChangeDetector;\r\n})(abstract_change_detector_1.AbstractChangeDetector);\r\nexports.DynamicChangeDetector = DynamicChangeDetector;\r\n},{\"./abstract_change_detector\":85,\"./change_detection_util\":89,\"./constants\":95,\"./proto_record\":114,\"angular2/src/core/reflection/reflection\":158,\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],102:[function(require,module,exports){\n'use strict';var EventBinding = (function () {\r\n    function EventBinding(eventName, elIndex, dirIndex, records) {\r\n        this.eventName = eventName;\r\n        this.elIndex = elIndex;\r\n        this.dirIndex = dirIndex;\r\n        this.records = records;\r\n    }\r\n    return EventBinding;\r\n})();\r\nexports.EventBinding = EventBinding;\r\n},{}],103:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar exceptions_1 = require(\"angular2/src/facade/exceptions\");\r\n/**\r\n * An error thrown if application changes model breaking the top-down data flow.\r\n *\r\n * This exception is only thrown in dev mode.\r\n *\r\n * <!-- TODO: Add a link once the dev mode option is configurable -->\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * @Component({\r\n *   selector: 'parent',\r\n *   template: `\r\n *     <child [prop]=\"parentProp\"></child>\r\n *   `,\r\n *   directives: [forwardRef(() => Child)]\r\n * })\r\n * class Parent {\r\n *   parentProp = \"init\";\r\n * }\r\n *\r\n * @Directive({selector: 'child', inputs: ['prop']})\r\n * class Child {\r\n *   constructor(public parent: Parent) {}\r\n *\r\n *   set prop(v) {\r\n *     // this updates the parent property, which is disallowed during change detection\r\n *     // this will result in ExpressionChangedAfterItHasBeenCheckedException\r\n *     this.parent.parentProp = \"updated\";\r\n *   }\r\n * }\r\n * ```\r\n */\r\nvar ExpressionChangedAfterItHasBeenCheckedException = (function (_super) {\r\n    __extends(ExpressionChangedAfterItHasBeenCheckedException, _super);\r\n    function ExpressionChangedAfterItHasBeenCheckedException(exp, oldValue, currValue, context) {\r\n        _super.call(this, (\"Expression '\" + exp + \"' has changed after it was checked. \") +\r\n            (\"Previous value: '\" + oldValue + \"'. Current value: '\" + currValue + \"'\"));\r\n    }\r\n    return ExpressionChangedAfterItHasBeenCheckedException;\r\n})(exceptions_1.BaseException);\r\nexports.ExpressionChangedAfterItHasBeenCheckedException = ExpressionChangedAfterItHasBeenCheckedException;\r\n/**\r\n * Thrown when an expression evaluation raises an exception.\r\n *\r\n * This error wraps the original exception to attach additional contextual information that can\r\n * be useful for debugging.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/2Kywoz?p=preview))\r\n *\r\n * ```typescript\r\n * @Directive({selector: 'child', inputs: ['prop']})\r\n * class Child {\r\n *   prop;\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   template: `\r\n *     <child [prop]=\"field.first\"></child>\r\n *   `,\r\n *   directives: [Child]\r\n * })\r\n * class App {\r\n *   field = null;\r\n * }\r\n *\r\n * bootstrap(App);\r\n * ```\r\n *\r\n * You can access the original exception and stack through the `originalException` and\r\n * `originalStack` properties.\r\n */\r\nvar ChangeDetectionError = (function (_super) {\r\n    __extends(ChangeDetectionError, _super);\r\n    function ChangeDetectionError(exp, originalException, originalStack, context) {\r\n        _super.call(this, originalException + \" in [\" + exp + \"]\", originalException, originalStack, context);\r\n        this.location = exp;\r\n    }\r\n    return ChangeDetectionError;\r\n})(exceptions_1.WrappedException);\r\nexports.ChangeDetectionError = ChangeDetectionError;\r\n/**\r\n * Thrown when change detector executes on dehydrated view.\r\n *\r\n * This error indicates a bug in the framework.\r\n *\r\n * This is an internal Angular error.\r\n */\r\nvar DehydratedException = (function (_super) {\r\n    __extends(DehydratedException, _super);\r\n    function DehydratedException() {\r\n        _super.call(this, 'Attempt to detect changes on a dehydrated detector.');\r\n    }\r\n    return DehydratedException;\r\n})(exceptions_1.BaseException);\r\nexports.DehydratedException = DehydratedException;\r\n/**\r\n * Wraps an exception thrown by an event handler.\r\n */\r\nvar EventEvaluationError = (function (_super) {\r\n    __extends(EventEvaluationError, _super);\r\n    function EventEvaluationError(eventName, originalException, originalStack, context) {\r\n        _super.call(this, \"Error during evaluation of \\\"\" + eventName + \"\\\"\", originalException, originalStack, context);\r\n    }\r\n    return EventEvaluationError;\r\n})(exceptions_1.WrappedException);\r\nexports.EventEvaluationError = EventEvaluationError;\r\n/**\r\n * Error context included when an event handler throws an exception.\r\n */\r\nvar EventEvaluationErrorContext = (function () {\r\n    function EventEvaluationErrorContext(element, componentElement, context, locals, injector) {\r\n        this.element = element;\r\n        this.componentElement = componentElement;\r\n        this.context = context;\r\n        this.locals = locals;\r\n        this.injector = injector;\r\n    }\r\n    return EventEvaluationErrorContext;\r\n})();\r\nexports.EventEvaluationErrorContext = EventEvaluationErrorContext;\r\n},{\"angular2/src/facade/exceptions\":173}],104:[function(require,module,exports){\n'use strict';var DebugContext = (function () {\r\n    function DebugContext(element, componentElement, directive, context, locals, injector) {\r\n        this.element = element;\r\n        this.componentElement = componentElement;\r\n        this.directive = directive;\r\n        this.context = context;\r\n        this.locals = locals;\r\n        this.injector = injector;\r\n    }\r\n    return DebugContext;\r\n})();\r\nexports.DebugContext = DebugContext;\r\nvar ChangeDetectorGenConfig = (function () {\r\n    function ChangeDetectorGenConfig(genDebugInfo, logBindingUpdate, useJit) {\r\n        this.genDebugInfo = genDebugInfo;\r\n        this.logBindingUpdate = logBindingUpdate;\r\n        this.useJit = useJit;\r\n    }\r\n    return ChangeDetectorGenConfig;\r\n})();\r\nexports.ChangeDetectorGenConfig = ChangeDetectorGenConfig;\r\nvar ChangeDetectorDefinition = (function () {\r\n    function ChangeDetectorDefinition(id, strategy, variableNames, bindingRecords, eventRecords, directiveRecords, genConfig) {\r\n        this.id = id;\r\n        this.strategy = strategy;\r\n        this.variableNames = variableNames;\r\n        this.bindingRecords = bindingRecords;\r\n        this.eventRecords = eventRecords;\r\n        this.directiveRecords = directiveRecords;\r\n        this.genConfig = genConfig;\r\n    }\r\n    return ChangeDetectorDefinition;\r\n})();\r\nexports.ChangeDetectorDefinition = ChangeDetectorDefinition;\r\n},{}],105:[function(require,module,exports){\n'use strict';var change_detection_jit_generator_1 = require('./change_detection_jit_generator');\r\nvar JitProtoChangeDetector = (function () {\r\n    function JitProtoChangeDetector(definition) {\r\n        this.definition = definition;\r\n        this._factory = this._createFactory(definition);\r\n    }\r\n    JitProtoChangeDetector.isSupported = function () { return true; };\r\n    JitProtoChangeDetector.prototype.instantiate = function () { return this._factory(); };\r\n    /** @internal */\r\n    JitProtoChangeDetector.prototype._createFactory = function (definition) {\r\n        return new change_detection_jit_generator_1.ChangeDetectorJITGenerator(definition, 'util', 'AbstractChangeDetector', 'ChangeDetectorStatus')\r\n            .generate();\r\n    };\r\n    return JitProtoChangeDetector;\r\n})();\r\nexports.JitProtoChangeDetector = JitProtoChangeDetector;\r\n},{\"./change_detection_jit_generator\":88}],106:[function(require,module,exports){\n'use strict';function isObservable(value) {\r\n    return false;\r\n}\r\nexports.isObservable = isObservable;\r\n},{}],107:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar collection_1 = require(\"angular2/src/facade/collection\");\r\nvar AST = (function () {\r\n    function AST() {\r\n    }\r\n    AST.prototype.visit = function (visitor) { return null; };\r\n    AST.prototype.toString = function () { return \"AST\"; };\r\n    return AST;\r\n})();\r\nexports.AST = AST;\r\n/**\r\n * Represents a quoted expression of the form:\r\n *\r\n * quote = prefix `:` uninterpretedExpression\r\n * prefix = identifier\r\n * uninterpretedExpression = arbitrary string\r\n *\r\n * A quoted expression is meant to be pre-processed by an AST transformer that\r\n * converts it into another AST that no longer contains quoted expressions.\r\n * It is meant to allow third-party developers to extend Angular template\r\n * expression language. The `uninterpretedExpression` part of the quote is\r\n * therefore not interpreted by the Angular's own expression parser.\r\n */\r\nvar Quote = (function (_super) {\r\n    __extends(Quote, _super);\r\n    function Quote(prefix, uninterpretedExpression, location) {\r\n        _super.call(this);\r\n        this.prefix = prefix;\r\n        this.uninterpretedExpression = uninterpretedExpression;\r\n        this.location = location;\r\n    }\r\n    Quote.prototype.visit = function (visitor) { return visitor.visitQuote(this); };\r\n    Quote.prototype.toString = function () { return \"Quote\"; };\r\n    return Quote;\r\n})(AST);\r\nexports.Quote = Quote;\r\nvar EmptyExpr = (function (_super) {\r\n    __extends(EmptyExpr, _super);\r\n    function EmptyExpr() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    EmptyExpr.prototype.visit = function (visitor) {\r\n        // do nothing\r\n    };\r\n    return EmptyExpr;\r\n})(AST);\r\nexports.EmptyExpr = EmptyExpr;\r\nvar ImplicitReceiver = (function (_super) {\r\n    __extends(ImplicitReceiver, _super);\r\n    function ImplicitReceiver() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    ImplicitReceiver.prototype.visit = function (visitor) { return visitor.visitImplicitReceiver(this); };\r\n    return ImplicitReceiver;\r\n})(AST);\r\nexports.ImplicitReceiver = ImplicitReceiver;\r\n/**\r\n * Multiple expressions separated by a semicolon.\r\n */\r\nvar Chain = (function (_super) {\r\n    __extends(Chain, _super);\r\n    function Chain(expressions) {\r\n        _super.call(this);\r\n        this.expressions = expressions;\r\n    }\r\n    Chain.prototype.visit = function (visitor) { return visitor.visitChain(this); };\r\n    return Chain;\r\n})(AST);\r\nexports.Chain = Chain;\r\nvar Conditional = (function (_super) {\r\n    __extends(Conditional, _super);\r\n    function Conditional(condition, trueExp, falseExp) {\r\n        _super.call(this);\r\n        this.condition = condition;\r\n        this.trueExp = trueExp;\r\n        this.falseExp = falseExp;\r\n    }\r\n    Conditional.prototype.visit = function (visitor) { return visitor.visitConditional(this); };\r\n    return Conditional;\r\n})(AST);\r\nexports.Conditional = Conditional;\r\nvar PropertyRead = (function (_super) {\r\n    __extends(PropertyRead, _super);\r\n    function PropertyRead(receiver, name, getter) {\r\n        _super.call(this);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n        this.getter = getter;\r\n    }\r\n    PropertyRead.prototype.visit = function (visitor) { return visitor.visitPropertyRead(this); };\r\n    return PropertyRead;\r\n})(AST);\r\nexports.PropertyRead = PropertyRead;\r\nvar PropertyWrite = (function (_super) {\r\n    __extends(PropertyWrite, _super);\r\n    function PropertyWrite(receiver, name, setter, value) {\r\n        _super.call(this);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n        this.setter = setter;\r\n        this.value = value;\r\n    }\r\n    PropertyWrite.prototype.visit = function (visitor) { return visitor.visitPropertyWrite(this); };\r\n    return PropertyWrite;\r\n})(AST);\r\nexports.PropertyWrite = PropertyWrite;\r\nvar SafePropertyRead = (function (_super) {\r\n    __extends(SafePropertyRead, _super);\r\n    function SafePropertyRead(receiver, name, getter) {\r\n        _super.call(this);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n        this.getter = getter;\r\n    }\r\n    SafePropertyRead.prototype.visit = function (visitor) { return visitor.visitSafePropertyRead(this); };\r\n    return SafePropertyRead;\r\n})(AST);\r\nexports.SafePropertyRead = SafePropertyRead;\r\nvar KeyedRead = (function (_super) {\r\n    __extends(KeyedRead, _super);\r\n    function KeyedRead(obj, key) {\r\n        _super.call(this);\r\n        this.obj = obj;\r\n        this.key = key;\r\n    }\r\n    KeyedRead.prototype.visit = function (visitor) { return visitor.visitKeyedRead(this); };\r\n    return KeyedRead;\r\n})(AST);\r\nexports.KeyedRead = KeyedRead;\r\nvar KeyedWrite = (function (_super) {\r\n    __extends(KeyedWrite, _super);\r\n    function KeyedWrite(obj, key, value) {\r\n        _super.call(this);\r\n        this.obj = obj;\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n    KeyedWrite.prototype.visit = function (visitor) { return visitor.visitKeyedWrite(this); };\r\n    return KeyedWrite;\r\n})(AST);\r\nexports.KeyedWrite = KeyedWrite;\r\nvar BindingPipe = (function (_super) {\r\n    __extends(BindingPipe, _super);\r\n    function BindingPipe(exp, name, args) {\r\n        _super.call(this);\r\n        this.exp = exp;\r\n        this.name = name;\r\n        this.args = args;\r\n    }\r\n    BindingPipe.prototype.visit = function (visitor) { return visitor.visitPipe(this); };\r\n    return BindingPipe;\r\n})(AST);\r\nexports.BindingPipe = BindingPipe;\r\nvar LiteralPrimitive = (function (_super) {\r\n    __extends(LiteralPrimitive, _super);\r\n    function LiteralPrimitive(value) {\r\n        _super.call(this);\r\n        this.value = value;\r\n    }\r\n    LiteralPrimitive.prototype.visit = function (visitor) { return visitor.visitLiteralPrimitive(this); };\r\n    return LiteralPrimitive;\r\n})(AST);\r\nexports.LiteralPrimitive = LiteralPrimitive;\r\nvar LiteralArray = (function (_super) {\r\n    __extends(LiteralArray, _super);\r\n    function LiteralArray(expressions) {\r\n        _super.call(this);\r\n        this.expressions = expressions;\r\n    }\r\n    LiteralArray.prototype.visit = function (visitor) { return visitor.visitLiteralArray(this); };\r\n    return LiteralArray;\r\n})(AST);\r\nexports.LiteralArray = LiteralArray;\r\nvar LiteralMap = (function (_super) {\r\n    __extends(LiteralMap, _super);\r\n    function LiteralMap(keys, values) {\r\n        _super.call(this);\r\n        this.keys = keys;\r\n        this.values = values;\r\n    }\r\n    LiteralMap.prototype.visit = function (visitor) { return visitor.visitLiteralMap(this); };\r\n    return LiteralMap;\r\n})(AST);\r\nexports.LiteralMap = LiteralMap;\r\nvar Interpolation = (function (_super) {\r\n    __extends(Interpolation, _super);\r\n    function Interpolation(strings, expressions) {\r\n        _super.call(this);\r\n        this.strings = strings;\r\n        this.expressions = expressions;\r\n    }\r\n    Interpolation.prototype.visit = function (visitor) { return visitor.visitInterpolation(this); };\r\n    return Interpolation;\r\n})(AST);\r\nexports.Interpolation = Interpolation;\r\nvar Binary = (function (_super) {\r\n    __extends(Binary, _super);\r\n    function Binary(operation, left, right) {\r\n        _super.call(this);\r\n        this.operation = operation;\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n    Binary.prototype.visit = function (visitor) { return visitor.visitBinary(this); };\r\n    return Binary;\r\n})(AST);\r\nexports.Binary = Binary;\r\nvar PrefixNot = (function (_super) {\r\n    __extends(PrefixNot, _super);\r\n    function PrefixNot(expression) {\r\n        _super.call(this);\r\n        this.expression = expression;\r\n    }\r\n    PrefixNot.prototype.visit = function (visitor) { return visitor.visitPrefixNot(this); };\r\n    return PrefixNot;\r\n})(AST);\r\nexports.PrefixNot = PrefixNot;\r\nvar MethodCall = (function (_super) {\r\n    __extends(MethodCall, _super);\r\n    function MethodCall(receiver, name, fn, args) {\r\n        _super.call(this);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n        this.fn = fn;\r\n        this.args = args;\r\n    }\r\n    MethodCall.prototype.visit = function (visitor) { return visitor.visitMethodCall(this); };\r\n    return MethodCall;\r\n})(AST);\r\nexports.MethodCall = MethodCall;\r\nvar SafeMethodCall = (function (_super) {\r\n    __extends(SafeMethodCall, _super);\r\n    function SafeMethodCall(receiver, name, fn, args) {\r\n        _super.call(this);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n        this.fn = fn;\r\n        this.args = args;\r\n    }\r\n    SafeMethodCall.prototype.visit = function (visitor) { return visitor.visitSafeMethodCall(this); };\r\n    return SafeMethodCall;\r\n})(AST);\r\nexports.SafeMethodCall = SafeMethodCall;\r\nvar FunctionCall = (function (_super) {\r\n    __extends(FunctionCall, _super);\r\n    function FunctionCall(target, args) {\r\n        _super.call(this);\r\n        this.target = target;\r\n        this.args = args;\r\n    }\r\n    FunctionCall.prototype.visit = function (visitor) { return visitor.visitFunctionCall(this); };\r\n    return FunctionCall;\r\n})(AST);\r\nexports.FunctionCall = FunctionCall;\r\nvar ASTWithSource = (function (_super) {\r\n    __extends(ASTWithSource, _super);\r\n    function ASTWithSource(ast, source, location) {\r\n        _super.call(this);\r\n        this.ast = ast;\r\n        this.source = source;\r\n        this.location = location;\r\n    }\r\n    ASTWithSource.prototype.visit = function (visitor) { return this.ast.visit(visitor); };\r\n    ASTWithSource.prototype.toString = function () { return this.source + \" in \" + this.location; };\r\n    return ASTWithSource;\r\n})(AST);\r\nexports.ASTWithSource = ASTWithSource;\r\nvar TemplateBinding = (function () {\r\n    function TemplateBinding(key, keyIsVar, name, expression) {\r\n        this.key = key;\r\n        this.keyIsVar = keyIsVar;\r\n        this.name = name;\r\n        this.expression = expression;\r\n    }\r\n    return TemplateBinding;\r\n})();\r\nexports.TemplateBinding = TemplateBinding;\r\nvar RecursiveAstVisitor = (function () {\r\n    function RecursiveAstVisitor() {\r\n    }\r\n    RecursiveAstVisitor.prototype.visitBinary = function (ast) {\r\n        ast.left.visit(this);\r\n        ast.right.visit(this);\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitChain = function (ast) { return this.visitAll(ast.expressions); };\r\n    RecursiveAstVisitor.prototype.visitConditional = function (ast) {\r\n        ast.condition.visit(this);\r\n        ast.trueExp.visit(this);\r\n        ast.falseExp.visit(this);\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitPipe = function (ast) {\r\n        ast.exp.visit(this);\r\n        this.visitAll(ast.args);\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast) {\r\n        ast.target.visit(this);\r\n        this.visitAll(ast.args);\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast) { return null; };\r\n    RecursiveAstVisitor.prototype.visitInterpolation = function (ast) { return this.visitAll(ast.expressions); };\r\n    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast) {\r\n        ast.obj.visit(this);\r\n        ast.key.visit(this);\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast) {\r\n        ast.obj.visit(this);\r\n        ast.key.visit(this);\r\n        ast.value.visit(this);\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast) { return this.visitAll(ast.expressions); };\r\n    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast) { return this.visitAll(ast.values); };\r\n    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast) { return null; };\r\n    RecursiveAstVisitor.prototype.visitMethodCall = function (ast) {\r\n        ast.receiver.visit(this);\r\n        return this.visitAll(ast.args);\r\n    };\r\n    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast) {\r\n        ast.expression.visit(this);\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast) {\r\n        ast.receiver.visit(this);\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast) {\r\n        ast.receiver.visit(this);\r\n        ast.value.visit(this);\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast) {\r\n        ast.receiver.visit(this);\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast) {\r\n        ast.receiver.visit(this);\r\n        return this.visitAll(ast.args);\r\n    };\r\n    RecursiveAstVisitor.prototype.visitAll = function (asts) {\r\n        var _this = this;\r\n        asts.forEach(function (ast) { return ast.visit(_this); });\r\n        return null;\r\n    };\r\n    RecursiveAstVisitor.prototype.visitQuote = function (ast) { return null; };\r\n    return RecursiveAstVisitor;\r\n})();\r\nexports.RecursiveAstVisitor = RecursiveAstVisitor;\r\nvar AstTransformer = (function () {\r\n    function AstTransformer() {\r\n    }\r\n    AstTransformer.prototype.visitImplicitReceiver = function (ast) { return ast; };\r\n    AstTransformer.prototype.visitInterpolation = function (ast) {\r\n        return new Interpolation(ast.strings, this.visitAll(ast.expressions));\r\n    };\r\n    AstTransformer.prototype.visitLiteralPrimitive = function (ast) { return new LiteralPrimitive(ast.value); };\r\n    AstTransformer.prototype.visitPropertyRead = function (ast) {\r\n        return new PropertyRead(ast.receiver.visit(this), ast.name, ast.getter);\r\n    };\r\n    AstTransformer.prototype.visitPropertyWrite = function (ast) {\r\n        return new PropertyWrite(ast.receiver.visit(this), ast.name, ast.setter, ast.value);\r\n    };\r\n    AstTransformer.prototype.visitSafePropertyRead = function (ast) {\r\n        return new SafePropertyRead(ast.receiver.visit(this), ast.name, ast.getter);\r\n    };\r\n    AstTransformer.prototype.visitMethodCall = function (ast) {\r\n        return new MethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));\r\n    };\r\n    AstTransformer.prototype.visitSafeMethodCall = function (ast) {\r\n        return new SafeMethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));\r\n    };\r\n    AstTransformer.prototype.visitFunctionCall = function (ast) {\r\n        return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));\r\n    };\r\n    AstTransformer.prototype.visitLiteralArray = function (ast) {\r\n        return new LiteralArray(this.visitAll(ast.expressions));\r\n    };\r\n    AstTransformer.prototype.visitLiteralMap = function (ast) {\r\n        return new LiteralMap(ast.keys, this.visitAll(ast.values));\r\n    };\r\n    AstTransformer.prototype.visitBinary = function (ast) {\r\n        return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));\r\n    };\r\n    AstTransformer.prototype.visitPrefixNot = function (ast) { return new PrefixNot(ast.expression.visit(this)); };\r\n    AstTransformer.prototype.visitConditional = function (ast) {\r\n        return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\r\n    };\r\n    AstTransformer.prototype.visitPipe = function (ast) {\r\n        return new BindingPipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args));\r\n    };\r\n    AstTransformer.prototype.visitKeyedRead = function (ast) {\r\n        return new KeyedRead(ast.obj.visit(this), ast.key.visit(this));\r\n    };\r\n    AstTransformer.prototype.visitKeyedWrite = function (ast) {\r\n        return new KeyedWrite(ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\r\n    };\r\n    AstTransformer.prototype.visitAll = function (asts) {\r\n        var res = collection_1.ListWrapper.createFixedSize(asts.length);\r\n        for (var i = 0; i < asts.length; ++i) {\r\n            res[i] = asts[i].visit(this);\r\n        }\r\n        return res;\r\n    };\r\n    AstTransformer.prototype.visitChain = function (ast) { return new Chain(this.visitAll(ast.expressions)); };\r\n    AstTransformer.prototype.visitQuote = function (ast) {\r\n        return new Quote(ast.prefix, ast.uninterpretedExpression, ast.location);\r\n    };\r\n    return AstTransformer;\r\n})();\r\nexports.AstTransformer = AstTransformer;\r\n},{\"angular2/src/facade/collection\":171}],108:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar decorators_1 = require('angular2/src/core/di/decorators');\r\nvar collection_1 = require(\"angular2/src/facade/collection\");\r\nvar lang_1 = require(\"angular2/src/facade/lang\");\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\n(function (TokenType) {\r\n    TokenType[TokenType[\"Character\"] = 0] = \"Character\";\r\n    TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\r\n    TokenType[TokenType[\"Keyword\"] = 2] = \"Keyword\";\r\n    TokenType[TokenType[\"String\"] = 3] = \"String\";\r\n    TokenType[TokenType[\"Operator\"] = 4] = \"Operator\";\r\n    TokenType[TokenType[\"Number\"] = 5] = \"Number\";\r\n})(exports.TokenType || (exports.TokenType = {}));\r\nvar TokenType = exports.TokenType;\r\nvar Lexer = (function () {\r\n    function Lexer() {\r\n    }\r\n    Lexer.prototype.tokenize = function (text) {\r\n        var scanner = new _Scanner(text);\r\n        var tokens = [];\r\n        var token = scanner.scanToken();\r\n        while (token != null) {\r\n            tokens.push(token);\r\n            token = scanner.scanToken();\r\n        }\r\n        return tokens;\r\n    };\r\n    Lexer = __decorate([\r\n        decorators_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], Lexer);\r\n    return Lexer;\r\n})();\r\nexports.Lexer = Lexer;\r\nvar Token = (function () {\r\n    function Token(index, type, numValue, strValue) {\r\n        this.index = index;\r\n        this.type = type;\r\n        this.numValue = numValue;\r\n        this.strValue = strValue;\r\n    }\r\n    Token.prototype.isCharacter = function (code) {\r\n        return (this.type == TokenType.Character && this.numValue == code);\r\n    };\r\n    Token.prototype.isNumber = function () { return (this.type == TokenType.Number); };\r\n    Token.prototype.isString = function () { return (this.type == TokenType.String); };\r\n    Token.prototype.isOperator = function (operater) {\r\n        return (this.type == TokenType.Operator && this.strValue == operater);\r\n    };\r\n    Token.prototype.isIdentifier = function () { return (this.type == TokenType.Identifier); };\r\n    Token.prototype.isKeyword = function () { return (this.type == TokenType.Keyword); };\r\n    Token.prototype.isKeywordVar = function () { return (this.type == TokenType.Keyword && this.strValue == \"var\"); };\r\n    Token.prototype.isKeywordNull = function () { return (this.type == TokenType.Keyword && this.strValue == \"null\"); };\r\n    Token.prototype.isKeywordUndefined = function () {\r\n        return (this.type == TokenType.Keyword && this.strValue == \"undefined\");\r\n    };\r\n    Token.prototype.isKeywordTrue = function () { return (this.type == TokenType.Keyword && this.strValue == \"true\"); };\r\n    Token.prototype.isKeywordFalse = function () { return (this.type == TokenType.Keyword && this.strValue == \"false\"); };\r\n    Token.prototype.toNumber = function () {\r\n        // -1 instead of NULL ok?\r\n        return (this.type == TokenType.Number) ? this.numValue : -1;\r\n    };\r\n    Token.prototype.toString = function () {\r\n        switch (this.type) {\r\n            case TokenType.Character:\r\n            case TokenType.Identifier:\r\n            case TokenType.Keyword:\r\n            case TokenType.Operator:\r\n            case TokenType.String:\r\n                return this.strValue;\r\n            case TokenType.Number:\r\n                return this.numValue.toString();\r\n            default:\r\n                return null;\r\n        }\r\n    };\r\n    return Token;\r\n})();\r\nexports.Token = Token;\r\nfunction newCharacterToken(index, code) {\r\n    return new Token(index, TokenType.Character, code, lang_1.StringWrapper.fromCharCode(code));\r\n}\r\nfunction newIdentifierToken(index, text) {\r\n    return new Token(index, TokenType.Identifier, 0, text);\r\n}\r\nfunction newKeywordToken(index, text) {\r\n    return new Token(index, TokenType.Keyword, 0, text);\r\n}\r\nfunction newOperatorToken(index, text) {\r\n    return new Token(index, TokenType.Operator, 0, text);\r\n}\r\nfunction newStringToken(index, text) {\r\n    return new Token(index, TokenType.String, 0, text);\r\n}\r\nfunction newNumberToken(index, n) {\r\n    return new Token(index, TokenType.Number, n, \"\");\r\n}\r\nexports.EOF = new Token(-1, TokenType.Character, 0, \"\");\r\nexports.$EOF = 0;\r\nexports.$TAB = 9;\r\nexports.$LF = 10;\r\nexports.$VTAB = 11;\r\nexports.$FF = 12;\r\nexports.$CR = 13;\r\nexports.$SPACE = 32;\r\nexports.$BANG = 33;\r\nexports.$DQ = 34;\r\nexports.$HASH = 35;\r\nexports.$$ = 36;\r\nexports.$PERCENT = 37;\r\nexports.$AMPERSAND = 38;\r\nexports.$SQ = 39;\r\nexports.$LPAREN = 40;\r\nexports.$RPAREN = 41;\r\nexports.$STAR = 42;\r\nexports.$PLUS = 43;\r\nexports.$COMMA = 44;\r\nexports.$MINUS = 45;\r\nexports.$PERIOD = 46;\r\nexports.$SLASH = 47;\r\nexports.$COLON = 58;\r\nexports.$SEMICOLON = 59;\r\nexports.$LT = 60;\r\nexports.$EQ = 61;\r\nexports.$GT = 62;\r\nexports.$QUESTION = 63;\r\nvar $0 = 48;\r\nvar $9 = 57;\r\nvar $A = 65, $E = 69, $Z = 90;\r\nexports.$LBRACKET = 91;\r\nexports.$BACKSLASH = 92;\r\nexports.$RBRACKET = 93;\r\nvar $CARET = 94;\r\nvar $_ = 95;\r\nvar $a = 97, $e = 101, $f = 102, $n = 110, $r = 114, $t = 116, $u = 117, $v = 118, $z = 122;\r\nexports.$LBRACE = 123;\r\nexports.$BAR = 124;\r\nexports.$RBRACE = 125;\r\nvar $NBSP = 160;\r\nvar ScannerError = (function (_super) {\r\n    __extends(ScannerError, _super);\r\n    function ScannerError(message) {\r\n        _super.call(this);\r\n        this.message = message;\r\n    }\r\n    ScannerError.prototype.toString = function () { return this.message; };\r\n    return ScannerError;\r\n})(exceptions_1.BaseException);\r\nexports.ScannerError = ScannerError;\r\nvar _Scanner = (function () {\r\n    function _Scanner(input) {\r\n        this.input = input;\r\n        this.peek = 0;\r\n        this.index = -1;\r\n        this.length = input.length;\r\n        this.advance();\r\n    }\r\n    _Scanner.prototype.advance = function () {\r\n        this.peek =\r\n            ++this.index >= this.length ? exports.$EOF : lang_1.StringWrapper.charCodeAt(this.input, this.index);\r\n    };\r\n    _Scanner.prototype.scanToken = function () {\r\n        var input = this.input, length = this.length, peek = this.peek, index = this.index;\r\n        // Skip whitespace.\r\n        while (peek <= exports.$SPACE) {\r\n            if (++index >= length) {\r\n                peek = exports.$EOF;\r\n                break;\r\n            }\r\n            else {\r\n                peek = lang_1.StringWrapper.charCodeAt(input, index);\r\n            }\r\n        }\r\n        this.peek = peek;\r\n        this.index = index;\r\n        if (index >= length) {\r\n            return null;\r\n        }\r\n        // Handle identifiers and numbers.\r\n        if (isIdentifierStart(peek))\r\n            return this.scanIdentifier();\r\n        if (isDigit(peek))\r\n            return this.scanNumber(index);\r\n        var start = index;\r\n        switch (peek) {\r\n            case exports.$PERIOD:\r\n                this.advance();\r\n                return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, exports.$PERIOD);\r\n            case exports.$LPAREN:\r\n            case exports.$RPAREN:\r\n            case exports.$LBRACE:\r\n            case exports.$RBRACE:\r\n            case exports.$LBRACKET:\r\n            case exports.$RBRACKET:\r\n            case exports.$COMMA:\r\n            case exports.$COLON:\r\n            case exports.$SEMICOLON:\r\n                return this.scanCharacter(start, peek);\r\n            case exports.$SQ:\r\n            case exports.$DQ:\r\n                return this.scanString();\r\n            case exports.$HASH:\r\n            case exports.$PLUS:\r\n            case exports.$MINUS:\r\n            case exports.$STAR:\r\n            case exports.$SLASH:\r\n            case exports.$PERCENT:\r\n            case $CARET:\r\n                return this.scanOperator(start, lang_1.StringWrapper.fromCharCode(peek));\r\n            case exports.$QUESTION:\r\n                return this.scanComplexOperator(start, '?', exports.$PERIOD, '.');\r\n            case exports.$LT:\r\n            case exports.$GT:\r\n                return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), exports.$EQ, '=');\r\n            case exports.$BANG:\r\n            case exports.$EQ:\r\n                return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), exports.$EQ, '=', exports.$EQ, '=');\r\n            case exports.$AMPERSAND:\r\n                return this.scanComplexOperator(start, '&', exports.$AMPERSAND, '&');\r\n            case exports.$BAR:\r\n                return this.scanComplexOperator(start, '|', exports.$BAR, '|');\r\n            case $NBSP:\r\n                while (isWhitespace(this.peek))\r\n                    this.advance();\r\n                return this.scanToken();\r\n        }\r\n        this.error(\"Unexpected character [\" + lang_1.StringWrapper.fromCharCode(peek) + \"]\", 0);\r\n        return null;\r\n    };\r\n    _Scanner.prototype.scanCharacter = function (start, code) {\r\n        assert(this.peek == code);\r\n        this.advance();\r\n        return newCharacterToken(start, code);\r\n    };\r\n    _Scanner.prototype.scanOperator = function (start, str) {\r\n        assert(this.peek == lang_1.StringWrapper.charCodeAt(str, 0));\r\n        assert(collection_1.SetWrapper.has(OPERATORS, str));\r\n        this.advance();\r\n        return newOperatorToken(start, str);\r\n    };\r\n    /**\r\n     * Tokenize a 2/3 char long operator\r\n     *\r\n     * @param start start index in the expression\r\n     * @param one first symbol (always part of the operator)\r\n     * @param twoCode code point for the second symbol\r\n     * @param two second symbol (part of the operator when the second code point matches)\r\n     * @param threeCode code point for the third symbol\r\n     * @param three third symbol (part of the operator when provided and matches source expression)\r\n     * @returns {Token}\r\n     */\r\n    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {\r\n        assert(this.peek == lang_1.StringWrapper.charCodeAt(one, 0));\r\n        this.advance();\r\n        var str = one;\r\n        if (this.peek == twoCode) {\r\n            this.advance();\r\n            str += two;\r\n        }\r\n        if (lang_1.isPresent(threeCode) && this.peek == threeCode) {\r\n            this.advance();\r\n            str += three;\r\n        }\r\n        assert(collection_1.SetWrapper.has(OPERATORS, str));\r\n        return newOperatorToken(start, str);\r\n    };\r\n    _Scanner.prototype.scanIdentifier = function () {\r\n        assert(isIdentifierStart(this.peek));\r\n        var start = this.index;\r\n        this.advance();\r\n        while (isIdentifierPart(this.peek))\r\n            this.advance();\r\n        var str = this.input.substring(start, this.index);\r\n        if (collection_1.SetWrapper.has(KEYWORDS, str)) {\r\n            return newKeywordToken(start, str);\r\n        }\r\n        else {\r\n            return newIdentifierToken(start, str);\r\n        }\r\n    };\r\n    _Scanner.prototype.scanNumber = function (start) {\r\n        assert(isDigit(this.peek));\r\n        var simple = (this.index === start);\r\n        this.advance(); // Skip initial digit.\r\n        while (true) {\r\n            if (isDigit(this.peek)) {\r\n            }\r\n            else if (this.peek == exports.$PERIOD) {\r\n                simple = false;\r\n            }\r\n            else if (isExponentStart(this.peek)) {\r\n                this.advance();\r\n                if (isExponentSign(this.peek))\r\n                    this.advance();\r\n                if (!isDigit(this.peek))\r\n                    this.error('Invalid exponent', -1);\r\n                simple = false;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            this.advance();\r\n        }\r\n        var str = this.input.substring(start, this.index);\r\n        // TODO\r\n        var value = simple ? lang_1.NumberWrapper.parseIntAutoRadix(str) : lang_1.NumberWrapper.parseFloat(str);\r\n        return newNumberToken(start, value);\r\n    };\r\n    _Scanner.prototype.scanString = function () {\r\n        assert(this.peek == exports.$SQ || this.peek == exports.$DQ);\r\n        var start = this.index;\r\n        var quote = this.peek;\r\n        this.advance(); // Skip initial quote.\r\n        var buffer;\r\n        var marker = this.index;\r\n        var input = this.input;\r\n        while (this.peek != quote) {\r\n            if (this.peek == exports.$BACKSLASH) {\r\n                if (buffer == null)\r\n                    buffer = new lang_1.StringJoiner();\r\n                buffer.add(input.substring(marker, this.index));\r\n                this.advance();\r\n                var unescapedCode;\r\n                if (this.peek == $u) {\r\n                    // 4 character hex code for unicode character.\r\n                    var hex = input.substring(this.index + 1, this.index + 5);\r\n                    try {\r\n                        unescapedCode = lang_1.NumberWrapper.parseInt(hex, 16);\r\n                    }\r\n                    catch (e) {\r\n                        this.error(\"Invalid unicode escape [\\\\u\" + hex + \"]\", 0);\r\n                    }\r\n                    for (var i = 0; i < 5; i++) {\r\n                        this.advance();\r\n                    }\r\n                }\r\n                else {\r\n                    unescapedCode = unescape(this.peek);\r\n                    this.advance();\r\n                }\r\n                buffer.add(lang_1.StringWrapper.fromCharCode(unescapedCode));\r\n                marker = this.index;\r\n            }\r\n            else if (this.peek == exports.$EOF) {\r\n                this.error('Unterminated quote', 0);\r\n            }\r\n            else {\r\n                this.advance();\r\n            }\r\n        }\r\n        var last = input.substring(marker, this.index);\r\n        this.advance(); // Skip terminating quote.\r\n        // Compute the unescaped string value.\r\n        var unescaped = last;\r\n        if (buffer != null) {\r\n            buffer.add(last);\r\n            unescaped = buffer.toString();\r\n        }\r\n        return newStringToken(start, unescaped);\r\n    };\r\n    _Scanner.prototype.error = function (message, offset) {\r\n        var position = this.index + offset;\r\n        throw new ScannerError(\"Lexer Error: \" + message + \" at column \" + position + \" in expression [\" + this.input + \"]\");\r\n    };\r\n    return _Scanner;\r\n})();\r\nfunction isWhitespace(code) {\r\n    return (code >= exports.$TAB && code <= exports.$SPACE) || (code == $NBSP);\r\n}\r\nfunction isIdentifierStart(code) {\r\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || (code == $_) || (code == exports.$$);\r\n}\r\nfunction isIdentifier(input) {\r\n    if (input.length == 0)\r\n        return false;\r\n    var scanner = new _Scanner(input);\r\n    if (!isIdentifierStart(scanner.peek))\r\n        return false;\r\n    scanner.advance();\r\n    while (scanner.peek !== exports.$EOF) {\r\n        if (!isIdentifierPart(scanner.peek))\r\n            return false;\r\n        scanner.advance();\r\n    }\r\n    return true;\r\n}\r\nexports.isIdentifier = isIdentifier;\r\nfunction isIdentifierPart(code) {\r\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || ($0 <= code && code <= $9) ||\r\n        (code == $_) || (code == exports.$$);\r\n}\r\nfunction isDigit(code) {\r\n    return $0 <= code && code <= $9;\r\n}\r\nfunction isExponentStart(code) {\r\n    return code == $e || code == $E;\r\n}\r\nfunction isExponentSign(code) {\r\n    return code == exports.$MINUS || code == exports.$PLUS;\r\n}\r\nfunction unescape(code) {\r\n    switch (code) {\r\n        case $n:\r\n            return exports.$LF;\r\n        case $f:\r\n            return exports.$FF;\r\n        case $r:\r\n            return exports.$CR;\r\n        case $t:\r\n            return exports.$TAB;\r\n        case $v:\r\n            return exports.$VTAB;\r\n        default:\r\n            return code;\r\n    }\r\n}\r\nvar OPERATORS = collection_1.SetWrapper.createFromList([\r\n    '+',\r\n    '-',\r\n    '*',\r\n    '/',\r\n    '%',\r\n    '^',\r\n    '=',\r\n    '==',\r\n    '!=',\r\n    '===',\r\n    '!==',\r\n    '<',\r\n    '>',\r\n    '<=',\r\n    '>=',\r\n    '&&',\r\n    '||',\r\n    '&',\r\n    '|',\r\n    '!',\r\n    '?',\r\n    '#',\r\n    '?.'\r\n]);\r\nvar KEYWORDS = collection_1.SetWrapper.createFromList(['var', 'null', 'undefined', 'true', 'false', 'if', 'else']);\r\n},{\"angular2/src/core/di/decorators\":118,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],109:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar Locals = (function () {\r\n    function Locals(parent, current) {\r\n        this.parent = parent;\r\n        this.current = current;\r\n    }\r\n    Locals.prototype.contains = function (name) {\r\n        if (this.current.has(name)) {\r\n            return true;\r\n        }\r\n        if (lang_1.isPresent(this.parent)) {\r\n            return this.parent.contains(name);\r\n        }\r\n        return false;\r\n    };\r\n    Locals.prototype.get = function (name) {\r\n        if (this.current.has(name)) {\r\n            return this.current.get(name);\r\n        }\r\n        if (lang_1.isPresent(this.parent)) {\r\n            return this.parent.get(name);\r\n        }\r\n        throw new exceptions_1.BaseException(\"Cannot find '\" + name + \"'\");\r\n    };\r\n    Locals.prototype.set = function (name, value) {\r\n        // TODO(rado): consider removing this check if we can guarantee this is not\r\n        // exposed to the public API.\r\n        // TODO: vsavkin maybe it should check only the local map\r\n        if (this.current.has(name)) {\r\n            this.current.set(name, value);\r\n        }\r\n        else {\r\n            throw new exceptions_1.BaseException(\"Setting of new keys post-construction is not supported. Key: \" + name + \".\");\r\n        }\r\n    };\r\n    Locals.prototype.clearLocalValues = function () { collection_1.MapWrapper.clearValues(this.current); };\r\n    return Locals;\r\n})();\r\nexports.Locals = Locals;\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],110:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar decorators_1 = require('angular2/src/core/di/decorators');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar lexer_1 = require('./lexer');\r\nvar reflection_1 = require('angular2/src/core/reflection/reflection');\r\nvar ast_1 = require('./ast');\r\nvar _implicitReceiver = new ast_1.ImplicitReceiver();\r\n// TODO(tbosch): Cannot make this const/final right now because of the transpiler...\r\nvar INTERPOLATION_REGEXP = /\\{\\{(.*?)\\}\\}/g;\r\nvar ParseException = (function (_super) {\r\n    __extends(ParseException, _super);\r\n    function ParseException(message, input, errLocation, ctxLocation) {\r\n        _super.call(this, \"Parser Error: \" + message + \" \" + errLocation + \" [\" + input + \"] in \" + ctxLocation);\r\n    }\r\n    return ParseException;\r\n})(exceptions_1.BaseException);\r\nvar Parser = (function () {\r\n    function Parser(/** @internal */ _lexer, providedReflector) {\r\n        if (providedReflector === void 0) { providedReflector = null; }\r\n        this._lexer = _lexer;\r\n        this._reflector = lang_1.isPresent(providedReflector) ? providedReflector : reflection_1.reflector;\r\n    }\r\n    Parser.prototype.parseAction = function (input, location) {\r\n        this._checkNoInterpolation(input, location);\r\n        var tokens = this._lexer.tokenize(input);\r\n        var ast = new _ParseAST(input, location, tokens, this._reflector, true).parseChain();\r\n        return new ast_1.ASTWithSource(ast, input, location);\r\n    };\r\n    Parser.prototype.parseBinding = function (input, location) {\r\n        var ast = this._parseBindingAst(input, location);\r\n        return new ast_1.ASTWithSource(ast, input, location);\r\n    };\r\n    Parser.prototype.parseSimpleBinding = function (input, location) {\r\n        var ast = this._parseBindingAst(input, location);\r\n        if (!SimpleExpressionChecker.check(ast)) {\r\n            throw new ParseException('Host binding expression can only contain field access and constants', input, location);\r\n        }\r\n        return new ast_1.ASTWithSource(ast, input, location);\r\n    };\r\n    Parser.prototype._parseBindingAst = function (input, location) {\r\n        // Quotes expressions use 3rd-party expression language. We don't want to use\r\n        // our lexer or parser for that, so we check for that ahead of time.\r\n        var quote = this._parseQuote(input, location);\r\n        if (lang_1.isPresent(quote)) {\r\n            return quote;\r\n        }\r\n        this._checkNoInterpolation(input, location);\r\n        var tokens = this._lexer.tokenize(input);\r\n        return new _ParseAST(input, location, tokens, this._reflector, false).parseChain();\r\n    };\r\n    Parser.prototype._parseQuote = function (input, location) {\r\n        if (lang_1.isBlank(input))\r\n            return null;\r\n        var prefixSeparatorIndex = input.indexOf(':');\r\n        if (prefixSeparatorIndex == -1)\r\n            return null;\r\n        var prefix = input.substring(0, prefixSeparatorIndex).trim();\r\n        if (!lexer_1.isIdentifier(prefix))\r\n            return null;\r\n        var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\r\n        return new ast_1.Quote(prefix, uninterpretedExpression, location);\r\n    };\r\n    Parser.prototype.parseTemplateBindings = function (input, location) {\r\n        var tokens = this._lexer.tokenize(input);\r\n        return new _ParseAST(input, location, tokens, this._reflector, false).parseTemplateBindings();\r\n    };\r\n    Parser.prototype.parseInterpolation = function (input, location) {\r\n        var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);\r\n        if (parts.length <= 1) {\r\n            return null;\r\n        }\r\n        var strings = [];\r\n        var expressions = [];\r\n        for (var i = 0; i < parts.length; i++) {\r\n            var part = parts[i];\r\n            if (i % 2 === 0) {\r\n                // fixed string\r\n                strings.push(part);\r\n            }\r\n            else if (part.trim().length > 0) {\r\n                var tokens = this._lexer.tokenize(part);\r\n                var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();\r\n                expressions.push(ast);\r\n            }\r\n            else {\r\n                throw new ParseException('Blank expressions are not allowed in interpolated strings', input, \"at column \" + this._findInterpolationErrorColumn(parts, i) + \" in\", location);\r\n            }\r\n        }\r\n        return new ast_1.ASTWithSource(new ast_1.Interpolation(strings, expressions), input, location);\r\n    };\r\n    Parser.prototype.wrapLiteralPrimitive = function (input, location) {\r\n        return new ast_1.ASTWithSource(new ast_1.LiteralPrimitive(input), input, location);\r\n    };\r\n    Parser.prototype._checkNoInterpolation = function (input, location) {\r\n        var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);\r\n        if (parts.length > 1) {\r\n            throw new ParseException('Got interpolation ({{}}) where expression was expected', input, \"at column \" + this._findInterpolationErrorColumn(parts, 1) + \" in\", location);\r\n        }\r\n    };\r\n    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx) {\r\n        var errLocation = '';\r\n        for (var j = 0; j < partInErrIdx; j++) {\r\n            errLocation += j % 2 === 0 ? parts[j] : \"{{\" + parts[j] + \"}}\";\r\n        }\r\n        return errLocation.length;\r\n    };\r\n    Parser = __decorate([\r\n        decorators_1.Injectable(), \r\n        __metadata('design:paramtypes', [lexer_1.Lexer, reflection_1.Reflector])\r\n    ], Parser);\r\n    return Parser;\r\n})();\r\nexports.Parser = Parser;\r\nvar _ParseAST = (function () {\r\n    function _ParseAST(input, location, tokens, reflector, parseAction) {\r\n        this.input = input;\r\n        this.location = location;\r\n        this.tokens = tokens;\r\n        this.reflector = reflector;\r\n        this.parseAction = parseAction;\r\n        this.index = 0;\r\n    }\r\n    _ParseAST.prototype.peek = function (offset) {\r\n        var i = this.index + offset;\r\n        return i < this.tokens.length ? this.tokens[i] : lexer_1.EOF;\r\n    };\r\n    Object.defineProperty(_ParseAST.prototype, \"next\", {\r\n        get: function () { return this.peek(0); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(_ParseAST.prototype, \"inputIndex\", {\r\n        get: function () {\r\n            return (this.index < this.tokens.length) ? this.next.index : this.input.length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    _ParseAST.prototype.advance = function () { this.index++; };\r\n    _ParseAST.prototype.optionalCharacter = function (code) {\r\n        if (this.next.isCharacter(code)) {\r\n            this.advance();\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    _ParseAST.prototype.optionalKeywordVar = function () {\r\n        if (this.peekKeywordVar()) {\r\n            this.advance();\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    _ParseAST.prototype.peekKeywordVar = function () { return this.next.isKeywordVar() || this.next.isOperator('#'); };\r\n    _ParseAST.prototype.expectCharacter = function (code) {\r\n        if (this.optionalCharacter(code))\r\n            return;\r\n        this.error(\"Missing expected \" + lang_1.StringWrapper.fromCharCode(code));\r\n    };\r\n    _ParseAST.prototype.optionalOperator = function (op) {\r\n        if (this.next.isOperator(op)) {\r\n            this.advance();\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    _ParseAST.prototype.expectOperator = function (operator) {\r\n        if (this.optionalOperator(operator))\r\n            return;\r\n        this.error(\"Missing expected operator \" + operator);\r\n    };\r\n    _ParseAST.prototype.expectIdentifierOrKeyword = function () {\r\n        var n = this.next;\r\n        if (!n.isIdentifier() && !n.isKeyword()) {\r\n            this.error(\"Unexpected token \" + n + \", expected identifier or keyword\");\r\n        }\r\n        this.advance();\r\n        return n.toString();\r\n    };\r\n    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {\r\n        var n = this.next;\r\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\r\n            this.error(\"Unexpected token \" + n + \", expected identifier, keyword, or string\");\r\n        }\r\n        this.advance();\r\n        return n.toString();\r\n    };\r\n    _ParseAST.prototype.parseChain = function () {\r\n        var exprs = [];\r\n        while (this.index < this.tokens.length) {\r\n            var expr = this.parsePipe();\r\n            exprs.push(expr);\r\n            if (this.optionalCharacter(lexer_1.$SEMICOLON)) {\r\n                if (!this.parseAction) {\r\n                    this.error(\"Binding expression cannot contain chained expression\");\r\n                }\r\n                while (this.optionalCharacter(lexer_1.$SEMICOLON)) {\r\n                } // read all semicolons\r\n            }\r\n            else if (this.index < this.tokens.length) {\r\n                this.error(\"Unexpected token '\" + this.next + \"'\");\r\n            }\r\n        }\r\n        if (exprs.length == 0)\r\n            return new ast_1.EmptyExpr();\r\n        if (exprs.length == 1)\r\n            return exprs[0];\r\n        return new ast_1.Chain(exprs);\r\n    };\r\n    _ParseAST.prototype.parsePipe = function () {\r\n        var result = this.parseExpression();\r\n        if (this.optionalOperator(\"|\")) {\r\n            if (this.parseAction) {\r\n                this.error(\"Cannot have a pipe in an action expression\");\r\n            }\r\n            do {\r\n                var name = this.expectIdentifierOrKeyword();\r\n                var args = [];\r\n                while (this.optionalCharacter(lexer_1.$COLON)) {\r\n                    args.push(this.parseExpression());\r\n                }\r\n                result = new ast_1.BindingPipe(result, name, args);\r\n            } while (this.optionalOperator(\"|\"));\r\n        }\r\n        return result;\r\n    };\r\n    _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };\r\n    _ParseAST.prototype.parseConditional = function () {\r\n        var start = this.inputIndex;\r\n        var result = this.parseLogicalOr();\r\n        if (this.optionalOperator('?')) {\r\n            var yes = this.parsePipe();\r\n            if (!this.optionalCharacter(lexer_1.$COLON)) {\r\n                var end = this.inputIndex;\r\n                var expression = this.input.substring(start, end);\r\n                this.error(\"Conditional expression \" + expression + \" requires all 3 expressions\");\r\n            }\r\n            var no = this.parsePipe();\r\n            return new ast_1.Conditional(result, yes, no);\r\n        }\r\n        else {\r\n            return result;\r\n        }\r\n    };\r\n    _ParseAST.prototype.parseLogicalOr = function () {\r\n        // '||'\r\n        var result = this.parseLogicalAnd();\r\n        while (this.optionalOperator('||')) {\r\n            result = new ast_1.Binary('||', result, this.parseLogicalAnd());\r\n        }\r\n        return result;\r\n    };\r\n    _ParseAST.prototype.parseLogicalAnd = function () {\r\n        // '&&'\r\n        var result = this.parseEquality();\r\n        while (this.optionalOperator('&&')) {\r\n            result = new ast_1.Binary('&&', result, this.parseEquality());\r\n        }\r\n        return result;\r\n    };\r\n    _ParseAST.prototype.parseEquality = function () {\r\n        // '==','!=','===','!=='\r\n        var result = this.parseRelational();\r\n        while (true) {\r\n            if (this.optionalOperator('==')) {\r\n                result = new ast_1.Binary('==', result, this.parseRelational());\r\n            }\r\n            else if (this.optionalOperator('===')) {\r\n                result = new ast_1.Binary('===', result, this.parseRelational());\r\n            }\r\n            else if (this.optionalOperator('!=')) {\r\n                result = new ast_1.Binary('!=', result, this.parseRelational());\r\n            }\r\n            else if (this.optionalOperator('!==')) {\r\n                result = new ast_1.Binary('!==', result, this.parseRelational());\r\n            }\r\n            else {\r\n                return result;\r\n            }\r\n        }\r\n    };\r\n    _ParseAST.prototype.parseRelational = function () {\r\n        // '<', '>', '<=', '>='\r\n        var result = this.parseAdditive();\r\n        while (true) {\r\n            if (this.optionalOperator('<')) {\r\n                result = new ast_1.Binary('<', result, this.parseAdditive());\r\n            }\r\n            else if (this.optionalOperator('>')) {\r\n                result = new ast_1.Binary('>', result, this.parseAdditive());\r\n            }\r\n            else if (this.optionalOperator('<=')) {\r\n                result = new ast_1.Binary('<=', result, this.parseAdditive());\r\n            }\r\n            else if (this.optionalOperator('>=')) {\r\n                result = new ast_1.Binary('>=', result, this.parseAdditive());\r\n            }\r\n            else {\r\n                return result;\r\n            }\r\n        }\r\n    };\r\n    _ParseAST.prototype.parseAdditive = function () {\r\n        // '+', '-'\r\n        var result = this.parseMultiplicative();\r\n        while (true) {\r\n            if (this.optionalOperator('+')) {\r\n                result = new ast_1.Binary('+', result, this.parseMultiplicative());\r\n            }\r\n            else if (this.optionalOperator('-')) {\r\n                result = new ast_1.Binary('-', result, this.parseMultiplicative());\r\n            }\r\n            else {\r\n                return result;\r\n            }\r\n        }\r\n    };\r\n    _ParseAST.prototype.parseMultiplicative = function () {\r\n        // '*', '%', '/'\r\n        var result = this.parsePrefix();\r\n        while (true) {\r\n            if (this.optionalOperator('*')) {\r\n                result = new ast_1.Binary('*', result, this.parsePrefix());\r\n            }\r\n            else if (this.optionalOperator('%')) {\r\n                result = new ast_1.Binary('%', result, this.parsePrefix());\r\n            }\r\n            else if (this.optionalOperator('/')) {\r\n                result = new ast_1.Binary('/', result, this.parsePrefix());\r\n            }\r\n            else {\r\n                return result;\r\n            }\r\n        }\r\n    };\r\n    _ParseAST.prototype.parsePrefix = function () {\r\n        if (this.optionalOperator('+')) {\r\n            return this.parsePrefix();\r\n        }\r\n        else if (this.optionalOperator('-')) {\r\n            return new ast_1.Binary('-', new ast_1.LiteralPrimitive(0), this.parsePrefix());\r\n        }\r\n        else if (this.optionalOperator('!')) {\r\n            return new ast_1.PrefixNot(this.parsePrefix());\r\n        }\r\n        else {\r\n            return this.parseCallChain();\r\n        }\r\n    };\r\n    _ParseAST.prototype.parseCallChain = function () {\r\n        var result = this.parsePrimary();\r\n        while (true) {\r\n            if (this.optionalCharacter(lexer_1.$PERIOD)) {\r\n                result = this.parseAccessMemberOrMethodCall(result, false);\r\n            }\r\n            else if (this.optionalOperator('?.')) {\r\n                result = this.parseAccessMemberOrMethodCall(result, true);\r\n            }\r\n            else if (this.optionalCharacter(lexer_1.$LBRACKET)) {\r\n                var key = this.parsePipe();\r\n                this.expectCharacter(lexer_1.$RBRACKET);\r\n                if (this.optionalOperator(\"=\")) {\r\n                    var value = this.parseConditional();\r\n                    result = new ast_1.KeyedWrite(result, key, value);\r\n                }\r\n                else {\r\n                    result = new ast_1.KeyedRead(result, key);\r\n                }\r\n            }\r\n            else if (this.optionalCharacter(lexer_1.$LPAREN)) {\r\n                var args = this.parseCallArguments();\r\n                this.expectCharacter(lexer_1.$RPAREN);\r\n                result = new ast_1.FunctionCall(result, args);\r\n            }\r\n            else {\r\n                return result;\r\n            }\r\n        }\r\n    };\r\n    _ParseAST.prototype.parsePrimary = function () {\r\n        if (this.optionalCharacter(lexer_1.$LPAREN)) {\r\n            var result = this.parsePipe();\r\n            this.expectCharacter(lexer_1.$RPAREN);\r\n            return result;\r\n        }\r\n        else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {\r\n            this.advance();\r\n            return new ast_1.LiteralPrimitive(null);\r\n        }\r\n        else if (this.next.isKeywordTrue()) {\r\n            this.advance();\r\n            return new ast_1.LiteralPrimitive(true);\r\n        }\r\n        else if (this.next.isKeywordFalse()) {\r\n            this.advance();\r\n            return new ast_1.LiteralPrimitive(false);\r\n        }\r\n        else if (this.optionalCharacter(lexer_1.$LBRACKET)) {\r\n            var elements = this.parseExpressionList(lexer_1.$RBRACKET);\r\n            this.expectCharacter(lexer_1.$RBRACKET);\r\n            return new ast_1.LiteralArray(elements);\r\n        }\r\n        else if (this.next.isCharacter(lexer_1.$LBRACE)) {\r\n            return this.parseLiteralMap();\r\n        }\r\n        else if (this.next.isIdentifier()) {\r\n            return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);\r\n        }\r\n        else if (this.next.isNumber()) {\r\n            var value = this.next.toNumber();\r\n            this.advance();\r\n            return new ast_1.LiteralPrimitive(value);\r\n        }\r\n        else if (this.next.isString()) {\r\n            var literalValue = this.next.toString();\r\n            this.advance();\r\n            return new ast_1.LiteralPrimitive(literalValue);\r\n        }\r\n        else if (this.index >= this.tokens.length) {\r\n            this.error(\"Unexpected end of expression: \" + this.input);\r\n        }\r\n        else {\r\n            this.error(\"Unexpected token \" + this.next);\r\n        }\r\n        // error() throws, so we don't reach here.\r\n        throw new exceptions_1.BaseException(\"Fell through all cases in parsePrimary\");\r\n    };\r\n    _ParseAST.prototype.parseExpressionList = function (terminator) {\r\n        var result = [];\r\n        if (!this.next.isCharacter(terminator)) {\r\n            do {\r\n                result.push(this.parsePipe());\r\n            } while (this.optionalCharacter(lexer_1.$COMMA));\r\n        }\r\n        return result;\r\n    };\r\n    _ParseAST.prototype.parseLiteralMap = function () {\r\n        var keys = [];\r\n        var values = [];\r\n        this.expectCharacter(lexer_1.$LBRACE);\r\n        if (!this.optionalCharacter(lexer_1.$RBRACE)) {\r\n            do {\r\n                var key = this.expectIdentifierOrKeywordOrString();\r\n                keys.push(key);\r\n                this.expectCharacter(lexer_1.$COLON);\r\n                values.push(this.parsePipe());\r\n            } while (this.optionalCharacter(lexer_1.$COMMA));\r\n            this.expectCharacter(lexer_1.$RBRACE);\r\n        }\r\n        return new ast_1.LiteralMap(keys, values);\r\n    };\r\n    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {\r\n        if (isSafe === void 0) { isSafe = false; }\r\n        var id = this.expectIdentifierOrKeyword();\r\n        if (this.optionalCharacter(lexer_1.$LPAREN)) {\r\n            var args = this.parseCallArguments();\r\n            this.expectCharacter(lexer_1.$RPAREN);\r\n            var fn = this.reflector.method(id);\r\n            return isSafe ? new ast_1.SafeMethodCall(receiver, id, fn, args) :\r\n                new ast_1.MethodCall(receiver, id, fn, args);\r\n        }\r\n        else {\r\n            if (isSafe) {\r\n                if (this.optionalOperator(\"=\")) {\r\n                    this.error(\"The '?.' operator cannot be used in the assignment\");\r\n                }\r\n                else {\r\n                    return new ast_1.SafePropertyRead(receiver, id, this.reflector.getter(id));\r\n                }\r\n            }\r\n            else {\r\n                if (this.optionalOperator(\"=\")) {\r\n                    if (!this.parseAction) {\r\n                        this.error(\"Bindings cannot contain assignments\");\r\n                    }\r\n                    var value = this.parseConditional();\r\n                    return new ast_1.PropertyWrite(receiver, id, this.reflector.setter(id), value);\r\n                }\r\n                else {\r\n                    return new ast_1.PropertyRead(receiver, id, this.reflector.getter(id));\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    _ParseAST.prototype.parseCallArguments = function () {\r\n        if (this.next.isCharacter(lexer_1.$RPAREN))\r\n            return [];\r\n        var positionals = [];\r\n        do {\r\n            positionals.push(this.parsePipe());\r\n        } while (this.optionalCharacter(lexer_1.$COMMA));\r\n        return positionals;\r\n    };\r\n    _ParseAST.prototype.parseBlockContent = function () {\r\n        if (!this.parseAction) {\r\n            this.error(\"Binding expression cannot contain chained expression\");\r\n        }\r\n        var exprs = [];\r\n        while (this.index < this.tokens.length && !this.next.isCharacter(lexer_1.$RBRACE)) {\r\n            var expr = this.parseExpression();\r\n            exprs.push(expr);\r\n            if (this.optionalCharacter(lexer_1.$SEMICOLON)) {\r\n                while (this.optionalCharacter(lexer_1.$SEMICOLON)) {\r\n                } // read all semicolons\r\n            }\r\n        }\r\n        if (exprs.length == 0)\r\n            return new ast_1.EmptyExpr();\r\n        if (exprs.length == 1)\r\n            return exprs[0];\r\n        return new ast_1.Chain(exprs);\r\n    };\r\n    /**\r\n     * An identifier, a keyword, a string with an optional `-` inbetween.\r\n     */\r\n    _ParseAST.prototype.expectTemplateBindingKey = function () {\r\n        var result = '';\r\n        var operatorFound = false;\r\n        do {\r\n            result += this.expectIdentifierOrKeywordOrString();\r\n            operatorFound = this.optionalOperator('-');\r\n            if (operatorFound) {\r\n                result += '-';\r\n            }\r\n        } while (operatorFound);\r\n        return result.toString();\r\n    };\r\n    _ParseAST.prototype.parseTemplateBindings = function () {\r\n        var bindings = [];\r\n        var prefix = null;\r\n        while (this.index < this.tokens.length) {\r\n            var keyIsVar = this.optionalKeywordVar();\r\n            var key = this.expectTemplateBindingKey();\r\n            if (!keyIsVar) {\r\n                if (prefix == null) {\r\n                    prefix = key;\r\n                }\r\n                else {\r\n                    key = prefix + key[0].toUpperCase() + key.substring(1);\r\n                }\r\n            }\r\n            this.optionalCharacter(lexer_1.$COLON);\r\n            var name = null;\r\n            var expression = null;\r\n            if (keyIsVar) {\r\n                if (this.optionalOperator(\"=\")) {\r\n                    name = this.expectTemplateBindingKey();\r\n                }\r\n                else {\r\n                    name = '\\$implicit';\r\n                }\r\n            }\r\n            else if (this.next !== lexer_1.EOF && !this.peekKeywordVar()) {\r\n                var start = this.inputIndex;\r\n                var ast = this.parsePipe();\r\n                var source = this.input.substring(start, this.inputIndex);\r\n                expression = new ast_1.ASTWithSource(ast, source, this.location);\r\n            }\r\n            bindings.push(new ast_1.TemplateBinding(key, keyIsVar, name, expression));\r\n            if (!this.optionalCharacter(lexer_1.$SEMICOLON)) {\r\n                this.optionalCharacter(lexer_1.$COMMA);\r\n            }\r\n        }\r\n        return bindings;\r\n    };\r\n    _ParseAST.prototype.error = function (message, index) {\r\n        if (index === void 0) { index = null; }\r\n        if (lang_1.isBlank(index))\r\n            index = this.index;\r\n        var location = (index < this.tokens.length) ? \"at column \" + (this.tokens[index].index + 1) + \" in\" :\r\n            \"at the end of the expression\";\r\n        throw new ParseException(message, this.input, location, this.location);\r\n    };\r\n    return _ParseAST;\r\n})();\r\nexports._ParseAST = _ParseAST;\r\nvar SimpleExpressionChecker = (function () {\r\n    function SimpleExpressionChecker() {\r\n        this.simple = true;\r\n    }\r\n    SimpleExpressionChecker.check = function (ast) {\r\n        var s = new SimpleExpressionChecker();\r\n        ast.visit(s);\r\n        return s.simple;\r\n    };\r\n    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast) { };\r\n    SimpleExpressionChecker.prototype.visitInterpolation = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast) { };\r\n    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast) { };\r\n    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitMethodCall = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast) { this.visitAll(ast.expressions); };\r\n    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast) { this.visitAll(ast.values); };\r\n    SimpleExpressionChecker.prototype.visitBinary = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitConditional = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitPipe = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitAll = function (asts) {\r\n        var res = collection_1.ListWrapper.createFixedSize(asts.length);\r\n        for (var i = 0; i < asts.length; ++i) {\r\n            res[i] = asts[i].visit(this);\r\n        }\r\n        return res;\r\n    };\r\n    SimpleExpressionChecker.prototype.visitChain = function (ast) { this.simple = false; };\r\n    SimpleExpressionChecker.prototype.visitQuote = function (ast) { this.simple = false; };\r\n    return SimpleExpressionChecker;\r\n})();\r\n},{\"./ast\":107,\"./lexer\":108,\"angular2/src/core/di/decorators\":118,\"angular2/src/core/reflection/reflection\":158,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],111:[function(require,module,exports){\n'use strict';function implementsOnDestroy(pipe) {\r\n    return pipe.constructor.prototype.ngOnDestroy;\r\n}\r\nexports.implementsOnDestroy = implementsOnDestroy;\r\n},{}],112:[function(require,module,exports){\n'use strict';var SelectedPipe = (function () {\r\n    function SelectedPipe(pipe, pure) {\r\n        this.pipe = pipe;\r\n        this.pure = pure;\r\n    }\r\n    return SelectedPipe;\r\n})();\r\nexports.SelectedPipe = SelectedPipe;\r\n},{}],113:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar ast_1 = require('./parser/ast');\r\nvar change_detection_util_1 = require('./change_detection_util');\r\nvar dynamic_change_detector_1 = require('./dynamic_change_detector');\r\nvar directive_record_1 = require('./directive_record');\r\nvar event_binding_1 = require('./event_binding');\r\nvar coalesce_1 = require('./coalesce');\r\nvar proto_record_1 = require('./proto_record');\r\nvar DynamicProtoChangeDetector = (function () {\r\n    function DynamicProtoChangeDetector(_definition) {\r\n        this._definition = _definition;\r\n        this._propertyBindingRecords = createPropertyRecords(_definition);\r\n        this._eventBindingRecords = createEventRecords(_definition);\r\n        this._propertyBindingTargets = this._definition.bindingRecords.map(function (b) { return b.target; });\r\n        this._directiveIndices = this._definition.directiveRecords.map(function (d) { return d.directiveIndex; });\r\n    }\r\n    DynamicProtoChangeDetector.prototype.instantiate = function () {\r\n        return new dynamic_change_detector_1.DynamicChangeDetector(this._definition.id, this._propertyBindingRecords.length, this._propertyBindingTargets, this._directiveIndices, this._definition.strategy, this._propertyBindingRecords, this._eventBindingRecords, this._definition.directiveRecords, this._definition.genConfig);\r\n    };\r\n    return DynamicProtoChangeDetector;\r\n})();\r\nexports.DynamicProtoChangeDetector = DynamicProtoChangeDetector;\r\nfunction createPropertyRecords(definition) {\r\n    var recordBuilder = new ProtoRecordBuilder();\r\n    collection_1.ListWrapper.forEachWithIndex(definition.bindingRecords, function (b, index) { return recordBuilder.add(b, definition.variableNames, index); });\r\n    return coalesce_1.coalesce(recordBuilder.records);\r\n}\r\nexports.createPropertyRecords = createPropertyRecords;\r\nfunction createEventRecords(definition) {\r\n    // TODO: vsavkin: remove $event when the compiler handles render-side variables properly\r\n    var varNames = collection_1.ListWrapper.concat(['$event'], definition.variableNames);\r\n    return definition.eventRecords.map(function (er) {\r\n        var records = _ConvertAstIntoProtoRecords.create(er, varNames);\r\n        var dirIndex = er.implicitReceiver instanceof directive_record_1.DirectiveIndex ? er.implicitReceiver : null;\r\n        return new event_binding_1.EventBinding(er.target.name, er.target.elementIndex, dirIndex, records);\r\n    });\r\n}\r\nexports.createEventRecords = createEventRecords;\r\nvar ProtoRecordBuilder = (function () {\r\n    function ProtoRecordBuilder() {\r\n        this.records = [];\r\n    }\r\n    ProtoRecordBuilder.prototype.add = function (b, variableNames, bindingIndex) {\r\n        var oldLast = collection_1.ListWrapper.last(this.records);\r\n        if (lang_1.isPresent(oldLast) && oldLast.bindingRecord.directiveRecord == b.directiveRecord) {\r\n            oldLast.lastInDirective = false;\r\n        }\r\n        var numberOfRecordsBefore = this.records.length;\r\n        this._appendRecords(b, variableNames, bindingIndex);\r\n        var newLast = collection_1.ListWrapper.last(this.records);\r\n        if (lang_1.isPresent(newLast) && newLast !== oldLast) {\r\n            newLast.lastInBinding = true;\r\n            newLast.lastInDirective = true;\r\n            this._setArgumentToPureFunction(numberOfRecordsBefore);\r\n        }\r\n    };\r\n    /** @internal */\r\n    ProtoRecordBuilder.prototype._setArgumentToPureFunction = function (startIndex) {\r\n        var _this = this;\r\n        for (var i = startIndex; i < this.records.length; ++i) {\r\n            var rec = this.records[i];\r\n            if (rec.isPureFunction()) {\r\n                rec.args.forEach(function (recordIndex) { return _this.records[recordIndex - 1].argumentToPureFunction =\r\n                    true; });\r\n            }\r\n            if (rec.mode === proto_record_1.RecordType.Pipe) {\r\n                rec.args.forEach(function (recordIndex) { return _this.records[recordIndex - 1].argumentToPureFunction =\r\n                    true; });\r\n                this.records[rec.contextIndex - 1].argumentToPureFunction = true;\r\n            }\r\n        }\r\n    };\r\n    /** @internal */\r\n    ProtoRecordBuilder.prototype._appendRecords = function (b, variableNames, bindingIndex) {\r\n        if (b.isDirectiveLifecycle()) {\r\n            this.records.push(new proto_record_1.ProtoRecord(proto_record_1.RecordType.DirectiveLifecycle, b.lifecycleEvent, null, [], [], -1, null, this.records.length + 1, b, false, false, false, false, null));\r\n        }\r\n        else {\r\n            _ConvertAstIntoProtoRecords.append(this.records, b, variableNames, bindingIndex);\r\n        }\r\n    };\r\n    return ProtoRecordBuilder;\r\n})();\r\nexports.ProtoRecordBuilder = ProtoRecordBuilder;\r\nvar _ConvertAstIntoProtoRecords = (function () {\r\n    function _ConvertAstIntoProtoRecords(_records, _bindingRecord, _variableNames, _bindingIndex) {\r\n        this._records = _records;\r\n        this._bindingRecord = _bindingRecord;\r\n        this._variableNames = _variableNames;\r\n        this._bindingIndex = _bindingIndex;\r\n    }\r\n    _ConvertAstIntoProtoRecords.append = function (records, b, variableNames, bindingIndex) {\r\n        var c = new _ConvertAstIntoProtoRecords(records, b, variableNames, bindingIndex);\r\n        b.ast.visit(c);\r\n    };\r\n    _ConvertAstIntoProtoRecords.create = function (b, variableNames) {\r\n        var rec = [];\r\n        _ConvertAstIntoProtoRecords.append(rec, b, variableNames, null);\r\n        rec[rec.length - 1].lastInBinding = true;\r\n        return rec;\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitImplicitReceiver = function (ast) { return this._bindingRecord.implicitReceiver; };\r\n    _ConvertAstIntoProtoRecords.prototype.visitInterpolation = function (ast) {\r\n        var args = this._visitAll(ast.expressions);\r\n        return this._addRecord(proto_record_1.RecordType.Interpolate, \"interpolate\", _interpolationFn(ast.strings), args, ast.strings, 0);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitLiteralPrimitive = function (ast) {\r\n        return this._addRecord(proto_record_1.RecordType.Const, \"literal\", ast.value, [], null, 0);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitPropertyRead = function (ast) {\r\n        var receiver = ast.receiver.visit(this);\r\n        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name) &&\r\n            ast.receiver instanceof ast_1.ImplicitReceiver) {\r\n            return this._addRecord(proto_record_1.RecordType.Local, ast.name, ast.name, [], null, receiver);\r\n        }\r\n        else {\r\n            return this._addRecord(proto_record_1.RecordType.PropertyRead, ast.name, ast.getter, [], null, receiver);\r\n        }\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitPropertyWrite = function (ast) {\r\n        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name) &&\r\n            ast.receiver instanceof ast_1.ImplicitReceiver) {\r\n            throw new exceptions_1.BaseException(\"Cannot reassign a variable binding \" + ast.name);\r\n        }\r\n        else {\r\n            var receiver = ast.receiver.visit(this);\r\n            var value = ast.value.visit(this);\r\n            return this._addRecord(proto_record_1.RecordType.PropertyWrite, ast.name, ast.setter, [value], null, receiver);\r\n        }\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitKeyedWrite = function (ast) {\r\n        var obj = ast.obj.visit(this);\r\n        var key = ast.key.visit(this);\r\n        var value = ast.value.visit(this);\r\n        return this._addRecord(proto_record_1.RecordType.KeyedWrite, null, null, [key, value], null, obj);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitSafePropertyRead = function (ast) {\r\n        var receiver = ast.receiver.visit(this);\r\n        return this._addRecord(proto_record_1.RecordType.SafeProperty, ast.name, ast.getter, [], null, receiver);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitMethodCall = function (ast) {\r\n        var receiver = ast.receiver.visit(this);\r\n        var args = this._visitAll(ast.args);\r\n        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name)) {\r\n            var target = this._addRecord(proto_record_1.RecordType.Local, ast.name, ast.name, [], null, receiver);\r\n            return this._addRecord(proto_record_1.RecordType.InvokeClosure, \"closure\", null, args, null, target);\r\n        }\r\n        else {\r\n            return this._addRecord(proto_record_1.RecordType.InvokeMethod, ast.name, ast.fn, args, null, receiver);\r\n        }\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitSafeMethodCall = function (ast) {\r\n        var receiver = ast.receiver.visit(this);\r\n        var args = this._visitAll(ast.args);\r\n        return this._addRecord(proto_record_1.RecordType.SafeMethodInvoke, ast.name, ast.fn, args, null, receiver);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitFunctionCall = function (ast) {\r\n        var target = ast.target.visit(this);\r\n        var args = this._visitAll(ast.args);\r\n        return this._addRecord(proto_record_1.RecordType.InvokeClosure, \"closure\", null, args, null, target);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitLiteralArray = function (ast) {\r\n        var primitiveName = \"arrayFn\" + ast.expressions.length;\r\n        return this._addRecord(proto_record_1.RecordType.CollectionLiteral, primitiveName, _arrayFn(ast.expressions.length), this._visitAll(ast.expressions), null, 0);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitLiteralMap = function (ast) {\r\n        return this._addRecord(proto_record_1.RecordType.CollectionLiteral, _mapPrimitiveName(ast.keys), change_detection_util_1.ChangeDetectionUtil.mapFn(ast.keys), this._visitAll(ast.values), null, 0);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitBinary = function (ast) {\r\n        var left = ast.left.visit(this);\r\n        switch (ast.operation) {\r\n            case '&&':\r\n                var branchEnd = [null];\r\n                this._addRecord(proto_record_1.RecordType.SkipRecordsIfNot, \"SkipRecordsIfNot\", null, [], branchEnd, left);\r\n                var right = ast.right.visit(this);\r\n                branchEnd[0] = right;\r\n                return this._addRecord(proto_record_1.RecordType.PrimitiveOp, \"cond\", change_detection_util_1.ChangeDetectionUtil.cond, [left, right, left], null, 0);\r\n            case '||':\r\n                var branchEnd = [null];\r\n                this._addRecord(proto_record_1.RecordType.SkipRecordsIf, \"SkipRecordsIf\", null, [], branchEnd, left);\r\n                var right = ast.right.visit(this);\r\n                branchEnd[0] = right;\r\n                return this._addRecord(proto_record_1.RecordType.PrimitiveOp, \"cond\", change_detection_util_1.ChangeDetectionUtil.cond, [left, left, right], null, 0);\r\n            default:\r\n                var right = ast.right.visit(this);\r\n                return this._addRecord(proto_record_1.RecordType.PrimitiveOp, _operationToPrimitiveName(ast.operation), _operationToFunction(ast.operation), [left, right], null, 0);\r\n        }\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitPrefixNot = function (ast) {\r\n        var exp = ast.expression.visit(this);\r\n        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, \"operation_negate\", change_detection_util_1.ChangeDetectionUtil.operation_negate, [exp], null, 0);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitConditional = function (ast) {\r\n        var condition = ast.condition.visit(this);\r\n        var startOfFalseBranch = [null];\r\n        var endOfFalseBranch = [null];\r\n        this._addRecord(proto_record_1.RecordType.SkipRecordsIfNot, \"SkipRecordsIfNot\", null, [], startOfFalseBranch, condition);\r\n        var whenTrue = ast.trueExp.visit(this);\r\n        var skip = this._addRecord(proto_record_1.RecordType.SkipRecords, \"SkipRecords\", null, [], endOfFalseBranch, 0);\r\n        var whenFalse = ast.falseExp.visit(this);\r\n        startOfFalseBranch[0] = skip;\r\n        endOfFalseBranch[0] = whenFalse;\r\n        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, \"cond\", change_detection_util_1.ChangeDetectionUtil.cond, [condition, whenTrue, whenFalse], null, 0);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitPipe = function (ast) {\r\n        var value = ast.exp.visit(this);\r\n        var args = this._visitAll(ast.args);\r\n        return this._addRecord(proto_record_1.RecordType.Pipe, ast.name, ast.name, args, null, value);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitKeyedRead = function (ast) {\r\n        var obj = ast.obj.visit(this);\r\n        var key = ast.key.visit(this);\r\n        return this._addRecord(proto_record_1.RecordType.KeyedRead, \"keyedAccess\", change_detection_util_1.ChangeDetectionUtil.keyedAccess, [key], null, obj);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitChain = function (ast) {\r\n        var _this = this;\r\n        var args = ast.expressions.map(function (e) { return e.visit(_this); });\r\n        return this._addRecord(proto_record_1.RecordType.Chain, \"chain\", null, args, null, 0);\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype.visitQuote = function (ast) {\r\n        throw new exceptions_1.BaseException((\"Caught uninterpreted expression at \" + ast.location + \": \" + ast.uninterpretedExpression + \". \") +\r\n            (\"Expression prefix \" + ast.prefix + \" did not match a template transformer to interpret the expression.\"));\r\n    };\r\n    _ConvertAstIntoProtoRecords.prototype._visitAll = function (asts) {\r\n        var res = collection_1.ListWrapper.createFixedSize(asts.length);\r\n        for (var i = 0; i < asts.length; ++i) {\r\n            res[i] = asts[i].visit(this);\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Adds a `ProtoRecord` and returns its selfIndex.\r\n     */\r\n    _ConvertAstIntoProtoRecords.prototype._addRecord = function (type, name, funcOrValue, args, fixedArgs, context) {\r\n        var selfIndex = this._records.length + 1;\r\n        if (context instanceof directive_record_1.DirectiveIndex) {\r\n            this._records.push(new proto_record_1.ProtoRecord(type, name, funcOrValue, args, fixedArgs, -1, context, selfIndex, this._bindingRecord, false, false, false, false, this._bindingIndex));\r\n        }\r\n        else {\r\n            this._records.push(new proto_record_1.ProtoRecord(type, name, funcOrValue, args, fixedArgs, context, null, selfIndex, this._bindingRecord, false, false, false, false, this._bindingIndex));\r\n        }\r\n        return selfIndex;\r\n    };\r\n    return _ConvertAstIntoProtoRecords;\r\n})();\r\nfunction _arrayFn(length) {\r\n    switch (length) {\r\n        case 0:\r\n            return change_detection_util_1.ChangeDetectionUtil.arrayFn0;\r\n        case 1:\r\n            return change_detection_util_1.ChangeDetectionUtil.arrayFn1;\r\n        case 2:\r\n            return change_detection_util_1.ChangeDetectionUtil.arrayFn2;\r\n        case 3:\r\n            return change_detection_util_1.ChangeDetectionUtil.arrayFn3;\r\n        case 4:\r\n            return change_detection_util_1.ChangeDetectionUtil.arrayFn4;\r\n        case 5:\r\n            return change_detection_util_1.ChangeDetectionUtil.arrayFn5;\r\n        case 6:\r\n            return change_detection_util_1.ChangeDetectionUtil.arrayFn6;\r\n        case 7:\r\n            return change_detection_util_1.ChangeDetectionUtil.arrayFn7;\r\n        case 8:\r\n            return change_detection_util_1.ChangeDetectionUtil.arrayFn8;\r\n        case 9:\r\n            return change_detection_util_1.ChangeDetectionUtil.arrayFn9;\r\n        default:\r\n            throw new exceptions_1.BaseException(\"Does not support literal maps with more than 9 elements\");\r\n    }\r\n}\r\nfunction _mapPrimitiveName(keys) {\r\n    var stringifiedKeys = keys.map(function (k) { return lang_1.isString(k) ? \"\\\"\" + k + \"\\\"\" : \"\" + k; }).join(', ');\r\n    return \"mapFn([\" + stringifiedKeys + \"])\";\r\n}\r\nfunction _operationToPrimitiveName(operation) {\r\n    switch (operation) {\r\n        case '+':\r\n            return \"operation_add\";\r\n        case '-':\r\n            return \"operation_subtract\";\r\n        case '*':\r\n            return \"operation_multiply\";\r\n        case '/':\r\n            return \"operation_divide\";\r\n        case '%':\r\n            return \"operation_remainder\";\r\n        case '==':\r\n            return \"operation_equals\";\r\n        case '!=':\r\n            return \"operation_not_equals\";\r\n        case '===':\r\n            return \"operation_identical\";\r\n        case '!==':\r\n            return \"operation_not_identical\";\r\n        case '<':\r\n            return \"operation_less_then\";\r\n        case '>':\r\n            return \"operation_greater_then\";\r\n        case '<=':\r\n            return \"operation_less_or_equals_then\";\r\n        case '>=':\r\n            return \"operation_greater_or_equals_then\";\r\n        default:\r\n            throw new exceptions_1.BaseException(\"Unsupported operation \" + operation);\r\n    }\r\n}\r\nfunction _operationToFunction(operation) {\r\n    switch (operation) {\r\n        case '+':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_add;\r\n        case '-':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_subtract;\r\n        case '*':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_multiply;\r\n        case '/':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_divide;\r\n        case '%':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_remainder;\r\n        case '==':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_equals;\r\n        case '!=':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_not_equals;\r\n        case '===':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_identical;\r\n        case '!==':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_not_identical;\r\n        case '<':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_less_then;\r\n        case '>':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_greater_then;\r\n        case '<=':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_less_or_equals_then;\r\n        case '>=':\r\n            return change_detection_util_1.ChangeDetectionUtil.operation_greater_or_equals_then;\r\n        default:\r\n            throw new exceptions_1.BaseException(\"Unsupported operation \" + operation);\r\n    }\r\n}\r\nfunction s(v) {\r\n    return lang_1.isPresent(v) ? \"\" + v : '';\r\n}\r\nfunction _interpolationFn(strings) {\r\n    var length = strings.length;\r\n    var c0 = length > 0 ? strings[0] : null;\r\n    var c1 = length > 1 ? strings[1] : null;\r\n    var c2 = length > 2 ? strings[2] : null;\r\n    var c3 = length > 3 ? strings[3] : null;\r\n    var c4 = length > 4 ? strings[4] : null;\r\n    var c5 = length > 5 ? strings[5] : null;\r\n    var c6 = length > 6 ? strings[6] : null;\r\n    var c7 = length > 7 ? strings[7] : null;\r\n    var c8 = length > 8 ? strings[8] : null;\r\n    var c9 = length > 9 ? strings[9] : null;\r\n    switch (length - 1) {\r\n        case 1:\r\n            return function (a1) { return c0 + s(a1) + c1; };\r\n        case 2:\r\n            return function (a1, a2) { return c0 + s(a1) + c1 + s(a2) + c2; };\r\n        case 3:\r\n            return function (a1, a2, a3) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3; };\r\n        case 4:\r\n            return function (a1, a2, a3, a4) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4; };\r\n        case 5:\r\n            return function (a1, a2, a3, a4, a5) {\r\n                return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5;\r\n            };\r\n        case 6:\r\n            return function (a1, a2, a3, a4, a5, a6) {\r\n                return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6;\r\n            };\r\n        case 7:\r\n            return function (a1, a2, a3, a4, a5, a6, a7) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) +\r\n                c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7; };\r\n        case 8:\r\n            return function (a1, a2, a3, a4, a5, a6, a7, a8) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) +\r\n                c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) +\r\n                c8; };\r\n        case 9:\r\n            return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 +\r\n                s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) +\r\n                c7 + s(a8) + c8 + s(a9) + c9; };\r\n        default:\r\n            throw new exceptions_1.BaseException(\"Does not support more than 9 expressions\");\r\n    }\r\n}\r\n},{\"./change_detection_util\":89,\"./coalesce\":91,\"./directive_record\":100,\"./dynamic_change_detector\":101,\"./event_binding\":102,\"./parser/ast\":107,\"./proto_record\":114,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],114:[function(require,module,exports){\n'use strict';(function (RecordType) {\r\n    RecordType[RecordType[\"Self\"] = 0] = \"Self\";\r\n    RecordType[RecordType[\"Const\"] = 1] = \"Const\";\r\n    RecordType[RecordType[\"PrimitiveOp\"] = 2] = \"PrimitiveOp\";\r\n    RecordType[RecordType[\"PropertyRead\"] = 3] = \"PropertyRead\";\r\n    RecordType[RecordType[\"PropertyWrite\"] = 4] = \"PropertyWrite\";\r\n    RecordType[RecordType[\"Local\"] = 5] = \"Local\";\r\n    RecordType[RecordType[\"InvokeMethod\"] = 6] = \"InvokeMethod\";\r\n    RecordType[RecordType[\"InvokeClosure\"] = 7] = \"InvokeClosure\";\r\n    RecordType[RecordType[\"KeyedRead\"] = 8] = \"KeyedRead\";\r\n    RecordType[RecordType[\"KeyedWrite\"] = 9] = \"KeyedWrite\";\r\n    RecordType[RecordType[\"Pipe\"] = 10] = \"Pipe\";\r\n    RecordType[RecordType[\"Interpolate\"] = 11] = \"Interpolate\";\r\n    RecordType[RecordType[\"SafeProperty\"] = 12] = \"SafeProperty\";\r\n    RecordType[RecordType[\"CollectionLiteral\"] = 13] = \"CollectionLiteral\";\r\n    RecordType[RecordType[\"SafeMethodInvoke\"] = 14] = \"SafeMethodInvoke\";\r\n    RecordType[RecordType[\"DirectiveLifecycle\"] = 15] = \"DirectiveLifecycle\";\r\n    RecordType[RecordType[\"Chain\"] = 16] = \"Chain\";\r\n    RecordType[RecordType[\"SkipRecordsIf\"] = 17] = \"SkipRecordsIf\";\r\n    RecordType[RecordType[\"SkipRecordsIfNot\"] = 18] = \"SkipRecordsIfNot\";\r\n    RecordType[RecordType[\"SkipRecords\"] = 19] = \"SkipRecords\"; // Skip records unconditionally\r\n})(exports.RecordType || (exports.RecordType = {}));\r\nvar RecordType = exports.RecordType;\r\nvar ProtoRecord = (function () {\r\n    function ProtoRecord(mode, name, funcOrValue, args, fixedArgs, contextIndex, directiveIndex, selfIndex, bindingRecord, lastInBinding, lastInDirective, argumentToPureFunction, referencedBySelf, propertyBindingIndex) {\r\n        this.mode = mode;\r\n        this.name = name;\r\n        this.funcOrValue = funcOrValue;\r\n        this.args = args;\r\n        this.fixedArgs = fixedArgs;\r\n        this.contextIndex = contextIndex;\r\n        this.directiveIndex = directiveIndex;\r\n        this.selfIndex = selfIndex;\r\n        this.bindingRecord = bindingRecord;\r\n        this.lastInBinding = lastInBinding;\r\n        this.lastInDirective = lastInDirective;\r\n        this.argumentToPureFunction = argumentToPureFunction;\r\n        this.referencedBySelf = referencedBySelf;\r\n        this.propertyBindingIndex = propertyBindingIndex;\r\n    }\r\n    ProtoRecord.prototype.isPureFunction = function () {\r\n        return this.mode === RecordType.Interpolate || this.mode === RecordType.CollectionLiteral;\r\n    };\r\n    ProtoRecord.prototype.isUsedByOtherRecord = function () { return !this.lastInBinding || this.referencedBySelf; };\r\n    ProtoRecord.prototype.shouldBeChecked = function () {\r\n        return this.argumentToPureFunction || this.lastInBinding || this.isPureFunction() ||\r\n            this.isPipeRecord();\r\n    };\r\n    ProtoRecord.prototype.isPipeRecord = function () { return this.mode === RecordType.Pipe; };\r\n    ProtoRecord.prototype.isConditionalSkipRecord = function () {\r\n        return this.mode === RecordType.SkipRecordsIfNot || this.mode === RecordType.SkipRecordsIf;\r\n    };\r\n    ProtoRecord.prototype.isUnconditionalSkipRecord = function () { return this.mode === RecordType.SkipRecords; };\r\n    ProtoRecord.prototype.isSkipRecord = function () {\r\n        return this.isConditionalSkipRecord() || this.isUnconditionalSkipRecord();\r\n    };\r\n    ProtoRecord.prototype.isLifeCycleRecord = function () { return this.mode === RecordType.DirectiveLifecycle; };\r\n    return ProtoRecord;\r\n})();\r\nexports.ProtoRecord = ProtoRecord;\r\n},{}],115:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar Console = (function () {\r\n    function Console() {\r\n    }\r\n    Console.prototype.log = function (message) { lang_1.print(message); };\r\n    Console = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], Console);\r\n    return Console;\r\n})();\r\nexports.Console = Console;\r\n},{\"angular2/src/core/di\":117,\"angular2/src/facade/lang\":176}],116:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\n/**\r\n * A DebugElement contains information from the Angular compiler about an\r\n * element and provides access to the corresponding ElementInjector and\r\n * underlying DOM Element, as well as a way to query for children.\r\n *\r\n * A DebugElement can be obtained from a {@link ComponentFixture} or from an\r\n * {@link ElementRef} via {@link inspectElement}.\r\n */\r\nvar DebugElement = (function () {\r\n    function DebugElement() {\r\n    }\r\n    Object.defineProperty(DebugElement.prototype, \"componentInstance\", {\r\n        /**\r\n         * Return the instance of the component associated with this element, if any.\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    Object.defineProperty(DebugElement.prototype, \"nativeElement\", {\r\n        /**\r\n         * Return the native HTML element for this DebugElement.\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    Object.defineProperty(DebugElement.prototype, \"elementRef\", {\r\n        /**\r\n         * Return an Angular {@link ElementRef} for this element.\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    Object.defineProperty(DebugElement.prototype, \"children\", {\r\n        /**\r\n         * Get child DebugElements from within the Light DOM.\r\n         *\r\n         * @return {DebugElement[]}\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    Object.defineProperty(DebugElement.prototype, \"componentViewChildren\", {\r\n        /**\r\n         * Get the root DebugElement children of a component. Returns an empty\r\n         * list if the current DebugElement is not a component root.\r\n         *\r\n         * @return {DebugElement[]}\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    /**\r\n     * Return the first descendant TestElement matching the given predicate\r\n     * and scope.\r\n     *\r\n     * @param {Function: boolean} predicate\r\n     * @param {Scope} scope\r\n     *\r\n     * @return {DebugElement}\r\n     */\r\n    DebugElement.prototype.query = function (predicate, scope) {\r\n        if (scope === void 0) { scope = Scope.all; }\r\n        var results = this.queryAll(predicate, scope);\r\n        return results.length > 0 ? results[0] : null;\r\n    };\r\n    /**\r\n     * Return descendant TestElememts matching the given predicate\r\n     * and scope.\r\n     *\r\n     * @param {Function: boolean} predicate\r\n     * @param {Scope} scope\r\n     *\r\n     * @return {DebugElement[]}\r\n     */\r\n    DebugElement.prototype.queryAll = function (predicate, scope) {\r\n        if (scope === void 0) { scope = Scope.all; }\r\n        var elementsInScope = scope(this);\r\n        return elementsInScope.filter(predicate);\r\n    };\r\n    return DebugElement;\r\n})();\r\nexports.DebugElement = DebugElement;\r\nvar DebugElement_ = (function (_super) {\r\n    __extends(DebugElement_, _super);\r\n    function DebugElement_(_appElement) {\r\n        _super.call(this);\r\n        this._appElement = _appElement;\r\n    }\r\n    Object.defineProperty(DebugElement_.prototype, \"componentInstance\", {\r\n        get: function () {\r\n            if (!lang_1.isPresent(this._appElement)) {\r\n                return null;\r\n            }\r\n            return this._appElement.getComponent();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DebugElement_.prototype, \"nativeElement\", {\r\n        get: function () { return this.elementRef.nativeElement; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DebugElement_.prototype, \"elementRef\", {\r\n        get: function () { return this._appElement.ref; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DebugElement_.prototype.getDirectiveInstance = function (directiveIndex) {\r\n        return this._appElement.getDirectiveAtIndex(directiveIndex);\r\n    };\r\n    Object.defineProperty(DebugElement_.prototype, \"children\", {\r\n        get: function () {\r\n            return this._getChildElements(this._appElement.parentView, this._appElement);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DebugElement_.prototype, \"componentViewChildren\", {\r\n        get: function () {\r\n            if (!lang_1.isPresent(this._appElement.componentView)) {\r\n                // The current element is not a component.\r\n                return [];\r\n            }\r\n            return this._getChildElements(this._appElement.componentView, null);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DebugElement_.prototype.triggerEventHandler = function (eventName, eventObj) {\r\n        this._appElement.parentView.triggerEventHandlers(eventName, eventObj, this._appElement.proto.index);\r\n    };\r\n    DebugElement_.prototype.hasDirective = function (type) {\r\n        if (!lang_1.isPresent(this._appElement)) {\r\n            return false;\r\n        }\r\n        return this._appElement.hasDirective(type);\r\n    };\r\n    DebugElement_.prototype.inject = function (type) {\r\n        if (!lang_1.isPresent(this._appElement)) {\r\n            return null;\r\n        }\r\n        return this._appElement.get(type);\r\n    };\r\n    DebugElement_.prototype.getLocal = function (name) { return this._appElement.parentView.locals.get(name); };\r\n    /** @internal */\r\n    DebugElement_.prototype._getChildElements = function (view, parentAppElement) {\r\n        var _this = this;\r\n        var els = [];\r\n        for (var i = 0; i < view.appElements.length; ++i) {\r\n            var appEl = view.appElements[i];\r\n            if (appEl.parent == parentAppElement) {\r\n                els.push(new DebugElement_(appEl));\r\n                var views = appEl.nestedViews;\r\n                if (lang_1.isPresent(views)) {\r\n                    views.forEach(function (nextView) { els = els.concat(_this._getChildElements(nextView, null)); });\r\n                }\r\n            }\r\n        }\r\n        return els;\r\n    };\r\n    return DebugElement_;\r\n})(DebugElement);\r\nexports.DebugElement_ = DebugElement_;\r\n/**\r\n * Returns a {@link DebugElement} for an {@link ElementRef}.\r\n *\r\n * @param {ElementRef}: elementRef\r\n * @return {DebugElement}\r\n */\r\nfunction inspectElement(elementRef) {\r\n    return new DebugElement_(elementRef.internalElement);\r\n}\r\nexports.inspectElement = inspectElement;\r\n/**\r\n * Maps an array of {@link DebugElement}s to an array of native DOM elements.\r\n */\r\nfunction asNativeElements(arr) {\r\n    return arr.map(function (debugEl) { return debugEl.nativeElement; });\r\n}\r\nexports.asNativeElements = asNativeElements;\r\n/**\r\n * Set of scope functions used with {@link DebugElement}'s query functionality.\r\n */\r\nvar Scope = (function () {\r\n    function Scope() {\r\n    }\r\n    /**\r\n     * Scope queries to both the light dom and view of an element and its\r\n     * children.\r\n     *\r\n     * ## Example\r\n     *\r\n     * {@example core/debug/ts/debug_element/debug_element.ts region='scope_all'}\r\n     */\r\n    Scope.all = function (debugElement) {\r\n        var scope = [];\r\n        scope.push(debugElement);\r\n        debugElement.children.forEach(function (child) { return scope = scope.concat(Scope.all(child)); });\r\n        debugElement.componentViewChildren.forEach(function (child) { return scope = scope.concat(Scope.all(child)); });\r\n        return scope;\r\n    };\r\n    /**\r\n     * Scope queries to the light dom of an element and its children.\r\n     *\r\n     * ## Example\r\n     *\r\n     * {@example core/debug/ts/debug_element/debug_element.ts region='scope_light'}\r\n     */\r\n    Scope.light = function (debugElement) {\r\n        var scope = [];\r\n        debugElement.children.forEach(function (child) {\r\n            scope.push(child);\r\n            scope = scope.concat(Scope.light(child));\r\n        });\r\n        return scope;\r\n    };\r\n    /**\r\n     * Scope queries to the view of an element of its children.\r\n     *\r\n     * ## Example\r\n     *\r\n     * {@example core/debug/ts/debug_element/debug_element.ts region='scope_view'}\r\n     */\r\n    Scope.view = function (debugElement) {\r\n        var scope = [];\r\n        debugElement.componentViewChildren.forEach(function (child) {\r\n            scope.push(child);\r\n            scope = scope.concat(Scope.light(child));\r\n        });\r\n        return scope;\r\n    };\r\n    return Scope;\r\n})();\r\nexports.Scope = Scope;\r\n},{\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],117:[function(require,module,exports){\n'use strict';/**\r\n * @module\r\n * @description\r\n * The `di` module provides dependency injection container services.\r\n */\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nvar metadata_1 = require('./di/metadata');\r\nexports.InjectMetadata = metadata_1.InjectMetadata;\r\nexports.OptionalMetadata = metadata_1.OptionalMetadata;\r\nexports.InjectableMetadata = metadata_1.InjectableMetadata;\r\nexports.SelfMetadata = metadata_1.SelfMetadata;\r\nexports.HostMetadata = metadata_1.HostMetadata;\r\nexports.SkipSelfMetadata = metadata_1.SkipSelfMetadata;\r\nexports.DependencyMetadata = metadata_1.DependencyMetadata;\r\n// we have to reexport * because Dart and TS export two different sets of types\r\n__export(require('./di/decorators'));\r\nvar forward_ref_1 = require('./di/forward_ref');\r\nexports.forwardRef = forward_ref_1.forwardRef;\r\nexports.resolveForwardRef = forward_ref_1.resolveForwardRef;\r\nvar injector_1 = require('./di/injector');\r\nexports.Injector = injector_1.Injector;\r\nvar provider_1 = require('./di/provider');\r\nexports.Binding = provider_1.Binding;\r\nexports.ProviderBuilder = provider_1.ProviderBuilder;\r\nexports.ResolvedFactory = provider_1.ResolvedFactory;\r\nexports.Dependency = provider_1.Dependency;\r\nexports.bind = provider_1.bind;\r\nexports.Provider = provider_1.Provider;\r\nexports.provide = provider_1.provide;\r\nvar key_1 = require('./di/key');\r\nexports.Key = key_1.Key;\r\nexports.TypeLiteral = key_1.TypeLiteral;\r\nvar exceptions_1 = require('./di/exceptions');\r\nexports.NoProviderError = exceptions_1.NoProviderError;\r\nexports.AbstractProviderError = exceptions_1.AbstractProviderError;\r\nexports.CyclicDependencyError = exceptions_1.CyclicDependencyError;\r\nexports.InstantiationError = exceptions_1.InstantiationError;\r\nexports.InvalidProviderError = exceptions_1.InvalidProviderError;\r\nexports.NoAnnotationError = exceptions_1.NoAnnotationError;\r\nexports.OutOfBoundsError = exceptions_1.OutOfBoundsError;\r\nvar opaque_token_1 = require('./di/opaque_token');\r\nexports.OpaqueToken = opaque_token_1.OpaqueToken;\r\n},{\"./di/decorators\":118,\"./di/exceptions\":119,\"./di/forward_ref\":120,\"./di/injector\":121,\"./di/key\":122,\"./di/metadata\":123,\"./di/opaque_token\":124,\"./di/provider\":125}],118:[function(require,module,exports){\n'use strict';var metadata_1 = require('./metadata');\r\nvar decorators_1 = require('../util/decorators');\r\n/**\r\n * Factory for creating {@link InjectMetadata}.\r\n */\r\nexports.Inject = decorators_1.makeParamDecorator(metadata_1.InjectMetadata);\r\n/**\r\n * Factory for creating {@link OptionalMetadata}.\r\n */\r\nexports.Optional = decorators_1.makeParamDecorator(metadata_1.OptionalMetadata);\r\n/**\r\n * Factory for creating {@link InjectableMetadata}.\r\n */\r\nexports.Injectable = decorators_1.makeDecorator(metadata_1.InjectableMetadata);\r\n/**\r\n * Factory for creating {@link SelfMetadata}.\r\n */\r\nexports.Self = decorators_1.makeParamDecorator(metadata_1.SelfMetadata);\r\n/**\r\n * Factory for creating {@link HostMetadata}.\r\n */\r\nexports.Host = decorators_1.makeParamDecorator(metadata_1.HostMetadata);\r\n/**\r\n * Factory for creating {@link SkipSelfMetadata}.\r\n */\r\nexports.SkipSelf = decorators_1.makeParamDecorator(metadata_1.SkipSelfMetadata);\r\n},{\"../util/decorators\":166,\"./metadata\":123}],119:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nfunction findFirstClosedCycle(keys) {\r\n    var res = [];\r\n    for (var i = 0; i < keys.length; ++i) {\r\n        if (collection_1.ListWrapper.contains(res, keys[i])) {\r\n            res.push(keys[i]);\r\n            return res;\r\n        }\r\n        else {\r\n            res.push(keys[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction constructResolvingPath(keys) {\r\n    if (keys.length > 1) {\r\n        var reversed = findFirstClosedCycle(collection_1.ListWrapper.reversed(keys));\r\n        var tokenStrs = reversed.map(function (k) { return lang_1.stringify(k.token); });\r\n        return \" (\" + tokenStrs.join(' -> ') + \")\";\r\n    }\r\n    else {\r\n        return \"\";\r\n    }\r\n}\r\n/**\r\n * Base class for all errors arising from misconfigured providers.\r\n */\r\nvar AbstractProviderError = (function (_super) {\r\n    __extends(AbstractProviderError, _super);\r\n    function AbstractProviderError(injector, key, constructResolvingMessage) {\r\n        _super.call(this, \"DI Exception\");\r\n        this.keys = [key];\r\n        this.injectors = [injector];\r\n        this.constructResolvingMessage = constructResolvingMessage;\r\n        this.message = this.constructResolvingMessage(this.keys);\r\n    }\r\n    AbstractProviderError.prototype.addKey = function (injector, key) {\r\n        this.injectors.push(injector);\r\n        this.keys.push(key);\r\n        this.message = this.constructResolvingMessage(this.keys);\r\n    };\r\n    Object.defineProperty(AbstractProviderError.prototype, \"context\", {\r\n        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return AbstractProviderError;\r\n})(exceptions_1.BaseException);\r\nexports.AbstractProviderError = AbstractProviderError;\r\n/**\r\n * Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the\r\n * {@link Injector} does not have a {@link Provider} for {@link Key}.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))\r\n *\r\n * ```typescript\r\n * class A {\r\n *   constructor(b:B) {}\r\n * }\r\n *\r\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\r\n * ```\r\n */\r\nvar NoProviderError = (function (_super) {\r\n    __extends(NoProviderError, _super);\r\n    function NoProviderError(injector, key) {\r\n        _super.call(this, injector, key, function (keys) {\r\n            var first = lang_1.stringify(collection_1.ListWrapper.first(keys).token);\r\n            return \"No provider for \" + first + \"!\" + constructResolvingPath(keys);\r\n        });\r\n    }\r\n    return NoProviderError;\r\n})(AbstractProviderError);\r\nexports.NoProviderError = NoProviderError;\r\n/**\r\n * Thrown when dependencies form a cycle.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))\r\n *\r\n * ```typescript\r\n * var injector = Injector.resolveAndCreate([\r\n *   provide(\"one\", {useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]}),\r\n *   provide(\"two\", {useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]})\r\n * ]);\r\n *\r\n * expect(() => injector.get(\"one\")).toThrowError();\r\n * ```\r\n *\r\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\r\n */\r\nvar CyclicDependencyError = (function (_super) {\r\n    __extends(CyclicDependencyError, _super);\r\n    function CyclicDependencyError(injector, key) {\r\n        _super.call(this, injector, key, function (keys) {\r\n            return \"Cannot instantiate cyclic dependency!\" + constructResolvingPath(keys);\r\n        });\r\n    }\r\n    return CyclicDependencyError;\r\n})(AbstractProviderError);\r\nexports.CyclicDependencyError = CyclicDependencyError;\r\n/**\r\n * Thrown when a constructing type returns with an Error.\r\n *\r\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\r\n * this object to be instantiated.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))\r\n *\r\n * ```typescript\r\n * class A {\r\n *   constructor() {\r\n *     throw new Error('message');\r\n *   }\r\n * }\r\n *\r\n * var injector = Injector.resolveAndCreate([A]);\r\n\r\n * try {\r\n *   injector.get(A);\r\n * } catch (e) {\r\n *   expect(e instanceof InstantiationError).toBe(true);\r\n *   expect(e.originalException.message).toEqual(\"message\");\r\n *   expect(e.originalStack).toBeDefined();\r\n * }\r\n * ```\r\n */\r\nvar InstantiationError = (function (_super) {\r\n    __extends(InstantiationError, _super);\r\n    function InstantiationError(injector, originalException, originalStack, key) {\r\n        _super.call(this, \"DI Exception\", originalException, originalStack, null);\r\n        this.keys = [key];\r\n        this.injectors = [injector];\r\n    }\r\n    InstantiationError.prototype.addKey = function (injector, key) {\r\n        this.injectors.push(injector);\r\n        this.keys.push(key);\r\n    };\r\n    Object.defineProperty(InstantiationError.prototype, \"wrapperMessage\", {\r\n        get: function () {\r\n            var first = lang_1.stringify(collection_1.ListWrapper.first(this.keys).token);\r\n            return \"Error during instantiation of \" + first + \"!\" + constructResolvingPath(this.keys) + \".\";\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstantiationError.prototype, \"causeKey\", {\r\n        get: function () { return this.keys[0]; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstantiationError.prototype, \"context\", {\r\n        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return InstantiationError;\r\n})(exceptions_1.WrappedException);\r\nexports.InstantiationError = InstantiationError;\r\n/**\r\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\r\n * creation.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))\r\n *\r\n * ```typescript\r\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\r\n * ```\r\n */\r\nvar InvalidProviderError = (function (_super) {\r\n    __extends(InvalidProviderError, _super);\r\n    function InvalidProviderError(provider) {\r\n        _super.call(this, \"Invalid provider - only instances of Provider and Type are allowed, got: \" +\r\n            provider.toString());\r\n    }\r\n    return InvalidProviderError;\r\n})(exceptions_1.BaseException);\r\nexports.InvalidProviderError = InvalidProviderError;\r\n/**\r\n * Thrown when the class has no annotation information.\r\n *\r\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\r\n * need to be injected into the constructor.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))\r\n *\r\n * ```typescript\r\n * class A {\r\n *   constructor(b) {}\r\n * }\r\n *\r\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\r\n * ```\r\n *\r\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\r\n *\r\n * ```typescript\r\n * class B {}\r\n *\r\n * class A {\r\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\r\n * }\r\n *\r\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\r\n * ```\r\n */\r\nvar NoAnnotationError = (function (_super) {\r\n    __extends(NoAnnotationError, _super);\r\n    function NoAnnotationError(typeOrFunc, params) {\r\n        _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));\r\n    }\r\n    NoAnnotationError._genMessage = function (typeOrFunc, params) {\r\n        var signature = [];\r\n        for (var i = 0, ii = params.length; i < ii; i++) {\r\n            var parameter = params[i];\r\n            if (lang_1.isBlank(parameter) || parameter.length == 0) {\r\n                signature.push('?');\r\n            }\r\n            else {\r\n                signature.push(parameter.map(lang_1.stringify).join(' '));\r\n            }\r\n        }\r\n        return \"Cannot resolve all parameters for '\" + lang_1.stringify(typeOrFunc) + \"'(\" +\r\n            signature.join(', ') + \"). \" +\r\n            \"Make sure that all the parameters are decorated with Inject or have valid type annotations and that '\" +\r\n            lang_1.stringify(typeOrFunc) + \"' is decorated with Injectable.\";\r\n    };\r\n    return NoAnnotationError;\r\n})(exceptions_1.BaseException);\r\nexports.NoAnnotationError = NoAnnotationError;\r\n/**\r\n * Thrown when getting an object by index.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))\r\n *\r\n * ```typescript\r\n * class A {}\r\n *\r\n * var injector = Injector.resolveAndCreate([A]);\r\n *\r\n * expect(() => injector.getAt(100)).toThrowError();\r\n * ```\r\n */\r\nvar OutOfBoundsError = (function (_super) {\r\n    __extends(OutOfBoundsError, _super);\r\n    function OutOfBoundsError(index) {\r\n        _super.call(this, \"Index \" + index + \" is out-of-bounds.\");\r\n    }\r\n    return OutOfBoundsError;\r\n})(exceptions_1.BaseException);\r\nexports.OutOfBoundsError = OutOfBoundsError;\r\n// TODO: add a working example after alpha38 is released\r\n/**\r\n * Thrown when a multi provider and a regular provider are bound to the same token.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * expect(() => Injector.resolveAndCreate([\r\n *   new Provider(\"Strings\", {useValue: \"string1\", multi: true}),\r\n *   new Provider(\"Strings\", {useValue: \"string2\", multi: false})\r\n * ])).toThrowError();\r\n * ```\r\n */\r\nvar MixingMultiProvidersWithRegularProvidersError = (function (_super) {\r\n    __extends(MixingMultiProvidersWithRegularProvidersError, _super);\r\n    function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {\r\n        _super.call(this, \"Cannot mix multi providers and regular providers, got: \" + provider1.toString() + \" \" +\r\n            provider2.toString());\r\n    }\r\n    return MixingMultiProvidersWithRegularProvidersError;\r\n})(exceptions_1.BaseException);\r\nexports.MixingMultiProvidersWithRegularProvidersError = MixingMultiProvidersWithRegularProvidersError;\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],120:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * Allows to refer to references which are not yet defined.\r\n *\r\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\r\n * DI is declared,\r\n * but not yet defined. It is also used when the `token` which we use when creating a query is not\r\n * yet defined.\r\n *\r\n * ### Example\r\n * {@example core/di/ts/forward_ref/forward_ref.ts region='forward_ref'}\r\n */\r\nfunction forwardRef(forwardRefFn) {\r\n    forwardRefFn.__forward_ref__ = forwardRef;\r\n    forwardRefFn.toString = function () { return lang_1.stringify(this()); };\r\n    return forwardRefFn;\r\n}\r\nexports.forwardRef = forwardRef;\r\n/**\r\n * Lazily retrieves the reference value from a forwardRef.\r\n *\r\n * Acts as the identity function when given a non-forward-ref value.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))\r\n *\r\n * ```typescript\r\n * var ref = forwardRef(() => \"refValue\");\r\n * expect(resolveForwardRef(ref)).toEqual(\"refValue\");\r\n * expect(resolveForwardRef(\"regularValue\")).toEqual(\"regularValue\");\r\n * ```\r\n *\r\n * See: {@link forwardRef}\r\n */\r\nfunction resolveForwardRef(type) {\r\n    if (lang_1.isFunction(type) && type.hasOwnProperty('__forward_ref__') &&\r\n        type.__forward_ref__ === forwardRef) {\r\n        return type();\r\n    }\r\n    else {\r\n        return type;\r\n    }\r\n}\r\nexports.resolveForwardRef = resolveForwardRef;\r\n},{\"angular2/src/facade/lang\":176}],121:[function(require,module,exports){\n'use strict';var collection_1 = require('angular2/src/facade/collection');\r\nvar provider_1 = require('./provider');\r\nvar exceptions_1 = require('./exceptions');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar key_1 = require('./key');\r\nvar metadata_1 = require('./metadata');\r\n// Threshold for the dynamic version\r\nvar _MAX_CONSTRUCTION_COUNTER = 10;\r\nexports.UNDEFINED = lang_1.CONST_EXPR(new Object());\r\n/**\r\n * Visibility of a {@link Provider}.\r\n */\r\n(function (Visibility) {\r\n    /**\r\n     * A `Public` {@link Provider} is only visible to regular (as opposed to host) child injectors.\r\n     */\r\n    Visibility[Visibility[\"Public\"] = 0] = \"Public\";\r\n    /**\r\n     * A `Private` {@link Provider} is only visible to host (as opposed to regular) child injectors.\r\n     */\r\n    Visibility[Visibility[\"Private\"] = 1] = \"Private\";\r\n    /**\r\n     * A `PublicAndPrivate` {@link Provider} is visible to both host and regular child injectors.\r\n     */\r\n    Visibility[Visibility[\"PublicAndPrivate\"] = 2] = \"PublicAndPrivate\";\r\n})(exports.Visibility || (exports.Visibility = {}));\r\nvar Visibility = exports.Visibility;\r\nfunction canSee(src, dst) {\r\n    return (src === dst) ||\r\n        (dst === Visibility.PublicAndPrivate || src === Visibility.PublicAndPrivate);\r\n}\r\nvar ProtoInjectorInlineStrategy = (function () {\r\n    function ProtoInjectorInlineStrategy(protoEI, bwv) {\r\n        this.provider0 = null;\r\n        this.provider1 = null;\r\n        this.provider2 = null;\r\n        this.provider3 = null;\r\n        this.provider4 = null;\r\n        this.provider5 = null;\r\n        this.provider6 = null;\r\n        this.provider7 = null;\r\n        this.provider8 = null;\r\n        this.provider9 = null;\r\n        this.keyId0 = null;\r\n        this.keyId1 = null;\r\n        this.keyId2 = null;\r\n        this.keyId3 = null;\r\n        this.keyId4 = null;\r\n        this.keyId5 = null;\r\n        this.keyId6 = null;\r\n        this.keyId7 = null;\r\n        this.keyId8 = null;\r\n        this.keyId9 = null;\r\n        this.visibility0 = null;\r\n        this.visibility1 = null;\r\n        this.visibility2 = null;\r\n        this.visibility3 = null;\r\n        this.visibility4 = null;\r\n        this.visibility5 = null;\r\n        this.visibility6 = null;\r\n        this.visibility7 = null;\r\n        this.visibility8 = null;\r\n        this.visibility9 = null;\r\n        var length = bwv.length;\r\n        if (length > 0) {\r\n            this.provider0 = bwv[0].provider;\r\n            this.keyId0 = bwv[0].getKeyId();\r\n            this.visibility0 = bwv[0].visibility;\r\n        }\r\n        if (length > 1) {\r\n            this.provider1 = bwv[1].provider;\r\n            this.keyId1 = bwv[1].getKeyId();\r\n            this.visibility1 = bwv[1].visibility;\r\n        }\r\n        if (length > 2) {\r\n            this.provider2 = bwv[2].provider;\r\n            this.keyId2 = bwv[2].getKeyId();\r\n            this.visibility2 = bwv[2].visibility;\r\n        }\r\n        if (length > 3) {\r\n            this.provider3 = bwv[3].provider;\r\n            this.keyId3 = bwv[3].getKeyId();\r\n            this.visibility3 = bwv[3].visibility;\r\n        }\r\n        if (length > 4) {\r\n            this.provider4 = bwv[4].provider;\r\n            this.keyId4 = bwv[4].getKeyId();\r\n            this.visibility4 = bwv[4].visibility;\r\n        }\r\n        if (length > 5) {\r\n            this.provider5 = bwv[5].provider;\r\n            this.keyId5 = bwv[5].getKeyId();\r\n            this.visibility5 = bwv[5].visibility;\r\n        }\r\n        if (length > 6) {\r\n            this.provider6 = bwv[6].provider;\r\n            this.keyId6 = bwv[6].getKeyId();\r\n            this.visibility6 = bwv[6].visibility;\r\n        }\r\n        if (length > 7) {\r\n            this.provider7 = bwv[7].provider;\r\n            this.keyId7 = bwv[7].getKeyId();\r\n            this.visibility7 = bwv[7].visibility;\r\n        }\r\n        if (length > 8) {\r\n            this.provider8 = bwv[8].provider;\r\n            this.keyId8 = bwv[8].getKeyId();\r\n            this.visibility8 = bwv[8].visibility;\r\n        }\r\n        if (length > 9) {\r\n            this.provider9 = bwv[9].provider;\r\n            this.keyId9 = bwv[9].getKeyId();\r\n            this.visibility9 = bwv[9].visibility;\r\n        }\r\n    }\r\n    ProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {\r\n        if (index == 0)\r\n            return this.provider0;\r\n        if (index == 1)\r\n            return this.provider1;\r\n        if (index == 2)\r\n            return this.provider2;\r\n        if (index == 3)\r\n            return this.provider3;\r\n        if (index == 4)\r\n            return this.provider4;\r\n        if (index == 5)\r\n            return this.provider5;\r\n        if (index == 6)\r\n            return this.provider6;\r\n        if (index == 7)\r\n            return this.provider7;\r\n        if (index == 8)\r\n            return this.provider8;\r\n        if (index == 9)\r\n            return this.provider9;\r\n        throw new exceptions_1.OutOfBoundsError(index);\r\n    };\r\n    ProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {\r\n        return new InjectorInlineStrategy(injector, this);\r\n    };\r\n    return ProtoInjectorInlineStrategy;\r\n})();\r\nexports.ProtoInjectorInlineStrategy = ProtoInjectorInlineStrategy;\r\nvar ProtoInjectorDynamicStrategy = (function () {\r\n    function ProtoInjectorDynamicStrategy(protoInj, bwv) {\r\n        var len = bwv.length;\r\n        this.providers = collection_1.ListWrapper.createFixedSize(len);\r\n        this.keyIds = collection_1.ListWrapper.createFixedSize(len);\r\n        this.visibilities = collection_1.ListWrapper.createFixedSize(len);\r\n        for (var i = 0; i < len; i++) {\r\n            this.providers[i] = bwv[i].provider;\r\n            this.keyIds[i] = bwv[i].getKeyId();\r\n            this.visibilities[i] = bwv[i].visibility;\r\n        }\r\n    }\r\n    ProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {\r\n        if (index < 0 || index >= this.providers.length) {\r\n            throw new exceptions_1.OutOfBoundsError(index);\r\n        }\r\n        return this.providers[index];\r\n    };\r\n    ProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {\r\n        return new InjectorDynamicStrategy(this, ei);\r\n    };\r\n    return ProtoInjectorDynamicStrategy;\r\n})();\r\nexports.ProtoInjectorDynamicStrategy = ProtoInjectorDynamicStrategy;\r\nvar ProtoInjector = (function () {\r\n    function ProtoInjector(bwv) {\r\n        this.numberOfProviders = bwv.length;\r\n        this._strategy = bwv.length > _MAX_CONSTRUCTION_COUNTER ?\r\n            new ProtoInjectorDynamicStrategy(this, bwv) :\r\n            new ProtoInjectorInlineStrategy(this, bwv);\r\n    }\r\n    ProtoInjector.fromResolvedProviders = function (providers) {\r\n        var bd = providers.map(function (b) { return new ProviderWithVisibility(b, Visibility.Public); });\r\n        return new ProtoInjector(bd);\r\n    };\r\n    ProtoInjector.prototype.getProviderAtIndex = function (index) { return this._strategy.getProviderAtIndex(index); };\r\n    return ProtoInjector;\r\n})();\r\nexports.ProtoInjector = ProtoInjector;\r\nvar InjectorInlineStrategy = (function () {\r\n    function InjectorInlineStrategy(injector, protoStrategy) {\r\n        this.injector = injector;\r\n        this.protoStrategy = protoStrategy;\r\n        this.obj0 = exports.UNDEFINED;\r\n        this.obj1 = exports.UNDEFINED;\r\n        this.obj2 = exports.UNDEFINED;\r\n        this.obj3 = exports.UNDEFINED;\r\n        this.obj4 = exports.UNDEFINED;\r\n        this.obj5 = exports.UNDEFINED;\r\n        this.obj6 = exports.UNDEFINED;\r\n        this.obj7 = exports.UNDEFINED;\r\n        this.obj8 = exports.UNDEFINED;\r\n        this.obj9 = exports.UNDEFINED;\r\n    }\r\n    InjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };\r\n    InjectorInlineStrategy.prototype.instantiateProvider = function (provider, visibility) {\r\n        return this.injector._new(provider, visibility);\r\n    };\r\n    InjectorInlineStrategy.prototype.getObjByKeyId = function (keyId, visibility) {\r\n        var p = this.protoStrategy;\r\n        var inj = this.injector;\r\n        if (p.keyId0 === keyId && canSee(p.visibility0, visibility)) {\r\n            if (this.obj0 === exports.UNDEFINED) {\r\n                this.obj0 = inj._new(p.provider0, p.visibility0);\r\n            }\r\n            return this.obj0;\r\n        }\r\n        if (p.keyId1 === keyId && canSee(p.visibility1, visibility)) {\r\n            if (this.obj1 === exports.UNDEFINED) {\r\n                this.obj1 = inj._new(p.provider1, p.visibility1);\r\n            }\r\n            return this.obj1;\r\n        }\r\n        if (p.keyId2 === keyId && canSee(p.visibility2, visibility)) {\r\n            if (this.obj2 === exports.UNDEFINED) {\r\n                this.obj2 = inj._new(p.provider2, p.visibility2);\r\n            }\r\n            return this.obj2;\r\n        }\r\n        if (p.keyId3 === keyId && canSee(p.visibility3, visibility)) {\r\n            if (this.obj3 === exports.UNDEFINED) {\r\n                this.obj3 = inj._new(p.provider3, p.visibility3);\r\n            }\r\n            return this.obj3;\r\n        }\r\n        if (p.keyId4 === keyId && canSee(p.visibility4, visibility)) {\r\n            if (this.obj4 === exports.UNDEFINED) {\r\n                this.obj4 = inj._new(p.provider4, p.visibility4);\r\n            }\r\n            return this.obj4;\r\n        }\r\n        if (p.keyId5 === keyId && canSee(p.visibility5, visibility)) {\r\n            if (this.obj5 === exports.UNDEFINED) {\r\n                this.obj5 = inj._new(p.provider5, p.visibility5);\r\n            }\r\n            return this.obj5;\r\n        }\r\n        if (p.keyId6 === keyId && canSee(p.visibility6, visibility)) {\r\n            if (this.obj6 === exports.UNDEFINED) {\r\n                this.obj6 = inj._new(p.provider6, p.visibility6);\r\n            }\r\n            return this.obj6;\r\n        }\r\n        if (p.keyId7 === keyId && canSee(p.visibility7, visibility)) {\r\n            if (this.obj7 === exports.UNDEFINED) {\r\n                this.obj7 = inj._new(p.provider7, p.visibility7);\r\n            }\r\n            return this.obj7;\r\n        }\r\n        if (p.keyId8 === keyId && canSee(p.visibility8, visibility)) {\r\n            if (this.obj8 === exports.UNDEFINED) {\r\n                this.obj8 = inj._new(p.provider8, p.visibility8);\r\n            }\r\n            return this.obj8;\r\n        }\r\n        if (p.keyId9 === keyId && canSee(p.visibility9, visibility)) {\r\n            if (this.obj9 === exports.UNDEFINED) {\r\n                this.obj9 = inj._new(p.provider9, p.visibility9);\r\n            }\r\n            return this.obj9;\r\n        }\r\n        return exports.UNDEFINED;\r\n    };\r\n    InjectorInlineStrategy.prototype.getObjAtIndex = function (index) {\r\n        if (index == 0)\r\n            return this.obj0;\r\n        if (index == 1)\r\n            return this.obj1;\r\n        if (index == 2)\r\n            return this.obj2;\r\n        if (index == 3)\r\n            return this.obj3;\r\n        if (index == 4)\r\n            return this.obj4;\r\n        if (index == 5)\r\n            return this.obj5;\r\n        if (index == 6)\r\n            return this.obj6;\r\n        if (index == 7)\r\n            return this.obj7;\r\n        if (index == 8)\r\n            return this.obj8;\r\n        if (index == 9)\r\n            return this.obj9;\r\n        throw new exceptions_1.OutOfBoundsError(index);\r\n    };\r\n    InjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };\r\n    return InjectorInlineStrategy;\r\n})();\r\nexports.InjectorInlineStrategy = InjectorInlineStrategy;\r\nvar InjectorDynamicStrategy = (function () {\r\n    function InjectorDynamicStrategy(protoStrategy, injector) {\r\n        this.protoStrategy = protoStrategy;\r\n        this.injector = injector;\r\n        this.objs = collection_1.ListWrapper.createFixedSize(protoStrategy.providers.length);\r\n        collection_1.ListWrapper.fill(this.objs, exports.UNDEFINED);\r\n    }\r\n    InjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };\r\n    InjectorDynamicStrategy.prototype.instantiateProvider = function (provider, visibility) {\r\n        return this.injector._new(provider, visibility);\r\n    };\r\n    InjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId, visibility) {\r\n        var p = this.protoStrategy;\r\n        for (var i = 0; i < p.keyIds.length; i++) {\r\n            if (p.keyIds[i] === keyId && canSee(p.visibilities[i], visibility)) {\r\n                if (this.objs[i] === exports.UNDEFINED) {\r\n                    this.objs[i] = this.injector._new(p.providers[i], p.visibilities[i]);\r\n                }\r\n                return this.objs[i];\r\n            }\r\n        }\r\n        return exports.UNDEFINED;\r\n    };\r\n    InjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {\r\n        if (index < 0 || index >= this.objs.length) {\r\n            throw new exceptions_1.OutOfBoundsError(index);\r\n        }\r\n        return this.objs[index];\r\n    };\r\n    InjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };\r\n    return InjectorDynamicStrategy;\r\n})();\r\nexports.InjectorDynamicStrategy = InjectorDynamicStrategy;\r\nvar ProviderWithVisibility = (function () {\r\n    function ProviderWithVisibility(provider, visibility) {\r\n        this.provider = provider;\r\n        this.visibility = visibility;\r\n    }\r\n    ;\r\n    ProviderWithVisibility.prototype.getKeyId = function () { return this.provider.key.id; };\r\n    return ProviderWithVisibility;\r\n})();\r\nexports.ProviderWithVisibility = ProviderWithVisibility;\r\n/**\r\n * A dependency injection container used for instantiating objects and resolving dependencies.\r\n *\r\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\r\n * constructor dependencies.\r\n *\r\n * In typical use, application code asks for the dependencies in the constructor and they are\r\n * resolved by the `Injector`.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))\r\n *\r\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\r\n *\r\n * ```typescript\r\n * @Injectable()\r\n * class Engine {\r\n * }\r\n *\r\n * @Injectable()\r\n * class Car {\r\n *   constructor(public engine:Engine) {}\r\n * }\r\n *\r\n * var injector = Injector.resolveAndCreate([Car, Engine]);\r\n * var car = injector.get(Car);\r\n * expect(car instanceof Car).toBe(true);\r\n * expect(car.engine instanceof Engine).toBe(true);\r\n * ```\r\n *\r\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\r\n * resolve all of the object's dependencies automatically.\r\n */\r\nvar Injector = (function () {\r\n    /**\r\n     * Private\r\n     */\r\n    function Injector(_proto /* ProtoInjector */, _parent, _isHostBoundary, _depProvider, _debugContext) {\r\n        if (_parent === void 0) { _parent = null; }\r\n        if (_isHostBoundary === void 0) { _isHostBoundary = false; }\r\n        if (_depProvider === void 0) { _depProvider = null; }\r\n        if (_debugContext === void 0) { _debugContext = null; }\r\n        this._isHostBoundary = _isHostBoundary;\r\n        this._depProvider = _depProvider;\r\n        this._debugContext = _debugContext;\r\n        /** @internal */\r\n        this._constructionCounter = 0;\r\n        this._proto = _proto;\r\n        this._parent = _parent;\r\n        this._strategy = _proto._strategy.createInjectorStrategy(this);\r\n    }\r\n    /**\r\n     * Turns an array of provider definitions into an array of resolved providers.\r\n     *\r\n     * A resolution is a process of flattening multiple nested arrays and converting individual\r\n     * providers into an array of {@link ResolvedProvider}s.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var providers = Injector.resolve([Car, [[Engine]]]);\r\n     *\r\n     * expect(providers.length).toEqual(2);\r\n     *\r\n     * expect(providers[0] instanceof ResolvedProvider).toBe(true);\r\n     * expect(providers[0].key.displayName).toBe(\"Car\");\r\n     * expect(providers[0].dependencies.length).toEqual(1);\r\n     * expect(providers[0].factory).toBeDefined();\r\n     *\r\n     * expect(providers[1].key.displayName).toBe(\"Engine\");\r\n     * });\r\n     * ```\r\n     *\r\n     * See {@link Injector#fromResolvedProviders} for more info.\r\n     */\r\n    Injector.resolve = function (providers) {\r\n        return provider_1.resolveProviders(providers);\r\n    };\r\n    /**\r\n     * Resolves an array of providers and creates an injector from those providers.\r\n     *\r\n     * The passed-in providers can be an array of `Type`, {@link Provider},\r\n     * or a recursive array of more providers.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var injector = Injector.resolveAndCreate([Car, Engine]);\r\n     * expect(injector.get(Car) instanceof Car).toBe(true);\r\n     * ```\r\n     *\r\n     * This function is slower than the corresponding `fromResolvedProviders`\r\n     * because it needs to resolve the passed-in providers first.\r\n     * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.\r\n     */\r\n    Injector.resolveAndCreate = function (providers) {\r\n        var resolvedProviders = Injector.resolve(providers);\r\n        return Injector.fromResolvedProviders(resolvedProviders);\r\n    };\r\n    /**\r\n     * Creates an injector from previously resolved providers.\r\n     *\r\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var providers = Injector.resolve([Car, Engine]);\r\n     * var injector = Injector.fromResolvedProviders(providers);\r\n     * expect(injector.get(Car) instanceof Car).toBe(true);\r\n     * ```\r\n     */\r\n    Injector.fromResolvedProviders = function (providers) {\r\n        return new Injector(ProtoInjector.fromResolvedProviders(providers));\r\n    };\r\n    /**\r\n     * @deprecated\r\n     */\r\n    Injector.fromResolvedBindings = function (providers) {\r\n        return Injector.fromResolvedProviders(providers);\r\n    };\r\n    Object.defineProperty(Injector.prototype, \"hostBoundary\", {\r\n        /**\r\n         * Whether this injector is a boundary to a host.\r\n         * @internal\r\n         */\r\n        get: function () { return this._isHostBoundary; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @internal\r\n     */\r\n    Injector.prototype.debugContext = function () { return this._debugContext(); };\r\n    /**\r\n     * Retrieves an instance from the injector based on the provided token.\r\n     * Throws {@link NoProviderError} if not found.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/HeXSHg?p=preview))\r\n     *\r\n     * ```typescript\r\n     * var injector = Injector.resolveAndCreate([\r\n     *   provide(\"validToken\", {useValue: \"Value\"})\r\n     * ]);\r\n     * expect(injector.get(\"validToken\")).toEqual(\"Value\");\r\n     * expect(() => injector.get(\"invalidToken\")).toThrowError();\r\n     * ```\r\n     *\r\n     * `Injector` returns itself when given `Injector` as a token.\r\n     *\r\n     * ```typescript\r\n     * var injector = Injector.resolveAndCreate([]);\r\n     * expect(injector.get(Injector)).toBe(injector);\r\n     * ```\r\n     */\r\n    Injector.prototype.get = function (token) {\r\n        return this._getByKey(key_1.Key.get(token), null, null, false, Visibility.PublicAndPrivate);\r\n    };\r\n    /**\r\n     * Retrieves an instance from the injector based on the provided token.\r\n     * Returns null if not found.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/tpEbEy?p=preview))\r\n     *\r\n     * ```typescript\r\n     * var injector = Injector.resolveAndCreate([\r\n     *   provide(\"validToken\", {useValue: \"Value\"})\r\n     * ]);\r\n     * expect(injector.getOptional(\"validToken\")).toEqual(\"Value\");\r\n     * expect(injector.getOptional(\"invalidToken\")).toBe(null);\r\n     * ```\r\n     *\r\n     * `Injector` returns itself when given `Injector` as a token.\r\n     *\r\n     * ```typescript\r\n     * var injector = Injector.resolveAndCreate([]);\r\n     * expect(injector.getOptional(Injector)).toBe(injector);\r\n     * ```\r\n     */\r\n    Injector.prototype.getOptional = function (token) {\r\n        return this._getByKey(key_1.Key.get(token), null, null, true, Visibility.PublicAndPrivate);\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    Injector.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };\r\n    Object.defineProperty(Injector.prototype, \"parent\", {\r\n        /**\r\n         * Parent of this injector.\r\n         *\r\n         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\r\n         * -->\r\n         *\r\n         * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))\r\n         *\r\n         * ```typescript\r\n         * var parent = Injector.resolveAndCreate([]);\r\n         * var child = parent.resolveAndCreateChild([]);\r\n         * expect(child.parent).toBe(parent);\r\n         * ```\r\n         */\r\n        get: function () { return this._parent; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Injector.prototype, \"internalStrategy\", {\r\n        /**\r\n         * @internal\r\n         * Internal. Do not use.\r\n         * We return `any` not to export the InjectorStrategy type.\r\n         */\r\n        get: function () { return this._strategy; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Resolves an array of providers and creates a child injector from those providers.\r\n     *\r\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\r\n     * -->\r\n     *\r\n     * The passed-in providers can be an array of `Type`, {@link Provider},\r\n     * or a recursive array of more providers.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))\r\n     *\r\n     * ```typescript\r\n     * class ParentProvider {}\r\n     * class ChildProvider {}\r\n     *\r\n     * var parent = Injector.resolveAndCreate([ParentProvider]);\r\n     * var child = parent.resolveAndCreateChild([ChildProvider]);\r\n     *\r\n     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\r\n     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\r\n     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\r\n     * ```\r\n     *\r\n     * This function is slower than the corresponding `createChildFromResolved`\r\n     * because it needs to resolve the passed-in providers first.\r\n     * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.\r\n     */\r\n    Injector.prototype.resolveAndCreateChild = function (providers) {\r\n        var resolvedProviders = Injector.resolve(providers);\r\n        return this.createChildFromResolved(resolvedProviders);\r\n    };\r\n    /**\r\n     * Creates a child injector from previously resolved providers.\r\n     *\r\n     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\r\n     * -->\r\n     *\r\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))\r\n     *\r\n     * ```typescript\r\n     * class ParentProvider {}\r\n     * class ChildProvider {}\r\n     *\r\n     * var parentProviders = Injector.resolve([ParentProvider]);\r\n     * var childProviders = Injector.resolve([ChildProvider]);\r\n     *\r\n     * var parent = Injector.fromResolvedProviders(parentProviders);\r\n     * var child = parent.createChildFromResolved(childProviders);\r\n     *\r\n     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\r\n     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\r\n     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\r\n     * ```\r\n     */\r\n    Injector.prototype.createChildFromResolved = function (providers) {\r\n        var bd = providers.map(function (b) { return new ProviderWithVisibility(b, Visibility.Public); });\r\n        var proto = new ProtoInjector(bd);\r\n        var inj = new Injector(proto);\r\n        inj._parent = this;\r\n        return inj;\r\n    };\r\n    /**\r\n     * Resolves a provider and instantiates an object in the context of the injector.\r\n     *\r\n     * The created object does not get cached by the injector.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var injector = Injector.resolveAndCreate([Engine]);\r\n     *\r\n     * var car = injector.resolveAndInstantiate(Car);\r\n     * expect(car.engine).toBe(injector.get(Engine));\r\n     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\r\n     * ```\r\n     */\r\n    Injector.prototype.resolveAndInstantiate = function (provider) {\r\n        return this.instantiateResolved(Injector.resolve([provider])[0]);\r\n    };\r\n    /**\r\n     * Instantiates an object using a resolved provider in the context of the injector.\r\n     *\r\n     * The created object does not get cached by the injector.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))\r\n     *\r\n     * ```typescript\r\n     * @Injectable()\r\n     * class Engine {\r\n     * }\r\n     *\r\n     * @Injectable()\r\n     * class Car {\r\n     *   constructor(public engine:Engine) {}\r\n     * }\r\n     *\r\n     * var injector = Injector.resolveAndCreate([Engine]);\r\n     * var carProvider = Injector.resolve([Car])[0];\r\n     * var car = injector.instantiateResolved(carProvider);\r\n     * expect(car.engine).toBe(injector.get(Engine));\r\n     * expect(car).not.toBe(injector.instantiateResolved(carProvider));\r\n     * ```\r\n     */\r\n    Injector.prototype.instantiateResolved = function (provider) {\r\n        return this._instantiateProvider(provider, Visibility.PublicAndPrivate);\r\n    };\r\n    /** @internal */\r\n    Injector.prototype._new = function (provider, visibility) {\r\n        if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {\r\n            throw new exceptions_1.CyclicDependencyError(this, provider.key);\r\n        }\r\n        return this._instantiateProvider(provider, visibility);\r\n    };\r\n    Injector.prototype._instantiateProvider = function (provider, visibility) {\r\n        if (provider.multiProvider) {\r\n            var res = collection_1.ListWrapper.createFixedSize(provider.resolvedFactories.length);\r\n            for (var i = 0; i < provider.resolvedFactories.length; ++i) {\r\n                res[i] = this._instantiate(provider, provider.resolvedFactories[i], visibility);\r\n            }\r\n            return res;\r\n        }\r\n        else {\r\n            return this._instantiate(provider, provider.resolvedFactories[0], visibility);\r\n        }\r\n    };\r\n    Injector.prototype._instantiate = function (provider, resolvedFactory, visibility) {\r\n        var factory = resolvedFactory.factory;\r\n        var deps = resolvedFactory.dependencies;\r\n        var length = deps.length;\r\n        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19;\r\n        try {\r\n            d0 = length > 0 ? this._getByDependency(provider, deps[0], visibility) : null;\r\n            d1 = length > 1 ? this._getByDependency(provider, deps[1], visibility) : null;\r\n            d2 = length > 2 ? this._getByDependency(provider, deps[2], visibility) : null;\r\n            d3 = length > 3 ? this._getByDependency(provider, deps[3], visibility) : null;\r\n            d4 = length > 4 ? this._getByDependency(provider, deps[4], visibility) : null;\r\n            d5 = length > 5 ? this._getByDependency(provider, deps[5], visibility) : null;\r\n            d6 = length > 6 ? this._getByDependency(provider, deps[6], visibility) : null;\r\n            d7 = length > 7 ? this._getByDependency(provider, deps[7], visibility) : null;\r\n            d8 = length > 8 ? this._getByDependency(provider, deps[8], visibility) : null;\r\n            d9 = length > 9 ? this._getByDependency(provider, deps[9], visibility) : null;\r\n            d10 = length > 10 ? this._getByDependency(provider, deps[10], visibility) : null;\r\n            d11 = length > 11 ? this._getByDependency(provider, deps[11], visibility) : null;\r\n            d12 = length > 12 ? this._getByDependency(provider, deps[12], visibility) : null;\r\n            d13 = length > 13 ? this._getByDependency(provider, deps[13], visibility) : null;\r\n            d14 = length > 14 ? this._getByDependency(provider, deps[14], visibility) : null;\r\n            d15 = length > 15 ? this._getByDependency(provider, deps[15], visibility) : null;\r\n            d16 = length > 16 ? this._getByDependency(provider, deps[16], visibility) : null;\r\n            d17 = length > 17 ? this._getByDependency(provider, deps[17], visibility) : null;\r\n            d18 = length > 18 ? this._getByDependency(provider, deps[18], visibility) : null;\r\n            d19 = length > 19 ? this._getByDependency(provider, deps[19], visibility) : null;\r\n        }\r\n        catch (e) {\r\n            if (e instanceof exceptions_1.AbstractProviderError || e instanceof exceptions_1.InstantiationError) {\r\n                e.addKey(this, provider.key);\r\n            }\r\n            throw e;\r\n        }\r\n        var obj;\r\n        try {\r\n            switch (length) {\r\n                case 0:\r\n                    obj = factory();\r\n                    break;\r\n                case 1:\r\n                    obj = factory(d0);\r\n                    break;\r\n                case 2:\r\n                    obj = factory(d0, d1);\r\n                    break;\r\n                case 3:\r\n                    obj = factory(d0, d1, d2);\r\n                    break;\r\n                case 4:\r\n                    obj = factory(d0, d1, d2, d3);\r\n                    break;\r\n                case 5:\r\n                    obj = factory(d0, d1, d2, d3, d4);\r\n                    break;\r\n                case 6:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5);\r\n                    break;\r\n                case 7:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6);\r\n                    break;\r\n                case 8:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);\r\n                    break;\r\n                case 9:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);\r\n                    break;\r\n                case 10:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);\r\n                    break;\r\n                case 11:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);\r\n                    break;\r\n                case 12:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);\r\n                    break;\r\n                case 13:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);\r\n                    break;\r\n                case 14:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);\r\n                    break;\r\n                case 15:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);\r\n                    break;\r\n                case 16:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);\r\n                    break;\r\n                case 17:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);\r\n                    break;\r\n                case 18:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);\r\n                    break;\r\n                case 19:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);\r\n                    break;\r\n                case 20:\r\n                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);\r\n                    break;\r\n            }\r\n        }\r\n        catch (e) {\r\n            throw new exceptions_1.InstantiationError(this, e, e.stack, provider.key);\r\n        }\r\n        return obj;\r\n    };\r\n    Injector.prototype._getByDependency = function (provider, dep, providerVisibility) {\r\n        var special = lang_1.isPresent(this._depProvider) ?\r\n            this._depProvider.getDependency(this, provider, dep) :\r\n            exports.UNDEFINED;\r\n        if (special !== exports.UNDEFINED) {\r\n            return special;\r\n        }\r\n        else {\r\n            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional, providerVisibility);\r\n        }\r\n    };\r\n    Injector.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, optional, providerVisibility) {\r\n        if (key === INJECTOR_KEY) {\r\n            return this;\r\n        }\r\n        if (upperBoundVisibility instanceof metadata_1.SelfMetadata) {\r\n            return this._getByKeySelf(key, optional, providerVisibility);\r\n        }\r\n        else if (upperBoundVisibility instanceof metadata_1.HostMetadata) {\r\n            return this._getByKeyHost(key, optional, providerVisibility, lowerBoundVisibility);\r\n        }\r\n        else {\r\n            return this._getByKeyDefault(key, optional, providerVisibility, lowerBoundVisibility);\r\n        }\r\n    };\r\n    /** @internal */\r\n    Injector.prototype._throwOrNull = function (key, optional) {\r\n        if (optional) {\r\n            return null;\r\n        }\r\n        else {\r\n            throw new exceptions_1.NoProviderError(this, key);\r\n        }\r\n    };\r\n    /** @internal */\r\n    Injector.prototype._getByKeySelf = function (key, optional, providerVisibility) {\r\n        var obj = this._strategy.getObjByKeyId(key.id, providerVisibility);\r\n        return (obj !== exports.UNDEFINED) ? obj : this._throwOrNull(key, optional);\r\n    };\r\n    /** @internal */\r\n    Injector.prototype._getByKeyHost = function (key, optional, providerVisibility, lowerBoundVisibility) {\r\n        var inj = this;\r\n        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {\r\n            if (inj._isHostBoundary) {\r\n                return this._getPrivateDependency(key, optional, inj);\r\n            }\r\n            else {\r\n                inj = inj._parent;\r\n            }\r\n        }\r\n        while (inj != null) {\r\n            var obj = inj._strategy.getObjByKeyId(key.id, providerVisibility);\r\n            if (obj !== exports.UNDEFINED)\r\n                return obj;\r\n            if (lang_1.isPresent(inj._parent) && inj._isHostBoundary) {\r\n                return this._getPrivateDependency(key, optional, inj);\r\n            }\r\n            else {\r\n                inj = inj._parent;\r\n            }\r\n        }\r\n        return this._throwOrNull(key, optional);\r\n    };\r\n    /** @internal */\r\n    Injector.prototype._getPrivateDependency = function (key, optional, inj) {\r\n        var obj = inj._parent._strategy.getObjByKeyId(key.id, Visibility.Private);\r\n        return (obj !== exports.UNDEFINED) ? obj : this._throwOrNull(key, optional);\r\n    };\r\n    /** @internal */\r\n    Injector.prototype._getByKeyDefault = function (key, optional, providerVisibility, lowerBoundVisibility) {\r\n        var inj = this;\r\n        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {\r\n            providerVisibility = inj._isHostBoundary ? Visibility.PublicAndPrivate : Visibility.Public;\r\n            inj = inj._parent;\r\n        }\r\n        while (inj != null) {\r\n            var obj = inj._strategy.getObjByKeyId(key.id, providerVisibility);\r\n            if (obj !== exports.UNDEFINED)\r\n                return obj;\r\n            providerVisibility = inj._isHostBoundary ? Visibility.PublicAndPrivate : Visibility.Public;\r\n            inj = inj._parent;\r\n        }\r\n        return this._throwOrNull(key, optional);\r\n    };\r\n    Object.defineProperty(Injector.prototype, \"displayName\", {\r\n        get: function () {\r\n            return \"Injector(providers: [\" + _mapProviders(this, function (b) { return (\" \\\"\" + b.key.displayName + \"\\\" \"); }).join(\", \") + \"])\";\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Injector.prototype.toString = function () { return this.displayName; };\r\n    return Injector;\r\n})();\r\nexports.Injector = Injector;\r\nvar INJECTOR_KEY = key_1.Key.get(Injector);\r\nfunction _mapProviders(injector, fn) {\r\n    var res = [];\r\n    for (var i = 0; i < injector._proto.numberOfProviders; ++i) {\r\n        res.push(fn(injector._proto.getProviderAtIndex(i)));\r\n    }\r\n    return res;\r\n}\r\n},{\"./exceptions\":119,\"./key\":122,\"./metadata\":123,\"./provider\":125,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],122:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar type_literal_1 = require('./type_literal');\r\nvar forward_ref_1 = require('./forward_ref');\r\nvar type_literal_2 = require('./type_literal');\r\nexports.TypeLiteral = type_literal_2.TypeLiteral;\r\n/**\r\n * A unique object used for retrieving items from the {@link Injector}.\r\n *\r\n * Keys have:\r\n * - a system-wide unique `id`.\r\n * - a `token`.\r\n *\r\n * `Key` is used internally by {@link Injector} because its system-wide unique `id` allows the\r\n * injector to store created objects in a more efficient way.\r\n *\r\n * `Key` should not be created directly. {@link Injector} creates keys automatically when resolving\r\n * providers.\r\n */\r\nvar Key = (function () {\r\n    /**\r\n     * Private\r\n     */\r\n    function Key(token, id) {\r\n        this.token = token;\r\n        this.id = id;\r\n        if (lang_1.isBlank(token)) {\r\n            throw new exceptions_1.BaseException('Token must be defined!');\r\n        }\r\n    }\r\n    Object.defineProperty(Key.prototype, \"displayName\", {\r\n        /**\r\n         * Returns a stringified token.\r\n         */\r\n        get: function () { return lang_1.stringify(this.token); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Retrieves a `Key` for a token.\r\n     */\r\n    Key.get = function (token) { return _globalKeyRegistry.get(forward_ref_1.resolveForwardRef(token)); };\r\n    Object.defineProperty(Key, \"numberOfKeys\", {\r\n        /**\r\n         * @returns the number of keys registered in the system.\r\n         */\r\n        get: function () { return _globalKeyRegistry.numberOfKeys; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Key;\r\n})();\r\nexports.Key = Key;\r\n/**\r\n * @internal\r\n */\r\nvar KeyRegistry = (function () {\r\n    function KeyRegistry() {\r\n        this._allKeys = new Map();\r\n    }\r\n    KeyRegistry.prototype.get = function (token) {\r\n        if (token instanceof Key)\r\n            return token;\r\n        // TODO: workaround for https://github.com/Microsoft/TypeScript/issues/3123\r\n        var theToken = token;\r\n        if (token instanceof type_literal_1.TypeLiteral) {\r\n            theToken = token.type;\r\n        }\r\n        token = theToken;\r\n        if (this._allKeys.has(token)) {\r\n            return this._allKeys.get(token);\r\n        }\r\n        var newKey = new Key(token, Key.numberOfKeys);\r\n        this._allKeys.set(token, newKey);\r\n        return newKey;\r\n    };\r\n    Object.defineProperty(KeyRegistry.prototype, \"numberOfKeys\", {\r\n        get: function () { return this._allKeys.size; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return KeyRegistry;\r\n})();\r\nexports.KeyRegistry = KeyRegistry;\r\nvar _globalKeyRegistry = new KeyRegistry();\r\n},{\"./forward_ref\":120,\"./type_literal\":126,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],123:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require(\"angular2/src/facade/lang\");\r\n/**\r\n * A parameter metadata that specifies a dependency.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/6uHYJK?p=preview))\r\n *\r\n * ```typescript\r\n * class Engine {}\r\n *\r\n * @Injectable()\r\n * class Car {\r\n *   engine;\r\n *   constructor(@Inject(\"MyEngine\") engine:Engine) {\r\n *     this.engine = engine;\r\n *   }\r\n * }\r\n *\r\n * var injector = Injector.resolveAndCreate([\r\n *  provide(\"MyEngine\", {useClass: Engine}),\r\n *  Car\r\n * ]);\r\n *\r\n * expect(injector.get(Car).engine instanceof Engine).toBe(true);\r\n * ```\r\n *\r\n * When `@Inject()` is not present, {@link Injector} will use the type annotation of the parameter.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * class Engine {}\r\n *\r\n * @Injectable()\r\n * class Car {\r\n *   constructor(public engine: Engine) {} //same as constructor(@Inject(Engine) engine:Engine)\r\n * }\r\n *\r\n * var injector = Injector.resolveAndCreate([Engine, Car]);\r\n * expect(injector.get(Car).engine instanceof Engine).toBe(true);\r\n * ```\r\n */\r\nvar InjectMetadata = (function () {\r\n    function InjectMetadata(token) {\r\n        this.token = token;\r\n    }\r\n    InjectMetadata.prototype.toString = function () { return \"@Inject(\" + lang_1.stringify(this.token) + \")\"; };\r\n    InjectMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object])\r\n    ], InjectMetadata);\r\n    return InjectMetadata;\r\n})();\r\nexports.InjectMetadata = InjectMetadata;\r\n/**\r\n * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if\r\n * the dependency is not found.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/AsryOm?p=preview))\r\n *\r\n * ```typescript\r\n * class Engine {}\r\n *\r\n * @Injectable()\r\n * class Car {\r\n *   engine;\r\n *   constructor(@Optional() engine:Engine) {\r\n *     this.engine = engine;\r\n *   }\r\n * }\r\n *\r\n * var injector = Injector.resolveAndCreate([Car]);\r\n * expect(injector.get(Car).engine).toBeNull();\r\n * ```\r\n */\r\nvar OptionalMetadata = (function () {\r\n    function OptionalMetadata() {\r\n    }\r\n    OptionalMetadata.prototype.toString = function () { return \"@Optional()\"; };\r\n    OptionalMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [])\r\n    ], OptionalMetadata);\r\n    return OptionalMetadata;\r\n})();\r\nexports.OptionalMetadata = OptionalMetadata;\r\n/**\r\n * `DependencyMetadata` is used by the framework to extend DI.\r\n * This is internal to Angular and should not be used directly.\r\n */\r\nvar DependencyMetadata = (function () {\r\n    function DependencyMetadata() {\r\n    }\r\n    Object.defineProperty(DependencyMetadata.prototype, \"token\", {\r\n        get: function () { return null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DependencyMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [])\r\n    ], DependencyMetadata);\r\n    return DependencyMetadata;\r\n})();\r\nexports.DependencyMetadata = DependencyMetadata;\r\n/**\r\n * A marker metadata that marks a class as available to {@link Injector} for creation.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/Wk4DMQ?p=preview))\r\n *\r\n * ```typescript\r\n * @Injectable()\r\n * class UsefulService {}\r\n *\r\n * @Injectable()\r\n * class NeedsService {\r\n *   constructor(public service:UsefulService) {}\r\n * }\r\n *\r\n * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);\r\n * expect(injector.get(NeedsService).service instanceof UsefulService).toBe(true);\r\n * ```\r\n * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that\r\n * does not have `@Injectable` marker, as shown in the example below.\r\n *\r\n * ```typescript\r\n * class UsefulService {}\r\n *\r\n * class NeedsService {\r\n *   constructor(public service:UsefulService) {}\r\n * }\r\n *\r\n * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);\r\n * expect(() => injector.get(NeedsService)).toThrowError();\r\n * ```\r\n */\r\nvar InjectableMetadata = (function () {\r\n    function InjectableMetadata() {\r\n    }\r\n    InjectableMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [])\r\n    ], InjectableMetadata);\r\n    return InjectableMetadata;\r\n})();\r\nexports.InjectableMetadata = InjectableMetadata;\r\n/**\r\n * Specifies that an {@link Injector} should retrieve a dependency only from itself.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/NeagAg?p=preview))\r\n *\r\n * ```typescript\r\n * class Dependency {\r\n * }\r\n *\r\n * @Injectable()\r\n * class NeedsDependency {\r\n *   dependency;\r\n *   constructor(@Self() dependency:Dependency) {\r\n *     this.dependency = dependency;\r\n *   }\r\n * }\r\n *\r\n * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);\r\n * var nd = inj.get(NeedsDependency);\r\n *\r\n * expect(nd.dependency instanceof Dependency).toBe(true);\r\n *\r\n * var inj = Injector.resolveAndCreate([Dependency]);\r\n * var child = inj.resolveAndCreateChild([NeedsDependency]);\r\n * expect(() => child.get(NeedsDependency)).toThrowError();\r\n * ```\r\n */\r\nvar SelfMetadata = (function () {\r\n    function SelfMetadata() {\r\n    }\r\n    SelfMetadata.prototype.toString = function () { return \"@Self()\"; };\r\n    SelfMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [])\r\n    ], SelfMetadata);\r\n    return SelfMetadata;\r\n})();\r\nexports.SelfMetadata = SelfMetadata;\r\n/**\r\n * Specifies that the dependency resolution should start from the parent injector.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/Wchdzb?p=preview))\r\n *\r\n * ```typescript\r\n * class Dependency {\r\n * }\r\n *\r\n * @Injectable()\r\n * class NeedsDependency {\r\n *   dependency;\r\n *   constructor(@SkipSelf() dependency:Dependency) {\r\n *     this.dependency = dependency;\r\n *   }\r\n * }\r\n *\r\n * var parent = Injector.resolveAndCreate([Dependency]);\r\n * var child = parent.resolveAndCreateChild([NeedsDependency]);\r\n * expect(child.get(NeedsDependency).dependency instanceof Depedency).toBe(true);\r\n *\r\n * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);\r\n * expect(() => inj.get(NeedsDependency)).toThrowError();\r\n * ```\r\n */\r\nvar SkipSelfMetadata = (function () {\r\n    function SkipSelfMetadata() {\r\n    }\r\n    SkipSelfMetadata.prototype.toString = function () { return \"@SkipSelf()\"; };\r\n    SkipSelfMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [])\r\n    ], SkipSelfMetadata);\r\n    return SkipSelfMetadata;\r\n})();\r\nexports.SkipSelfMetadata = SkipSelfMetadata;\r\n/**\r\n * Specifies that an injector should retrieve a dependency from any injector until reaching the\r\n * closest host.\r\n *\r\n * In Angular, a component element is automatically declared as a host for all the injectors in\r\n * its view.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/GX79pV?p=preview))\r\n *\r\n * In the following example `App` contains `ParentCmp`, which contains `ChildDirective`.\r\n * So `ParentCmp` is the host of `ChildDirective`.\r\n *\r\n * `ChildDirective` depends on two services: `HostService` and `OtherService`.\r\n * `HostService` is defined at `ParentCmp`, and `OtherService` is defined at `App`.\r\n *\r\n *```typescript\r\n * class OtherService {}\r\n * class HostService {}\r\n *\r\n * @Directive({\r\n *   selector: 'child-directive'\r\n * })\r\n * class ChildDirective {\r\n *   constructor(@Optional() @Host() os:OtherService, @Optional() @Host() hs:HostService){\r\n *     console.log(\"os is null\", os);\r\n *     console.log(\"hs is NOT null\", hs);\r\n *   }\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'parent-cmp',\r\n *   providers: [HostService],\r\n *   template: `\r\n *     Dir: <child-directive></child-directive>\r\n *   `,\r\n *   directives: [ChildDirective]\r\n * })\r\n * class ParentCmp {\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   providers: [OtherService],\r\n *   template: `\r\n *     Parent: <parent-cmp></parent-cmp>\r\n *   `,\r\n *   directives: [ParentCmp]\r\n * })\r\n * class App {\r\n * }\r\n *\r\n * bootstrap(App);\r\n *```\r\n */\r\nvar HostMetadata = (function () {\r\n    function HostMetadata() {\r\n    }\r\n    HostMetadata.prototype.toString = function () { return \"@Host()\"; };\r\n    HostMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [])\r\n    ], HostMetadata);\r\n    return HostMetadata;\r\n})();\r\nexports.HostMetadata = HostMetadata;\r\n},{\"angular2/src/facade/lang\":176}],124:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * Creates a token that can be used in a DI Provider.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))\r\n *\r\n * ```typescript\r\n * var t = new OpaqueToken(\"value\");\r\n *\r\n * var injector = Injector.resolveAndCreate([\r\n *   provide(t, {useValue: \"providedValue\"})\r\n * ]);\r\n *\r\n * expect(injector.get(t)).toEqual(\"bindingValue\");\r\n * ```\r\n *\r\n * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions\r\n * caused by multiple providers using the same string as two different tokens.\r\n *\r\n * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better\r\n * error messages.\r\n */\r\nvar OpaqueToken = (function () {\r\n    function OpaqueToken(_desc) {\r\n        this._desc = _desc;\r\n    }\r\n    OpaqueToken.prototype.toString = function () { return \"Token \" + this._desc; };\r\n    OpaqueToken = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [String])\r\n    ], OpaqueToken);\r\n    return OpaqueToken;\r\n})();\r\nexports.OpaqueToken = OpaqueToken;\r\n},{\"angular2/src/facade/lang\":176}],125:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar reflection_1 = require('angular2/src/core/reflection/reflection');\r\nvar key_1 = require('./key');\r\nvar metadata_1 = require('./metadata');\r\nvar exceptions_2 = require('./exceptions');\r\nvar forward_ref_1 = require('./forward_ref');\r\n/**\r\n * `Dependency` is used by the framework to extend DI.\r\n * This is internal to Angular and should not be used directly.\r\n */\r\nvar Dependency = (function () {\r\n    function Dependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {\r\n        this.key = key;\r\n        this.optional = optional;\r\n        this.lowerBoundVisibility = lowerBoundVisibility;\r\n        this.upperBoundVisibility = upperBoundVisibility;\r\n        this.properties = properties;\r\n    }\r\n    Dependency.fromKey = function (key) { return new Dependency(key, false, null, null, []); };\r\n    return Dependency;\r\n})();\r\nexports.Dependency = Dependency;\r\nvar _EMPTY_LIST = lang_1.CONST_EXPR([]);\r\n/**\r\n * Describes how the {@link Injector} should instantiate a given token.\r\n *\r\n * See {@link provide}.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/GNAyj6K6PfYg2NBzgwZ5?p%3Dpreview&p=preview))\r\n *\r\n * ```javascript\r\n * var injector = Injector.resolveAndCreate([\r\n *   new Provider(\"message\", { useValue: 'Hello' })\r\n * ]);\r\n *\r\n * expect(injector.get(\"message\")).toEqual('Hello');\r\n * ```\r\n */\r\nvar Provider = (function () {\r\n    function Provider(token, _a) {\r\n        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;\r\n        this.token = token;\r\n        this.useClass = useClass;\r\n        this.useValue = useValue;\r\n        this.useExisting = useExisting;\r\n        this.useFactory = useFactory;\r\n        this.dependencies = deps;\r\n        this._multi = multi;\r\n    }\r\n    Object.defineProperty(Provider.prototype, \"multi\", {\r\n        // TODO: Provide a full working example after alpha38 is released.\r\n        /**\r\n         * Creates multiple providers matching the same token (a multi-provider).\r\n         *\r\n         * Multi-providers are used for creating pluggable service, where the system comes\r\n         * with some default providers, and the user can register additional providers.\r\n         * The combination of the default providers and the additional providers will be\r\n         * used to drive the behavior of the system.\r\n         *\r\n         * ### Example\r\n         *\r\n         * ```typescript\r\n         * var injector = Injector.resolveAndCreate([\r\n         *   new Provider(\"Strings\", { useValue: \"String1\", multi: true}),\r\n         *   new Provider(\"Strings\", { useValue: \"String2\", multi: true})\r\n         * ]);\r\n         *\r\n         * expect(injector.get(\"Strings\")).toEqual([\"String1\", \"String2\"]);\r\n         * ```\r\n         *\r\n         * Multi-providers and regular providers cannot be mixed. The following\r\n         * will throw an exception:\r\n         *\r\n         * ```typescript\r\n         * var injector = Injector.resolveAndCreate([\r\n         *   new Provider(\"Strings\", { useValue: \"String1\", multi: true }),\r\n         *   new Provider(\"Strings\", { useValue: \"String2\"})\r\n         * ]);\r\n         * ```\r\n         */\r\n        get: function () { return lang_1.normalizeBool(this._multi); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Provider = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object, Object])\r\n    ], Provider);\r\n    return Provider;\r\n})();\r\nexports.Provider = Provider;\r\n/**\r\n * See {@link Provider} instead.\r\n *\r\n * @deprecated\r\n */\r\nvar Binding = (function (_super) {\r\n    __extends(Binding, _super);\r\n    function Binding(token, _a) {\r\n        var toClass = _a.toClass, toValue = _a.toValue, toAlias = _a.toAlias, toFactory = _a.toFactory, deps = _a.deps, multi = _a.multi;\r\n        _super.call(this, token, {\r\n            useClass: toClass,\r\n            useValue: toValue,\r\n            useExisting: toAlias,\r\n            useFactory: toFactory,\r\n            deps: deps,\r\n            multi: multi\r\n        });\r\n    }\r\n    Object.defineProperty(Binding.prototype, \"toClass\", {\r\n        /**\r\n         * @deprecated\r\n         */\r\n        get: function () { return this.useClass; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Binding.prototype, \"toAlias\", {\r\n        /**\r\n         * @deprecated\r\n         */\r\n        get: function () { return this.useExisting; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Binding.prototype, \"toFactory\", {\r\n        /**\r\n         * @deprecated\r\n         */\r\n        get: function () { return this.useFactory; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Binding.prototype, \"toValue\", {\r\n        /**\r\n         * @deprecated\r\n         */\r\n        get: function () { return this.useValue; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Binding = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object, Object])\r\n    ], Binding);\r\n    return Binding;\r\n})(Provider);\r\nexports.Binding = Binding;\r\nvar ResolvedProvider_ = (function () {\r\n    function ResolvedProvider_(key, resolvedFactories, multiProvider) {\r\n        this.key = key;\r\n        this.resolvedFactories = resolvedFactories;\r\n        this.multiProvider = multiProvider;\r\n    }\r\n    Object.defineProperty(ResolvedProvider_.prototype, \"resolvedFactory\", {\r\n        get: function () { return this.resolvedFactories[0]; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return ResolvedProvider_;\r\n})();\r\nexports.ResolvedProvider_ = ResolvedProvider_;\r\n/**\r\n * An internal resolved representation of a factory function created by resolving {@link Provider}.\r\n */\r\nvar ResolvedFactory = (function () {\r\n    function ResolvedFactory(\r\n        /**\r\n         * Factory function which can return an instance of an object represented by a key.\r\n         */\r\n        factory, \r\n        /**\r\n         * Arguments (dependencies) to the `factory` function.\r\n         */\r\n        dependencies) {\r\n        this.factory = factory;\r\n        this.dependencies = dependencies;\r\n    }\r\n    return ResolvedFactory;\r\n})();\r\nexports.ResolvedFactory = ResolvedFactory;\r\n/**\r\n * Creates a {@link Provider}.\r\n *\r\n * To construct a {@link Provider}, bind a `token` to either a class, a value, a factory function,\r\n * or\r\n * to an existing `token`.\r\n * See {@link ProviderBuilder} for more details.\r\n *\r\n * The `token` is most commonly a class or {@link angular2/di/OpaqueToken}.\r\n *\r\n * @deprecated\r\n */\r\nfunction bind(token) {\r\n    return new ProviderBuilder(token);\r\n}\r\nexports.bind = bind;\r\n/**\r\n * Creates a {@link Provider}.\r\n *\r\n * See {@link Provider} for more details.\r\n *\r\n * <!-- TODO: improve the docs -->\r\n */\r\nfunction provide(token, _a) {\r\n    var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;\r\n    return new Provider(token, {\r\n        useClass: useClass,\r\n        useValue: useValue,\r\n        useExisting: useExisting,\r\n        useFactory: useFactory,\r\n        deps: deps,\r\n        multi: multi\r\n    });\r\n}\r\nexports.provide = provide;\r\n/**\r\n * Helper class for the {@link bind} function.\r\n */\r\nvar ProviderBuilder = (function () {\r\n    function ProviderBuilder(token) {\r\n        this.token = token;\r\n    }\r\n    /**\r\n     * Binds a DI token to a class.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/ZpBCSYqv6e2ud5KXLdxQ?p=preview))\r\n     *\r\n     * Because `toAlias` and `toClass` are often confused, the example contains\r\n     * both use cases for easy comparison.\r\n     *\r\n     * ```typescript\r\n     * class Vehicle {}\r\n     *\r\n     * class Car extends Vehicle {}\r\n     *\r\n     * var injectorClass = Injector.resolveAndCreate([\r\n     *   Car,\r\n     *   provide(Vehicle, {useClass: Car})\r\n     * ]);\r\n     * var injectorAlias = Injector.resolveAndCreate([\r\n     *   Car,\r\n     *   provide(Vehicle, {useExisting: Car})\r\n     * ]);\r\n     *\r\n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\r\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\r\n     *\r\n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\r\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\r\n     * ```\r\n     */\r\n    ProviderBuilder.prototype.toClass = function (type) {\r\n        if (!lang_1.isType(type)) {\r\n            throw new exceptions_1.BaseException(\"Trying to create a class provider but \\\"\" + lang_1.stringify(type) + \"\\\" is not a class!\");\r\n        }\r\n        return new Provider(this.token, { useClass: type });\r\n    };\r\n    /**\r\n     * Binds a DI token to a value.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/G024PFHmDL0cJFgfZK8O?p=preview))\r\n     *\r\n     * ```typescript\r\n     * var injector = Injector.resolveAndCreate([\r\n     *   provide('message', {useValue: 'Hello'})\r\n     * ]);\r\n     *\r\n     * expect(injector.get('message')).toEqual('Hello');\r\n     * ```\r\n     */\r\n    ProviderBuilder.prototype.toValue = function (value) { return new Provider(this.token, { useValue: value }); };\r\n    /**\r\n     * Binds a DI token to an existing token.\r\n     *\r\n     * Angular will return the same instance as if the provided token was used. (This is\r\n     * in contrast to `useClass` where a separate instance of `useClass` will be returned.)\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/uBaoF2pN5cfc5AfZapNw?p=preview))\r\n     *\r\n     * Because `toAlias` and `toClass` are often confused, the example contains\r\n     * both use cases for easy comparison.\r\n     *\r\n     * ```typescript\r\n     * class Vehicle {}\r\n     *\r\n     * class Car extends Vehicle {}\r\n     *\r\n     * var injectorAlias = Injector.resolveAndCreate([\r\n     *   Car,\r\n     *   provide(Vehicle, {useExisting: Car})\r\n     * ]);\r\n     * var injectorClass = Injector.resolveAndCreate([\r\n     *   Car,\r\n     *   provide(Vehicle, {useClass: Car})\r\n     * ]);\r\n     *\r\n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\r\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\r\n     *\r\n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\r\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\r\n     * ```\r\n     */\r\n    ProviderBuilder.prototype.toAlias = function (aliasToken) {\r\n        if (lang_1.isBlank(aliasToken)) {\r\n            throw new exceptions_1.BaseException(\"Can not alias \" + lang_1.stringify(this.token) + \" to a blank value!\");\r\n        }\r\n        return new Provider(this.token, { useExisting: aliasToken });\r\n    };\r\n    /**\r\n     * Binds a DI token to a function which computes the value.\r\n     *\r\n     * ### Example ([live demo](http://plnkr.co/edit/OejNIfTT3zb1iBxaIYOb?p=preview))\r\n     *\r\n     * ```typescript\r\n     * var injector = Injector.resolveAndCreate([\r\n     *   provide(Number, {useFactory: () => { return 1+2; }}),\r\n     *   provide(String, {useFactory: (v) => { return \"Value: \" + v; }, deps: [Number]})\r\n     * ]);\r\n     *\r\n     * expect(injector.get(Number)).toEqual(3);\r\n     * expect(injector.get(String)).toEqual('Value: 3');\r\n     * ```\r\n     */\r\n    ProviderBuilder.prototype.toFactory = function (factory, dependencies) {\r\n        if (!lang_1.isFunction(factory)) {\r\n            throw new exceptions_1.BaseException(\"Trying to create a factory provider but \\\"\" + lang_1.stringify(factory) + \"\\\" is not a function!\");\r\n        }\r\n        return new Provider(this.token, { useFactory: factory, deps: dependencies });\r\n    };\r\n    return ProviderBuilder;\r\n})();\r\nexports.ProviderBuilder = ProviderBuilder;\r\n/**\r\n * Resolve a single provider.\r\n */\r\nfunction resolveFactory(provider) {\r\n    var factoryFn;\r\n    var resolvedDeps;\r\n    if (lang_1.isPresent(provider.useClass)) {\r\n        var useClass = forward_ref_1.resolveForwardRef(provider.useClass);\r\n        factoryFn = reflection_1.reflector.factory(useClass);\r\n        resolvedDeps = _dependenciesFor(useClass);\r\n    }\r\n    else if (lang_1.isPresent(provider.useExisting)) {\r\n        factoryFn = function (aliasInstance) { return aliasInstance; };\r\n        resolvedDeps = [Dependency.fromKey(key_1.Key.get(provider.useExisting))];\r\n    }\r\n    else if (lang_1.isPresent(provider.useFactory)) {\r\n        factoryFn = provider.useFactory;\r\n        resolvedDeps = _constructDependencies(provider.useFactory, provider.dependencies);\r\n    }\r\n    else {\r\n        factoryFn = function () { return provider.useValue; };\r\n        resolvedDeps = _EMPTY_LIST;\r\n    }\r\n    return new ResolvedFactory(factoryFn, resolvedDeps);\r\n}\r\nexports.resolveFactory = resolveFactory;\r\n/**\r\n * Converts the {@link Provider} into {@link ResolvedProvider}.\r\n *\r\n * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains\r\n * convenience provider syntax.\r\n */\r\nfunction resolveProvider(provider) {\r\n    return new ResolvedProvider_(key_1.Key.get(provider.token), [resolveFactory(provider)], provider.multi);\r\n}\r\nexports.resolveProvider = resolveProvider;\r\n/**\r\n * Resolve a list of Providers.\r\n */\r\nfunction resolveProviders(providers) {\r\n    var normalized = _normalizeProviders(providers, []);\r\n    var resolved = normalized.map(resolveProvider);\r\n    return collection_1.MapWrapper.values(mergeResolvedProviders(resolved, new Map()));\r\n}\r\nexports.resolveProviders = resolveProviders;\r\n/**\r\n * Merges a list of ResolvedProviders into a list where\r\n * each key is contained exactly once and multi providers\r\n * have been merged.\r\n */\r\nfunction mergeResolvedProviders(providers, normalizedProvidersMap) {\r\n    for (var i = 0; i < providers.length; i++) {\r\n        var provider = providers[i];\r\n        var existing = normalizedProvidersMap.get(provider.key.id);\r\n        if (lang_1.isPresent(existing)) {\r\n            if (provider.multiProvider !== existing.multiProvider) {\r\n                throw new exceptions_2.MixingMultiProvidersWithRegularProvidersError(existing, provider);\r\n            }\r\n            if (provider.multiProvider) {\r\n                for (var j = 0; j < provider.resolvedFactories.length; j++) {\r\n                    existing.resolvedFactories.push(provider.resolvedFactories[j]);\r\n                }\r\n            }\r\n            else {\r\n                normalizedProvidersMap.set(provider.key.id, provider);\r\n            }\r\n        }\r\n        else {\r\n            var resolvedProvider;\r\n            if (provider.multiProvider) {\r\n                resolvedProvider = new ResolvedProvider_(provider.key, collection_1.ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);\r\n            }\r\n            else {\r\n                resolvedProvider = provider;\r\n            }\r\n            normalizedProvidersMap.set(provider.key.id, resolvedProvider);\r\n        }\r\n    }\r\n    return normalizedProvidersMap;\r\n}\r\nexports.mergeResolvedProviders = mergeResolvedProviders;\r\nfunction _normalizeProviders(providers, res) {\r\n    providers.forEach(function (b) {\r\n        if (b instanceof lang_1.Type) {\r\n            res.push(provide(b, { useClass: b }));\r\n        }\r\n        else if (b instanceof Provider) {\r\n            res.push(b);\r\n        }\r\n        else if (b instanceof Array) {\r\n            _normalizeProviders(b, res);\r\n        }\r\n        else if (b instanceof ProviderBuilder) {\r\n            throw new exceptions_2.InvalidProviderError(b.token);\r\n        }\r\n        else {\r\n            throw new exceptions_2.InvalidProviderError(b);\r\n        }\r\n    });\r\n    return res;\r\n}\r\nfunction _constructDependencies(factoryFunction, dependencies) {\r\n    if (lang_1.isBlank(dependencies)) {\r\n        return _dependenciesFor(factoryFunction);\r\n    }\r\n    else {\r\n        var params = dependencies.map(function (t) { return [t]; });\r\n        return dependencies.map(function (t) { return _extractToken(factoryFunction, t, params); });\r\n    }\r\n}\r\nfunction _dependenciesFor(typeOrFunc) {\r\n    var params = reflection_1.reflector.parameters(typeOrFunc);\r\n    if (lang_1.isBlank(params))\r\n        return [];\r\n    if (params.some(lang_1.isBlank)) {\r\n        throw new exceptions_2.NoAnnotationError(typeOrFunc, params);\r\n    }\r\n    return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });\r\n}\r\nfunction _extractToken(typeOrFunc, metadata /*any[] | any*/, params) {\r\n    var depProps = [];\r\n    var token = null;\r\n    var optional = false;\r\n    if (!lang_1.isArray(metadata)) {\r\n        if (metadata instanceof metadata_1.InjectMetadata) {\r\n            return _createDependency(metadata.token, optional, null, null, depProps);\r\n        }\r\n        else {\r\n            return _createDependency(metadata, optional, null, null, depProps);\r\n        }\r\n    }\r\n    var lowerBoundVisibility = null;\r\n    var upperBoundVisibility = null;\r\n    for (var i = 0; i < metadata.length; ++i) {\r\n        var paramMetadata = metadata[i];\r\n        if (paramMetadata instanceof lang_1.Type) {\r\n            token = paramMetadata;\r\n        }\r\n        else if (paramMetadata instanceof metadata_1.InjectMetadata) {\r\n            token = paramMetadata.token;\r\n        }\r\n        else if (paramMetadata instanceof metadata_1.OptionalMetadata) {\r\n            optional = true;\r\n        }\r\n        else if (paramMetadata instanceof metadata_1.SelfMetadata) {\r\n            upperBoundVisibility = paramMetadata;\r\n        }\r\n        else if (paramMetadata instanceof metadata_1.HostMetadata) {\r\n            upperBoundVisibility = paramMetadata;\r\n        }\r\n        else if (paramMetadata instanceof metadata_1.SkipSelfMetadata) {\r\n            lowerBoundVisibility = paramMetadata;\r\n        }\r\n        else if (paramMetadata instanceof metadata_1.DependencyMetadata) {\r\n            if (lang_1.isPresent(paramMetadata.token)) {\r\n                token = paramMetadata.token;\r\n            }\r\n            depProps.push(paramMetadata);\r\n        }\r\n    }\r\n    token = forward_ref_1.resolveForwardRef(token);\r\n    if (lang_1.isPresent(token)) {\r\n        return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);\r\n    }\r\n    else {\r\n        throw new exceptions_2.NoAnnotationError(typeOrFunc, params);\r\n    }\r\n}\r\nfunction _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {\r\n    return new Dependency(key_1.Key.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);\r\n}\r\n},{\"./exceptions\":119,\"./forward_ref\":120,\"./key\":122,\"./metadata\":123,\"angular2/src/core/reflection/reflection\":158,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],126:[function(require,module,exports){\n'use strict';/**\r\n * Type literals is a Dart-only feature. This is here only so we can x-compile\r\n * to multiple languages.\r\n */\r\nvar TypeLiteral = (function () {\r\n    function TypeLiteral() {\r\n    }\r\n    Object.defineProperty(TypeLiteral.prototype, \"type\", {\r\n        get: function () { throw new Error(\"Type literals are only supported in Dart\"); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return TypeLiteral;\r\n})();\r\nexports.TypeLiteral = TypeLiteral;\r\n},{}],127:[function(require,module,exports){\n'use strict';// Public API for compiler\r\nvar directive_resolver_1 = require('./linker/directive_resolver');\r\nexports.DirectiveResolver = directive_resolver_1.DirectiveResolver;\r\nvar view_resolver_1 = require('./linker/view_resolver');\r\nexports.ViewResolver = view_resolver_1.ViewResolver;\r\nvar compiler_1 = require('./linker/compiler');\r\nexports.Compiler = compiler_1.Compiler;\r\nvar view_manager_1 = require('./linker/view_manager');\r\nexports.AppViewManager = view_manager_1.AppViewManager;\r\nvar query_list_1 = require('./linker/query_list');\r\nexports.QueryList = query_list_1.QueryList;\r\nvar dynamic_component_loader_1 = require('./linker/dynamic_component_loader');\r\nexports.DynamicComponentLoader = dynamic_component_loader_1.DynamicComponentLoader;\r\nvar element_ref_1 = require('./linker/element_ref');\r\nexports.ElementRef = element_ref_1.ElementRef;\r\nvar template_ref_1 = require('./linker/template_ref');\r\nexports.TemplateRef = template_ref_1.TemplateRef;\r\nvar view_ref_1 = require('./linker/view_ref');\r\nexports.EmbeddedViewRef = view_ref_1.EmbeddedViewRef;\r\nexports.HostViewRef = view_ref_1.HostViewRef;\r\nexports.ViewRef = view_ref_1.ViewRef;\r\nexports.HostViewFactoryRef = view_ref_1.HostViewFactoryRef;\r\nvar view_container_ref_1 = require('./linker/view_container_ref');\r\nexports.ViewContainerRef = view_container_ref_1.ViewContainerRef;\r\nvar dynamic_component_loader_2 = require('./linker/dynamic_component_loader');\r\nexports.ComponentRef = dynamic_component_loader_2.ComponentRef;\r\n},{\"./linker/compiler\":128,\"./linker/directive_resolver\":130,\"./linker/dynamic_component_loader\":131,\"./linker/element_ref\":133,\"./linker/query_list\":136,\"./linker/template_ref\":138,\"./linker/view_container_ref\":140,\"./linker/view_manager\":142,\"./linker/view_ref\":143,\"./linker/view_resolver\":144}],128:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar reflection_1 = require('angular2/src/core/reflection/reflection');\r\nvar view_1 = require('angular2/src/core/linker/view');\r\nvar view_ref_1 = require('angular2/src/core/linker/view_ref');\r\n/**\r\n * Low-level service for compiling {@link Component}s into {@link ProtoViewRef ProtoViews}s, which\r\n * can later be used to create and render a Component instance.\r\n *\r\n * Most applications should instead use higher-level {@link DynamicComponentLoader} service, which\r\n * both compiles and instantiates a Component.\r\n */\r\nvar Compiler = (function () {\r\n    function Compiler() {\r\n    }\r\n    return Compiler;\r\n})();\r\nexports.Compiler = Compiler;\r\nfunction isHostViewFactory(type) {\r\n    return type instanceof view_1.HostViewFactory;\r\n}\r\nvar Compiler_ = (function (_super) {\r\n    __extends(Compiler_, _super);\r\n    function Compiler_() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    Compiler_.prototype.compileInHost = function (componentType) {\r\n        var metadatas = reflection_1.reflector.annotations(componentType);\r\n        var hostViewFactory = metadatas.find(isHostViewFactory);\r\n        if (lang_1.isBlank(hostViewFactory)) {\r\n            throw new exceptions_1.BaseException(\"No precompiled component \" + lang_1.stringify(componentType) + \" found\");\r\n        }\r\n        return async_1.PromiseWrapper.resolve(new view_ref_1.HostViewFactoryRef_(hostViewFactory));\r\n    };\r\n    Compiler_.prototype.clearCache = function () { };\r\n    Compiler_ = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], Compiler_);\r\n    return Compiler_;\r\n})(Compiler);\r\nexports.Compiler_ = Compiler_;\r\n},{\"angular2/src/core/di\":117,\"angular2/src/core/linker/view\":139,\"angular2/src/core/linker/view_ref\":143,\"angular2/src/core/reflection/reflection\":158,\"angular2/src/facade/async\":169,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],129:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar interfaces_1 = require('./interfaces');\r\nfunction hasLifecycleHook(lcInterface, token) {\r\n    if (!(token instanceof lang_1.Type))\r\n        return false;\r\n    var proto = token.prototype;\r\n    switch (lcInterface) {\r\n        case interfaces_1.LifecycleHooks.AfterContentInit:\r\n            return !!proto.ngAfterContentInit;\r\n        case interfaces_1.LifecycleHooks.AfterContentChecked:\r\n            return !!proto.ngAfterContentChecked;\r\n        case interfaces_1.LifecycleHooks.AfterViewInit:\r\n            return !!proto.ngAfterViewInit;\r\n        case interfaces_1.LifecycleHooks.AfterViewChecked:\r\n            return !!proto.ngAfterViewChecked;\r\n        case interfaces_1.LifecycleHooks.OnChanges:\r\n            return !!proto.ngOnChanges;\r\n        case interfaces_1.LifecycleHooks.DoCheck:\r\n            return !!proto.ngDoCheck;\r\n        case interfaces_1.LifecycleHooks.OnDestroy:\r\n            return !!proto.ngOnDestroy;\r\n        case interfaces_1.LifecycleHooks.OnInit:\r\n            return !!proto.ngOnInit;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nexports.hasLifecycleHook = hasLifecycleHook;\r\n},{\"./interfaces\":134,\"angular2/src/facade/lang\":176}],130:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar metadata_1 = require('angular2/src/core/metadata');\r\nvar reflection_1 = require('angular2/src/core/reflection/reflection');\r\nfunction _isDirectiveMetadata(type) {\r\n    return type instanceof metadata_1.DirectiveMetadata;\r\n}\r\n/*\r\n * Resolve a `Type` for {@link DirectiveMetadata}.\r\n *\r\n * This interface can be overridden by the application developer to create custom behavior.\r\n *\r\n * See {@link Compiler}\r\n */\r\nvar DirectiveResolver = (function () {\r\n    function DirectiveResolver() {\r\n    }\r\n    /**\r\n     * Return {@link DirectiveMetadata} for a given `Type`.\r\n     */\r\n    DirectiveResolver.prototype.resolve = function (type) {\r\n        var typeMetadata = reflection_1.reflector.annotations(di_1.resolveForwardRef(type));\r\n        if (lang_1.isPresent(typeMetadata)) {\r\n            var metadata = typeMetadata.find(_isDirectiveMetadata);\r\n            if (lang_1.isPresent(metadata)) {\r\n                var propertyMetadata = reflection_1.reflector.propMetadata(type);\r\n                return this._mergeWithPropertyMetadata(metadata, propertyMetadata);\r\n            }\r\n        }\r\n        throw new exceptions_1.BaseException(\"No Directive annotation found on \" + lang_1.stringify(type));\r\n    };\r\n    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata) {\r\n        var inputs = [];\r\n        var outputs = [];\r\n        var host = {};\r\n        var queries = {};\r\n        collection_1.StringMapWrapper.forEach(propertyMetadata, function (metadata, propName) {\r\n            metadata.forEach(function (a) {\r\n                if (a instanceof metadata_1.InputMetadata) {\r\n                    if (lang_1.isPresent(a.bindingPropertyName)) {\r\n                        inputs.push(propName + \": \" + a.bindingPropertyName);\r\n                    }\r\n                    else {\r\n                        inputs.push(propName);\r\n                    }\r\n                }\r\n                if (a instanceof metadata_1.OutputMetadata) {\r\n                    if (lang_1.isPresent(a.bindingPropertyName)) {\r\n                        outputs.push(propName + \": \" + a.bindingPropertyName);\r\n                    }\r\n                    else {\r\n                        outputs.push(propName);\r\n                    }\r\n                }\r\n                if (a instanceof metadata_1.HostBindingMetadata) {\r\n                    if (lang_1.isPresent(a.hostPropertyName)) {\r\n                        host[(\"[\" + a.hostPropertyName + \"]\")] = propName;\r\n                    }\r\n                    else {\r\n                        host[(\"[\" + propName + \"]\")] = propName;\r\n                    }\r\n                }\r\n                if (a instanceof metadata_1.HostListenerMetadata) {\r\n                    var args = lang_1.isPresent(a.args) ? a.args.join(', ') : '';\r\n                    host[(\"(\" + a.eventName + \")\")] = propName + \"(\" + args + \")\";\r\n                }\r\n                if (a instanceof metadata_1.ContentChildrenMetadata) {\r\n                    queries[propName] = a;\r\n                }\r\n                if (a instanceof metadata_1.ViewChildrenMetadata) {\r\n                    queries[propName] = a;\r\n                }\r\n                if (a instanceof metadata_1.ContentChildMetadata) {\r\n                    queries[propName] = a;\r\n                }\r\n                if (a instanceof metadata_1.ViewChildMetadata) {\r\n                    queries[propName] = a;\r\n                }\r\n            });\r\n        });\r\n        return this._merge(dm, inputs, outputs, host, queries);\r\n    };\r\n    DirectiveResolver.prototype._merge = function (dm, inputs, outputs, host, queries) {\r\n        var mergedInputs = lang_1.isPresent(dm.inputs) ? collection_1.ListWrapper.concat(dm.inputs, inputs) : inputs;\r\n        var mergedOutputs = lang_1.isPresent(dm.outputs) ? collection_1.ListWrapper.concat(dm.outputs, outputs) : outputs;\r\n        var mergedHost = lang_1.isPresent(dm.host) ? collection_1.StringMapWrapper.merge(dm.host, host) : host;\r\n        var mergedQueries = lang_1.isPresent(dm.queries) ? collection_1.StringMapWrapper.merge(dm.queries, queries) : queries;\r\n        if (dm instanceof metadata_1.ComponentMetadata) {\r\n            return new metadata_1.ComponentMetadata({\r\n                selector: dm.selector,\r\n                inputs: mergedInputs,\r\n                outputs: mergedOutputs,\r\n                host: mergedHost,\r\n                exportAs: dm.exportAs,\r\n                moduleId: dm.moduleId,\r\n                queries: mergedQueries,\r\n                changeDetection: dm.changeDetection,\r\n                providers: dm.providers,\r\n                viewProviders: dm.viewProviders\r\n            });\r\n        }\r\n        else {\r\n            return new metadata_1.DirectiveMetadata({\r\n                selector: dm.selector,\r\n                inputs: mergedInputs,\r\n                outputs: mergedOutputs,\r\n                host: mergedHost,\r\n                exportAs: dm.exportAs,\r\n                queries: mergedQueries,\r\n                providers: dm.providers\r\n            });\r\n        }\r\n    };\r\n    DirectiveResolver = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], DirectiveResolver);\r\n    return DirectiveResolver;\r\n})();\r\nexports.DirectiveResolver = DirectiveResolver;\r\nexports.CODEGEN_DIRECTIVE_RESOLVER = new DirectiveResolver();\r\n},{\"angular2/src/core/di\":117,\"angular2/src/core/metadata\":146,\"angular2/src/core/reflection/reflection\":158,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],131:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar compiler_1 = require('./compiler');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar view_manager_1 = require('angular2/src/core/linker/view_manager');\r\n/**\r\n * Represents an instance of a Component created via {@link DynamicComponentLoader}.\r\n *\r\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\r\n * Component Instance and allows you to destroy the Component Instance via the {@link #dispose}\r\n * method.\r\n */\r\nvar ComponentRef = (function () {\r\n    function ComponentRef() {\r\n    }\r\n    Object.defineProperty(ComponentRef.prototype, \"hostView\", {\r\n        /**\r\n         * The {@link ViewRef} of the Host View of this Component instance.\r\n         */\r\n        get: function () {\r\n            return this.location.internalElement.parentView.ref;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ComponentRef.prototype, \"hostComponent\", {\r\n        /**\r\n         * @internal\r\n         *\r\n         * The instance of the component.\r\n         *\r\n         * TODO(i): this api should be removed\r\n         */\r\n        get: function () { return this.instance; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return ComponentRef;\r\n})();\r\nexports.ComponentRef = ComponentRef;\r\nvar ComponentRef_ = (function (_super) {\r\n    __extends(ComponentRef_, _super);\r\n    /**\r\n     * TODO(i): refactor into public/private fields\r\n     */\r\n    function ComponentRef_(location, instance, componentType, injector, _dispose) {\r\n        _super.call(this);\r\n        this._dispose = _dispose;\r\n        this.location = location;\r\n        this.instance = instance;\r\n        this.componentType = componentType;\r\n        this.injector = injector;\r\n    }\r\n    Object.defineProperty(ComponentRef_.prototype, \"hostComponentType\", {\r\n        /**\r\n         * @internal\r\n         *\r\n         * Returns the type of this Component instance.\r\n         *\r\n         * TODO(i): this api should be removed\r\n         */\r\n        get: function () { return this.componentType; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ComponentRef_.prototype.dispose = function () { this._dispose(); };\r\n    return ComponentRef_;\r\n})(ComponentRef);\r\nexports.ComponentRef_ = ComponentRef_;\r\n/**\r\n * Service for instantiating a Component and attaching it to a View at a specified location.\r\n */\r\nvar DynamicComponentLoader = (function () {\r\n    function DynamicComponentLoader() {\r\n    }\r\n    return DynamicComponentLoader;\r\n})();\r\nexports.DynamicComponentLoader = DynamicComponentLoader;\r\nvar DynamicComponentLoader_ = (function (_super) {\r\n    __extends(DynamicComponentLoader_, _super);\r\n    function DynamicComponentLoader_(_compiler, _viewManager) {\r\n        _super.call(this);\r\n        this._compiler = _compiler;\r\n        this._viewManager = _viewManager;\r\n    }\r\n    DynamicComponentLoader_.prototype.loadAsRoot = function (type, overrideSelector, injector, onDispose, projectableNodes) {\r\n        var _this = this;\r\n        return this._compiler.compileInHost(type).then(function (hostProtoViewRef) {\r\n            var hostViewRef = _this._viewManager.createRootHostView(hostProtoViewRef, overrideSelector, injector, projectableNodes);\r\n            var newLocation = _this._viewManager.getHostElement(hostViewRef);\r\n            var component = _this._viewManager.getComponent(newLocation);\r\n            var dispose = function () {\r\n                if (lang_1.isPresent(onDispose)) {\r\n                    onDispose();\r\n                }\r\n                _this._viewManager.destroyRootHostView(hostViewRef);\r\n            };\r\n            return new ComponentRef_(newLocation, component, type, injector, dispose);\r\n        });\r\n    };\r\n    DynamicComponentLoader_.prototype.loadIntoLocation = function (type, hostLocation, anchorName, providers, projectableNodes) {\r\n        if (providers === void 0) { providers = null; }\r\n        if (projectableNodes === void 0) { projectableNodes = null; }\r\n        return this.loadNextToLocation(type, this._viewManager.getNamedElementInComponentView(hostLocation, anchorName), providers, projectableNodes);\r\n    };\r\n    DynamicComponentLoader_.prototype.loadNextToLocation = function (type, location, providers, projectableNodes) {\r\n        var _this = this;\r\n        if (providers === void 0) { providers = null; }\r\n        if (projectableNodes === void 0) { projectableNodes = null; }\r\n        return this._compiler.compileInHost(type).then(function (hostProtoViewRef) {\r\n            var viewContainer = _this._viewManager.getViewContainer(location);\r\n            var hostViewRef = viewContainer.createHostView(hostProtoViewRef, viewContainer.length, providers, projectableNodes);\r\n            var newLocation = _this._viewManager.getHostElement(hostViewRef);\r\n            var component = _this._viewManager.getComponent(newLocation);\r\n            var dispose = function () {\r\n                var index = viewContainer.indexOf(hostViewRef);\r\n                if (!hostViewRef.destroyed && index !== -1) {\r\n                    viewContainer.remove(index);\r\n                }\r\n            };\r\n            return new ComponentRef_(newLocation, component, type, null, dispose);\r\n        });\r\n    };\r\n    DynamicComponentLoader_ = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [compiler_1.Compiler, view_manager_1.AppViewManager])\r\n    ], DynamicComponentLoader_);\r\n    return DynamicComponentLoader_;\r\n})(DynamicComponentLoader);\r\nexports.DynamicComponentLoader_ = DynamicComponentLoader_;\r\n},{\"./compiler\":128,\"angular2/src/core/di\":117,\"angular2/src/core/linker/view_manager\":142,\"angular2/src/facade/lang\":176}],132:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar provider_1 = require('angular2/src/core/di/provider');\r\nvar injector_1 = require('angular2/src/core/di/injector');\r\nvar provider_2 = require('angular2/src/core/di/provider');\r\nvar di_2 = require('../metadata/di');\r\nvar view_type_1 = require('./view_type');\r\nvar element_ref_1 = require('./element_ref');\r\nvar view_container_ref_1 = require('./view_container_ref');\r\nvar element_ref_2 = require('./element_ref');\r\nvar api_1 = require('angular2/src/core/render/api');\r\nvar template_ref_1 = require('./template_ref');\r\nvar directives_1 = require('../metadata/directives');\r\nvar change_detection_1 = require('angular2/src/core/change_detection/change_detection');\r\nvar query_list_1 = require('./query_list');\r\nvar reflection_1 = require('angular2/src/core/reflection/reflection');\r\nvar pipe_provider_1 = require('angular2/src/core/pipes/pipe_provider');\r\nvar view_container_ref_2 = require(\"./view_container_ref\");\r\nvar _staticKeys;\r\nvar StaticKeys = (function () {\r\n    function StaticKeys() {\r\n        this.templateRefId = di_1.Key.get(template_ref_1.TemplateRef).id;\r\n        this.viewContainerId = di_1.Key.get(view_container_ref_1.ViewContainerRef).id;\r\n        this.changeDetectorRefId = di_1.Key.get(change_detection_1.ChangeDetectorRef).id;\r\n        this.elementRefId = di_1.Key.get(element_ref_2.ElementRef).id;\r\n        this.rendererId = di_1.Key.get(api_1.Renderer).id;\r\n    }\r\n    StaticKeys.instance = function () {\r\n        if (lang_1.isBlank(_staticKeys))\r\n            _staticKeys = new StaticKeys();\r\n        return _staticKeys;\r\n    };\r\n    return StaticKeys;\r\n})();\r\nexports.StaticKeys = StaticKeys;\r\nvar DirectiveDependency = (function (_super) {\r\n    __extends(DirectiveDependency, _super);\r\n    function DirectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties, attributeName, queryDecorator) {\r\n        _super.call(this, key, optional, lowerBoundVisibility, upperBoundVisibility, properties);\r\n        this.attributeName = attributeName;\r\n        this.queryDecorator = queryDecorator;\r\n        this._verify();\r\n    }\r\n    /** @internal */\r\n    DirectiveDependency.prototype._verify = function () {\r\n        var count = 0;\r\n        if (lang_1.isPresent(this.queryDecorator))\r\n            count++;\r\n        if (lang_1.isPresent(this.attributeName))\r\n            count++;\r\n        if (count > 1)\r\n            throw new exceptions_1.BaseException('A directive injectable can contain only one of the following @Attribute or @Query.');\r\n    };\r\n    DirectiveDependency.createFrom = function (d) {\r\n        return new DirectiveDependency(d.key, d.optional, d.lowerBoundVisibility, d.upperBoundVisibility, d.properties, DirectiveDependency._attributeName(d.properties), DirectiveDependency._query(d.properties));\r\n    };\r\n    /** @internal */\r\n    DirectiveDependency._attributeName = function (properties) {\r\n        var p = properties.find(function (p) { return p instanceof di_2.AttributeMetadata; });\r\n        return lang_1.isPresent(p) ? p.attributeName : null;\r\n    };\r\n    /** @internal */\r\n    DirectiveDependency._query = function (properties) {\r\n        return properties.find(function (p) { return p instanceof di_2.QueryMetadata; });\r\n    };\r\n    return DirectiveDependency;\r\n})(di_1.Dependency);\r\nexports.DirectiveDependency = DirectiveDependency;\r\nvar DirectiveProvider = (function (_super) {\r\n    __extends(DirectiveProvider, _super);\r\n    function DirectiveProvider(key, factory, deps, isComponent, providers, viewProviders, queries) {\r\n        _super.call(this, key, [new provider_2.ResolvedFactory(factory, deps)], false);\r\n        this.isComponent = isComponent;\r\n        this.providers = providers;\r\n        this.viewProviders = viewProviders;\r\n        this.queries = queries;\r\n    }\r\n    Object.defineProperty(DirectiveProvider.prototype, \"displayName\", {\r\n        get: function () { return this.key.displayName; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DirectiveProvider.createFromType = function (type, meta) {\r\n        var provider = new di_1.Provider(type, { useClass: type });\r\n        if (lang_1.isBlank(meta)) {\r\n            meta = new directives_1.DirectiveMetadata();\r\n        }\r\n        var rb = provider_2.resolveProvider(provider);\r\n        var rf = rb.resolvedFactories[0];\r\n        var deps = rf.dependencies.map(DirectiveDependency.createFrom);\r\n        var isComponent = meta instanceof directives_1.ComponentMetadata;\r\n        var resolvedProviders = lang_1.isPresent(meta.providers) ? di_1.Injector.resolve(meta.providers) : null;\r\n        var resolvedViewProviders = meta instanceof directives_1.ComponentMetadata && lang_1.isPresent(meta.viewProviders) ?\r\n            di_1.Injector.resolve(meta.viewProviders) :\r\n            null;\r\n        var queries = [];\r\n        if (lang_1.isPresent(meta.queries)) {\r\n            collection_1.StringMapWrapper.forEach(meta.queries, function (meta, fieldName) {\r\n                var setter = reflection_1.reflector.setter(fieldName);\r\n                queries.push(new QueryMetadataWithSetter(setter, meta));\r\n            });\r\n        }\r\n        // queries passed into the constructor.\r\n        // TODO: remove this after constructor queries are no longer supported\r\n        deps.forEach(function (d) {\r\n            if (lang_1.isPresent(d.queryDecorator)) {\r\n                queries.push(new QueryMetadataWithSetter(null, d.queryDecorator));\r\n            }\r\n        });\r\n        return new DirectiveProvider(rb.key, rf.factory, deps, isComponent, resolvedProviders, resolvedViewProviders, queries);\r\n    };\r\n    return DirectiveProvider;\r\n})(provider_2.ResolvedProvider_);\r\nexports.DirectiveProvider = DirectiveProvider;\r\nvar QueryMetadataWithSetter = (function () {\r\n    function QueryMetadataWithSetter(setter, metadata) {\r\n        this.setter = setter;\r\n        this.metadata = metadata;\r\n    }\r\n    return QueryMetadataWithSetter;\r\n})();\r\nexports.QueryMetadataWithSetter = QueryMetadataWithSetter;\r\nfunction setProvidersVisibility(providers, visibility, result) {\r\n    for (var i = 0; i < providers.length; i++) {\r\n        result.set(providers[i].key.id, visibility);\r\n    }\r\n}\r\nvar AppProtoElement = (function () {\r\n    function AppProtoElement(firstProviderIsComponent, index, attributes, pwvs, protoQueryRefs, directiveVariableBindings) {\r\n        this.firstProviderIsComponent = firstProviderIsComponent;\r\n        this.index = index;\r\n        this.attributes = attributes;\r\n        this.protoQueryRefs = protoQueryRefs;\r\n        this.directiveVariableBindings = directiveVariableBindings;\r\n        var length = pwvs.length;\r\n        if (length > 0) {\r\n            this.protoInjector = new injector_1.ProtoInjector(pwvs);\r\n        }\r\n        else {\r\n            this.protoInjector = null;\r\n            this.protoQueryRefs = [];\r\n        }\r\n    }\r\n    AppProtoElement.create = function (metadataCache, index, attributes, directiveTypes, directiveVariableBindings) {\r\n        var componentDirProvider = null;\r\n        var mergedProvidersMap = new Map();\r\n        var providerVisibilityMap = new Map();\r\n        var providers = collection_1.ListWrapper.createGrowableSize(directiveTypes.length);\r\n        var protoQueryRefs = [];\r\n        for (var i = 0; i < directiveTypes.length; i++) {\r\n            var dirProvider = metadataCache.getResolvedDirectiveMetadata(directiveTypes[i]);\r\n            providers[i] = new injector_1.ProviderWithVisibility(dirProvider, dirProvider.isComponent ? injector_1.Visibility.PublicAndPrivate : injector_1.Visibility.Public);\r\n            if (dirProvider.isComponent) {\r\n                componentDirProvider = dirProvider;\r\n            }\r\n            else {\r\n                if (lang_1.isPresent(dirProvider.providers)) {\r\n                    provider_1.mergeResolvedProviders(dirProvider.providers, mergedProvidersMap);\r\n                    setProvidersVisibility(dirProvider.providers, injector_1.Visibility.Public, providerVisibilityMap);\r\n                }\r\n            }\r\n            if (lang_1.isPresent(dirProvider.viewProviders)) {\r\n                provider_1.mergeResolvedProviders(dirProvider.viewProviders, mergedProvidersMap);\r\n                setProvidersVisibility(dirProvider.viewProviders, injector_1.Visibility.Private, providerVisibilityMap);\r\n            }\r\n            for (var queryIdx = 0; queryIdx < dirProvider.queries.length; queryIdx++) {\r\n                var q = dirProvider.queries[queryIdx];\r\n                protoQueryRefs.push(new ProtoQueryRef(i, q.setter, q.metadata));\r\n            }\r\n        }\r\n        if (lang_1.isPresent(componentDirProvider) && lang_1.isPresent(componentDirProvider.providers)) {\r\n            // directive providers need to be prioritized over component providers\r\n            provider_1.mergeResolvedProviders(componentDirProvider.providers, mergedProvidersMap);\r\n            setProvidersVisibility(componentDirProvider.providers, injector_1.Visibility.Public, providerVisibilityMap);\r\n        }\r\n        mergedProvidersMap.forEach(function (provider, _) {\r\n            providers.push(new injector_1.ProviderWithVisibility(provider, providerVisibilityMap.get(provider.key.id)));\r\n        });\r\n        return new AppProtoElement(lang_1.isPresent(componentDirProvider), index, attributes, providers, protoQueryRefs, directiveVariableBindings);\r\n    };\r\n    AppProtoElement.prototype.getProviderAtIndex = function (index) { return this.protoInjector.getProviderAtIndex(index); };\r\n    return AppProtoElement;\r\n})();\r\nexports.AppProtoElement = AppProtoElement;\r\nvar _Context = (function () {\r\n    function _Context(element, componentElement, injector) {\r\n        this.element = element;\r\n        this.componentElement = componentElement;\r\n        this.injector = injector;\r\n    }\r\n    return _Context;\r\n})();\r\nvar InjectorWithHostBoundary = (function () {\r\n    function InjectorWithHostBoundary(injector, hostInjectorBoundary) {\r\n        this.injector = injector;\r\n        this.hostInjectorBoundary = hostInjectorBoundary;\r\n    }\r\n    return InjectorWithHostBoundary;\r\n})();\r\nexports.InjectorWithHostBoundary = InjectorWithHostBoundary;\r\nvar AppElement = (function () {\r\n    function AppElement(proto, parentView, parent, nativeElement, embeddedViewFactory) {\r\n        var _this = this;\r\n        this.proto = proto;\r\n        this.parentView = parentView;\r\n        this.parent = parent;\r\n        this.nativeElement = nativeElement;\r\n        this.embeddedViewFactory = embeddedViewFactory;\r\n        this.nestedViews = null;\r\n        this.componentView = null;\r\n        this.ref = new element_ref_1.ElementRef_(this);\r\n        var parentInjector = lang_1.isPresent(parent) ? parent._injector : parentView.parentInjector;\r\n        if (lang_1.isPresent(this.proto.protoInjector)) {\r\n            var isBoundary;\r\n            if (lang_1.isPresent(parent) && lang_1.isPresent(parent.proto.protoInjector)) {\r\n                isBoundary = false;\r\n            }\r\n            else {\r\n                isBoundary = parentView.hostInjectorBoundary;\r\n            }\r\n            this._queryStrategy = this._buildQueryStrategy();\r\n            this._injector = new di_1.Injector(this.proto.protoInjector, parentInjector, isBoundary, this, function () { return _this._debugContext(); });\r\n            // we couple ourselves to the injector strategy to avoid polymorphic calls\r\n            var injectorStrategy = this._injector.internalStrategy;\r\n            this._strategy = injectorStrategy instanceof injector_1.InjectorInlineStrategy ?\r\n                new ElementDirectiveInlineStrategy(injectorStrategy, this) :\r\n                new ElementDirectiveDynamicStrategy(injectorStrategy, this);\r\n            this._strategy.init();\r\n        }\r\n        else {\r\n            this._queryStrategy = null;\r\n            this._injector = parentInjector;\r\n            this._strategy = null;\r\n        }\r\n    }\r\n    AppElement.getViewParentInjector = function (parentViewType, containerAppElement, imperativelyCreatedProviders, rootInjector) {\r\n        var parentInjector;\r\n        var hostInjectorBoundary;\r\n        switch (parentViewType) {\r\n            case view_type_1.ViewType.COMPONENT:\r\n                parentInjector = containerAppElement._injector;\r\n                hostInjectorBoundary = true;\r\n                break;\r\n            case view_type_1.ViewType.EMBEDDED:\r\n                parentInjector = lang_1.isPresent(containerAppElement.proto.protoInjector) ?\r\n                    containerAppElement._injector.parent :\r\n                    containerAppElement._injector;\r\n                hostInjectorBoundary = containerAppElement._injector.hostBoundary;\r\n                break;\r\n            case view_type_1.ViewType.HOST:\r\n                if (lang_1.isPresent(containerAppElement)) {\r\n                    // host view is attached to a container\r\n                    parentInjector = lang_1.isPresent(containerAppElement.proto.protoInjector) ?\r\n                        containerAppElement._injector.parent :\r\n                        containerAppElement._injector;\r\n                    if (lang_1.isPresent(imperativelyCreatedProviders)) {\r\n                        var imperativeProvidersWithVisibility = imperativelyCreatedProviders.map(function (p) { return new injector_1.ProviderWithVisibility(p, injector_1.Visibility.Public); });\r\n                        // The imperative injector is similar to having an element between\r\n                        // the dynamic-loaded component and its parent => no boundary between\r\n                        // the component and imperativelyCreatedInjector.\r\n                        parentInjector = new di_1.Injector(new injector_1.ProtoInjector(imperativeProvidersWithVisibility), parentInjector, true, null, null);\r\n                        hostInjectorBoundary = false;\r\n                    }\r\n                    else {\r\n                        hostInjectorBoundary = containerAppElement._injector.hostBoundary;\r\n                    }\r\n                }\r\n                else {\r\n                    // bootstrap\r\n                    parentInjector = rootInjector;\r\n                    hostInjectorBoundary = true;\r\n                }\r\n                break;\r\n        }\r\n        return new InjectorWithHostBoundary(parentInjector, hostInjectorBoundary);\r\n    };\r\n    AppElement.prototype.attachComponentView = function (componentView) { this.componentView = componentView; };\r\n    AppElement.prototype._debugContext = function () {\r\n        var c = this.parentView.getDebugContext(this, null, null);\r\n        return lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.injector) : null;\r\n    };\r\n    AppElement.prototype.hasVariableBinding = function (name) {\r\n        var vb = this.proto.directiveVariableBindings;\r\n        return lang_1.isPresent(vb) && collection_1.StringMapWrapper.contains(vb, name);\r\n    };\r\n    AppElement.prototype.getVariableBinding = function (name) {\r\n        var index = this.proto.directiveVariableBindings[name];\r\n        return lang_1.isPresent(index) ? this.getDirectiveAtIndex(index) : this.getElementRef();\r\n    };\r\n    AppElement.prototype.get = function (token) { return this._injector.get(token); };\r\n    AppElement.prototype.hasDirective = function (type) { return lang_1.isPresent(this._injector.getOptional(type)); };\r\n    AppElement.prototype.getComponent = function () { return lang_1.isPresent(this._strategy) ? this._strategy.getComponent() : null; };\r\n    AppElement.prototype.getInjector = function () { return this._injector; };\r\n    AppElement.prototype.getElementRef = function () { return this.ref; };\r\n    AppElement.prototype.getViewContainerRef = function () { return new view_container_ref_2.ViewContainerRef_(this); };\r\n    AppElement.prototype.getTemplateRef = function () {\r\n        if (lang_1.isPresent(this.embeddedViewFactory)) {\r\n            return new template_ref_1.TemplateRef_(this.ref);\r\n        }\r\n        return null;\r\n    };\r\n    AppElement.prototype.getDependency = function (injector, provider, dep) {\r\n        if (provider instanceof DirectiveProvider) {\r\n            var dirDep = dep;\r\n            if (lang_1.isPresent(dirDep.attributeName))\r\n                return this._buildAttribute(dirDep);\r\n            if (lang_1.isPresent(dirDep.queryDecorator))\r\n                return this._queryStrategy.findQuery(dirDep.queryDecorator).list;\r\n            if (dirDep.key.id === StaticKeys.instance().changeDetectorRefId) {\r\n                // We provide the component's view change detector to components and\r\n                // the surrounding component's change detector to directives.\r\n                if (this.proto.firstProviderIsComponent) {\r\n                    // Note: The component view is not yet created when\r\n                    // this method is called!\r\n                    return new _ComponentViewChangeDetectorRef(this);\r\n                }\r\n                else {\r\n                    return this.parentView.changeDetector.ref;\r\n                }\r\n            }\r\n            if (dirDep.key.id === StaticKeys.instance().elementRefId) {\r\n                return this.getElementRef();\r\n            }\r\n            if (dirDep.key.id === StaticKeys.instance().viewContainerId) {\r\n                return this.getViewContainerRef();\r\n            }\r\n            if (dirDep.key.id === StaticKeys.instance().templateRefId) {\r\n                var tr = this.getTemplateRef();\r\n                if (lang_1.isBlank(tr) && !dirDep.optional) {\r\n                    throw new di_1.NoProviderError(null, dirDep.key);\r\n                }\r\n                return tr;\r\n            }\r\n            if (dirDep.key.id === StaticKeys.instance().rendererId) {\r\n                return this.parentView.renderer;\r\n            }\r\n        }\r\n        else if (provider instanceof pipe_provider_1.PipeProvider) {\r\n            if (dep.key.id === StaticKeys.instance().changeDetectorRefId) {\r\n                // We provide the component's view change detector to components and\r\n                // the surrounding component's change detector to directives.\r\n                if (this.proto.firstProviderIsComponent) {\r\n                    // Note: The component view is not yet created when\r\n                    // this method is called!\r\n                    return new _ComponentViewChangeDetectorRef(this);\r\n                }\r\n                else {\r\n                    return this.parentView.changeDetector;\r\n                }\r\n            }\r\n        }\r\n        return injector_1.UNDEFINED;\r\n    };\r\n    AppElement.prototype._buildAttribute = function (dep) {\r\n        var attributes = this.proto.attributes;\r\n        if (lang_1.isPresent(attributes) && collection_1.StringMapWrapper.contains(attributes, dep.attributeName)) {\r\n            return attributes[dep.attributeName];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    AppElement.prototype.addDirectivesMatchingQuery = function (query, list) {\r\n        var templateRef = this.getTemplateRef();\r\n        if (query.selector === template_ref_1.TemplateRef && lang_1.isPresent(templateRef)) {\r\n            list.push(templateRef);\r\n        }\r\n        if (this._strategy != null) {\r\n            this._strategy.addDirectivesMatchingQuery(query, list);\r\n        }\r\n    };\r\n    AppElement.prototype._buildQueryStrategy = function () {\r\n        if (this.proto.protoQueryRefs.length === 0) {\r\n            return _emptyQueryStrategy;\r\n        }\r\n        else if (this.proto.protoQueryRefs.length <=\r\n            InlineQueryStrategy.NUMBER_OF_SUPPORTED_QUERIES) {\r\n            return new InlineQueryStrategy(this);\r\n        }\r\n        else {\r\n            return new DynamicQueryStrategy(this);\r\n        }\r\n    };\r\n    AppElement.prototype.getDirectiveAtIndex = function (index) { return this._injector.getAt(index); };\r\n    AppElement.prototype.ngAfterViewChecked = function () {\r\n        if (lang_1.isPresent(this._queryStrategy))\r\n            this._queryStrategy.updateViewQueries();\r\n    };\r\n    AppElement.prototype.ngAfterContentChecked = function () {\r\n        if (lang_1.isPresent(this._queryStrategy))\r\n            this._queryStrategy.updateContentQueries();\r\n    };\r\n    AppElement.prototype.traverseAndSetQueriesAsDirty = function () {\r\n        var inj = this;\r\n        while (lang_1.isPresent(inj)) {\r\n            inj._setQueriesAsDirty();\r\n            inj = inj.parent;\r\n        }\r\n    };\r\n    AppElement.prototype._setQueriesAsDirty = function () {\r\n        if (lang_1.isPresent(this._queryStrategy)) {\r\n            this._queryStrategy.setContentQueriesAsDirty();\r\n        }\r\n        if (this.parentView.proto.type === view_type_1.ViewType.COMPONENT) {\r\n            this.parentView.containerAppElement._queryStrategy.setViewQueriesAsDirty();\r\n        }\r\n    };\r\n    return AppElement;\r\n})();\r\nexports.AppElement = AppElement;\r\nvar _EmptyQueryStrategy = (function () {\r\n    function _EmptyQueryStrategy() {\r\n    }\r\n    _EmptyQueryStrategy.prototype.setContentQueriesAsDirty = function () { };\r\n    _EmptyQueryStrategy.prototype.setViewQueriesAsDirty = function () { };\r\n    _EmptyQueryStrategy.prototype.updateContentQueries = function () { };\r\n    _EmptyQueryStrategy.prototype.updateViewQueries = function () { };\r\n    _EmptyQueryStrategy.prototype.findQuery = function (query) {\r\n        throw new exceptions_1.BaseException(\"Cannot find query for directive \" + query + \".\");\r\n    };\r\n    return _EmptyQueryStrategy;\r\n})();\r\nvar _emptyQueryStrategy = new _EmptyQueryStrategy();\r\nvar InlineQueryStrategy = (function () {\r\n    function InlineQueryStrategy(ei) {\r\n        var protoRefs = ei.proto.protoQueryRefs;\r\n        if (protoRefs.length > 0)\r\n            this.query0 = new QueryRef(protoRefs[0], ei);\r\n        if (protoRefs.length > 1)\r\n            this.query1 = new QueryRef(protoRefs[1], ei);\r\n        if (protoRefs.length > 2)\r\n            this.query2 = new QueryRef(protoRefs[2], ei);\r\n    }\r\n    InlineQueryStrategy.prototype.setContentQueriesAsDirty = function () {\r\n        if (lang_1.isPresent(this.query0) && !this.query0.isViewQuery)\r\n            this.query0.dirty = true;\r\n        if (lang_1.isPresent(this.query1) && !this.query1.isViewQuery)\r\n            this.query1.dirty = true;\r\n        if (lang_1.isPresent(this.query2) && !this.query2.isViewQuery)\r\n            this.query2.dirty = true;\r\n    };\r\n    InlineQueryStrategy.prototype.setViewQueriesAsDirty = function () {\r\n        if (lang_1.isPresent(this.query0) && this.query0.isViewQuery)\r\n            this.query0.dirty = true;\r\n        if (lang_1.isPresent(this.query1) && this.query1.isViewQuery)\r\n            this.query1.dirty = true;\r\n        if (lang_1.isPresent(this.query2) && this.query2.isViewQuery)\r\n            this.query2.dirty = true;\r\n    };\r\n    InlineQueryStrategy.prototype.updateContentQueries = function () {\r\n        if (lang_1.isPresent(this.query0) && !this.query0.isViewQuery) {\r\n            this.query0.update();\r\n        }\r\n        if (lang_1.isPresent(this.query1) && !this.query1.isViewQuery) {\r\n            this.query1.update();\r\n        }\r\n        if (lang_1.isPresent(this.query2) && !this.query2.isViewQuery) {\r\n            this.query2.update();\r\n        }\r\n    };\r\n    InlineQueryStrategy.prototype.updateViewQueries = function () {\r\n        if (lang_1.isPresent(this.query0) && this.query0.isViewQuery) {\r\n            this.query0.update();\r\n        }\r\n        if (lang_1.isPresent(this.query1) && this.query1.isViewQuery) {\r\n            this.query1.update();\r\n        }\r\n        if (lang_1.isPresent(this.query2) && this.query2.isViewQuery) {\r\n            this.query2.update();\r\n        }\r\n    };\r\n    InlineQueryStrategy.prototype.findQuery = function (query) {\r\n        if (lang_1.isPresent(this.query0) && this.query0.protoQueryRef.query === query) {\r\n            return this.query0;\r\n        }\r\n        if (lang_1.isPresent(this.query1) && this.query1.protoQueryRef.query === query) {\r\n            return this.query1;\r\n        }\r\n        if (lang_1.isPresent(this.query2) && this.query2.protoQueryRef.query === query) {\r\n            return this.query2;\r\n        }\r\n        throw new exceptions_1.BaseException(\"Cannot find query for directive \" + query + \".\");\r\n    };\r\n    InlineQueryStrategy.NUMBER_OF_SUPPORTED_QUERIES = 3;\r\n    return InlineQueryStrategy;\r\n})();\r\nvar DynamicQueryStrategy = (function () {\r\n    function DynamicQueryStrategy(ei) {\r\n        this.queries = ei.proto.protoQueryRefs.map(function (p) { return new QueryRef(p, ei); });\r\n    }\r\n    DynamicQueryStrategy.prototype.setContentQueriesAsDirty = function () {\r\n        for (var i = 0; i < this.queries.length; ++i) {\r\n            var q = this.queries[i];\r\n            if (!q.isViewQuery)\r\n                q.dirty = true;\r\n        }\r\n    };\r\n    DynamicQueryStrategy.prototype.setViewQueriesAsDirty = function () {\r\n        for (var i = 0; i < this.queries.length; ++i) {\r\n            var q = this.queries[i];\r\n            if (q.isViewQuery)\r\n                q.dirty = true;\r\n        }\r\n    };\r\n    DynamicQueryStrategy.prototype.updateContentQueries = function () {\r\n        for (var i = 0; i < this.queries.length; ++i) {\r\n            var q = this.queries[i];\r\n            if (!q.isViewQuery) {\r\n                q.update();\r\n            }\r\n        }\r\n    };\r\n    DynamicQueryStrategy.prototype.updateViewQueries = function () {\r\n        for (var i = 0; i < this.queries.length; ++i) {\r\n            var q = this.queries[i];\r\n            if (q.isViewQuery) {\r\n                q.update();\r\n            }\r\n        }\r\n    };\r\n    DynamicQueryStrategy.prototype.findQuery = function (query) {\r\n        for (var i = 0; i < this.queries.length; ++i) {\r\n            var q = this.queries[i];\r\n            if (q.protoQueryRef.query === query) {\r\n                return q;\r\n            }\r\n        }\r\n        throw new exceptions_1.BaseException(\"Cannot find query for directive \" + query + \".\");\r\n    };\r\n    return DynamicQueryStrategy;\r\n})();\r\n/**\r\n * Strategy used by the `ElementInjector` when the number of providers is 10 or less.\r\n * In such a case, inlining fields is beneficial for performances.\r\n */\r\nvar ElementDirectiveInlineStrategy = (function () {\r\n    function ElementDirectiveInlineStrategy(injectorStrategy, _ei) {\r\n        this.injectorStrategy = injectorStrategy;\r\n        this._ei = _ei;\r\n    }\r\n    ElementDirectiveInlineStrategy.prototype.init = function () {\r\n        var i = this.injectorStrategy;\r\n        var p = i.protoStrategy;\r\n        i.resetConstructionCounter();\r\n        if (p.provider0 instanceof DirectiveProvider && lang_1.isPresent(p.keyId0) && i.obj0 === injector_1.UNDEFINED)\r\n            i.obj0 = i.instantiateProvider(p.provider0, p.visibility0);\r\n        if (p.provider1 instanceof DirectiveProvider && lang_1.isPresent(p.keyId1) && i.obj1 === injector_1.UNDEFINED)\r\n            i.obj1 = i.instantiateProvider(p.provider1, p.visibility1);\r\n        if (p.provider2 instanceof DirectiveProvider && lang_1.isPresent(p.keyId2) && i.obj2 === injector_1.UNDEFINED)\r\n            i.obj2 = i.instantiateProvider(p.provider2, p.visibility2);\r\n        if (p.provider3 instanceof DirectiveProvider && lang_1.isPresent(p.keyId3) && i.obj3 === injector_1.UNDEFINED)\r\n            i.obj3 = i.instantiateProvider(p.provider3, p.visibility3);\r\n        if (p.provider4 instanceof DirectiveProvider && lang_1.isPresent(p.keyId4) && i.obj4 === injector_1.UNDEFINED)\r\n            i.obj4 = i.instantiateProvider(p.provider4, p.visibility4);\r\n        if (p.provider5 instanceof DirectiveProvider && lang_1.isPresent(p.keyId5) && i.obj5 === injector_1.UNDEFINED)\r\n            i.obj5 = i.instantiateProvider(p.provider5, p.visibility5);\r\n        if (p.provider6 instanceof DirectiveProvider && lang_1.isPresent(p.keyId6) && i.obj6 === injector_1.UNDEFINED)\r\n            i.obj6 = i.instantiateProvider(p.provider6, p.visibility6);\r\n        if (p.provider7 instanceof DirectiveProvider && lang_1.isPresent(p.keyId7) && i.obj7 === injector_1.UNDEFINED)\r\n            i.obj7 = i.instantiateProvider(p.provider7, p.visibility7);\r\n        if (p.provider8 instanceof DirectiveProvider && lang_1.isPresent(p.keyId8) && i.obj8 === injector_1.UNDEFINED)\r\n            i.obj8 = i.instantiateProvider(p.provider8, p.visibility8);\r\n        if (p.provider9 instanceof DirectiveProvider && lang_1.isPresent(p.keyId9) && i.obj9 === injector_1.UNDEFINED)\r\n            i.obj9 = i.instantiateProvider(p.provider9, p.visibility9);\r\n    };\r\n    ElementDirectiveInlineStrategy.prototype.getComponent = function () { return this.injectorStrategy.obj0; };\r\n    ElementDirectiveInlineStrategy.prototype.isComponentKey = function (key) {\r\n        return this._ei.proto.firstProviderIsComponent && lang_1.isPresent(key) &&\r\n            key.id === this.injectorStrategy.protoStrategy.keyId0;\r\n    };\r\n    ElementDirectiveInlineStrategy.prototype.addDirectivesMatchingQuery = function (query, list) {\r\n        var i = this.injectorStrategy;\r\n        var p = i.protoStrategy;\r\n        if (lang_1.isPresent(p.provider0) && p.provider0.key.token === query.selector) {\r\n            if (i.obj0 === injector_1.UNDEFINED)\r\n                i.obj0 = i.instantiateProvider(p.provider0, p.visibility0);\r\n            list.push(i.obj0);\r\n        }\r\n        if (lang_1.isPresent(p.provider1) && p.provider1.key.token === query.selector) {\r\n            if (i.obj1 === injector_1.UNDEFINED)\r\n                i.obj1 = i.instantiateProvider(p.provider1, p.visibility1);\r\n            list.push(i.obj1);\r\n        }\r\n        if (lang_1.isPresent(p.provider2) && p.provider2.key.token === query.selector) {\r\n            if (i.obj2 === injector_1.UNDEFINED)\r\n                i.obj2 = i.instantiateProvider(p.provider2, p.visibility2);\r\n            list.push(i.obj2);\r\n        }\r\n        if (lang_1.isPresent(p.provider3) && p.provider3.key.token === query.selector) {\r\n            if (i.obj3 === injector_1.UNDEFINED)\r\n                i.obj3 = i.instantiateProvider(p.provider3, p.visibility3);\r\n            list.push(i.obj3);\r\n        }\r\n        if (lang_1.isPresent(p.provider4) && p.provider4.key.token === query.selector) {\r\n            if (i.obj4 === injector_1.UNDEFINED)\r\n                i.obj4 = i.instantiateProvider(p.provider4, p.visibility4);\r\n            list.push(i.obj4);\r\n        }\r\n        if (lang_1.isPresent(p.provider5) && p.provider5.key.token === query.selector) {\r\n            if (i.obj5 === injector_1.UNDEFINED)\r\n                i.obj5 = i.instantiateProvider(p.provider5, p.visibility5);\r\n            list.push(i.obj5);\r\n        }\r\n        if (lang_1.isPresent(p.provider6) && p.provider6.key.token === query.selector) {\r\n            if (i.obj6 === injector_1.UNDEFINED)\r\n                i.obj6 = i.instantiateProvider(p.provider6, p.visibility6);\r\n            list.push(i.obj6);\r\n        }\r\n        if (lang_1.isPresent(p.provider7) && p.provider7.key.token === query.selector) {\r\n            if (i.obj7 === injector_1.UNDEFINED)\r\n                i.obj7 = i.instantiateProvider(p.provider7, p.visibility7);\r\n            list.push(i.obj7);\r\n        }\r\n        if (lang_1.isPresent(p.provider8) && p.provider8.key.token === query.selector) {\r\n            if (i.obj8 === injector_1.UNDEFINED)\r\n                i.obj8 = i.instantiateProvider(p.provider8, p.visibility8);\r\n            list.push(i.obj8);\r\n        }\r\n        if (lang_1.isPresent(p.provider9) && p.provider9.key.token === query.selector) {\r\n            if (i.obj9 === injector_1.UNDEFINED)\r\n                i.obj9 = i.instantiateProvider(p.provider9, p.visibility9);\r\n            list.push(i.obj9);\r\n        }\r\n    };\r\n    return ElementDirectiveInlineStrategy;\r\n})();\r\n/**\r\n * Strategy used by the `ElementInjector` when the number of bindings is 11 or more.\r\n * In such a case, there are too many fields to inline (see ElementInjectorInlineStrategy).\r\n */\r\nvar ElementDirectiveDynamicStrategy = (function () {\r\n    function ElementDirectiveDynamicStrategy(injectorStrategy, _ei) {\r\n        this.injectorStrategy = injectorStrategy;\r\n        this._ei = _ei;\r\n    }\r\n    ElementDirectiveDynamicStrategy.prototype.init = function () {\r\n        var inj = this.injectorStrategy;\r\n        var p = inj.protoStrategy;\r\n        inj.resetConstructionCounter();\r\n        for (var i = 0; i < p.keyIds.length; i++) {\r\n            if (p.providers[i] instanceof DirectiveProvider && lang_1.isPresent(p.keyIds[i]) &&\r\n                inj.objs[i] === injector_1.UNDEFINED) {\r\n                inj.objs[i] = inj.instantiateProvider(p.providers[i], p.visibilities[i]);\r\n            }\r\n        }\r\n    };\r\n    ElementDirectiveDynamicStrategy.prototype.getComponent = function () { return this.injectorStrategy.objs[0]; };\r\n    ElementDirectiveDynamicStrategy.prototype.isComponentKey = function (key) {\r\n        var p = this.injectorStrategy.protoStrategy;\r\n        return this._ei.proto.firstProviderIsComponent && lang_1.isPresent(key) && key.id === p.keyIds[0];\r\n    };\r\n    ElementDirectiveDynamicStrategy.prototype.addDirectivesMatchingQuery = function (query, list) {\r\n        var ist = this.injectorStrategy;\r\n        var p = ist.protoStrategy;\r\n        for (var i = 0; i < p.providers.length; i++) {\r\n            if (p.providers[i].key.token === query.selector) {\r\n                if (ist.objs[i] === injector_1.UNDEFINED) {\r\n                    ist.objs[i] = ist.instantiateProvider(p.providers[i], p.visibilities[i]);\r\n                }\r\n                list.push(ist.objs[i]);\r\n            }\r\n        }\r\n    };\r\n    return ElementDirectiveDynamicStrategy;\r\n})();\r\nvar ProtoQueryRef = (function () {\r\n    function ProtoQueryRef(dirIndex, setter, query) {\r\n        this.dirIndex = dirIndex;\r\n        this.setter = setter;\r\n        this.query = query;\r\n    }\r\n    Object.defineProperty(ProtoQueryRef.prototype, \"usesPropertySyntax\", {\r\n        get: function () { return lang_1.isPresent(this.setter); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return ProtoQueryRef;\r\n})();\r\nexports.ProtoQueryRef = ProtoQueryRef;\r\nvar QueryRef = (function () {\r\n    function QueryRef(protoQueryRef, originator) {\r\n        this.protoQueryRef = protoQueryRef;\r\n        this.originator = originator;\r\n        this.list = new query_list_1.QueryList();\r\n        this.dirty = true;\r\n    }\r\n    Object.defineProperty(QueryRef.prototype, \"isViewQuery\", {\r\n        get: function () { return this.protoQueryRef.query.isViewQuery; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    QueryRef.prototype.update = function () {\r\n        if (!this.dirty)\r\n            return;\r\n        this._update();\r\n        this.dirty = false;\r\n        // TODO delete the check once only field queries are supported\r\n        if (this.protoQueryRef.usesPropertySyntax) {\r\n            var dir = this.originator.getDirectiveAtIndex(this.protoQueryRef.dirIndex);\r\n            if (this.protoQueryRef.query.first) {\r\n                this.protoQueryRef.setter(dir, this.list.length > 0 ? this.list.first : null);\r\n            }\r\n            else {\r\n                this.protoQueryRef.setter(dir, this.list);\r\n            }\r\n        }\r\n        this.list.notifyOnChanges();\r\n    };\r\n    QueryRef.prototype._update = function () {\r\n        var aggregator = [];\r\n        if (this.protoQueryRef.query.isViewQuery) {\r\n            // intentionally skipping originator for view queries.\r\n            var nestedView = this.originator.componentView;\r\n            if (lang_1.isPresent(nestedView))\r\n                this._visitView(nestedView, aggregator);\r\n        }\r\n        else {\r\n            this._visit(this.originator, aggregator);\r\n        }\r\n        this.list.reset(aggregator);\r\n    };\r\n    ;\r\n    QueryRef.prototype._visit = function (inj, aggregator) {\r\n        var view = inj.parentView;\r\n        var startIdx = inj.proto.index;\r\n        for (var i = startIdx; i < view.appElements.length; i++) {\r\n            var curInj = view.appElements[i];\r\n            // The first injector after inj, that is outside the subtree rooted at\r\n            // inj has to have a null parent or a parent that is an ancestor of inj.\r\n            if (i > startIdx && (lang_1.isBlank(curInj.parent) || curInj.parent.proto.index < startIdx)) {\r\n                break;\r\n            }\r\n            if (!this.protoQueryRef.query.descendants &&\r\n                !(curInj.parent == this.originator || curInj == this.originator))\r\n                continue;\r\n            // We visit the view container(VC) views right after the injector that contains\r\n            // the VC. Theoretically, that might not be the right order if there are\r\n            // child injectors of said injector. Not clear whether if such case can\r\n            // even be constructed with the current apis.\r\n            this._visitInjector(curInj, aggregator);\r\n            this._visitViewContainerViews(curInj.nestedViews, aggregator);\r\n        }\r\n    };\r\n    QueryRef.prototype._visitInjector = function (inj, aggregator) {\r\n        if (this.protoQueryRef.query.isVarBindingQuery) {\r\n            this._aggregateVariableBinding(inj, aggregator);\r\n        }\r\n        else {\r\n            this._aggregateDirective(inj, aggregator);\r\n        }\r\n    };\r\n    QueryRef.prototype._visitViewContainerViews = function (views, aggregator) {\r\n        if (lang_1.isPresent(views)) {\r\n            for (var j = 0; j < views.length; j++) {\r\n                this._visitView(views[j], aggregator);\r\n            }\r\n        }\r\n    };\r\n    QueryRef.prototype._visitView = function (view, aggregator) {\r\n        for (var i = 0; i < view.appElements.length; i++) {\r\n            var inj = view.appElements[i];\r\n            this._visitInjector(inj, aggregator);\r\n            this._visitViewContainerViews(inj.nestedViews, aggregator);\r\n        }\r\n    };\r\n    QueryRef.prototype._aggregateVariableBinding = function (inj, aggregator) {\r\n        var vb = this.protoQueryRef.query.varBindings;\r\n        for (var i = 0; i < vb.length; ++i) {\r\n            if (inj.hasVariableBinding(vb[i])) {\r\n                aggregator.push(inj.getVariableBinding(vb[i]));\r\n            }\r\n        }\r\n    };\r\n    QueryRef.prototype._aggregateDirective = function (inj, aggregator) {\r\n        inj.addDirectivesMatchingQuery(this.protoQueryRef.query, aggregator);\r\n    };\r\n    return QueryRef;\r\n})();\r\nexports.QueryRef = QueryRef;\r\nvar _ComponentViewChangeDetectorRef = (function (_super) {\r\n    __extends(_ComponentViewChangeDetectorRef, _super);\r\n    function _ComponentViewChangeDetectorRef(_appElement) {\r\n        _super.call(this);\r\n        this._appElement = _appElement;\r\n    }\r\n    _ComponentViewChangeDetectorRef.prototype.markForCheck = function () { this._appElement.componentView.changeDetector.ref.markForCheck(); };\r\n    _ComponentViewChangeDetectorRef.prototype.detach = function () { this._appElement.componentView.changeDetector.ref.detach(); };\r\n    _ComponentViewChangeDetectorRef.prototype.detectChanges = function () { this._appElement.componentView.changeDetector.ref.detectChanges(); };\r\n    _ComponentViewChangeDetectorRef.prototype.checkNoChanges = function () { this._appElement.componentView.changeDetector.ref.checkNoChanges(); };\r\n    _ComponentViewChangeDetectorRef.prototype.reattach = function () { this._appElement.componentView.changeDetector.ref.reattach(); };\r\n    return _ComponentViewChangeDetectorRef;\r\n})(change_detection_1.ChangeDetectorRef);\r\n},{\"../metadata/di\":147,\"../metadata/directives\":148,\"./element_ref\":133,\"./query_list\":136,\"./template_ref\":138,\"./view_container_ref\":140,\"./view_type\":145,\"angular2/src/core/change_detection/change_detection\":87,\"angular2/src/core/di\":117,\"angular2/src/core/di/injector\":121,\"angular2/src/core/di/provider\":125,\"angular2/src/core/pipes/pipe_provider\":150,\"angular2/src/core/reflection/reflection\":158,\"angular2/src/core/render/api\":162,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],133:[function(require,module,exports){\n'use strict';var exceptions_1 = require('angular2/src/facade/exceptions');\r\n/**\r\n * Represents a location in a View that has an injection, change-detection and render context\r\n * associated with it.\r\n *\r\n * An `ElementRef` is created for each element in the Template that contains a Directive, Component\r\n * or data-binding.\r\n *\r\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\r\n * element.\r\n */\r\nvar ElementRef = (function () {\r\n    function ElementRef() {\r\n    }\r\n    Object.defineProperty(ElementRef.prototype, \"nativeElement\", {\r\n        /**\r\n         * The underlying native element or `null` if direct access to native elements is not supported\r\n         * (e.g. when the application runs in a web worker).\r\n         *\r\n         * <div class=\"callout is-critical\">\r\n         *   <header>Use with caution</header>\r\n         *   <p>\r\n         *    Use this API as the last resort when direct access to DOM is needed. Use templating and\r\n         *    data-binding provided by Angular instead. Alternatively you take a look at {@link Renderer}\r\n         *    which provides API that can safely be used even when direct access to native elements is not\r\n         *    supported.\r\n         *   </p>\r\n         *   <p>\r\n         *    Relying on direct DOM access creates tight coupling between your application and rendering\r\n         *    layers which will make it impossible to separate the two and deploy your application into a\r\n         *    web worker.\r\n         *   </p>\r\n         * </div>\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return ElementRef;\r\n})();\r\nexports.ElementRef = ElementRef;\r\nvar ElementRef_ = (function () {\r\n    function ElementRef_(_appElement) {\r\n        this._appElement = _appElement;\r\n    }\r\n    Object.defineProperty(ElementRef_.prototype, \"internalElement\", {\r\n        get: function () { return this._appElement; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ElementRef_.prototype, \"nativeElement\", {\r\n        get: function () { return this._appElement.nativeElement; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return ElementRef_;\r\n})();\r\nexports.ElementRef_ = ElementRef_;\r\n},{\"angular2/src/facade/exceptions\":173}],134:[function(require,module,exports){\n'use strict';(function (LifecycleHooks) {\r\n    LifecycleHooks[LifecycleHooks[\"OnInit\"] = 0] = \"OnInit\";\r\n    LifecycleHooks[LifecycleHooks[\"OnDestroy\"] = 1] = \"OnDestroy\";\r\n    LifecycleHooks[LifecycleHooks[\"DoCheck\"] = 2] = \"DoCheck\";\r\n    LifecycleHooks[LifecycleHooks[\"OnChanges\"] = 3] = \"OnChanges\";\r\n    LifecycleHooks[LifecycleHooks[\"AfterContentInit\"] = 4] = \"AfterContentInit\";\r\n    LifecycleHooks[LifecycleHooks[\"AfterContentChecked\"] = 5] = \"AfterContentChecked\";\r\n    LifecycleHooks[LifecycleHooks[\"AfterViewInit\"] = 6] = \"AfterViewInit\";\r\n    LifecycleHooks[LifecycleHooks[\"AfterViewChecked\"] = 7] = \"AfterViewChecked\";\r\n})(exports.LifecycleHooks || (exports.LifecycleHooks = {}));\r\nvar LifecycleHooks = exports.LifecycleHooks;\r\n/**\r\n * @internal\r\n */\r\nexports.LIFECYCLE_HOOKS_VALUES = [\r\n    LifecycleHooks.OnInit,\r\n    LifecycleHooks.OnDestroy,\r\n    LifecycleHooks.DoCheck,\r\n    LifecycleHooks.OnChanges,\r\n    LifecycleHooks.AfterContentInit,\r\n    LifecycleHooks.AfterContentChecked,\r\n    LifecycleHooks.AfterViewInit,\r\n    LifecycleHooks.AfterViewChecked\r\n];\r\n},{}],135:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar metadata_1 = require('angular2/src/core/metadata');\r\nvar reflection_1 = require('angular2/src/core/reflection/reflection');\r\nfunction _isPipeMetadata(type) {\r\n    return type instanceof metadata_1.PipeMetadata;\r\n}\r\n/**\r\n * Resolve a `Type` for {@link PipeMetadata}.\r\n *\r\n * This interface can be overridden by the application developer to create custom behavior.\r\n *\r\n * See {@link Compiler}\r\n */\r\nvar PipeResolver = (function () {\r\n    function PipeResolver() {\r\n    }\r\n    /**\r\n     * Return {@link PipeMetadata} for a given `Type`.\r\n     */\r\n    PipeResolver.prototype.resolve = function (type) {\r\n        var metas = reflection_1.reflector.annotations(di_1.resolveForwardRef(type));\r\n        if (lang_1.isPresent(metas)) {\r\n            var annotation = metas.find(_isPipeMetadata);\r\n            if (lang_1.isPresent(annotation)) {\r\n                return annotation;\r\n            }\r\n        }\r\n        throw new exceptions_1.BaseException(\"No Pipe decorator found on \" + lang_1.stringify(type));\r\n    };\r\n    PipeResolver = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], PipeResolver);\r\n    return PipeResolver;\r\n})();\r\nexports.PipeResolver = PipeResolver;\r\nexports.CODEGEN_PIPE_RESOLVER = new PipeResolver();\r\n},{\"angular2/src/core/di\":117,\"angular2/src/core/metadata\":146,\"angular2/src/core/reflection/reflection\":158,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],136:[function(require,module,exports){\n'use strict';var collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar async_1 = require('angular2/src/facade/async');\r\n/**\r\n * An unmodifiable list of items that Angular keeps up to date when the state\r\n * of the application changes.\r\n *\r\n * The type of object that {@link QueryMetadata} and {@link ViewQueryMetadata} provide.\r\n *\r\n * Implements an iterable interface, therefore it can be used in both ES6\r\n * javascript `for (var i of items)` loops as well as in Angular templates with\r\n * `*ngFor=\"#i of myList\"`.\r\n *\r\n * Changes can be observed by subscribing to the changes `Observable`.\r\n *\r\n * NOTE: In the future this class will implement an `Observable` interface.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))\r\n * ```typescript\r\n * @Component({...})\r\n * class Container {\r\n *   constructor(@Query(Item) items: QueryList<Item>) {\r\n *     items.changes.subscribe(_ => console.log(items.length));\r\n *   }\r\n * }\r\n * ```\r\n */\r\nvar QueryList = (function () {\r\n    function QueryList() {\r\n        this._results = [];\r\n        this._emitter = new async_1.EventEmitter();\r\n    }\r\n    Object.defineProperty(QueryList.prototype, \"changes\", {\r\n        get: function () { return this._emitter; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(QueryList.prototype, \"length\", {\r\n        get: function () { return this._results.length; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(QueryList.prototype, \"first\", {\r\n        get: function () { return collection_1.ListWrapper.first(this._results); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(QueryList.prototype, \"last\", {\r\n        get: function () { return collection_1.ListWrapper.last(this._results); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * returns a new array with the passed in function applied to each element.\r\n     */\r\n    QueryList.prototype.map = function (fn) { return this._results.map(fn); };\r\n    /**\r\n     * returns a filtered array.\r\n     */\r\n    QueryList.prototype.filter = function (fn) { return this._results.filter(fn); };\r\n    /**\r\n     * returns a reduced value.\r\n     */\r\n    QueryList.prototype.reduce = function (fn, init) { return this._results.reduce(fn, init); };\r\n    /**\r\n     * converts QueryList into an array\r\n     */\r\n    QueryList.prototype.toArray = function () { return collection_1.ListWrapper.clone(this._results); };\r\n    QueryList.prototype[lang_1.getSymbolIterator()] = function () { return this._results[lang_1.getSymbolIterator()](); };\r\n    QueryList.prototype.toString = function () { return this._results.toString(); };\r\n    /**\r\n     * @internal\r\n     */\r\n    QueryList.prototype.reset = function (res) { this._results = res; };\r\n    /** @internal */\r\n    QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };\r\n    return QueryList;\r\n})();\r\nexports.QueryList = QueryList;\r\n},{\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],137:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('../di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar element_1 = require('./element');\r\nvar directive_resolver_1 = require('./directive_resolver');\r\nvar pipe_provider_1 = require('../pipes/pipe_provider');\r\nvar pipe_resolver_1 = require('./pipe_resolver');\r\nvar ResolvedMetadataCache = (function () {\r\n    function ResolvedMetadataCache(_directiveResolver, _pipeResolver) {\r\n        this._directiveResolver = _directiveResolver;\r\n        this._pipeResolver = _pipeResolver;\r\n        this._directiveCache = new Map();\r\n        this._pipeCache = new Map();\r\n    }\r\n    ResolvedMetadataCache.prototype.getResolvedDirectiveMetadata = function (type) {\r\n        var result = this._directiveCache.get(type);\r\n        if (lang_1.isBlank(result)) {\r\n            result = element_1.DirectiveProvider.createFromType(type, this._directiveResolver.resolve(type));\r\n            this._directiveCache.set(type, result);\r\n        }\r\n        return result;\r\n    };\r\n    ResolvedMetadataCache.prototype.getResolvedPipeMetadata = function (type) {\r\n        var result = this._pipeCache.get(type);\r\n        if (lang_1.isBlank(result)) {\r\n            result = pipe_provider_1.PipeProvider.createFromType(type, this._pipeResolver.resolve(type));\r\n            this._pipeCache.set(type, result);\r\n        }\r\n        return result;\r\n    };\r\n    ResolvedMetadataCache = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [directive_resolver_1.DirectiveResolver, pipe_resolver_1.PipeResolver])\r\n    ], ResolvedMetadataCache);\r\n    return ResolvedMetadataCache;\r\n})();\r\nexports.ResolvedMetadataCache = ResolvedMetadataCache;\r\nexports.CODEGEN_RESOLVED_METADATA_CACHE = new ResolvedMetadataCache(directive_resolver_1.CODEGEN_DIRECTIVE_RESOLVER, pipe_resolver_1.CODEGEN_PIPE_RESOLVER);\r\n},{\"../di\":117,\"../pipes/pipe_provider\":150,\"./directive_resolver\":130,\"./element\":132,\"./pipe_resolver\":135,\"angular2/src/facade/lang\":176}],138:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n/**\r\n * Represents an Embedded Template that can be used to instantiate Embedded Views.\r\n *\r\n * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or\r\n * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the\r\n * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the\r\n * `TemplateRef` from a Component or a Directive via {@link Query}.\r\n *\r\n * To instantiate Embedded Views based on a Template, use\r\n * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the\r\n * View Container.\r\n */\r\nvar TemplateRef = (function () {\r\n    function TemplateRef() {\r\n    }\r\n    return TemplateRef;\r\n})();\r\nexports.TemplateRef = TemplateRef;\r\nvar TemplateRef_ = (function (_super) {\r\n    __extends(TemplateRef_, _super);\r\n    function TemplateRef_(_elementRef) {\r\n        _super.call(this);\r\n        this._elementRef = _elementRef;\r\n    }\r\n    Object.defineProperty(TemplateRef_.prototype, \"elementRef\", {\r\n        get: function () { return this._elementRef; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return TemplateRef_;\r\n})(TemplateRef);\r\nexports.TemplateRef_ = TemplateRef_;\r\n},{}],139:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar change_detection_1 = require('angular2/src/core/change_detection/change_detection');\r\nvar interfaces_1 = require('angular2/src/core/change_detection/interfaces');\r\nvar element_1 = require('./element');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar view_ref_1 = require('./view_ref');\r\nvar pipes_1 = require('angular2/src/core/pipes/pipes');\r\nvar util_1 = require('angular2/src/core/render/util');\r\nvar interfaces_2 = require('angular2/src/core/change_detection/interfaces');\r\nexports.DebugContext = interfaces_2.DebugContext;\r\nvar pipes_2 = require('angular2/src/core/pipes/pipes');\r\nvar view_type_1 = require('./view_type');\r\nvar REFLECT_PREFIX = 'ng-reflect-';\r\nvar EMPTY_CONTEXT = lang_1.CONST_EXPR(new Object());\r\n/**\r\n * Cost of making objects: http://jsperf.com/instantiate-size-of-object\r\n *\r\n */\r\nvar AppView = (function () {\r\n    function AppView(proto, renderer, viewManager, projectableNodes, containerAppElement, imperativelyCreatedProviders, rootInjector, changeDetector) {\r\n        this.proto = proto;\r\n        this.renderer = renderer;\r\n        this.viewManager = viewManager;\r\n        this.projectableNodes = projectableNodes;\r\n        this.containerAppElement = containerAppElement;\r\n        this.changeDetector = changeDetector;\r\n        /**\r\n         * The context against which data-binding expressions in this view are evaluated against.\r\n         * This is always a component instance.\r\n         */\r\n        this.context = null;\r\n        this.destroyed = false;\r\n        this.ref = new view_ref_1.ViewRef_(this);\r\n        var injectorWithHostBoundary = element_1.AppElement.getViewParentInjector(this.proto.type, containerAppElement, imperativelyCreatedProviders, rootInjector);\r\n        this.parentInjector = injectorWithHostBoundary.injector;\r\n        this.hostInjectorBoundary = injectorWithHostBoundary.hostInjectorBoundary;\r\n        var pipes;\r\n        var context;\r\n        switch (proto.type) {\r\n            case view_type_1.ViewType.COMPONENT:\r\n                pipes = new pipes_2.Pipes(proto.protoPipes, containerAppElement.getInjector());\r\n                context = containerAppElement.getComponent();\r\n                break;\r\n            case view_type_1.ViewType.EMBEDDED:\r\n                pipes = containerAppElement.parentView.pipes;\r\n                context = containerAppElement.parentView.context;\r\n                break;\r\n            case view_type_1.ViewType.HOST:\r\n                pipes = null;\r\n                context = EMPTY_CONTEXT;\r\n                break;\r\n        }\r\n        this.pipes = pipes;\r\n        this.context = context;\r\n    }\r\n    AppView.prototype.init = function (rootNodesOrAppElements, allNodes, disposables, appElements) {\r\n        this.rootNodesOrAppElements = rootNodesOrAppElements;\r\n        this.allNodes = allNodes;\r\n        this.disposables = disposables;\r\n        this.appElements = appElements;\r\n        var localsMap = new collection_1.Map();\r\n        collection_1.StringMapWrapper.forEach(this.proto.templateVariableBindings, function (templateName, _) { localsMap.set(templateName, null); });\r\n        for (var i = 0; i < appElements.length; i++) {\r\n            var appEl = appElements[i];\r\n            collection_1.StringMapWrapper.forEach(appEl.proto.directiveVariableBindings, function (directiveIndex, name) {\r\n                if (lang_1.isBlank(directiveIndex)) {\r\n                    localsMap.set(name, appEl.nativeElement);\r\n                }\r\n                else {\r\n                    localsMap.set(name, appEl.getDirectiveAtIndex(directiveIndex));\r\n                }\r\n            });\r\n        }\r\n        var parentLocals = null;\r\n        if (this.proto.type !== view_type_1.ViewType.COMPONENT) {\r\n            parentLocals =\r\n                lang_1.isPresent(this.containerAppElement) ? this.containerAppElement.parentView.locals : null;\r\n        }\r\n        if (this.proto.type === view_type_1.ViewType.COMPONENT) {\r\n            // Note: the render nodes have been attached to their host element\r\n            // in the ViewFactory already.\r\n            this.containerAppElement.attachComponentView(this);\r\n            this.containerAppElement.parentView.changeDetector.addViewChild(this.changeDetector);\r\n        }\r\n        this.locals = new change_detection_1.Locals(parentLocals, localsMap);\r\n        this.changeDetector.hydrate(this.context, this.locals, this, this.pipes);\r\n        this.viewManager.onViewCreated(this);\r\n    };\r\n    AppView.prototype.destroy = function () {\r\n        if (this.destroyed) {\r\n            throw new exceptions_1.BaseException('This view has already been destroyed!');\r\n        }\r\n        this.changeDetector.destroyRecursive();\r\n    };\r\n    AppView.prototype.notifyOnDestroy = function () {\r\n        this.destroyed = true;\r\n        var hostElement = this.proto.type === view_type_1.ViewType.COMPONENT ? this.containerAppElement.nativeElement : null;\r\n        this.renderer.destroyView(hostElement, this.allNodes);\r\n        for (var i = 0; i < this.disposables.length; i++) {\r\n            this.disposables[i]();\r\n        }\r\n        this.viewManager.onViewDestroyed(this);\r\n    };\r\n    Object.defineProperty(AppView.prototype, \"changeDetectorRef\", {\r\n        get: function () { return this.changeDetector.ref; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AppView.prototype, \"flatRootNodes\", {\r\n        get: function () { return flattenNestedViewRenderNodes(this.rootNodesOrAppElements); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    AppView.prototype.hasLocal = function (contextName) {\r\n        return collection_1.StringMapWrapper.contains(this.proto.templateVariableBindings, contextName);\r\n    };\r\n    AppView.prototype.setLocal = function (contextName, value) {\r\n        if (!this.hasLocal(contextName)) {\r\n            return;\r\n        }\r\n        var templateName = this.proto.templateVariableBindings[contextName];\r\n        this.locals.set(templateName, value);\r\n    };\r\n    // dispatch to element injector or text nodes based on context\r\n    AppView.prototype.notifyOnBinding = function (b, currentValue) {\r\n        if (b.isTextNode()) {\r\n            this.renderer.setText(this.allNodes[b.elementIndex], currentValue);\r\n        }\r\n        else {\r\n            var nativeElement = this.appElements[b.elementIndex].nativeElement;\r\n            if (b.isElementProperty()) {\r\n                this.renderer.setElementProperty(nativeElement, b.name, currentValue);\r\n            }\r\n            else if (b.isElementAttribute()) {\r\n                this.renderer.setElementAttribute(nativeElement, b.name, lang_1.isPresent(currentValue) ? \"\" + currentValue : null);\r\n            }\r\n            else if (b.isElementClass()) {\r\n                this.renderer.setElementClass(nativeElement, b.name, currentValue);\r\n            }\r\n            else if (b.isElementStyle()) {\r\n                var unit = lang_1.isPresent(b.unit) ? b.unit : '';\r\n                this.renderer.setElementStyle(nativeElement, b.name, lang_1.isPresent(currentValue) ? \"\" + currentValue + unit : null);\r\n            }\r\n            else {\r\n                throw new exceptions_1.BaseException('Unsupported directive record');\r\n            }\r\n        }\r\n    };\r\n    AppView.prototype.logBindingUpdate = function (b, value) {\r\n        if (b.isDirective() || b.isElementProperty()) {\r\n            var nativeElement = this.appElements[b.elementIndex].nativeElement;\r\n            this.renderer.setBindingDebugInfo(nativeElement, \"\" + REFLECT_PREFIX + util_1.camelCaseToDashCase(b.name), \"\" + value);\r\n        }\r\n    };\r\n    AppView.prototype.notifyAfterContentChecked = function () {\r\n        var count = this.appElements.length;\r\n        for (var i = count - 1; i >= 0; i--) {\r\n            this.appElements[i].ngAfterContentChecked();\r\n        }\r\n    };\r\n    AppView.prototype.notifyAfterViewChecked = function () {\r\n        var count = this.appElements.length;\r\n        for (var i = count - 1; i >= 0; i--) {\r\n            this.appElements[i].ngAfterViewChecked();\r\n        }\r\n    };\r\n    AppView.prototype.getDebugContext = function (appElement, elementIndex, directiveIndex) {\r\n        try {\r\n            if (lang_1.isBlank(appElement) && elementIndex < this.appElements.length) {\r\n                appElement = this.appElements[elementIndex];\r\n            }\r\n            var container = this.containerAppElement;\r\n            var element = lang_1.isPresent(appElement) ? appElement.nativeElement : null;\r\n            var componentElement = lang_1.isPresent(container) ? container.nativeElement : null;\r\n            var directive = lang_1.isPresent(directiveIndex) ? appElement.getDirectiveAtIndex(directiveIndex) : null;\r\n            var injector = lang_1.isPresent(appElement) ? appElement.getInjector() : null;\r\n            return new interfaces_1.DebugContext(element, componentElement, directive, this.context, _localsToStringMap(this.locals), injector);\r\n        }\r\n        catch (e) {\r\n            // TODO: vsavkin log the exception once we have a good way to log errors and warnings\r\n            // if an error happens during getting the debug context, we return null.\r\n            return null;\r\n        }\r\n    };\r\n    AppView.prototype.getDirectiveFor = function (directive) {\r\n        return this.appElements[directive.elementIndex].getDirectiveAtIndex(directive.directiveIndex);\r\n    };\r\n    AppView.prototype.getDetectorFor = function (directive) {\r\n        var componentView = this.appElements[directive.elementIndex].componentView;\r\n        return lang_1.isPresent(componentView) ? componentView.changeDetector : null;\r\n    };\r\n    /**\r\n     * Triggers the event handlers for the element and the directives.\r\n     *\r\n     * This method is intended to be called from directive EventEmitters.\r\n     *\r\n     * @param {string} eventName\r\n     * @param {*} eventObj\r\n     * @param {number} boundElementIndex\r\n     * @return false if preventDefault must be applied to the DOM event\r\n     */\r\n    AppView.prototype.triggerEventHandlers = function (eventName, eventObj, boundElementIndex) {\r\n        return this.changeDetector.handleEvent(eventName, boundElementIndex, eventObj);\r\n    };\r\n    return AppView;\r\n})();\r\nexports.AppView = AppView;\r\nfunction _localsToStringMap(locals) {\r\n    var res = {};\r\n    var c = locals;\r\n    while (lang_1.isPresent(c)) {\r\n        res = collection_1.StringMapWrapper.merge(res, collection_1.MapWrapper.toStringMap(c.current));\r\n        c = c.parent;\r\n    }\r\n    return res;\r\n}\r\n/**\r\n *\r\n */\r\nvar AppProtoView = (function () {\r\n    function AppProtoView(type, protoPipes, templateVariableBindings) {\r\n        this.type = type;\r\n        this.protoPipes = protoPipes;\r\n        this.templateVariableBindings = templateVariableBindings;\r\n    }\r\n    AppProtoView.create = function (metadataCache, type, pipes, templateVariableBindings) {\r\n        var protoPipes = null;\r\n        if (lang_1.isPresent(pipes) && pipes.length > 0) {\r\n            var boundPipes = collection_1.ListWrapper.createFixedSize(pipes.length);\r\n            for (var i = 0; i < pipes.length; i++) {\r\n                boundPipes[i] = metadataCache.getResolvedPipeMetadata(pipes[i]);\r\n            }\r\n            protoPipes = pipes_1.ProtoPipes.fromProviders(boundPipes);\r\n        }\r\n        return new AppProtoView(type, protoPipes, templateVariableBindings);\r\n    };\r\n    return AppProtoView;\r\n})();\r\nexports.AppProtoView = AppProtoView;\r\nvar HostViewFactory = (function () {\r\n    function HostViewFactory(selector, viewFactory) {\r\n        this.selector = selector;\r\n        this.viewFactory = viewFactory;\r\n    }\r\n    HostViewFactory = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [String, Function])\r\n    ], HostViewFactory);\r\n    return HostViewFactory;\r\n})();\r\nexports.HostViewFactory = HostViewFactory;\r\nfunction flattenNestedViewRenderNodes(nodes) {\r\n    return _flattenNestedViewRenderNodes(nodes, []);\r\n}\r\nexports.flattenNestedViewRenderNodes = flattenNestedViewRenderNodes;\r\nfunction _flattenNestedViewRenderNodes(nodes, renderNodes) {\r\n    for (var i = 0; i < nodes.length; i++) {\r\n        var node = nodes[i];\r\n        if (node instanceof element_1.AppElement) {\r\n            var appEl = node;\r\n            renderNodes.push(appEl.nativeElement);\r\n            if (lang_1.isPresent(appEl.nestedViews)) {\r\n                for (var k = 0; k < appEl.nestedViews.length; k++) {\r\n                    _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            renderNodes.push(node);\r\n        }\r\n    }\r\n    return renderNodes;\r\n}\r\nfunction checkSlotCount(componentName, expectedSlotCount, projectableNodes) {\r\n    var givenSlotCount = lang_1.isPresent(projectableNodes) ? projectableNodes.length : 0;\r\n    if (givenSlotCount < expectedSlotCount) {\r\n        throw new exceptions_1.BaseException((\"The component \" + componentName + \" has \" + expectedSlotCount + \" <ng-content> elements,\") +\r\n            (\" but only \" + givenSlotCount + \" slots were provided.\"));\r\n    }\r\n}\r\nexports.checkSlotCount = checkSlotCount;\r\n},{\"./element\":132,\"./view_ref\":143,\"./view_type\":145,\"angular2/src/core/change_detection/change_detection\":87,\"angular2/src/core/change_detection/interfaces\":104,\"angular2/src/core/pipes/pipes\":151,\"angular2/src/core/render/util\":163,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],140:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * Represents a container where one or more Views can be attached.\r\n *\r\n * The container can contain two kinds of Views. Host Views, created by instantiating a\r\n * {@link Component} via {@link #createHostView}, and Embedded Views, created by instantiating an\r\n * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.\r\n *\r\n * The location of the View Container within the containing View is specified by the Anchor\r\n * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only\r\n * have a single View Container.\r\n *\r\n * Root elements of Views attached to this container become siblings of the Anchor Element in\r\n * the Rendered View.\r\n *\r\n * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected\r\n * with `ViewContainerRef` on the Element, or you obtain it via\r\n * {@link AppViewManager#getViewContainer}.\r\n *\r\n * <!-- TODO(i): we are also considering ElementRef#viewContainer api -->\r\n */\r\nvar ViewContainerRef = (function () {\r\n    function ViewContainerRef() {\r\n    }\r\n    Object.defineProperty(ViewContainerRef.prototype, \"element\", {\r\n        /**\r\n         * Anchor element that specifies the location of this container in the containing View.\r\n         * <!-- TODO: rename to anchorElement -->\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Destroys all Views in this container.\r\n     */\r\n    ViewContainerRef.prototype.clear = function () {\r\n        for (var i = this.length - 1; i >= 0; i--) {\r\n            this.remove(i);\r\n        }\r\n    };\r\n    Object.defineProperty(ViewContainerRef.prototype, \"length\", {\r\n        /**\r\n         * Returns the number of Views currently attached to this container.\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    return ViewContainerRef;\r\n})();\r\nexports.ViewContainerRef = ViewContainerRef;\r\nvar ViewContainerRef_ = (function (_super) {\r\n    __extends(ViewContainerRef_, _super);\r\n    function ViewContainerRef_(_element) {\r\n        _super.call(this);\r\n        this._element = _element;\r\n    }\r\n    ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };\r\n    Object.defineProperty(ViewContainerRef_.prototype, \"length\", {\r\n        get: function () {\r\n            var views = this._element.nestedViews;\r\n            return lang_1.isPresent(views) ? views.length : 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ViewContainerRef_.prototype, \"element\", {\r\n        get: function () { return this._element.ref; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // TODO(rado): profile and decide whether bounds checks should be added\r\n    // to the methods below.\r\n    ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, index) {\r\n        if (index === void 0) { index = -1; }\r\n        if (index == -1)\r\n            index = this.length;\r\n        var vm = this._element.parentView.viewManager;\r\n        return vm.createEmbeddedViewInContainer(this._element.ref, index, templateRef);\r\n    };\r\n    ViewContainerRef_.prototype.createHostView = function (hostViewFactoryRef, index, dynamicallyCreatedProviders, projectableNodes) {\r\n        if (index === void 0) { index = -1; }\r\n        if (dynamicallyCreatedProviders === void 0) { dynamicallyCreatedProviders = null; }\r\n        if (projectableNodes === void 0) { projectableNodes = null; }\r\n        if (index == -1)\r\n            index = this.length;\r\n        var vm = this._element.parentView.viewManager;\r\n        return vm.createHostViewInContainer(this._element.ref, index, hostViewFactoryRef, dynamicallyCreatedProviders, projectableNodes);\r\n    };\r\n    // TODO(i): refactor insert+remove into move\r\n    ViewContainerRef_.prototype.insert = function (viewRef, index) {\r\n        if (index === void 0) { index = -1; }\r\n        if (index == -1)\r\n            index = this.length;\r\n        var vm = this._element.parentView.viewManager;\r\n        return vm.attachViewInContainer(this._element.ref, index, viewRef);\r\n    };\r\n    ViewContainerRef_.prototype.indexOf = function (viewRef) {\r\n        return collection_1.ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);\r\n    };\r\n    // TODO(i): rename to destroy\r\n    ViewContainerRef_.prototype.remove = function (index) {\r\n        if (index === void 0) { index = -1; }\r\n        if (index == -1)\r\n            index = this.length - 1;\r\n        var vm = this._element.parentView.viewManager;\r\n        return vm.destroyViewInContainer(this._element.ref, index);\r\n        // view is intentionally not returned to the client.\r\n    };\r\n    // TODO(i): refactor insert+remove into move\r\n    ViewContainerRef_.prototype.detach = function (index) {\r\n        if (index === void 0) { index = -1; }\r\n        if (index == -1)\r\n            index = this.length - 1;\r\n        var vm = this._element.parentView.viewManager;\r\n        return vm.detachViewInContainer(this._element.ref, index);\r\n    };\r\n    return ViewContainerRef_;\r\n})(ViewContainerRef);\r\nexports.ViewContainerRef_ = ViewContainerRef_;\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],141:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\n/**\r\n * Listener for view creation / destruction.\r\n */\r\nvar AppViewListener = (function () {\r\n    function AppViewListener() {\r\n    }\r\n    AppViewListener.prototype.onViewCreated = function (view) { };\r\n    AppViewListener.prototype.onViewDestroyed = function (view) { };\r\n    AppViewListener = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], AppViewListener);\r\n    return AppViewListener;\r\n})();\r\nexports.AppViewListener = AppViewListener;\r\n},{\"angular2/src/core/di\":117}],142:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar view_1 = require('./view');\r\nvar element_1 = require('./element');\r\nvar view_listener_1 = require('./view_listener');\r\nvar api_1 = require('angular2/src/core/render/api');\r\nvar profile_1 = require('../profile/profile');\r\nvar application_tokens_1 = require('angular2/src/core/application_tokens');\r\nvar view_type_1 = require('./view_type');\r\n/**\r\n * Service exposing low level API for creating, moving and destroying Views.\r\n *\r\n * Most applications should use higher-level abstractions like {@link DynamicComponentLoader} and\r\n * {@link ViewContainerRef} instead.\r\n */\r\nvar AppViewManager = (function () {\r\n    function AppViewManager() {\r\n    }\r\n    return AppViewManager;\r\n})();\r\nexports.AppViewManager = AppViewManager;\r\nvar AppViewManager_ = (function (_super) {\r\n    __extends(AppViewManager_, _super);\r\n    function AppViewManager_(_renderer, _viewListener, _appId) {\r\n        _super.call(this);\r\n        this._renderer = _renderer;\r\n        this._viewListener = _viewListener;\r\n        this._appId = _appId;\r\n        this._nextCompTypeId = 0;\r\n        /** @internal */\r\n        this._createRootHostViewScope = profile_1.wtfCreateScope('AppViewManager#createRootHostView()');\r\n        /** @internal */\r\n        this._destroyRootHostViewScope = profile_1.wtfCreateScope('AppViewManager#destroyRootHostView()');\r\n        /** @internal */\r\n        this._createEmbeddedViewInContainerScope = profile_1.wtfCreateScope('AppViewManager#createEmbeddedViewInContainer()');\r\n        /** @internal */\r\n        this._createHostViewInContainerScope = profile_1.wtfCreateScope('AppViewManager#createHostViewInContainer()');\r\n        /** @internal */\r\n        this._destroyViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#destroyViewInContainer()');\r\n        /** @internal */\r\n        this._attachViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#attachViewInContainer()');\r\n        /** @internal */\r\n        this._detachViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#detachViewInContainer()');\r\n    }\r\n    AppViewManager_.prototype.getViewContainer = function (location) {\r\n        return location.internalElement.getViewContainerRef();\r\n    };\r\n    AppViewManager_.prototype.getHostElement = function (hostViewRef) {\r\n        var hostView = hostViewRef.internalView;\r\n        if (hostView.proto.type !== view_type_1.ViewType.HOST) {\r\n            throw new exceptions_1.BaseException('This operation is only allowed on host views');\r\n        }\r\n        return hostView.appElements[0].ref;\r\n    };\r\n    AppViewManager_.prototype.getNamedElementInComponentView = function (hostLocation, variableName) {\r\n        var appEl = hostLocation.internalElement;\r\n        var componentView = appEl.componentView;\r\n        if (lang_1.isBlank(componentView)) {\r\n            throw new exceptions_1.BaseException(\"There is no component directive at element \" + hostLocation);\r\n        }\r\n        for (var i = 0; i < componentView.appElements.length; i++) {\r\n            var compAppEl = componentView.appElements[i];\r\n            if (collection_1.StringMapWrapper.contains(compAppEl.proto.directiveVariableBindings, variableName)) {\r\n                return compAppEl.ref;\r\n            }\r\n        }\r\n        throw new exceptions_1.BaseException(\"Could not find variable \" + variableName);\r\n    };\r\n    AppViewManager_.prototype.getComponent = function (hostLocation) {\r\n        return hostLocation.internalElement.getComponent();\r\n    };\r\n    AppViewManager_.prototype.createRootHostView = function (hostViewFactoryRef, overrideSelector, injector, projectableNodes) {\r\n        if (projectableNodes === void 0) { projectableNodes = null; }\r\n        var s = this._createRootHostViewScope();\r\n        var hostViewFactory = hostViewFactoryRef.internalHostViewFactory;\r\n        var selector = lang_1.isPresent(overrideSelector) ? overrideSelector : hostViewFactory.selector;\r\n        var view = hostViewFactory.viewFactory(this._renderer, this, null, projectableNodes, selector, null, injector);\r\n        return profile_1.wtfLeave(s, view.ref);\r\n    };\r\n    AppViewManager_.prototype.destroyRootHostView = function (hostViewRef) {\r\n        var s = this._destroyRootHostViewScope();\r\n        var hostView = hostViewRef.internalView;\r\n        hostView.renderer.detachView(view_1.flattenNestedViewRenderNodes(hostView.rootNodesOrAppElements));\r\n        hostView.destroy();\r\n        profile_1.wtfLeave(s);\r\n    };\r\n    AppViewManager_.prototype.createEmbeddedViewInContainer = function (viewContainerLocation, index, templateRef) {\r\n        var s = this._createEmbeddedViewInContainerScope();\r\n        var contextEl = templateRef.elementRef.internalElement;\r\n        var view = contextEl.embeddedViewFactory(contextEl.parentView.renderer, this, contextEl, contextEl.parentView.projectableNodes, null, null, null);\r\n        this._attachViewToContainer(view, viewContainerLocation.internalElement, index);\r\n        return profile_1.wtfLeave(s, view.ref);\r\n    };\r\n    AppViewManager_.prototype.createHostViewInContainer = function (viewContainerLocation, index, hostViewFactoryRef, dynamicallyCreatedProviders, projectableNodes) {\r\n        var s = this._createHostViewInContainerScope();\r\n        // TODO(tbosch): This should be specifiable via an additional argument!\r\n        var contextEl = viewContainerLocation.internalElement;\r\n        var hostViewFactory = hostViewFactoryRef.internalHostViewFactory;\r\n        var view = hostViewFactory.viewFactory(contextEl.parentView.renderer, contextEl.parentView.viewManager, contextEl, projectableNodes, null, dynamicallyCreatedProviders, null);\r\n        this._attachViewToContainer(view, viewContainerLocation.internalElement, index);\r\n        return profile_1.wtfLeave(s, view.ref);\r\n    };\r\n    AppViewManager_.prototype.destroyViewInContainer = function (viewContainerLocation, index) {\r\n        var s = this._destroyViewInContainerScope();\r\n        var view = this._detachViewInContainer(viewContainerLocation.internalElement, index);\r\n        view.destroy();\r\n        profile_1.wtfLeave(s);\r\n    };\r\n    // TODO(i): refactor detachViewInContainer+attachViewInContainer to moveViewInContainer\r\n    AppViewManager_.prototype.attachViewInContainer = function (viewContainerLocation, index, viewRef) {\r\n        var s = this._attachViewInContainerScope();\r\n        this._attachViewToContainer(viewRef.internalView, viewContainerLocation.internalElement, index);\r\n        return profile_1.wtfLeave(s, viewRef);\r\n    };\r\n    // TODO(i): refactor detachViewInContainer+attachViewInContainer to moveViewInContainer\r\n    AppViewManager_.prototype.detachViewInContainer = function (viewContainerLocation, index) {\r\n        var s = this._detachViewInContainerScope();\r\n        var view = this._detachViewInContainer(viewContainerLocation.internalElement, index);\r\n        return profile_1.wtfLeave(s, view.ref);\r\n    };\r\n    /** @internal */\r\n    AppViewManager_.prototype.onViewCreated = function (view) { this._viewListener.onViewCreated(view); };\r\n    /** @internal */\r\n    AppViewManager_.prototype.onViewDestroyed = function (view) { this._viewListener.onViewDestroyed(view); };\r\n    /** @internal */\r\n    AppViewManager_.prototype.createRenderComponentType = function (encapsulation, styles) {\r\n        return new api_1.RenderComponentType(this._appId + \"-\" + this._nextCompTypeId++, encapsulation, styles);\r\n    };\r\n    AppViewManager_.prototype._attachViewToContainer = function (view, vcAppElement, viewIndex) {\r\n        if (view.proto.type === view_type_1.ViewType.COMPONENT) {\r\n            throw new exceptions_1.BaseException(\"Component views can't be moved!\");\r\n        }\r\n        var nestedViews = vcAppElement.nestedViews;\r\n        if (nestedViews == null) {\r\n            nestedViews = [];\r\n            vcAppElement.nestedViews = nestedViews;\r\n        }\r\n        collection_1.ListWrapper.insert(nestedViews, viewIndex, view);\r\n        var refNode;\r\n        if (viewIndex > 0) {\r\n            var prevView = nestedViews[viewIndex - 1];\r\n            refNode = prevView.rootNodesOrAppElements.length > 0 ?\r\n                prevView.rootNodesOrAppElements[prevView.rootNodesOrAppElements.length - 1] :\r\n                null;\r\n        }\r\n        else {\r\n            refNode = vcAppElement.nativeElement;\r\n        }\r\n        if (lang_1.isPresent(refNode)) {\r\n            var refRenderNode;\r\n            if (refNode instanceof element_1.AppElement) {\r\n                refRenderNode = refNode.nativeElement;\r\n            }\r\n            else {\r\n                refRenderNode = refNode;\r\n            }\r\n            view.renderer.attachViewAfter(refRenderNode, view_1.flattenNestedViewRenderNodes(view.rootNodesOrAppElements));\r\n        }\r\n        // TODO: This is only needed when a view is destroyed,\r\n        // not when it is detached for reordering with ng-for...\r\n        vcAppElement.parentView.changeDetector.addContentChild(view.changeDetector);\r\n        vcAppElement.traverseAndSetQueriesAsDirty();\r\n    };\r\n    AppViewManager_.prototype._detachViewInContainer = function (vcAppElement, viewIndex) {\r\n        var view = collection_1.ListWrapper.removeAt(vcAppElement.nestedViews, viewIndex);\r\n        if (view.proto.type === view_type_1.ViewType.COMPONENT) {\r\n            throw new exceptions_1.BaseException(\"Component views can't be moved!\");\r\n        }\r\n        vcAppElement.traverseAndSetQueriesAsDirty();\r\n        view.renderer.detachView(view_1.flattenNestedViewRenderNodes(view.rootNodesOrAppElements));\r\n        // TODO: This is only needed when a view is destroyed,\r\n        // not when it is detached for reordering with ng-for...\r\n        view.changeDetector.remove();\r\n        return view;\r\n    };\r\n    AppViewManager_ = __decorate([\r\n        di_1.Injectable(),\r\n        __param(2, di_1.Inject(application_tokens_1.APP_ID)), \r\n        __metadata('design:paramtypes', [api_1.RootRenderer, view_listener_1.AppViewListener, String])\r\n    ], AppViewManager_);\r\n    return AppViewManager_;\r\n})(AppViewManager);\r\nexports.AppViewManager_ = AppViewManager_;\r\n},{\"../profile/profile\":155,\"./element\":132,\"./view\":139,\"./view_listener\":141,\"./view_type\":145,\"angular2/src/core/application_tokens\":83,\"angular2/src/core/di\":117,\"angular2/src/core/render/api\":162,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],143:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar ViewRef = (function () {\r\n    function ViewRef() {\r\n    }\r\n    Object.defineProperty(ViewRef.prototype, \"changeDetectorRef\", {\r\n        /**\r\n         * @internal\r\n         */\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    Object.defineProperty(ViewRef.prototype, \"destroyed\", {\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return ViewRef;\r\n})();\r\nexports.ViewRef = ViewRef;\r\n/**\r\n * Represents a View containing a single Element that is the Host Element of a {@link Component}\r\n * instance.\r\n *\r\n * A Host View is created for every dynamically created Component that was compiled on its own (as\r\n * opposed to as a part of another Component's Template) via {@link Compiler#compileInHost} or one\r\n * of the higher-level APIs: {@link AppViewManager#createRootHostView},\r\n * {@link AppViewManager#createHostViewInContainer}, {@link ViewContainerRef#createHostView}.\r\n */\r\nvar HostViewRef = (function (_super) {\r\n    __extends(HostViewRef, _super);\r\n    function HostViewRef() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    Object.defineProperty(HostViewRef.prototype, \"rootNodes\", {\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    return HostViewRef;\r\n})(ViewRef);\r\nexports.HostViewRef = HostViewRef;\r\n/**\r\n * Represents an Angular View.\r\n *\r\n * <!-- TODO: move the next two paragraphs to the dev guide -->\r\n * A View is a fundamental building block of the application UI. It is the smallest grouping of\r\n * Elements which are created and destroyed together.\r\n *\r\n * Properties of elements in a View can change, but the structure (number and order) of elements in\r\n * a View cannot. Changing the structure of Elements can only be done by inserting, moving or\r\n * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.\r\n * <!-- /TODO -->\r\n *\r\n * ### Example\r\n *\r\n * Given this template...\r\n *\r\n * ```\r\n * Count: {{items.length}}\r\n * <ul>\r\n *   <li *ngFor=\"var item of items\">{{item}}</li>\r\n * </ul>\r\n * ```\r\n *\r\n * ... we have two {@link ProtoViewRef}s:\r\n *\r\n * Outer {@link ProtoViewRef}:\r\n * ```\r\n * Count: {{items.length}}\r\n * <ul>\r\n *   <template ngFor var-item [ngForOf]=\"items\"></template>\r\n * </ul>\r\n * ```\r\n *\r\n * Inner {@link ProtoViewRef}:\r\n * ```\r\n *   <li>{{item}}</li>\r\n * ```\r\n *\r\n * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.\r\n *\r\n * The outer/inner {@link ProtoViewRef}s are then assembled into views like so:\r\n *\r\n * ```\r\n * <!-- ViewRef: outer-0 -->\r\n * Count: 2\r\n * <ul>\r\n *   <template view-container-ref></template>\r\n *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\r\n *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\r\n * </ul>\r\n * <!-- /ViewRef: outer-0 -->\r\n * ```\r\n */\r\nvar EmbeddedViewRef = (function (_super) {\r\n    __extends(EmbeddedViewRef, _super);\r\n    function EmbeddedViewRef() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    Object.defineProperty(EmbeddedViewRef.prototype, \"rootNodes\", {\r\n        get: function () { return exceptions_1.unimplemented(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    return EmbeddedViewRef;\r\n})(ViewRef);\r\nexports.EmbeddedViewRef = EmbeddedViewRef;\r\nvar ViewRef_ = (function () {\r\n    function ViewRef_(_view) {\r\n        this._view = _view;\r\n        this._view = _view;\r\n    }\r\n    Object.defineProperty(ViewRef_.prototype, \"internalView\", {\r\n        get: function () { return this._view; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ViewRef_.prototype, \"changeDetectorRef\", {\r\n        /**\r\n         * Return `ChangeDetectorRef`\r\n         */\r\n        get: function () { return this._view.changeDetector.ref; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ViewRef_.prototype, \"rootNodes\", {\r\n        get: function () { return this._view.flatRootNodes; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ViewRef_.prototype.setLocal = function (variableName, value) { this._view.setLocal(variableName, value); };\r\n    ViewRef_.prototype.hasLocal = function (variableName) { return this._view.hasLocal(variableName); };\r\n    Object.defineProperty(ViewRef_.prototype, \"destroyed\", {\r\n        get: function () { return this._view.destroyed; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return ViewRef_;\r\n})();\r\nexports.ViewRef_ = ViewRef_;\r\nvar HostViewFactoryRef = (function () {\r\n    function HostViewFactoryRef() {\r\n    }\r\n    return HostViewFactoryRef;\r\n})();\r\nexports.HostViewFactoryRef = HostViewFactoryRef;\r\nvar HostViewFactoryRef_ = (function () {\r\n    function HostViewFactoryRef_(_hostViewFactory) {\r\n        this._hostViewFactory = _hostViewFactory;\r\n    }\r\n    Object.defineProperty(HostViewFactoryRef_.prototype, \"internalHostViewFactory\", {\r\n        get: function () { return this._hostViewFactory; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return HostViewFactoryRef_;\r\n})();\r\nexports.HostViewFactoryRef_ = HostViewFactoryRef_;\r\n},{\"angular2/src/facade/exceptions\":173}],144:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar view_1 = require('../metadata/view');\r\nvar directives_1 = require('../metadata/directives');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar reflection_1 = require('angular2/src/core/reflection/reflection');\r\n/**\r\n * Resolves types to {@link ViewMetadata}.\r\n */\r\nvar ViewResolver = (function () {\r\n    function ViewResolver() {\r\n        /** @internal */\r\n        this._cache = new collection_1.Map();\r\n    }\r\n    ViewResolver.prototype.resolve = function (component) {\r\n        var view = this._cache.get(component);\r\n        if (lang_1.isBlank(view)) {\r\n            view = this._resolve(component);\r\n            this._cache.set(component, view);\r\n        }\r\n        return view;\r\n    };\r\n    /** @internal */\r\n    ViewResolver.prototype._resolve = function (component) {\r\n        var compMeta;\r\n        var viewMeta;\r\n        reflection_1.reflector.annotations(component).forEach(function (m) {\r\n            if (m instanceof view_1.ViewMetadata) {\r\n                viewMeta = m;\r\n            }\r\n            if (m instanceof directives_1.ComponentMetadata) {\r\n                compMeta = m;\r\n            }\r\n        });\r\n        if (lang_1.isPresent(compMeta)) {\r\n            if (lang_1.isBlank(compMeta.template) && lang_1.isBlank(compMeta.templateUrl) && lang_1.isBlank(viewMeta)) {\r\n                throw new exceptions_1.BaseException(\"Component '\" + lang_1.stringify(component) + \"' must have either 'template', 'templateUrl', or '@View' set.\");\r\n            }\r\n            else if (lang_1.isPresent(compMeta.template) && lang_1.isPresent(viewMeta)) {\r\n                this._throwMixingViewAndComponent(\"template\", component);\r\n            }\r\n            else if (lang_1.isPresent(compMeta.templateUrl) && lang_1.isPresent(viewMeta)) {\r\n                this._throwMixingViewAndComponent(\"templateUrl\", component);\r\n            }\r\n            else if (lang_1.isPresent(compMeta.directives) && lang_1.isPresent(viewMeta)) {\r\n                this._throwMixingViewAndComponent(\"directives\", component);\r\n            }\r\n            else if (lang_1.isPresent(compMeta.pipes) && lang_1.isPresent(viewMeta)) {\r\n                this._throwMixingViewAndComponent(\"pipes\", component);\r\n            }\r\n            else if (lang_1.isPresent(compMeta.encapsulation) && lang_1.isPresent(viewMeta)) {\r\n                this._throwMixingViewAndComponent(\"encapsulation\", component);\r\n            }\r\n            else if (lang_1.isPresent(compMeta.styles) && lang_1.isPresent(viewMeta)) {\r\n                this._throwMixingViewAndComponent(\"styles\", component);\r\n            }\r\n            else if (lang_1.isPresent(compMeta.styleUrls) && lang_1.isPresent(viewMeta)) {\r\n                this._throwMixingViewAndComponent(\"styleUrls\", component);\r\n            }\r\n            else if (lang_1.isPresent(viewMeta)) {\r\n                return viewMeta;\r\n            }\r\n            else {\r\n                return new view_1.ViewMetadata({\r\n                    templateUrl: compMeta.templateUrl,\r\n                    template: compMeta.template,\r\n                    directives: compMeta.directives,\r\n                    pipes: compMeta.pipes,\r\n                    encapsulation: compMeta.encapsulation,\r\n                    styles: compMeta.styles,\r\n                    styleUrls: compMeta.styleUrls\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            if (lang_1.isBlank(viewMeta)) {\r\n                throw new exceptions_1.BaseException(\"No View decorator found on component '\" + lang_1.stringify(component) + \"'\");\r\n            }\r\n            else {\r\n                return viewMeta;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /** @internal */\r\n    ViewResolver.prototype._throwMixingViewAndComponent = function (propertyName, component) {\r\n        throw new exceptions_1.BaseException(\"Component '\" + lang_1.stringify(component) + \"' cannot have both '\" + propertyName + \"' and '@View' set at the same time\\\"\");\r\n    };\r\n    ViewResolver = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], ViewResolver);\r\n    return ViewResolver;\r\n})();\r\nexports.ViewResolver = ViewResolver;\r\n},{\"../metadata/directives\":148,\"../metadata/view\":149,\"angular2/src/core/di\":117,\"angular2/src/core/reflection/reflection\":158,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],145:[function(require,module,exports){\n'use strict';(function (ViewType) {\r\n    // A view that contains the host element with bound component directive.\r\n    // Contains a COMPONENT view\r\n    ViewType[ViewType[\"HOST\"] = 0] = \"HOST\";\r\n    // The view of the component\r\n    // Can contain 0 to n EMBEDDED views\r\n    ViewType[ViewType[\"COMPONENT\"] = 1] = \"COMPONENT\";\r\n    // A view that is embedded into another View via a <template> element\r\n    // inside of a COMPONENT view\r\n    ViewType[ViewType[\"EMBEDDED\"] = 2] = \"EMBEDDED\";\r\n})(exports.ViewType || (exports.ViewType = {}));\r\nvar ViewType = exports.ViewType;\r\n},{}],146:[function(require,module,exports){\n'use strict';/**\r\n * This indirection is needed to free up Component, etc symbols in the public API\r\n * to be used by the decorator versions of these annotations.\r\n */\r\nvar di_1 = require('./metadata/di');\r\nexports.QueryMetadata = di_1.QueryMetadata;\r\nexports.ContentChildrenMetadata = di_1.ContentChildrenMetadata;\r\nexports.ContentChildMetadata = di_1.ContentChildMetadata;\r\nexports.ViewChildrenMetadata = di_1.ViewChildrenMetadata;\r\nexports.ViewQueryMetadata = di_1.ViewQueryMetadata;\r\nexports.ViewChildMetadata = di_1.ViewChildMetadata;\r\nexports.AttributeMetadata = di_1.AttributeMetadata;\r\nvar directives_1 = require('./metadata/directives');\r\nexports.ComponentMetadata = directives_1.ComponentMetadata;\r\nexports.DirectiveMetadata = directives_1.DirectiveMetadata;\r\nexports.PipeMetadata = directives_1.PipeMetadata;\r\nexports.InputMetadata = directives_1.InputMetadata;\r\nexports.OutputMetadata = directives_1.OutputMetadata;\r\nexports.HostBindingMetadata = directives_1.HostBindingMetadata;\r\nexports.HostListenerMetadata = directives_1.HostListenerMetadata;\r\nvar view_1 = require('./metadata/view');\r\nexports.ViewMetadata = view_1.ViewMetadata;\r\nexports.ViewEncapsulation = view_1.ViewEncapsulation;\r\nvar di_2 = require('./metadata/di');\r\nvar directives_2 = require('./metadata/directives');\r\nvar view_2 = require('./metadata/view');\r\nvar decorators_1 = require('./util/decorators');\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from ComponentMetadata.\r\n/**\r\n * Declare reusable UI building blocks for an application.\r\n *\r\n * Each Angular component requires a single `@Component` and at least one `@View` annotation. The\r\n * `@Component`\r\n * annotation specifies when a component is instantiated, and which properties and hostListeners it\r\n * binds to.\r\n *\r\n * When a component is instantiated, Angular\r\n * - creates a shadow DOM for the component.\r\n * - loads the selected template into the shadow DOM.\r\n * - creates all the injectable objects configured with `providers` and `viewProviders`.\r\n *\r\n * All template expressions and statements are then evaluated against the component instance.\r\n *\r\n * For details on the `@View` annotation, see {@link ViewMetadata}.\r\n *\r\n * ## Lifecycle hooks\r\n *\r\n * When the component class implements some {@link angular2/lifecycle_hooks} the callbacks are\r\n * called by the change detection at defined points in time during the life of the component.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/ts/metadata/metadata.ts region='component'}\r\n */\r\nexports.Component = decorators_1.makeDecorator(directives_2.ComponentMetadata, function (fn) { return fn.View = exports.View; });\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from DirectiveMetadata.\r\n/**\r\n * Directives allow you to attach behavior to elements in the DOM.\r\n *\r\n * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.\r\n *\r\n * A directive consists of a single directive annotation and a controller class. When the\r\n * directive's `selector` matches\r\n * elements in the DOM, the following steps occur:\r\n *\r\n * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor\r\n * arguments.\r\n * 2. Angular instantiates directives for each matched element using `ElementInjector` in a\r\n * depth-first order,\r\n *    as declared in the HTML.\r\n *\r\n * ## Understanding How Injection Works\r\n *\r\n * There are three stages of injection resolution.\r\n * - *Pre-existing Injectors*:\r\n *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if\r\n * the dependency was\r\n *     specified as `@Optional`, returns `null`.\r\n *   - The platform injector resolves browser singleton resources, such as: cookies, title,\r\n * location, and others.\r\n * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow\r\n * the same parent-child hierarchy\r\n *     as the component instances in the DOM.\r\n * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each\r\n * element has an `ElementInjector`\r\n *     which follow the same parent-child hierarchy as the DOM elements themselves.\r\n *\r\n * When a template is instantiated, it also must instantiate the corresponding directives in a\r\n * depth-first order. The\r\n * current `ElementInjector` resolves the constructor dependencies for each directive.\r\n *\r\n * Angular then resolves dependencies as follows, according to the order in which they appear in the\r\n * {@link ViewMetadata}:\r\n *\r\n * 1. Dependencies on the current element\r\n * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary\r\n * 3. Dependencies on component injectors and their parents until it encounters the root component\r\n * 4. Dependencies on pre-existing injectors\r\n *\r\n *\r\n * The `ElementInjector` can inject other directives, element-specific special objects, or it can\r\n * delegate to the parent\r\n * injector.\r\n *\r\n * To inject other directives, declare the constructor parameter as:\r\n * - `directive:DirectiveType`: a directive on the current element only\r\n * - `@Host() directive:DirectiveType`: any directive that matches the type between the current\r\n * element and the\r\n *    Shadow DOM root.\r\n * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child\r\n * directives.\r\n * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any\r\n * child directives.\r\n *\r\n * To inject element-specific special objects, declare the constructor parameter as:\r\n * - `element: ElementRef` to obtain a reference to logical element in the view.\r\n * - `viewContainer: ViewContainerRef` to control child template instantiation, for\r\n * {@link DirectiveMetadata} directives only\r\n * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.\r\n *\r\n * ### Example\r\n *\r\n * The following example demonstrates how dependency injection resolves constructor arguments in\r\n * practice.\r\n *\r\n *\r\n * Assume this HTML template:\r\n *\r\n * ```\r\n * <div dependency=\"1\">\r\n *   <div dependency=\"2\">\r\n *     <div dependency=\"3\" my-directive>\r\n *       <div dependency=\"4\">\r\n *         <div dependency=\"5\"></div>\r\n *       </div>\r\n *       <div dependency=\"6\"></div>\r\n *     </div>\r\n *   </div>\r\n * </div>\r\n * ```\r\n *\r\n * With the following `dependency` decorator and `SomeService` injectable class.\r\n *\r\n * ```\r\n * @Injectable()\r\n * class SomeService {\r\n * }\r\n *\r\n * @Directive({\r\n *   selector: '[dependency]',\r\n *   inputs: [\r\n *     'id: dependency'\r\n *   ]\r\n * })\r\n * class Dependency {\r\n *   id:string;\r\n * }\r\n * ```\r\n *\r\n * Let's step through the different ways in which `MyDirective` could be declared...\r\n *\r\n *\r\n * ### No injection\r\n *\r\n * Here the constructor is declared with no arguments, therefore nothing is injected into\r\n * `MyDirective`.\r\n *\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor() {\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This directive would be instantiated with no dependencies.\r\n *\r\n *\r\n * ### Component-level injection\r\n *\r\n * Directives can inject any injectable instance from the closest component injector or any of its\r\n * parents.\r\n *\r\n * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type\r\n * from the parent\r\n * component's injector.\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(someService: SomeService) {\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This directive would be instantiated with a dependency on `SomeService`.\r\n *\r\n *\r\n * ### Injecting a directive from the current element\r\n *\r\n * Directives can inject other directives declared on the current element.\r\n *\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(dependency: Dependency) {\r\n *     expect(dependency.id).toEqual(3);\r\n *   }\r\n * }\r\n * ```\r\n * This directive would be instantiated with `Dependency` declared at the same element, in this case\r\n * `dependency=\"3\"`.\r\n *\r\n * ### Injecting a directive from any ancestor elements\r\n *\r\n * Directives can inject other directives declared on any ancestor element (in the current Shadow\r\n * DOM), i.e. on the current element, the\r\n * parent element, or its parents.\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(@Host() dependency: Dependency) {\r\n *     expect(dependency.id).toEqual(2);\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * `@Host` checks the current element, the parent, as well as its parents recursively. If\r\n * `dependency=\"2\"` didn't\r\n * exist on the direct parent, this injection would\r\n * have returned\r\n * `dependency=\"1\"`.\r\n *\r\n *\r\n * ### Injecting a live collection of direct child directives\r\n *\r\n *\r\n * A directive can also query for other child directives. Since parent directives are instantiated\r\n * before child directives, a directive can't simply inject the list of child directives. Instead,\r\n * the directive injects a {@link QueryList}, which updates its contents as children are added,\r\n * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an\r\n * `ngIf`, or an `ngSwitch`.\r\n *\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and\r\n * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.\r\n *\r\n * ### Injecting a live collection of descendant directives\r\n *\r\n * By passing the descendant flag to `@Query` above, we can include the children of the child\r\n * elements.\r\n *\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.\r\n *\r\n * ### Optional injection\r\n *\r\n * The normal behavior of directives is to return an error when a specified dependency cannot be\r\n * resolved. If you\r\n * would like to inject `null` on unresolved dependency instead, you can annotate that dependency\r\n * with `@Optional()`.\r\n * This explicitly permits the author of a template to treat some of the surrounding directives as\r\n * optional.\r\n *\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(@Optional() dependency:Dependency) {\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This directive would be instantiated with a `Dependency` directive found on the current element.\r\n * If none can be\r\n * found, the injector supplies `null` instead of throwing an error.\r\n *\r\n * ### Example\r\n *\r\n * Here we use a decorator directive to simply define basic tool-tip behavior.\r\n *\r\n * ```\r\n * @Directive({\r\n *   selector: '[tooltip]',\r\n *   inputs: [\r\n *     'text: tooltip'\r\n *   ],\r\n *   host: {\r\n *     '(mouseenter)': 'onMouseEnter()',\r\n *     '(mouseleave)': 'onMouseLeave()'\r\n *   }\r\n * })\r\n * class Tooltip{\r\n *   text:string;\r\n *   overlay:Overlay; // NOT YET IMPLEMENTED\r\n *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED\r\n *\r\n *   constructor(overlayManager:OverlayManager) {\r\n *     this.overlay = overlay;\r\n *   }\r\n *\r\n *   onMouseEnter() {\r\n *     // exact signature to be determined\r\n *     this.overlay = this.overlayManager.open(text, ...);\r\n *   }\r\n *\r\n *   onMouseLeave() {\r\n *     this.overlay.close();\r\n *     this.overlay = null;\r\n *   }\r\n * }\r\n * ```\r\n * In our HTML template, we can then add this behavior to a `<div>` or any other element with the\r\n * `tooltip` selector,\r\n * like so:\r\n *\r\n * ```\r\n * <div tooltip=\"some text here\"></div>\r\n * ```\r\n *\r\n * Directives can also control the instantiation, destruction, and positioning of inline template\r\n * elements:\r\n *\r\n * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at\r\n * runtime.\r\n * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a\r\n * location in the current view\r\n * where these actions are performed.\r\n *\r\n * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the\r\n * `<template>` element. Thus a\r\n * directive in a child view cannot inject the directive that created it.\r\n *\r\n * Since directives that create views via ViewContainers are common in Angular, and using the full\r\n * `<template>` element syntax is wordy, Angular\r\n * also supports a shorthand notation: `<li *foo=\"bar\">` and `<li template=\"foo: bar\">` are\r\n * equivalent.\r\n *\r\n * Thus,\r\n *\r\n * ```\r\n * <ul>\r\n *   <li *foo=\"bar\" title=\"text\"></li>\r\n * </ul>\r\n * ```\r\n *\r\n * Expands in use to:\r\n *\r\n * ```\r\n * <ul>\r\n *   <template [foo]=\"bar\">\r\n *     <li title=\"text\"></li>\r\n *   </template>\r\n * </ul>\r\n * ```\r\n *\r\n * Notice that although the shorthand places `*foo=\"bar\"` within the `<li>` element, the binding for\r\n * the directive\r\n * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.\r\n *\r\n * ## Lifecycle hooks\r\n *\r\n * When the directive class implements some {@link angular2/lifecycle_hooks} the callbacks are\r\n * called by the change detection at defined points in time during the life of the directive.\r\n *\r\n * ### Example\r\n *\r\n * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.\r\n *\r\n * Here is a simple directive that triggers on an `unless` selector:\r\n *\r\n * ```\r\n * @Directive({\r\n *   selector: '[unless]',\r\n *   inputs: ['unless']\r\n * })\r\n * export class Unless {\r\n *   viewContainer: ViewContainerRef;\r\n *   templateRef: TemplateRef;\r\n *   prevCondition: boolean;\r\n *\r\n *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {\r\n *     this.viewContainer = viewContainer;\r\n *     this.templateRef = templateRef;\r\n *     this.prevCondition = null;\r\n *   }\r\n *\r\n *   set unless(newCondition) {\r\n *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {\r\n *       this.prevCondition = true;\r\n *       this.viewContainer.clear();\r\n *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {\r\n *       this.prevCondition = false;\r\n *       this.viewContainer.create(this.templateRef);\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * We can then use this `unless` selector in a template:\r\n * ```\r\n * <ul>\r\n *   <li *unless=\"expr\"></li>\r\n * </ul>\r\n * ```\r\n *\r\n * Once the directive instantiates the child view, the shorthand notation for the template expands\r\n * and the result is:\r\n *\r\n * ```\r\n * <ul>\r\n *   <template [unless]=\"exp\">\r\n *     <li></li>\r\n *   </template>\r\n *   <li></li>\r\n * </ul>\r\n * ```\r\n *\r\n * Note also that although the `<li></li>` template still exists inside the `<template></template>`,\r\n * the instantiated\r\n * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.\r\n */\r\nexports.Directive = decorators_1.makeDecorator(directives_2.DirectiveMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewMetadata.\r\n/**\r\n * Metadata properties available for configuring Views.\r\n *\r\n * Each Angular component requires a single `@Component` and at least one `@View` annotation. The\r\n * `@View` annotation specifies the HTML template to use, and lists the directives that are active\r\n * within the template.\r\n *\r\n * When a component is instantiated, the template is loaded into the component's shadow root, and\r\n * the expressions and statements in the template are evaluated against the component.\r\n *\r\n * For details on the `@Component` annotation, see {@link ComponentMetadata}.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * @Component({\r\n *   selector: 'greet',\r\n *   template: 'Hello {{name}}!',\r\n *   directives: [GreetUser, Bold]\r\n * })\r\n * class Greet {\r\n *   name: string;\r\n *\r\n *   constructor() {\r\n *     this.name = 'World';\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexports.View = decorators_1.makeDecorator(view_2.ViewMetadata, function (fn) { return fn.View = exports.View; });\r\n/**\r\n * Specifies that a constant attribute value should be injected.\r\n *\r\n * The directive can inject constant string literals of host element attributes.\r\n *\r\n * ### Example\r\n *\r\n * Suppose we have an `<input>` element and want to know its `type`.\r\n *\r\n * ```html\r\n * <input type=\"text\">\r\n * ```\r\n *\r\n * A decorator can inject string literal `text` like so:\r\n *\r\n * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\r\n */\r\nexports.Attribute = decorators_1.makeParamDecorator(di_2.AttributeMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from QueryMetadata.\r\n/**\r\n * Declares an injectable parameter to be a live list of directives or variable\r\n * bindings from the content children of a directive.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))\r\n *\r\n * Assume that `<tabs>` component would like to get a list its children `<pane>`\r\n * components as shown in this example:\r\n *\r\n * ```html\r\n * <tabs>\r\n *   <pane title=\"Overview\">...</pane>\r\n *   <pane *ngFor=\"#o of objects\" [title]=\"o.title\">{{o.text}}</pane>\r\n * </tabs>\r\n * ```\r\n *\r\n * The preferred solution is to query for `Pane` directives using this decorator.\r\n *\r\n * ```javascript\r\n * @Component({\r\n *   selector: 'pane',\r\n *   inputs: ['title']\r\n * })\r\n * class Pane {\r\n *   title:string;\r\n * }\r\n *\r\n * @Component({\r\n *  selector: 'tabs',\r\n *  template: `\r\n *    <ul>\r\n *      <li *ngFor=\"#pane of panes\">{{pane.title}}</li>\r\n *    </ul>\r\n *    <content></content>\r\n *  `\r\n * })\r\n * class Tabs {\r\n *   panes: QueryList<Pane>;\r\n *   constructor(@Query(Pane) panes:QueryList<Pane>) {\r\n *     this.panes = panes;\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * A query can look for variable bindings by passing in a string with desired binding symbol.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))\r\n * ```html\r\n * <seeker>\r\n *   <div #findme>...</div>\r\n * </seeker>\r\n *\r\n * @Component({ selector: 'foo' })\r\n * class seeker {\r\n *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}\r\n * }\r\n * ```\r\n *\r\n * In this case the object that is injected depend on the type of the variable\r\n * binding. It can be an ElementRef, a directive or a component.\r\n *\r\n * Passing in a comma separated list of variable bindings will query for all of them.\r\n *\r\n * ```html\r\n * <seeker>\r\n *   <div #findMe>...</div>\r\n *   <div #findMeToo>...</div>\r\n * </seeker>\r\n *\r\n *  @Component({\r\n *   selector: 'foo'\r\n * })\r\n * class Seeker {\r\n *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}\r\n * }\r\n * ```\r\n *\r\n * Configure whether query looks for direct children or all descendants\r\n * of the querying element, by using the `descendants` parameter.\r\n * It is set to `false` by default.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))\r\n * ```html\r\n * <container #first>\r\n *   <item>a</item>\r\n *   <item>b</item>\r\n *   <container #second>\r\n *     <item>c</item>\r\n *   </container>\r\n * </container>\r\n * ```\r\n *\r\n * When querying for items, the first container will see only `a` and `b` by default,\r\n * but with `Query(TextDirective, {descendants: true})` it will see `c` too.\r\n *\r\n * The queried directives are kept in a depth-first pre-order with respect to their\r\n * positions in the DOM.\r\n *\r\n * Query does not look deep into any subcomponent views.\r\n *\r\n * Query is updated as part of the change-detection cycle. Since change detection\r\n * happens after construction of a directive, QueryList will always be empty when observed in the\r\n * constructor.\r\n *\r\n * The injected object is an unmodifiable live list.\r\n * See {@link QueryList} for more details.\r\n */\r\nexports.Query = decorators_1.makeParamDecorator(di_2.QueryMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildrenMetadata.\r\n/**\r\n * Configures a content query.\r\n *\r\n * Content queries are set before the `ngAfterContentInit` callback is called.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * @Directive({\r\n *   selector: 'someDir'\r\n * })\r\n * class SomeDir {\r\n *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;\r\n *\r\n *   ngAfterContentInit() {\r\n *     // contentChildren is set\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexports.ContentChildren = decorators_1.makePropDecorator(di_2.ContentChildrenMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildMetadata.\r\n/**\r\n * Configures a content query.\r\n *\r\n * Content queries are set before the `ngAfterContentInit` callback is called.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * @Directive({\r\n *   selector: 'someDir'\r\n * })\r\n * class SomeDir {\r\n *   @ContentChild(ChildDirective) contentChild;\r\n *\r\n *   ngAfterContentInit() {\r\n *     // contentChild is set\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexports.ContentChild = decorators_1.makePropDecorator(di_2.ContentChildMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildrenMetadata.\r\n/**\r\n * Configures a view query.\r\n *\r\n * View queries are set before the `ngAfterViewInit` callback is called.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * @Component({\r\n *   selector: 'someDir',\r\n *   templateUrl: 'someTemplate',\r\n *   directives: [ItemDirective]\r\n * })\r\n * class SomeDir {\r\n *   @ViewChildren(ItemDirective) viewChildren: QueryList<ItemDirective>;\r\n *\r\n *   ngAfterViewInit() {\r\n *     // viewChildren is set\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexports.ViewChildren = decorators_1.makePropDecorator(di_2.ViewChildrenMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildMetadata.\r\n/**\r\n * Configures a view query.\r\n *\r\n * View queries are set before the `ngAfterViewInit` callback is called.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * @Component({\r\n *   selector: 'someDir',\r\n *   templateUrl: 'someTemplate',\r\n *   directives: [ItemDirective]\r\n * })\r\n * class SomeDir {\r\n *   @ViewChild(ItemDirective) viewChild:ItemDirective;\r\n *\r\n *   ngAfterViewInit() {\r\n *     // viewChild is set\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexports.ViewChild = decorators_1.makePropDecorator(di_2.ViewChildMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewQueryMetadata.\r\n/**\r\n * Similar to {@link QueryMetadata}, but querying the component view, instead of\r\n * the content children.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))\r\n *\r\n * ```javascript\r\n * @Component({...})\r\n * @View({\r\n *   template: `\r\n *     <item> a </item>\r\n *     <item> b </item>\r\n *     <item> c </item>\r\n *   `\r\n * })\r\n * class MyComponent {\r\n *   shown: boolean;\r\n *\r\n *   constructor(private @Query(Item) items:QueryList<Item>) {\r\n *     items.onChange(() => console.log(items.length));\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Supports the same querying parameters as {@link QueryMetadata}, except\r\n * `descendants`. This always queries the whole view.\r\n *\r\n * As `shown` is flipped between true and false, items will contain zero of one\r\n * items.\r\n *\r\n * Specifies that a {@link QueryList} should be injected.\r\n *\r\n * The injected object is an iterable and observable live list.\r\n * See {@link QueryList} for more details.\r\n */\r\nexports.ViewQuery = decorators_1.makeParamDecorator(di_2.ViewQueryMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from PipeMetadata.\r\n/**\r\n * Declare reusable pipe function.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/ts/metadata/metadata.ts region='pipe'}\r\n */\r\nexports.Pipe = decorators_1.makeDecorator(directives_2.PipeMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from InputMetadata.\r\n/**\r\n * Declares a data-bound input property.\r\n *\r\n * Angular automatically updates data-bound properties during change detection.\r\n *\r\n * `InputMetadata` takes an optional parameter that specifies the name\r\n * used when instantiating a component in the template. When not provided,\r\n * the name of the decorated property is used.\r\n *\r\n * ### Example\r\n *\r\n * The following example creates a component with two input properties.\r\n *\r\n * ```typescript\r\n * @Component({\r\n *   selector: 'bank-account',\r\n *   template: `\r\n *     Bank Name: {{bankName}}\r\n *     Account Id: {{id}}\r\n *   `\r\n * })\r\n * class BankAccount {\r\n *   @Input() bankName: string;\r\n *   @Input('account-id') id: string;\r\n *\r\n *   // this property is not bound, and won't be automatically updated by Angular\r\n *   normalizedBankName: string;\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   template: `\r\n *     <bank-account bank-name=\"RBC\" account-id=\"4747\"></bank-account>\r\n *   `,\r\n *   directives: [BankAccount]\r\n * })\r\n * class App {}\r\n *\r\n * bootstrap(App);\r\n * ```\r\n */\r\nexports.Input = decorators_1.makePropDecorator(directives_2.InputMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from OutputMetadata.\r\n/**\r\n * Declares an event-bound output property.\r\n *\r\n * When an output property emits an event, an event handler attached to that event\r\n * the template is invoked.\r\n *\r\n * `OutputMetadata` takes an optional parameter that specifies the name\r\n * used when instantiating a component in the template. When not provided,\r\n * the name of the decorated property is used.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * @Directive({\r\n *   selector: 'interval-dir',\r\n * })\r\n * class IntervalDir {\r\n *   @Output() everySecond = new EventEmitter();\r\n *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();\r\n *\r\n *   constructor() {\r\n *     setInterval(() => this.everySecond.emit(\"event\"), 1000);\r\n *     setInterval(() => this.five5Secs.emit(\"event\"), 5000);\r\n *   }\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   template: `\r\n *     <interval-dir (every-second)=\"everySecond()\" (every-five-seconds)=\"everyFiveSeconds()\">\r\n *     </interval-dir>\r\n *   `,\r\n *   directives: [IntervalDir]\r\n * })\r\n * class App {\r\n *   everySecond() { console.log('second'); }\r\n *   everyFiveSeconds() { console.log('five seconds'); }\r\n * }\r\n * bootstrap(App);\r\n * ```\r\n */\r\nexports.Output = decorators_1.makePropDecorator(directives_2.OutputMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from HostBindingMetadata.\r\n/**\r\n * Declares a host property binding.\r\n *\r\n * Angular automatically checks host property bindings during change detection.\r\n * If a binding changes, it will update the host element of the directive.\r\n *\r\n * `HostBindingMetadata` takes an optional parameter that specifies the property\r\n * name of the host element that will be updated. When not provided,\r\n * the class property name is used.\r\n *\r\n * ### Example\r\n *\r\n * The following example creates a directive that sets the `valid` and `invalid` classes\r\n * on the DOM element that has ngModel directive on it.\r\n *\r\n * ```typescript\r\n * @Directive({selector: '[ngModel]'})\r\n * class NgModelStatus {\r\n *   constructor(public control:NgModel) {}\r\n *   @HostBinding('[class.valid]') get valid { return this.control.valid; }\r\n *   @HostBinding('[class.invalid]') get invalid { return this.control.invalid; }\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   template: `<input [(ngModel)]=\"prop\">`,\r\n *   directives: [FORM_DIRECTIVES, NgModelStatus]\r\n * })\r\n * class App {\r\n *   prop;\r\n * }\r\n *\r\n * bootstrap(App);\r\n * ```\r\n */\r\nexports.HostBinding = decorators_1.makePropDecorator(directives_2.HostBindingMetadata);\r\n// TODO(alexeagle): remove the duplication of this doc. It is copied from HostListenerMetadata.\r\n/**\r\n * Declares a host listener.\r\n *\r\n * Angular will invoke the decorated method when the host element emits the specified event.\r\n *\r\n * If the decorated method returns `false`, then `preventDefault` is applied on the DOM\r\n * event.\r\n *\r\n * ### Example\r\n *\r\n * The following example declares a directive that attaches a click listener to the button and\r\n * counts clicks.\r\n *\r\n * ```typescript\r\n * @Directive({selector: 'button[counting]'})\r\n * class CountClicks {\r\n *   numberOfClicks = 0;\r\n *\r\n *   @HostListener('click', ['$event.target'])\r\n *   onClick(btn) {\r\n *     console.log(\"button\", btn, \"number of clicks:\", this.numberOfClicks++);\r\n *   }\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   template: `<button counting>Increment</button>`,\r\n *   directives: [CountClicks]\r\n * })\r\n * class App {}\r\n *\r\n * bootstrap(App);\r\n * ```\r\n */\r\nexports.HostListener = decorators_1.makePropDecorator(directives_2.HostListenerMetadata);\r\n},{\"./metadata/di\":147,\"./metadata/directives\":148,\"./metadata/view\":149,\"./util/decorators\":166}],147:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar metadata_1 = require('angular2/src/core/di/metadata');\r\n/**\r\n * Specifies that a constant attribute value should be injected.\r\n *\r\n * The directive can inject constant string literals of host element attributes.\r\n *\r\n * ### Example\r\n *\r\n * Suppose we have an `<input>` element and want to know its `type`.\r\n *\r\n * ```html\r\n * <input type=\"text\">\r\n * ```\r\n *\r\n * A decorator can inject string literal `text` like so:\r\n *\r\n * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\r\n */\r\nvar AttributeMetadata = (function (_super) {\r\n    __extends(AttributeMetadata, _super);\r\n    function AttributeMetadata(attributeName) {\r\n        _super.call(this);\r\n        this.attributeName = attributeName;\r\n    }\r\n    Object.defineProperty(AttributeMetadata.prototype, \"token\", {\r\n        get: function () {\r\n            // Normally one would default a token to a type of an injected value but here\r\n            // the type of a variable is \"string\" and we can't use primitive type as a return value\r\n            // so we use instance of Attribute instead. This doesn't matter much in practice as arguments\r\n            // with @Attribute annotation are injected by ElementInjector that doesn't take tokens into\r\n            // account.\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    AttributeMetadata.prototype.toString = function () { return \"@Attribute(\" + lang_1.stringify(this.attributeName) + \")\"; };\r\n    AttributeMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [String])\r\n    ], AttributeMetadata);\r\n    return AttributeMetadata;\r\n})(metadata_1.DependencyMetadata);\r\nexports.AttributeMetadata = AttributeMetadata;\r\n/**\r\n * Declares an injectable parameter to be a live list of directives or variable\r\n * bindings from the content children of a directive.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))\r\n *\r\n * Assume that `<tabs>` component would like to get a list its children `<pane>`\r\n * components as shown in this example:\r\n *\r\n * ```html\r\n * <tabs>\r\n *   <pane title=\"Overview\">...</pane>\r\n *   <pane *ngFor=\"#o of objects\" [title]=\"o.title\">{{o.text}}</pane>\r\n * </tabs>\r\n * ```\r\n *\r\n * The preferred solution is to query for `Pane` directives using this decorator.\r\n *\r\n * ```javascript\r\n * @Component({\r\n *   selector: 'pane',\r\n *   inputs: ['title']\r\n * })\r\n * class Pane {\r\n *   title:string;\r\n * }\r\n *\r\n * @Component({\r\n *  selector: 'tabs',\r\n *  template: `\r\n *    <ul>\r\n *      <li *ngFor=\"#pane of panes\">{{pane.title}}</li>\r\n *    </ul>\r\n *    <content></content>\r\n *  `\r\n * })\r\n * class Tabs {\r\n *   panes: QueryList<Pane>;\r\n *   constructor(@Query(Pane) panes:QueryList<Pane>) {\r\n  *    this.panes = panes;\r\n  *  }\r\n * }\r\n * ```\r\n *\r\n * A query can look for variable bindings by passing in a string with desired binding symbol.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))\r\n * ```html\r\n * <seeker>\r\n *   <div #findme>...</div>\r\n * </seeker>\r\n *\r\n * @Component({ selector: 'seeker' })\r\n * class Seeker {\r\n *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}\r\n * }\r\n * ```\r\n *\r\n * In this case the object that is injected depend on the type of the variable\r\n * binding. It can be an ElementRef, a directive or a component.\r\n *\r\n * Passing in a comma separated list of variable bindings will query for all of them.\r\n *\r\n * ```html\r\n * <seeker>\r\n *   <div #find-me>...</div>\r\n *   <div #find-me-too>...</div>\r\n * </seeker>\r\n *\r\n *  @Component({\r\n *   selector: 'seeker'\r\n * })\r\n * class Seeker {\r\n *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}\r\n * }\r\n * ```\r\n *\r\n * Configure whether query looks for direct children or all descendants\r\n * of the querying element, by using the `descendants` parameter.\r\n * It is set to `false` by default.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))\r\n * ```html\r\n * <container #first>\r\n *   <item>a</item>\r\n *   <item>b</item>\r\n *   <container #second>\r\n *     <item>c</item>\r\n *   </container>\r\n * </container>\r\n * ```\r\n *\r\n * When querying for items, the first container will see only `a` and `b` by default,\r\n * but with `Query(TextDirective, {descendants: true})` it will see `c` too.\r\n *\r\n * The queried directives are kept in a depth-first pre-order with respect to their\r\n * positions in the DOM.\r\n *\r\n * Query does not look deep into any subcomponent views.\r\n *\r\n * Query is updated as part of the change-detection cycle. Since change detection\r\n * happens after construction of a directive, QueryList will always be empty when observed in the\r\n * constructor.\r\n *\r\n * The injected object is an unmodifiable live list.\r\n * See {@link QueryList} for more details.\r\n */\r\nvar QueryMetadata = (function (_super) {\r\n    __extends(QueryMetadata, _super);\r\n    function QueryMetadata(_selector, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d;\r\n        _super.call(this);\r\n        this._selector = _selector;\r\n        this.descendants = descendants;\r\n        this.first = first;\r\n    }\r\n    Object.defineProperty(QueryMetadata.prototype, \"isViewQuery\", {\r\n        /**\r\n         * always `false` to differentiate it with {@link ViewQueryMetadata}.\r\n         */\r\n        get: function () { return false; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(QueryMetadata.prototype, \"selector\", {\r\n        /**\r\n         * what this is querying for.\r\n         */\r\n        get: function () { return di_1.resolveForwardRef(this._selector); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(QueryMetadata.prototype, \"isVarBindingQuery\", {\r\n        /**\r\n         * whether this is querying for a variable binding or a directive.\r\n         */\r\n        get: function () { return lang_1.isString(this.selector); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(QueryMetadata.prototype, \"varBindings\", {\r\n        /**\r\n         * returns a list of variable bindings this is querying for.\r\n         * Only applicable if this is a variable bindings query.\r\n         */\r\n        get: function () { return this.selector.split(','); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    QueryMetadata.prototype.toString = function () { return \"@Query(\" + lang_1.stringify(this.selector) + \")\"; };\r\n    QueryMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object, Object])\r\n    ], QueryMetadata);\r\n    return QueryMetadata;\r\n})(metadata_1.DependencyMetadata);\r\nexports.QueryMetadata = QueryMetadata;\r\n// TODO: add an example after ContentChildren and ViewChildren are in master\r\n/**\r\n * Configures a content query.\r\n *\r\n * Content queries are set before the `ngAfterContentInit` callback is called.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * @Directive({\r\n *   selector: 'someDir'\r\n * })\r\n * class SomeDir {\r\n *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;\r\n *\r\n *   ngAfterContentInit() {\r\n *     // contentChildren is set\r\n *   }\r\n * }\r\n * ```\r\n */\r\nvar ContentChildrenMetadata = (function (_super) {\r\n    __extends(ContentChildrenMetadata, _super);\r\n    function ContentChildrenMetadata(_selector, _a) {\r\n        var _b = (_a === void 0 ? {} : _a).descendants, descendants = _b === void 0 ? false : _b;\r\n        _super.call(this, _selector, { descendants: descendants });\r\n    }\r\n    ContentChildrenMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object, Object])\r\n    ], ContentChildrenMetadata);\r\n    return ContentChildrenMetadata;\r\n})(QueryMetadata);\r\nexports.ContentChildrenMetadata = ContentChildrenMetadata;\r\n// TODO: add an example after ContentChild and ViewChild are in master\r\n/**\r\n * Configures a content query.\r\n *\r\n * Content queries are set before the `ngAfterContentInit` callback is called.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * @Directive({\r\n *   selector: 'someDir'\r\n * })\r\n * class SomeDir {\r\n *   @ContentChild(ChildDirective) contentChild;\r\n *\r\n *   ngAfterContentInit() {\r\n *     // contentChild is set\r\n *   }\r\n * }\r\n * ```\r\n */\r\nvar ContentChildMetadata = (function (_super) {\r\n    __extends(ContentChildMetadata, _super);\r\n    function ContentChildMetadata(_selector) {\r\n        _super.call(this, _selector, { descendants: true, first: true });\r\n    }\r\n    ContentChildMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object])\r\n    ], ContentChildMetadata);\r\n    return ContentChildMetadata;\r\n})(QueryMetadata);\r\nexports.ContentChildMetadata = ContentChildMetadata;\r\n/**\r\n * Similar to {@link QueryMetadata}, but querying the component view, instead of\r\n * the content children.\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))\r\n *\r\n * ```javascript\r\n * @Component({...})\r\n * @View({\r\n *   template: `\r\n *     <item> a </item>\r\n *     <item> b </item>\r\n *     <item> c </item>\r\n *   `\r\n * })\r\n * class MyComponent {\r\n *   shown: boolean;\r\n *\r\n *   constructor(private @Query(Item) items:QueryList<Item>) {\r\n *     items.onChange(() => console.log(items.length));\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Supports the same querying parameters as {@link QueryMetadata}, except\r\n * `descendants`. This always queries the whole view.\r\n *\r\n * As `shown` is flipped between true and false, items will contain zero of one\r\n * items.\r\n *\r\n * Specifies that a {@link QueryList} should be injected.\r\n *\r\n * The injected object is an iterable and observable live list.\r\n * See {@link QueryList} for more details.\r\n */\r\nvar ViewQueryMetadata = (function (_super) {\r\n    __extends(ViewQueryMetadata, _super);\r\n    function ViewQueryMetadata(_selector, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d;\r\n        _super.call(this, _selector, { descendants: descendants, first: first });\r\n    }\r\n    Object.defineProperty(ViewQueryMetadata.prototype, \"isViewQuery\", {\r\n        /**\r\n         * always `true` to differentiate it with {@link QueryMetadata}.\r\n         */\r\n        get: function () { return true; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ViewQueryMetadata.prototype.toString = function () { return \"@ViewQuery(\" + lang_1.stringify(this.selector) + \")\"; };\r\n    ViewQueryMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object, Object])\r\n    ], ViewQueryMetadata);\r\n    return ViewQueryMetadata;\r\n})(QueryMetadata);\r\nexports.ViewQueryMetadata = ViewQueryMetadata;\r\n/**\r\n * Configures a view query.\r\n *\r\n * View queries are set before the `ngAfterViewInit` callback is called.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * @Component({\r\n *   selector: 'someDir',\r\n *   templateUrl: 'someTemplate',\r\n *   directives: [ItemDirective]\r\n * })\r\n * class SomeDir {\r\n *   @ViewChildren(ItemDirective) viewChildren: QueryList<ItemDirective>;\r\n *\r\n *   ngAfterViewInit() {\r\n *     // viewChildren is set\r\n *   }\r\n * }\r\n * ```\r\n */\r\nvar ViewChildrenMetadata = (function (_super) {\r\n    __extends(ViewChildrenMetadata, _super);\r\n    function ViewChildrenMetadata(_selector) {\r\n        _super.call(this, _selector, { descendants: true });\r\n    }\r\n    ViewChildrenMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object])\r\n    ], ViewChildrenMetadata);\r\n    return ViewChildrenMetadata;\r\n})(ViewQueryMetadata);\r\nexports.ViewChildrenMetadata = ViewChildrenMetadata;\r\n/**\r\n * Configures a view query.\r\n *\r\n * View queries are set before the `ngAfterViewInit` callback is called.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * @Component({\r\n *   selector: 'someDir',\r\n *   templateUrl: 'someTemplate',\r\n *   directives: [ItemDirective]\r\n * })\r\n * class SomeDir {\r\n *   @ViewChild(ItemDirective) viewChild:ItemDirective;\r\n *\r\n *   ngAfterViewInit() {\r\n *     // viewChild is set\r\n *   }\r\n * }\r\n * ```\r\n */\r\nvar ViewChildMetadata = (function (_super) {\r\n    __extends(ViewChildMetadata, _super);\r\n    function ViewChildMetadata(_selector) {\r\n        _super.call(this, _selector, { descendants: true, first: true });\r\n    }\r\n    ViewChildMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object])\r\n    ], ViewChildMetadata);\r\n    return ViewChildMetadata;\r\n})(ViewQueryMetadata);\r\nexports.ViewChildMetadata = ViewChildMetadata;\r\n},{\"angular2/src/core/di\":117,\"angular2/src/core/di/metadata\":123,\"angular2/src/facade/lang\":176}],148:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar metadata_1 = require('angular2/src/core/di/metadata');\r\nvar change_detection_1 = require('angular2/src/core/change_detection');\r\n/**\r\n * Directives allow you to attach behavior to elements in the DOM.\r\n *\r\n * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.\r\n *\r\n * A directive consists of a single directive annotation and a controller class. When the\r\n * directive's `selector` matches\r\n * elements in the DOM, the following steps occur:\r\n *\r\n * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor\r\n * arguments.\r\n * 2. Angular instantiates directives for each matched element using `ElementInjector` in a\r\n * depth-first order,\r\n *    as declared in the HTML.\r\n *\r\n * ## Understanding How Injection Works\r\n *\r\n * There are three stages of injection resolution.\r\n * - *Pre-existing Injectors*:\r\n *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if\r\n * the dependency was\r\n *     specified as `@Optional`, returns `null`.\r\n *   - The platform injector resolves browser singleton resources, such as: cookies, title,\r\n * location, and others.\r\n * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow\r\n * the same parent-child hierarchy\r\n *     as the component instances in the DOM.\r\n * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each\r\n * element has an `ElementInjector`\r\n *     which follow the same parent-child hierarchy as the DOM elements themselves.\r\n *\r\n * When a template is instantiated, it also must instantiate the corresponding directives in a\r\n * depth-first order. The\r\n * current `ElementInjector` resolves the constructor dependencies for each directive.\r\n *\r\n * Angular then resolves dependencies as follows, according to the order in which they appear in the\r\n * {@link ViewMetadata}:\r\n *\r\n * 1. Dependencies on the current element\r\n * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary\r\n * 3. Dependencies on component injectors and their parents until it encounters the root component\r\n * 4. Dependencies on pre-existing injectors\r\n *\r\n *\r\n * The `ElementInjector` can inject other directives, element-specific special objects, or it can\r\n * delegate to the parent\r\n * injector.\r\n *\r\n * To inject other directives, declare the constructor parameter as:\r\n * - `directive:DirectiveType`: a directive on the current element only\r\n * - `@Host() directive:DirectiveType`: any directive that matches the type between the current\r\n * element and the\r\n *    Shadow DOM root.\r\n * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child\r\n * directives.\r\n * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any\r\n * child directives.\r\n *\r\n * To inject element-specific special objects, declare the constructor parameter as:\r\n * - `element: ElementRef` to obtain a reference to logical element in the view.\r\n * - `viewContainer: ViewContainerRef` to control child template instantiation, for\r\n * {@link DirectiveMetadata} directives only\r\n * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.\r\n *\r\n * ### Example\r\n *\r\n * The following example demonstrates how dependency injection resolves constructor arguments in\r\n * practice.\r\n *\r\n *\r\n * Assume this HTML template:\r\n *\r\n * ```\r\n * <div dependency=\"1\">\r\n *   <div dependency=\"2\">\r\n *     <div dependency=\"3\" my-directive>\r\n *       <div dependency=\"4\">\r\n *         <div dependency=\"5\"></div>\r\n *       </div>\r\n *       <div dependency=\"6\"></div>\r\n *     </div>\r\n *   </div>\r\n * </div>\r\n * ```\r\n *\r\n * With the following `dependency` decorator and `SomeService` injectable class.\r\n *\r\n * ```\r\n * @Injectable()\r\n * class SomeService {\r\n * }\r\n *\r\n * @Directive({\r\n *   selector: '[dependency]',\r\n *   inputs: [\r\n *     'id: dependency'\r\n *   ]\r\n * })\r\n * class Dependency {\r\n *   id:string;\r\n * }\r\n * ```\r\n *\r\n * Let's step through the different ways in which `MyDirective` could be declared...\r\n *\r\n *\r\n * ### No injection\r\n *\r\n * Here the constructor is declared with no arguments, therefore nothing is injected into\r\n * `MyDirective`.\r\n *\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor() {\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This directive would be instantiated with no dependencies.\r\n *\r\n *\r\n * ### Component-level injection\r\n *\r\n * Directives can inject any injectable instance from the closest component injector or any of its\r\n * parents.\r\n *\r\n * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type\r\n * from the parent\r\n * component's injector.\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(someService: SomeService) {\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This directive would be instantiated with a dependency on `SomeService`.\r\n *\r\n *\r\n * ### Injecting a directive from the current element\r\n *\r\n * Directives can inject other directives declared on the current element.\r\n *\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(dependency: Dependency) {\r\n *     expect(dependency.id).toEqual(3);\r\n *   }\r\n * }\r\n * ```\r\n * This directive would be instantiated with `Dependency` declared at the same element, in this case\r\n * `dependency=\"3\"`.\r\n *\r\n * ### Injecting a directive from any ancestor elements\r\n *\r\n * Directives can inject other directives declared on any ancestor element (in the current Shadow\r\n * DOM), i.e. on the current element, the\r\n * parent element, or its parents.\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(@Host() dependency: Dependency) {\r\n *     expect(dependency.id).toEqual(2);\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * `@Host` checks the current element, the parent, as well as its parents recursively. If\r\n * `dependency=\"2\"` didn't\r\n * exist on the direct parent, this injection would\r\n * have returned\r\n * `dependency=\"1\"`.\r\n *\r\n *\r\n * ### Injecting a live collection of direct child directives\r\n *\r\n *\r\n * A directive can also query for other child directives. Since parent directives are instantiated\r\n * before child directives, a directive can't simply inject the list of child directives. Instead,\r\n * the directive injects a {@link QueryList}, which updates its contents as children are added,\r\n * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an\r\n * `ngIf`, or an `ngSwitch`.\r\n *\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and\r\n * `Dependency` 6. Here, `Dependency` 5 would not be included, because it is not a direct child.\r\n *\r\n * ### Injecting a live collection of descendant directives\r\n *\r\n * By passing the descendant flag to `@Query` above, we can include the children of the child\r\n * elements.\r\n *\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.\r\n *\r\n * ### Optional injection\r\n *\r\n * The normal behavior of directives is to return an error when a specified dependency cannot be\r\n * resolved. If you\r\n * would like to inject `null` on unresolved dependency instead, you can annotate that dependency\r\n * with `@Optional()`.\r\n * This explicitly permits the author of a template to treat some of the surrounding directives as\r\n * optional.\r\n *\r\n * ```\r\n * @Directive({ selector: '[my-directive]' })\r\n * class MyDirective {\r\n *   constructor(@Optional() dependency:Dependency) {\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * This directive would be instantiated with a `Dependency` directive found on the current element.\r\n * If none can be\r\n * found, the injector supplies `null` instead of throwing an error.\r\n *\r\n * ### Example\r\n *\r\n * Here we use a decorator directive to simply define basic tool-tip behavior.\r\n *\r\n * ```\r\n * @Directive({\r\n *   selector: '[tooltip]',\r\n *   inputs: [\r\n *     'text: tooltip'\r\n *   ],\r\n *   host: {\r\n *     '(mouseenter)': 'onMouseEnter()',\r\n *     '(mouseleave)': 'onMouseLeave()'\r\n *   }\r\n * })\r\n * class Tooltip{\r\n *   text:string;\r\n *   overlay:Overlay; // NOT YET IMPLEMENTED\r\n *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED\r\n *\r\n *   constructor(overlayManager:OverlayManager) {\r\n *     this.overlay = overlay;\r\n *   }\r\n *\r\n *   onMouseEnter() {\r\n *     // exact signature to be determined\r\n *     this.overlay = this.overlayManager.open(text, ...);\r\n *   }\r\n *\r\n *   onMouseLeave() {\r\n *     this.overlay.close();\r\n *     this.overlay = null;\r\n *   }\r\n * }\r\n * ```\r\n * In our HTML template, we can then add this behavior to a `<div>` or any other element with the\r\n * `tooltip` selector,\r\n * like so:\r\n *\r\n * ```\r\n * <div tooltip=\"some text here\"></div>\r\n * ```\r\n *\r\n * Directives can also control the instantiation, destruction, and positioning of inline template\r\n * elements:\r\n *\r\n * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at\r\n * runtime.\r\n * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a\r\n * location in the current view\r\n * where these actions are performed.\r\n *\r\n * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the\r\n * `<template>` element. Thus a\r\n * directive in a child view cannot inject the directive that created it.\r\n *\r\n * Since directives that create views via ViewContainers are common in Angular, and using the full\r\n * `<template>` element syntax is wordy, Angular\r\n * also supports a shorthand notation: `<li *foo=\"bar\">` and `<li template=\"foo: bar\">` are\r\n * equivalent.\r\n *\r\n * Thus,\r\n *\r\n * ```\r\n * <ul>\r\n *   <li *foo=\"bar\" title=\"text\"></li>\r\n * </ul>\r\n * ```\r\n *\r\n * Expands in use to:\r\n *\r\n * ```\r\n * <ul>\r\n *   <template [foo]=\"bar\">\r\n *     <li title=\"text\"></li>\r\n *   </template>\r\n * </ul>\r\n * ```\r\n *\r\n * Notice that although the shorthand places `*foo=\"bar\"` within the `<li>` element, the binding for\r\n * the directive\r\n * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.\r\n *\r\n * ## Lifecycle hooks\r\n *\r\n * When the directive class implements some {@link angular2/lifecycle_hooks} the callbacks are\r\n * called by the change detection at defined points in time during the life of the directive.\r\n *\r\n * ### Example\r\n *\r\n * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.\r\n *\r\n * Here is a simple directive that triggers on an `unless` selector:\r\n *\r\n * ```\r\n * @Directive({\r\n *   selector: '[unless]',\r\n *   inputs: ['unless']\r\n * })\r\n * export class Unless {\r\n *   viewContainer: ViewContainerRef;\r\n *   templateRef: TemplateRef;\r\n *   prevCondition: boolean;\r\n *\r\n *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {\r\n *     this.viewContainer = viewContainer;\r\n *     this.templateRef = templateRef;\r\n *     this.prevCondition = null;\r\n *   }\r\n *\r\n *   set unless(newCondition) {\r\n *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {\r\n *       this.prevCondition = true;\r\n *       this.viewContainer.clear();\r\n *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {\r\n *       this.prevCondition = false;\r\n *       this.viewContainer.create(this.templateRef);\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * We can then use this `unless` selector in a template:\r\n * ```\r\n * <ul>\r\n *   <li *unless=\"expr\"></li>\r\n * </ul>\r\n * ```\r\n *\r\n * Once the directive instantiates the child view, the shorthand notation for the template expands\r\n * and the result is:\r\n *\r\n * ```\r\n * <ul>\r\n *   <template [unless]=\"exp\">\r\n *     <li></li>\r\n *   </template>\r\n *   <li></li>\r\n * </ul>\r\n * ```\r\n *\r\n * Note also that although the `<li></li>` template still exists inside the `<template></template>`,\r\n * the instantiated\r\n * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.\r\n */\r\nvar DirectiveMetadata = (function (_super) {\r\n    __extends(DirectiveMetadata, _super);\r\n    function DirectiveMetadata(_a) {\r\n        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, bindings = _b.bindings, providers = _b.providers, exportAs = _b.exportAs, queries = _b.queries;\r\n        _super.call(this);\r\n        this.selector = selector;\r\n        this._inputs = inputs;\r\n        this._properties = properties;\r\n        this._outputs = outputs;\r\n        this._events = events;\r\n        this.host = host;\r\n        this.exportAs = exportAs;\r\n        this.queries = queries;\r\n        this._providers = providers;\r\n        this._bindings = bindings;\r\n    }\r\n    Object.defineProperty(DirectiveMetadata.prototype, \"inputs\", {\r\n        /**\r\n         * Enumerates the set of data-bound input properties for a directive\r\n         *\r\n         * Angular automatically updates input properties during change detection.\r\n         *\r\n         * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`\r\n         * configuration:\r\n         *\r\n         * - `directiveProperty` specifies the component property where the value is written.\r\n         * - `bindingProperty` specifies the DOM property where the value is read from.\r\n         *\r\n         * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.\r\n         *\r\n         * ### Example ([live demo](http://plnkr.co/edit/ivhfXY?p=preview))\r\n         *\r\n         * The following example creates a component with two data-bound properties.\r\n         *\r\n         * ```typescript\r\n         * @Component({\r\n         *   selector: 'bank-account',\r\n         *   inputs: ['bankName', 'id: account-id'],\r\n         *   template: `\r\n         *     Bank Name: {{bankName}}\r\n         *     Account Id: {{id}}\r\n         *   `\r\n         * })\r\n         * class BankAccount {\r\n         *   bankName: string;\r\n         *   id: string;\r\n         *\r\n         *   // this property is not bound, and won't be automatically updated by Angular\r\n         *   normalizedBankName: string;\r\n         * }\r\n         *\r\n         * @Component({\r\n         *   selector: 'app',\r\n         *   template: `\r\n         *     <bank-account bank-name=\"RBC\" account-id=\"4747\"></bank-account>\r\n         *   `,\r\n         *   directives: [BankAccount]\r\n         * })\r\n         * class App {}\r\n         *\r\n         * bootstrap(App);\r\n         * ```\r\n         *\r\n         */\r\n        get: function () {\r\n            return lang_1.isPresent(this._properties) && this._properties.length > 0 ? this._properties :\r\n                this._inputs;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DirectiveMetadata.prototype, \"properties\", {\r\n        get: function () { return this.inputs; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DirectiveMetadata.prototype, \"outputs\", {\r\n        /**\r\n         * Enumerates the set of event-bound output properties.\r\n         *\r\n         * When an output property emits an event, an event handler attached to that event\r\n         * the template is invoked.\r\n         *\r\n         * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`\r\n         * configuration:\r\n         *\r\n         * - `directiveProperty` specifies the component property that emits events.\r\n         * - `bindingProperty` specifies the DOM property the event handler is attached to.\r\n         *\r\n         * ### Example ([live demo](http://plnkr.co/edit/d5CNq7?p=preview))\r\n         *\r\n         * ```typescript\r\n         * @Directive({\r\n         *   selector: 'interval-dir',\r\n         *   outputs: ['everySecond', 'five5Secs: everyFiveSeconds']\r\n         * })\r\n         * class IntervalDir {\r\n         *   everySecond = new EventEmitter();\r\n         *   five5Secs = new EventEmitter();\r\n         *\r\n         *   constructor() {\r\n         *     setInterval(() => this.everySecond.emit(\"event\"), 1000);\r\n         *     setInterval(() => this.five5Secs.emit(\"event\"), 5000);\r\n         *   }\r\n         * }\r\n         *\r\n         * @Component({\r\n         *   selector: 'app',\r\n         *   template: `\r\n         *     <interval-dir (every-second)=\"everySecond()\" (every-five-seconds)=\"everyFiveSeconds()\">\r\n         *     </interval-dir>\r\n         *   `,\r\n         *   directives: [IntervalDir]\r\n         * })\r\n         * class App {\r\n         *   everySecond() { console.log('second'); }\r\n         *   everyFiveSeconds() { console.log('five seconds'); }\r\n         * }\r\n         * bootstrap(App);\r\n         * ```\r\n         *\r\n         */\r\n        get: function () {\r\n            return lang_1.isPresent(this._events) && this._events.length > 0 ? this._events : this._outputs;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DirectiveMetadata.prototype, \"events\", {\r\n        get: function () { return this.outputs; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DirectiveMetadata.prototype, \"providers\", {\r\n        /**\r\n         * Defines the set of injectable objects that are visible to a Directive and its light DOM\r\n         * children.\r\n         *\r\n         * ## Simple Example\r\n         *\r\n         * Here is an example of a class that can be injected:\r\n         *\r\n         * ```\r\n         * class Greeter {\r\n         *    greet(name:string) {\r\n         *      return 'Hello ' + name + '!';\r\n         *    }\r\n         * }\r\n         *\r\n         * @Directive({\r\n         *   selector: 'greet',\r\n         *   bindings: [\r\n         *     Greeter\r\n         *   ]\r\n         * })\r\n         * class HelloWorld {\r\n         *   greeter:Greeter;\r\n         *\r\n         *   constructor(greeter:Greeter) {\r\n         *     this.greeter = greeter;\r\n         *   }\r\n         * }\r\n         * ```\r\n         */\r\n        get: function () {\r\n            return lang_1.isPresent(this._bindings) && this._bindings.length > 0 ? this._bindings :\r\n                this._providers;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DirectiveMetadata.prototype, \"bindings\", {\r\n        /** @deprecated */\r\n        get: function () { return this.providers; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DirectiveMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object])\r\n    ], DirectiveMetadata);\r\n    return DirectiveMetadata;\r\n})(metadata_1.InjectableMetadata);\r\nexports.DirectiveMetadata = DirectiveMetadata;\r\n/**\r\n * Declare reusable UI building blocks for an application.\r\n *\r\n * Each Angular component requires a single `@Component` annotation. The\r\n * `@Component`\r\n * annotation specifies when a component is instantiated, and which properties and hostListeners it\r\n * binds to.\r\n *\r\n * When a component is instantiated, Angular\r\n * - creates a shadow DOM for the component.\r\n * - loads the selected template into the shadow DOM.\r\n * - creates all the injectable objects configured with `providers` and `viewProviders`.\r\n *\r\n * All template expressions and statements are then evaluated against the component instance.\r\n *\r\n * For details on the `@View` annotation, see {@link ViewMetadata}.\r\n *\r\n * ## Lifecycle hooks\r\n *\r\n * When the component class implements some {@link angular2/lifecycle_hooks} the callbacks are\r\n * called by the change detection at defined points in time during the life of the component.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/ts/metadata/metadata.ts region='component'}\r\n */\r\nvar ComponentMetadata = (function (_super) {\r\n    __extends(ComponentMetadata, _super);\r\n    function ComponentMetadata(_a) {\r\n        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, exportAs = _b.exportAs, moduleId = _b.moduleId, bindings = _b.bindings, providers = _b.providers, viewBindings = _b.viewBindings, viewProviders = _b.viewProviders, _c = _b.changeDetection, changeDetection = _c === void 0 ? change_detection_1.ChangeDetectionStrategy.Default : _c, queries = _b.queries, templateUrl = _b.templateUrl, template = _b.template, styleUrls = _b.styleUrls, styles = _b.styles, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation;\r\n        _super.call(this, {\r\n            selector: selector,\r\n            inputs: inputs,\r\n            outputs: outputs,\r\n            properties: properties,\r\n            events: events,\r\n            host: host,\r\n            exportAs: exportAs,\r\n            bindings: bindings,\r\n            providers: providers,\r\n            queries: queries\r\n        });\r\n        this.changeDetection = changeDetection;\r\n        this._viewProviders = viewProviders;\r\n        this._viewBindings = viewBindings;\r\n        this.templateUrl = templateUrl;\r\n        this.template = template;\r\n        this.styleUrls = styleUrls;\r\n        this.styles = styles;\r\n        this.directives = directives;\r\n        this.pipes = pipes;\r\n        this.encapsulation = encapsulation;\r\n        this.moduleId = moduleId;\r\n    }\r\n    Object.defineProperty(ComponentMetadata.prototype, \"viewProviders\", {\r\n        /**\r\n         * Defines the set of injectable objects that are visible to its view DOM children.\r\n         *\r\n         * ## Simple Example\r\n         *\r\n         * Here is an example of a class that can be injected:\r\n         *\r\n         * ```\r\n         * class Greeter {\r\n         *    greet(name:string) {\r\n         *      return 'Hello ' + name + '!';\r\n         *    }\r\n         * }\r\n         *\r\n         * @Directive({\r\n         *   selector: 'needs-greeter'\r\n         * })\r\n         * class NeedsGreeter {\r\n         *   greeter:Greeter;\r\n         *\r\n         *   constructor(greeter:Greeter) {\r\n         *     this.greeter = greeter;\r\n         *   }\r\n         * }\r\n         *\r\n         * @Component({\r\n         *   selector: 'greet',\r\n         *   viewProviders: [\r\n         *     Greeter\r\n         *   ],\r\n         *   template: `<needs-greeter></needs-greeter>`,\r\n         *   directives: [NeedsGreeter]\r\n         * })\r\n         * class HelloWorld {\r\n         * }\r\n         *\r\n         * ```\r\n         */\r\n        get: function () {\r\n            return lang_1.isPresent(this._viewBindings) && this._viewBindings.length > 0 ? this._viewBindings :\r\n                this._viewProviders;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ComponentMetadata.prototype, \"viewBindings\", {\r\n        get: function () { return this.viewProviders; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ComponentMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object])\r\n    ], ComponentMetadata);\r\n    return ComponentMetadata;\r\n})(DirectiveMetadata);\r\nexports.ComponentMetadata = ComponentMetadata;\r\n/**\r\n * Declare reusable pipe function.\r\n *\r\n * A \"pure\" pipe is only re-evaluated when either the input or any of the arguments change.\r\n *\r\n * When not specified, pipes default to being pure.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/ts/metadata/metadata.ts region='pipe'}\r\n */\r\nvar PipeMetadata = (function (_super) {\r\n    __extends(PipeMetadata, _super);\r\n    function PipeMetadata(_a) {\r\n        var name = _a.name, pure = _a.pure;\r\n        _super.call(this);\r\n        this.name = name;\r\n        this._pure = pure;\r\n    }\r\n    Object.defineProperty(PipeMetadata.prototype, \"pure\", {\r\n        get: function () { return lang_1.isPresent(this._pure) ? this._pure : true; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    PipeMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object])\r\n    ], PipeMetadata);\r\n    return PipeMetadata;\r\n})(metadata_1.InjectableMetadata);\r\nexports.PipeMetadata = PipeMetadata;\r\n/**\r\n * Declares a data-bound input property.\r\n *\r\n * Angular automatically updates data-bound properties during change detection.\r\n *\r\n * `InputMetadata` takes an optional parameter that specifies the name\r\n * used when instantiating a component in the template. When not provided,\r\n * the name of the decorated property is used.\r\n *\r\n * ### Example\r\n *\r\n * The following example creates a component with two input properties.\r\n *\r\n * ```typescript\r\n * @Component({\r\n *   selector: 'bank-account',\r\n *   template: `\r\n *     Bank Name: {{bankName}}\r\n *     Account Id: {{id}}\r\n *   `\r\n * })\r\n * class BankAccount {\r\n *   @Input() bankName: string;\r\n *   @Input('account-id') id: string;\r\n *\r\n *   // this property is not bound, and won't be automatically updated by Angular\r\n *   normalizedBankName: string;\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   template: `\r\n *     <bank-account bank-name=\"RBC\" account-id=\"4747\"></bank-account>\r\n *   `,\r\n *   directives: [BankAccount]\r\n * })\r\n * class App {}\r\n *\r\n * bootstrap(App);\r\n * ```\r\n */\r\nvar InputMetadata = (function () {\r\n    function InputMetadata(\r\n        /**\r\n         * Name used when instantiating a component in the temlate.\r\n         */\r\n        bindingPropertyName) {\r\n        this.bindingPropertyName = bindingPropertyName;\r\n    }\r\n    InputMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [String])\r\n    ], InputMetadata);\r\n    return InputMetadata;\r\n})();\r\nexports.InputMetadata = InputMetadata;\r\n/**\r\n * Declares an event-bound output property.\r\n *\r\n * When an output property emits an event, an event handler attached to that event\r\n * the template is invoked.\r\n *\r\n * `OutputMetadata` takes an optional parameter that specifies the name\r\n * used when instantiating a component in the template. When not provided,\r\n * the name of the decorated property is used.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * @Directive({\r\n *   selector: 'interval-dir',\r\n * })\r\n * class IntervalDir {\r\n *   @Output() everySecond = new EventEmitter();\r\n *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();\r\n *\r\n *   constructor() {\r\n *     setInterval(() => this.everySecond.emit(\"event\"), 1000);\r\n *     setInterval(() => this.five5Secs.emit(\"event\"), 5000);\r\n *   }\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   template: `\r\n *     <interval-dir (every-second)=\"everySecond()\" (every-five-seconds)=\"everyFiveSeconds()\">\r\n *     </interval-dir>\r\n *   `,\r\n *   directives: [IntervalDir]\r\n * })\r\n * class App {\r\n *   everySecond() { console.log('second'); }\r\n *   everyFiveSeconds() { console.log('five seconds'); }\r\n * }\r\n * bootstrap(App);\r\n * ```\r\n */\r\nvar OutputMetadata = (function () {\r\n    function OutputMetadata(bindingPropertyName) {\r\n        this.bindingPropertyName = bindingPropertyName;\r\n    }\r\n    OutputMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [String])\r\n    ], OutputMetadata);\r\n    return OutputMetadata;\r\n})();\r\nexports.OutputMetadata = OutputMetadata;\r\n/**\r\n * Declares a host property binding.\r\n *\r\n * Angular automatically checks host property bindings during change detection.\r\n * If a binding changes, it will update the host element of the directive.\r\n *\r\n * `HostBindingMetadata` takes an optional parameter that specifies the property\r\n * name of the host element that will be updated. When not provided,\r\n * the class property name is used.\r\n *\r\n * ### Example\r\n *\r\n * The following example creates a directive that sets the `valid` and `invalid` classes\r\n * on the DOM element that has ngModel directive on it.\r\n *\r\n * ```typescript\r\n * @Directive({selector: '[ngModel]'})\r\n * class NgModelStatus {\r\n *   constructor(public control:NgModel) {}\r\n *   @HostBinding('[class.valid]') get valid { return this.control.valid; }\r\n *   @HostBinding('[class.invalid]') get invalid { return this.control.invalid; }\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   template: `<input [(ngModel)]=\"prop\">`,\r\n *   directives: [FORM_DIRECTIVES, NgModelStatus]\r\n * })\r\n * class App {\r\n *   prop;\r\n * }\r\n *\r\n * bootstrap(App);\r\n * ```\r\n */\r\nvar HostBindingMetadata = (function () {\r\n    function HostBindingMetadata(hostPropertyName) {\r\n        this.hostPropertyName = hostPropertyName;\r\n    }\r\n    HostBindingMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [String])\r\n    ], HostBindingMetadata);\r\n    return HostBindingMetadata;\r\n})();\r\nexports.HostBindingMetadata = HostBindingMetadata;\r\n/**\r\n * Declares a host listener.\r\n *\r\n * Angular will invoke the decorated method when the host element emits the specified event.\r\n *\r\n * If the decorated method returns `false`, then `preventDefault` is applied on the DOM\r\n * event.\r\n *\r\n * ### Example\r\n *\r\n * The following example declares a directive that attaches a click listener to the button and\r\n * counts clicks.\r\n *\r\n * ```typescript\r\n * @Directive({selector: 'button[counting]'})\r\n * class CountClicks {\r\n *   numberOfClicks = 0;\r\n *\r\n *   @HostListener('click', ['$event.target'])\r\n *   onClick(btn) {\r\n *     console.log(\"button\", btn, \"number of clicks:\", this.numberOfClicks++);\r\n *   }\r\n * }\r\n *\r\n * @Component({\r\n *   selector: 'app',\r\n *   template: `<button counting>Increment</button>`,\r\n *   directives: [CountClicks]\r\n * })\r\n * class App {}\r\n *\r\n * bootstrap(App);\r\n * ```\r\n */\r\nvar HostListenerMetadata = (function () {\r\n    function HostListenerMetadata(eventName, args) {\r\n        this.eventName = eventName;\r\n        this.args = args;\r\n    }\r\n    HostListenerMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [String, Array])\r\n    ], HostListenerMetadata);\r\n    return HostListenerMetadata;\r\n})();\r\nexports.HostListenerMetadata = HostListenerMetadata;\r\n},{\"angular2/src/core/change_detection\":84,\"angular2/src/core/di/metadata\":123,\"angular2/src/facade/lang\":176}],149:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * Defines template and style encapsulation options available for Component's {@link View}.\r\n *\r\n * See {@link ViewMetadata#encapsulation}.\r\n */\r\n(function (ViewEncapsulation) {\r\n    /**\r\n     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\r\n     * Element and pre-processing the style rules provided via\r\n     * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element\r\n     * attribute to all selectors.\r\n     *\r\n     * This is the default option.\r\n     */\r\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\r\n    /**\r\n     * Use the native encapsulation mechanism of the renderer.\r\n     *\r\n     * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\r\n     * creating a ShadowRoot for Component's Host Element.\r\n     */\r\n    ViewEncapsulation[ViewEncapsulation[\"Native\"] = 1] = \"Native\";\r\n    /**\r\n     * Don't provide any template or style encapsulation.\r\n     */\r\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\r\n})(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));\r\nvar ViewEncapsulation = exports.ViewEncapsulation;\r\nexports.VIEW_ENCAPSULATION_VALUES = [ViewEncapsulation.Emulated, ViewEncapsulation.Native, ViewEncapsulation.None];\r\n/**\r\n * Metadata properties available for configuring Views.\r\n *\r\n * Each Angular component requires a single `@Component` and at least one `@View` annotation. The\r\n * `@View` annotation specifies the HTML template to use, and lists the directives that are active\r\n * within the template.\r\n *\r\n * When a component is instantiated, the template is loaded into the component's shadow root, and\r\n * the expressions and statements in the template are evaluated against the component.\r\n *\r\n * For details on the `@Component` annotation, see {@link ComponentMetadata}.\r\n *\r\n * ### Example\r\n *\r\n * ```\r\n * @Component({\r\n *   selector: 'greet',\r\n *   template: 'Hello {{name}}!',\r\n *   directives: [GreetUser, Bold]\r\n * })\r\n * class Greet {\r\n *   name: string;\r\n *\r\n *   constructor() {\r\n *     this.name = 'World';\r\n *   }\r\n * }\r\n * ```\r\n */\r\nvar ViewMetadata = (function () {\r\n    function ViewMetadata(_a) {\r\n        var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls;\r\n        this.templateUrl = templateUrl;\r\n        this.template = template;\r\n        this.styleUrls = styleUrls;\r\n        this.styles = styles;\r\n        this.directives = directives;\r\n        this.pipes = pipes;\r\n        this.encapsulation = encapsulation;\r\n    }\r\n    ViewMetadata = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [Object])\r\n    ], ViewMetadata);\r\n    return ViewMetadata;\r\n})();\r\nexports.ViewMetadata = ViewMetadata;\r\n},{\"angular2/src/facade/lang\":176}],150:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar provider_1 = require('angular2/src/core/di/provider');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar PipeProvider = (function (_super) {\r\n    __extends(PipeProvider, _super);\r\n    function PipeProvider(name, pure, key, resolvedFactories, multiBinding) {\r\n        _super.call(this, key, resolvedFactories, multiBinding);\r\n        this.name = name;\r\n        this.pure = pure;\r\n    }\r\n    PipeProvider.createFromType = function (type, metadata) {\r\n        var provider = new di_1.Provider(type, { useClass: type });\r\n        var rb = provider_1.resolveProvider(provider);\r\n        return new PipeProvider(metadata.name, metadata.pure, rb.key, rb.resolvedFactories, rb.multiProvider);\r\n    };\r\n    return PipeProvider;\r\n})(provider_1.ResolvedProvider_);\r\nexports.PipeProvider = PipeProvider;\r\n},{\"angular2/src/core/di\":117,\"angular2/src/core/di/provider\":125}],151:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar cd = require('angular2/src/core/change_detection/pipes');\r\nvar ProtoPipes = (function () {\r\n    function ProtoPipes(\r\n        /**\r\n        * Map of {@link PipeMetadata} names to {@link PipeMetadata} implementations.\r\n        */\r\n        config) {\r\n        this.config = config;\r\n        this.config = config;\r\n    }\r\n    ProtoPipes.fromProviders = function (providers) {\r\n        var config = {};\r\n        providers.forEach(function (b) { return config[b.name] = b; });\r\n        return new ProtoPipes(config);\r\n    };\r\n    ProtoPipes.prototype.get = function (name) {\r\n        var provider = this.config[name];\r\n        if (lang_1.isBlank(provider))\r\n            throw new exceptions_1.BaseException(\"Cannot find pipe '\" + name + \"'.\");\r\n        return provider;\r\n    };\r\n    return ProtoPipes;\r\n})();\r\nexports.ProtoPipes = ProtoPipes;\r\nvar Pipes = (function () {\r\n    function Pipes(proto, injector) {\r\n        this.proto = proto;\r\n        this.injector = injector;\r\n        /** @internal */\r\n        this._config = {};\r\n    }\r\n    Pipes.prototype.get = function (name) {\r\n        var cached = collection_1.StringMapWrapper.get(this._config, name);\r\n        if (lang_1.isPresent(cached))\r\n            return cached;\r\n        var p = this.proto.get(name);\r\n        var transform = this.injector.instantiateResolved(p);\r\n        var res = new cd.SelectedPipe(transform, p.pure);\r\n        if (p.pure) {\r\n            collection_1.StringMapWrapper.set(this._config, name, res);\r\n        }\r\n        return res;\r\n    };\r\n    return Pipes;\r\n})();\r\nexports.Pipes = Pipes;\r\n},{\"angular2/src/core/change_detection/pipes\":112,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],152:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar console_1 = require('angular2/src/core/console');\r\nvar reflection_1 = require('./reflection/reflection');\r\nvar testability_1 = require('angular2/src/core/testability/testability');\r\nfunction _reflector() {\r\n    return reflection_1.reflector;\r\n}\r\n/**\r\n * A default set of providers which should be included in any Angular platform.\r\n */\r\nexports.PLATFORM_COMMON_PROVIDERS = lang_1.CONST_EXPR([new di_1.Provider(reflection_1.Reflector, { useFactory: _reflector, deps: [] }), testability_1.TestabilityRegistry, console_1.Console]);\r\n},{\"./reflection/reflection\":158,\"angular2/src/core/console\":115,\"angular2/src/core/di\":117,\"angular2/src/core/testability/testability\":164,\"angular2/src/facade/lang\":176}],153:[function(require,module,exports){\n'use strict';var di_1 = require(\"angular2/src/core/di\");\r\nvar lang_1 = require(\"angular2/src/facade/lang\");\r\n/**\r\n * A token that can be provided when bootstraping an application to make an array of directives\r\n * available in every component of the application.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import {PLATFORM_DIRECTIVES} from 'angular2/core';\r\n * import {OtherDirective} from './myDirectives';\r\n *\r\n * @Component({\r\n *   selector: 'my-component',\r\n *   template: `\r\n *     <!-- can use other directive even though the component does not list it in `directives` -->\r\n *     <other-directive></other-directive>\r\n *   `\r\n * })\r\n * export class MyComponent {\r\n *   ...\r\n * }\r\n *\r\n * bootstrap(MyComponent, [provide(PLATFORM_DIRECTIVES, {useValue: [OtherDirective], multi:true})]);\r\n * ```\r\n */\r\nexports.PLATFORM_DIRECTIVES = lang_1.CONST_EXPR(new di_1.OpaqueToken(\"Platform Directives\"));\r\n/**\r\n * A token that can be provided when bootstraping an application to make an array of pipes\r\n * available in every component of the application.\r\n *\r\n * ### Example\r\n *\r\n * ```typescript\r\n * import {PLATFORM_PIPES} from 'angular2/core';\r\n * import {OtherPipe} from './myPipe';\r\n *\r\n * @Component({\r\n *   selector: 'my-component',\r\n *   template: `\r\n *     {{123 | other-pipe}}\r\n *   `\r\n * })\r\n * export class MyComponent {\r\n *   ...\r\n * }\r\n *\r\n * bootstrap(MyComponent, [provide(PLATFORM_PIPES, {useValue: [OtherPipe], multi:true})]);\r\n * ```\r\n */\r\nexports.PLATFORM_PIPES = lang_1.CONST_EXPR(new di_1.OpaqueToken(\"Platform Pipes\"));\r\n},{\"angular2/src/core/di\":117,\"angular2/src/facade/lang\":176}],154:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nexports.enableProdMode = lang_1.enableProdMode;\r\n},{\"angular2/src/facade/lang\":176}],155:[function(require,module,exports){\n'use strict';var impl = require(\"./wtf_impl\");\r\n// Change exports to const once https://github.com/angular/ts2dart/issues/150\r\n/**\r\n * True if WTF is enabled.\r\n */\r\nexports.wtfEnabled = impl.detectWTF();\r\nfunction noopScope(arg0, arg1) {\r\n    return null;\r\n}\r\n/**\r\n * Create trace scope.\r\n *\r\n * Scopes must be strictly nested and are analogous to stack frames, but\r\n * do not have to follow the stack frames. Instead it is recommended that they follow logical\r\n * nesting. You may want to use\r\n * [Event\r\n * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\r\n * as they are defined in WTF.\r\n *\r\n * Used to mark scope entry. The return value is used to leave the scope.\r\n *\r\n *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\r\n *\r\n *     someMethod() {\r\n *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\r\n *        // DO SOME WORK HERE\r\n *        return wtfLeave(s, 123); // Return value 123\r\n *     }\r\n *\r\n * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\r\n * negatively impact the performance of your application. For this reason we recommend that\r\n * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\r\n * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\r\n * exception, will produce incorrect trace, but presence of exception signifies logic error which\r\n * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\r\n * an exception is expected during normal execution while profiling.\r\n *\r\n */\r\nexports.wtfCreateScope = exports.wtfEnabled ? impl.createScope : function (signature, flags) { return noopScope; };\r\n/**\r\n * Used to mark end of Scope.\r\n *\r\n * - `scope` to end.\r\n * - `returnValue` (optional) to be passed to the WTF.\r\n *\r\n * Returns the `returnValue for easy chaining.\r\n */\r\nexports.wtfLeave = exports.wtfEnabled ? impl.leave : function (s, r) { return r; };\r\n/**\r\n * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\r\n * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\r\n * enabled.\r\n *\r\n *     someMethod() {\r\n *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\r\n *        var future = new Future.delay(5).then((_) {\r\n *          wtfEndTimeRange(s);\r\n *        });\r\n *     }\r\n */\r\nexports.wtfStartTimeRange = exports.wtfEnabled ? impl.startTimeRange : function (rangeType, action) { return null; };\r\n/**\r\n * Ends a async time range operation.\r\n * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\r\n * enabled.\r\n */\r\nexports.wtfEndTimeRange = exports.wtfEnabled ? impl.endTimeRange : function (r) {\r\n    return null;\r\n};\r\n},{\"./wtf_impl\":156}],156:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar trace;\r\nvar events;\r\nfunction detectWTF() {\r\n    var wtf = lang_1.global['wtf'];\r\n    if (wtf) {\r\n        trace = wtf['trace'];\r\n        if (trace) {\r\n            events = trace['events'];\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.detectWTF = detectWTF;\r\nfunction createScope(signature, flags) {\r\n    if (flags === void 0) { flags = null; }\r\n    return events.createScope(signature, flags);\r\n}\r\nexports.createScope = createScope;\r\nfunction leave(scope, returnValue) {\r\n    trace.leaveScope(scope, returnValue);\r\n    return returnValue;\r\n}\r\nexports.leave = leave;\r\nfunction startTimeRange(rangeType, action) {\r\n    return trace.beginTimeRange(rangeType, action);\r\n}\r\nexports.startTimeRange = startTimeRange;\r\nfunction endTimeRange(range) {\r\n    trace.endTimeRange(range);\r\n}\r\nexports.endTimeRange = endTimeRange;\r\n},{\"angular2/src/facade/lang\":176}],157:[function(require,module,exports){\n'use strict';/**\r\n * This is here because DART requires it. It is noop in JS.\r\n */\r\nfunction wtfInit() { }\r\nexports.wtfInit = wtfInit;\r\n},{}],158:[function(require,module,exports){\n'use strict';var reflector_1 = require('./reflector');\r\nvar reflector_2 = require('./reflector');\r\nexports.Reflector = reflector_2.Reflector;\r\nexports.ReflectionInfo = reflector_2.ReflectionInfo;\r\nvar reflection_capabilities_1 = require('./reflection_capabilities');\r\n/**\r\n * The {@link Reflector} used internally in Angular to access metadata\r\n * about symbols.\r\n */\r\nexports.reflector = new reflector_1.Reflector(new reflection_capabilities_1.ReflectionCapabilities());\r\n},{\"./reflection_capabilities\":159,\"./reflector\":160}],159:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar ReflectionCapabilities = (function () {\r\n    function ReflectionCapabilities(reflect) {\r\n        this._reflect = lang_1.isPresent(reflect) ? reflect : lang_1.global.Reflect;\r\n    }\r\n    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };\r\n    ReflectionCapabilities.prototype.factory = function (t) {\r\n        switch (t.length) {\r\n            case 0:\r\n                return function () { return new t(); };\r\n            case 1:\r\n                return function (a1) { return new t(a1); };\r\n            case 2:\r\n                return function (a1, a2) { return new t(a1, a2); };\r\n            case 3:\r\n                return function (a1, a2, a3) { return new t(a1, a2, a3); };\r\n            case 4:\r\n                return function (a1, a2, a3, a4) { return new t(a1, a2, a3, a4); };\r\n            case 5:\r\n                return function (a1, a2, a3, a4, a5) { return new t(a1, a2, a3, a4, a5); };\r\n            case 6:\r\n                return function (a1, a2, a3, a4, a5, a6) { return new t(a1, a2, a3, a4, a5, a6); };\r\n            case 7:\r\n                return function (a1, a2, a3, a4, a5, a6, a7) { return new t(a1, a2, a3, a4, a5, a6, a7); };\r\n            case 8:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8) { return new t(a1, a2, a3, a4, a5, a6, a7, a8); };\r\n            case 9:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) { return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9); };\r\n            case 10:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);\r\n                };\r\n            case 11:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);\r\n                };\r\n            case 12:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);\r\n                };\r\n            case 13:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);\r\n                };\r\n            case 14:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);\r\n                };\r\n            case 15:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);\r\n                };\r\n            case 16:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);\r\n                };\r\n            case 17:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);\r\n                };\r\n            case 18:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);\r\n                };\r\n            case 19:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);\r\n                };\r\n            case 20:\r\n                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {\r\n                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\r\n                };\r\n        }\r\n        ;\r\n        throw new Error(\"Cannot create a factory for '\" + lang_1.stringify(t) + \"' because its constructor has more than 20 arguments\");\r\n    };\r\n    /** @internal */\r\n    ReflectionCapabilities.prototype._zipTypesAndAnnotaions = function (paramTypes, paramAnnotations) {\r\n        var result;\r\n        if (typeof paramTypes === 'undefined') {\r\n            result = new Array(paramAnnotations.length);\r\n        }\r\n        else {\r\n            result = new Array(paramTypes.length);\r\n        }\r\n        for (var i = 0; i < result.length; i++) {\r\n            // TS outputs Object for parameters without types, while Traceur omits\r\n            // the annotations. For now we preserve the Traceur behavior to aid\r\n            // migration, but this can be revisited.\r\n            if (typeof paramTypes === 'undefined') {\r\n                result[i] = [];\r\n            }\r\n            else if (paramTypes[i] != Object) {\r\n                result[i] = [paramTypes[i]];\r\n            }\r\n            else {\r\n                result[i] = [];\r\n            }\r\n            if (lang_1.isPresent(paramAnnotations) && lang_1.isPresent(paramAnnotations[i])) {\r\n                result[i] = result[i].concat(paramAnnotations[i]);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    ReflectionCapabilities.prototype.parameters = function (typeOrFunc) {\r\n        // Prefer the direct API.\r\n        if (lang_1.isPresent(typeOrFunc.parameters)) {\r\n            return typeOrFunc.parameters;\r\n        }\r\n        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {\r\n            var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);\r\n            var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);\r\n            if (lang_1.isPresent(paramTypes) || lang_1.isPresent(paramAnnotations)) {\r\n                return this._zipTypesAndAnnotaions(paramTypes, paramAnnotations);\r\n            }\r\n        }\r\n        // The array has to be filled with `undefined` because holes would be skipped by `some`\r\n        var parameters = new Array(typeOrFunc.length);\r\n        parameters.fill(undefined);\r\n        return parameters;\r\n    };\r\n    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {\r\n        // Prefer the direct API.\r\n        if (lang_1.isPresent(typeOrFunc.annotations)) {\r\n            var annotations = typeOrFunc.annotations;\r\n            if (lang_1.isFunction(annotations) && annotations.annotations) {\r\n                annotations = annotations.annotations;\r\n            }\r\n            return annotations;\r\n        }\r\n        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {\r\n            var annotations = this._reflect.getMetadata('annotations', typeOrFunc);\r\n            if (lang_1.isPresent(annotations))\r\n                return annotations;\r\n        }\r\n        return [];\r\n    };\r\n    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {\r\n        // Prefer the direct API.\r\n        if (lang_1.isPresent(typeOrFunc.propMetadata)) {\r\n            var propMetadata = typeOrFunc.propMetadata;\r\n            if (lang_1.isFunction(propMetadata) && propMetadata.propMetadata) {\r\n                propMetadata = propMetadata.propMetadata;\r\n            }\r\n            return propMetadata;\r\n        }\r\n        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {\r\n            var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);\r\n            if (lang_1.isPresent(propMetadata))\r\n                return propMetadata;\r\n        }\r\n        return {};\r\n    };\r\n    ReflectionCapabilities.prototype.interfaces = function (type) {\r\n        throw new exceptions_1.BaseException(\"JavaScript does not support interfaces\");\r\n    };\r\n    ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };\r\n    ReflectionCapabilities.prototype.setter = function (name) {\r\n        return new Function('o', 'v', 'return o.' + name + ' = v;');\r\n    };\r\n    ReflectionCapabilities.prototype.method = function (name) {\r\n        var functionBody = \"if (!o.\" + name + \") throw new Error('\\\"\" + name + \"\\\" is undefined');\\n        return o.\" + name + \".apply(o, args);\";\r\n        return new Function('o', 'args', functionBody);\r\n    };\r\n    // There is not a concept of import uri in Js, but this is useful in developing Dart applications.\r\n    ReflectionCapabilities.prototype.importUri = function (type) { return './'; };\r\n    return ReflectionCapabilities;\r\n})();\r\nexports.ReflectionCapabilities = ReflectionCapabilities;\r\n},{\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],160:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\n/**\r\n * Reflective information about a symbol, including annotations, interfaces, and other metadata.\r\n */\r\nvar ReflectionInfo = (function () {\r\n    function ReflectionInfo(annotations, parameters, factory, interfaces, propMetadata) {\r\n        this.annotations = annotations;\r\n        this.parameters = parameters;\r\n        this.factory = factory;\r\n        this.interfaces = interfaces;\r\n        this.propMetadata = propMetadata;\r\n    }\r\n    return ReflectionInfo;\r\n})();\r\nexports.ReflectionInfo = ReflectionInfo;\r\n/**\r\n * Provides access to reflection data about symbols. Used internally by Angular\r\n * to power dependency injection and compilation.\r\n */\r\nvar Reflector = (function () {\r\n    function Reflector(reflectionCapabilities) {\r\n        /** @internal */\r\n        this._injectableInfo = new collection_1.Map();\r\n        /** @internal */\r\n        this._getters = new collection_1.Map();\r\n        /** @internal */\r\n        this._setters = new collection_1.Map();\r\n        /** @internal */\r\n        this._methods = new collection_1.Map();\r\n        this._usedKeys = null;\r\n        this.reflectionCapabilities = reflectionCapabilities;\r\n    }\r\n    Reflector.prototype.isReflectionEnabled = function () { return this.reflectionCapabilities.isReflectionEnabled(); };\r\n    /**\r\n     * Causes `this` reflector to track keys used to access\r\n     * {@link ReflectionInfo} objects.\r\n     */\r\n    Reflector.prototype.trackUsage = function () { this._usedKeys = new collection_1.Set(); };\r\n    /**\r\n     * Lists types for which reflection information was not requested since\r\n     * {@link #trackUsage} was called. This list could later be audited as\r\n     * potential dead code.\r\n     */\r\n    Reflector.prototype.listUnusedKeys = function () {\r\n        var _this = this;\r\n        if (this._usedKeys == null) {\r\n            throw new exceptions_1.BaseException('Usage tracking is disabled');\r\n        }\r\n        var allTypes = collection_1.MapWrapper.keys(this._injectableInfo);\r\n        return allTypes.filter(function (key) { return !collection_1.SetWrapper.has(_this._usedKeys, key); });\r\n    };\r\n    Reflector.prototype.registerFunction = function (func, funcInfo) {\r\n        this._injectableInfo.set(func, funcInfo);\r\n    };\r\n    Reflector.prototype.registerType = function (type, typeInfo) {\r\n        this._injectableInfo.set(type, typeInfo);\r\n    };\r\n    Reflector.prototype.registerGetters = function (getters) { _mergeMaps(this._getters, getters); };\r\n    Reflector.prototype.registerSetters = function (setters) { _mergeMaps(this._setters, setters); };\r\n    Reflector.prototype.registerMethods = function (methods) { _mergeMaps(this._methods, methods); };\r\n    Reflector.prototype.factory = function (type) {\r\n        if (this._containsReflectionInfo(type)) {\r\n            var res = this._getReflectionInfo(type).factory;\r\n            return lang_1.isPresent(res) ? res : null;\r\n        }\r\n        else {\r\n            return this.reflectionCapabilities.factory(type);\r\n        }\r\n    };\r\n    Reflector.prototype.parameters = function (typeOrFunc) {\r\n        if (this._injectableInfo.has(typeOrFunc)) {\r\n            var res = this._getReflectionInfo(typeOrFunc).parameters;\r\n            return lang_1.isPresent(res) ? res : [];\r\n        }\r\n        else {\r\n            return this.reflectionCapabilities.parameters(typeOrFunc);\r\n        }\r\n    };\r\n    Reflector.prototype.annotations = function (typeOrFunc) {\r\n        if (this._injectableInfo.has(typeOrFunc)) {\r\n            var res = this._getReflectionInfo(typeOrFunc).annotations;\r\n            return lang_1.isPresent(res) ? res : [];\r\n        }\r\n        else {\r\n            return this.reflectionCapabilities.annotations(typeOrFunc);\r\n        }\r\n    };\r\n    Reflector.prototype.propMetadata = function (typeOrFunc) {\r\n        if (this._injectableInfo.has(typeOrFunc)) {\r\n            var res = this._getReflectionInfo(typeOrFunc).propMetadata;\r\n            return lang_1.isPresent(res) ? res : {};\r\n        }\r\n        else {\r\n            return this.reflectionCapabilities.propMetadata(typeOrFunc);\r\n        }\r\n    };\r\n    Reflector.prototype.interfaces = function (type) {\r\n        if (this._injectableInfo.has(type)) {\r\n            var res = this._getReflectionInfo(type).interfaces;\r\n            return lang_1.isPresent(res) ? res : [];\r\n        }\r\n        else {\r\n            return this.reflectionCapabilities.interfaces(type);\r\n        }\r\n    };\r\n    Reflector.prototype.getter = function (name) {\r\n        if (this._getters.has(name)) {\r\n            return this._getters.get(name);\r\n        }\r\n        else {\r\n            return this.reflectionCapabilities.getter(name);\r\n        }\r\n    };\r\n    Reflector.prototype.setter = function (name) {\r\n        if (this._setters.has(name)) {\r\n            return this._setters.get(name);\r\n        }\r\n        else {\r\n            return this.reflectionCapabilities.setter(name);\r\n        }\r\n    };\r\n    Reflector.prototype.method = function (name) {\r\n        if (this._methods.has(name)) {\r\n            return this._methods.get(name);\r\n        }\r\n        else {\r\n            return this.reflectionCapabilities.method(name);\r\n        }\r\n    };\r\n    /** @internal */\r\n    Reflector.prototype._getReflectionInfo = function (typeOrFunc) {\r\n        if (lang_1.isPresent(this._usedKeys)) {\r\n            this._usedKeys.add(typeOrFunc);\r\n        }\r\n        return this._injectableInfo.get(typeOrFunc);\r\n    };\r\n    /** @internal */\r\n    Reflector.prototype._containsReflectionInfo = function (typeOrFunc) { return this._injectableInfo.has(typeOrFunc); };\r\n    Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };\r\n    return Reflector;\r\n})();\r\nexports.Reflector = Reflector;\r\nfunction _mergeMaps(target, config) {\r\n    collection_1.StringMapWrapper.forEach(config, function (v, k) { return target.set(k, v); });\r\n}\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],161:[function(require,module,exports){\n'use strict';// Public API for render\r\nvar api_1 = require('./render/api');\r\nexports.RootRenderer = api_1.RootRenderer;\r\nexports.Renderer = api_1.Renderer;\r\nexports.RenderComponentType = api_1.RenderComponentType;\r\n},{\"./render/api\":162}],162:[function(require,module,exports){\n'use strict';var RenderComponentType = (function () {\r\n    function RenderComponentType(id, encapsulation, styles) {\r\n        this.id = id;\r\n        this.encapsulation = encapsulation;\r\n        this.styles = styles;\r\n    }\r\n    return RenderComponentType;\r\n})();\r\nexports.RenderComponentType = RenderComponentType;\r\nvar Renderer = (function () {\r\n    function Renderer() {\r\n    }\r\n    return Renderer;\r\n})();\r\nexports.Renderer = Renderer;\r\n/**\r\n * Injectable service that provides a low-level interface for modifying the UI.\r\n *\r\n * Use this service to bypass Angular's templating and make custom UI changes that can't be\r\n * expressed declaratively. For example if you need to set a property or an attribute whose name is\r\n * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}\r\n * respectively.\r\n *\r\n * If you are implementing a custom renderer, you must implement this interface.\r\n *\r\n * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.\r\n */\r\nvar RootRenderer = (function () {\r\n    function RootRenderer() {\r\n    }\r\n    return RootRenderer;\r\n})();\r\nexports.RootRenderer = RootRenderer;\r\n},{}],163:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar CAMEL_CASE_REGEXP = /([A-Z])/g;\r\nvar DASH_CASE_REGEXP = /-([a-z])/g;\r\nfunction camelCaseToDashCase(input) {\r\n    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });\r\n}\r\nexports.camelCaseToDashCase = camelCaseToDashCase;\r\nfunction dashCaseToCamelCase(input) {\r\n    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });\r\n}\r\nexports.dashCaseToCamelCase = dashCaseToCamelCase;\r\n},{\"angular2/src/facade/lang\":176}],164:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar ng_zone_1 = require('../zone/ng_zone');\r\nvar async_1 = require('angular2/src/facade/async');\r\n/**\r\n * The Testability service provides testing hooks that can be accessed from\r\n * the browser and by services such as Protractor. Each bootstrapped Angular\r\n * application on the page will have an instance of Testability.\r\n */\r\nvar Testability = (function () {\r\n    function Testability(_ngZone) {\r\n        /** @internal */\r\n        this._pendingCount = 0;\r\n        /** @internal */\r\n        this._callbacks = [];\r\n        /** @internal */\r\n        this._isAngularEventPending = false;\r\n        this._watchAngularEvents(_ngZone);\r\n    }\r\n    /** @internal */\r\n    Testability.prototype._watchAngularEvents = function (_ngZone) {\r\n        var _this = this;\r\n        async_1.ObservableWrapper.subscribe(_ngZone.onTurnStart, function (_) { _this._isAngularEventPending = true; });\r\n        _ngZone.runOutsideAngular(function () {\r\n            async_1.ObservableWrapper.subscribe(_ngZone.onEventDone, function (_) {\r\n                if (!_ngZone.hasPendingTimers) {\r\n                    _this._isAngularEventPending = false;\r\n                    _this._runCallbacksIfReady();\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Testability.prototype.increasePendingRequestCount = function () {\r\n        this._pendingCount += 1;\r\n        return this._pendingCount;\r\n    };\r\n    Testability.prototype.decreasePendingRequestCount = function () {\r\n        this._pendingCount -= 1;\r\n        if (this._pendingCount < 0) {\r\n            throw new exceptions_1.BaseException('pending async requests below zero');\r\n        }\r\n        this._runCallbacksIfReady();\r\n        return this._pendingCount;\r\n    };\r\n    Testability.prototype.isStable = function () { return this._pendingCount == 0 && !this._isAngularEventPending; };\r\n    /** @internal */\r\n    Testability.prototype._runCallbacksIfReady = function () {\r\n        var _this = this;\r\n        if (!this.isStable()) {\r\n            return; // Not ready\r\n        }\r\n        // Schedules the call backs in a new frame so that it is always async.\r\n        async_1.PromiseWrapper.resolve(null).then(function (_) {\r\n            while (_this._callbacks.length !== 0) {\r\n                (_this._callbacks.pop())();\r\n            }\r\n        });\r\n    };\r\n    Testability.prototype.whenStable = function (callback) {\r\n        this._callbacks.push(callback);\r\n        this._runCallbacksIfReady();\r\n    };\r\n    Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };\r\n    // This only accounts for ngZone, and not pending counts. Use `whenStable` to\r\n    // check for stability.\r\n    Testability.prototype.isAngularEventPending = function () { return this._isAngularEventPending; };\r\n    Testability.prototype.findBindings = function (using, provider, exactMatch) {\r\n        // TODO(juliemr): implement.\r\n        return [];\r\n    };\r\n    Testability.prototype.findProviders = function (using, provider, exactMatch) {\r\n        // TODO(juliemr): implement.\r\n        return [];\r\n    };\r\n    Testability = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [ng_zone_1.NgZone])\r\n    ], Testability);\r\n    return Testability;\r\n})();\r\nexports.Testability = Testability;\r\n/**\r\n * A global registry of {@link Testability} instances for specific elements.\r\n */\r\nvar TestabilityRegistry = (function () {\r\n    function TestabilityRegistry() {\r\n        /** @internal */\r\n        this._applications = new collection_1.Map();\r\n        _testabilityGetter.addToWindow(this);\r\n    }\r\n    TestabilityRegistry.prototype.registerApplication = function (token, testability) {\r\n        this._applications.set(token, testability);\r\n    };\r\n    TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };\r\n    TestabilityRegistry.prototype.getAllTestabilities = function () { return collection_1.MapWrapper.values(this._applications); };\r\n    TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {\r\n        if (findInAncestors === void 0) { findInAncestors = true; }\r\n        return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);\r\n    };\r\n    TestabilityRegistry = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], TestabilityRegistry);\r\n    return TestabilityRegistry;\r\n})();\r\nexports.TestabilityRegistry = TestabilityRegistry;\r\nvar _NoopGetTestability = (function () {\r\n    function _NoopGetTestability() {\r\n    }\r\n    _NoopGetTestability.prototype.addToWindow = function (registry) { };\r\n    _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {\r\n        return null;\r\n    };\r\n    _NoopGetTestability = __decorate([\r\n        lang_1.CONST(), \r\n        __metadata('design:paramtypes', [])\r\n    ], _NoopGetTestability);\r\n    return _NoopGetTestability;\r\n})();\r\n/**\r\n * Set the {@link GetTestability} implementation used by the Angular testing framework.\r\n */\r\nfunction setTestabilityGetter(getter) {\r\n    _testabilityGetter = getter;\r\n}\r\nexports.setTestabilityGetter = setTestabilityGetter;\r\nvar _testabilityGetter = lang_1.CONST_EXPR(new _NoopGetTestability());\r\n},{\"../zone/ng_zone\":168,\"angular2/src/core/di\":117,\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],165:[function(require,module,exports){\n'use strict';// Public API for util\r\nvar decorators_1 = require('./util/decorators');\r\nexports.Class = decorators_1.Class;\r\n},{\"./util/decorators\":166}],166:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar _nextClassId = 0;\r\nfunction extractAnnotation(annotation) {\r\n    if (lang_1.isFunction(annotation) && annotation.hasOwnProperty('annotation')) {\r\n        // it is a decorator, extract annotation\r\n        annotation = annotation.annotation;\r\n    }\r\n    return annotation;\r\n}\r\nfunction applyParams(fnOrArray, key) {\r\n    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||\r\n        fnOrArray === Number || fnOrArray === Array) {\r\n        throw new Error(\"Can not use native \" + lang_1.stringify(fnOrArray) + \" as constructor\");\r\n    }\r\n    if (lang_1.isFunction(fnOrArray)) {\r\n        return fnOrArray;\r\n    }\r\n    else if (fnOrArray instanceof Array) {\r\n        var annotations = fnOrArray;\r\n        var fn = fnOrArray[fnOrArray.length - 1];\r\n        if (!lang_1.isFunction(fn)) {\r\n            throw new Error(\"Last position of Class method array must be Function in key \" + key + \" was '\" + lang_1.stringify(fn) + \"'\");\r\n        }\r\n        var annoLength = annotations.length - 1;\r\n        if (annoLength != fn.length) {\r\n            throw new Error(\"Number of annotations (\" + annoLength + \") does not match number of arguments (\" + fn.length + \") in the function: \" + lang_1.stringify(fn));\r\n        }\r\n        var paramsAnnotations = [];\r\n        for (var i = 0, ii = annotations.length - 1; i < ii; i++) {\r\n            var paramAnnotations = [];\r\n            paramsAnnotations.push(paramAnnotations);\r\n            var annotation = annotations[i];\r\n            if (annotation instanceof Array) {\r\n                for (var j = 0; j < annotation.length; j++) {\r\n                    paramAnnotations.push(extractAnnotation(annotation[j]));\r\n                }\r\n            }\r\n            else if (lang_1.isFunction(annotation)) {\r\n                paramAnnotations.push(extractAnnotation(annotation));\r\n            }\r\n            else {\r\n                paramAnnotations.push(annotation);\r\n            }\r\n        }\r\n        Reflect.defineMetadata('parameters', paramsAnnotations, fn);\r\n        return fn;\r\n    }\r\n    else {\r\n        throw new Error(\"Only Function or Array is supported in Class definition for key '\" + key + \"' is '\" + lang_1.stringify(fnOrArray) + \"'\");\r\n    }\r\n}\r\n/**\r\n * Provides a way for expressing ES6 classes with parameter annotations in ES5.\r\n *\r\n * ## Basic Example\r\n *\r\n * ```\r\n * var Greeter = ng.Class({\r\n *   constructor: function(name) {\r\n *     this.name = name;\r\n *   },\r\n *\r\n *   greet: function() {\r\n *     alert('Hello ' + this.name + '!');\r\n *   }\r\n * });\r\n * ```\r\n *\r\n * is equivalent to ES6:\r\n *\r\n * ```\r\n * class Greeter {\r\n *   constructor(name) {\r\n *     this.name = name;\r\n *   }\r\n *\r\n *   greet() {\r\n *     alert('Hello ' + this.name + '!');\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * or equivalent to ES5:\r\n *\r\n * ```\r\n * var Greeter = function (name) {\r\n *   this.name = name;\r\n * }\r\n *\r\n * Greeter.prototype.greet = function () {\r\n *   alert('Hello ' + this.name + '!');\r\n * }\r\n * ```\r\n *\r\n * ### Example with parameter annotations\r\n *\r\n * ```\r\n * var MyService = ng.Class({\r\n *   constructor: [String, [new Query(), QueryList], function(name, queryList) {\r\n *     ...\r\n *   }]\r\n * });\r\n * ```\r\n *\r\n * is equivalent to ES6:\r\n *\r\n * ```\r\n * class MyService {\r\n *   constructor(name: string, @Query() queryList: QueryList) {\r\n *     ...\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * ### Example with inheritance\r\n *\r\n * ```\r\n * var Shape = ng.Class({\r\n *   constructor: (color) {\r\n *     this.color = color;\r\n *   }\r\n * });\r\n *\r\n * var Square = ng.Class({\r\n *   extends: Shape,\r\n *   constructor: function(color, size) {\r\n *     Shape.call(this, color);\r\n *     this.size = size;\r\n *   }\r\n * });\r\n * ```\r\n */\r\nfunction Class(clsDef) {\r\n    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');\r\n    var proto = constructor.prototype;\r\n    if (clsDef.hasOwnProperty('extends')) {\r\n        if (lang_1.isFunction(clsDef.extends)) {\r\n            constructor.prototype = proto =\r\n                Object.create(clsDef.extends.prototype);\r\n        }\r\n        else {\r\n            throw new Error(\"Class definition 'extends' property must be a constructor function was: \" + lang_1.stringify(clsDef.extends));\r\n        }\r\n    }\r\n    for (var key in clsDef) {\r\n        if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {\r\n            proto[key] = applyParams(clsDef[key], key);\r\n        }\r\n    }\r\n    if (this && this.annotations instanceof Array) {\r\n        Reflect.defineMetadata('annotations', this.annotations, constructor);\r\n    }\r\n    if (!constructor['name']) {\r\n        constructor['overriddenName'] = \"class\" + _nextClassId++;\r\n    }\r\n    return constructor;\r\n}\r\nexports.Class = Class;\r\nvar Reflect = lang_1.global.Reflect;\r\nif (!(Reflect && Reflect.getMetadata)) {\r\n    throw 'reflect-metadata shim is required when using class decorators';\r\n}\r\nfunction makeDecorator(annotationCls, chainFn) {\r\n    if (chainFn === void 0) { chainFn = null; }\r\n    function DecoratorFactory(objOrType) {\r\n        var annotationInstance = new annotationCls(objOrType);\r\n        if (this instanceof annotationCls) {\r\n            return annotationInstance;\r\n        }\r\n        else {\r\n            var chainAnnotation = lang_1.isFunction(this) && this.annotations instanceof Array ? this.annotations : [];\r\n            chainAnnotation.push(annotationInstance);\r\n            var TypeDecorator = function TypeDecorator(cls) {\r\n                var annotations = Reflect.getOwnMetadata('annotations', cls);\r\n                annotations = annotations || [];\r\n                annotations.push(annotationInstance);\r\n                Reflect.defineMetadata('annotations', annotations, cls);\r\n                return cls;\r\n            };\r\n            TypeDecorator.annotations = chainAnnotation;\r\n            TypeDecorator.Class = Class;\r\n            if (chainFn)\r\n                chainFn(TypeDecorator);\r\n            return TypeDecorator;\r\n        }\r\n    }\r\n    DecoratorFactory.prototype = Object.create(annotationCls.prototype);\r\n    return DecoratorFactory;\r\n}\r\nexports.makeDecorator = makeDecorator;\r\nfunction makeParamDecorator(annotationCls) {\r\n    function ParamDecoratorFactory() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i - 0] = arguments[_i];\r\n        }\r\n        var annotationInstance = Object.create(annotationCls.prototype);\r\n        annotationCls.apply(annotationInstance, args);\r\n        if (this instanceof annotationCls) {\r\n            return annotationInstance;\r\n        }\r\n        else {\r\n            ParamDecorator.annotation = annotationInstance;\r\n            return ParamDecorator;\r\n        }\r\n        function ParamDecorator(cls, unusedKey, index) {\r\n            var parameters = Reflect.getMetadata('parameters', cls);\r\n            parameters = parameters || [];\r\n            // there might be gaps if some in between parameters do not have annotations.\r\n            // we pad with nulls.\r\n            while (parameters.length <= index) {\r\n                parameters.push(null);\r\n            }\r\n            parameters[index] = parameters[index] || [];\r\n            var annotationsForParam = parameters[index];\r\n            annotationsForParam.push(annotationInstance);\r\n            Reflect.defineMetadata('parameters', parameters, cls);\r\n            return cls;\r\n        }\r\n    }\r\n    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);\r\n    return ParamDecoratorFactory;\r\n}\r\nexports.makeParamDecorator = makeParamDecorator;\r\nfunction makePropDecorator(decoratorCls) {\r\n    function PropDecoratorFactory() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i - 0] = arguments[_i];\r\n        }\r\n        var decoratorInstance = Object.create(decoratorCls.prototype);\r\n        decoratorCls.apply(decoratorInstance, args);\r\n        if (this instanceof decoratorCls) {\r\n            return decoratorInstance;\r\n        }\r\n        else {\r\n            return function PropDecorator(target, name) {\r\n                var meta = Reflect.getOwnMetadata('propMetadata', target.constructor);\r\n                meta = meta || {};\r\n                meta[name] = meta[name] || [];\r\n                meta[name].unshift(decoratorInstance);\r\n                Reflect.defineMetadata('propMetadata', meta, target.constructor);\r\n            };\r\n        }\r\n    }\r\n    PropDecoratorFactory.prototype = Object.create(decoratorCls.prototype);\r\n    return PropDecoratorFactory;\r\n}\r\nexports.makePropDecorator = makePropDecorator;\r\n},{\"angular2/src/facade/lang\":176}],167:[function(require,module,exports){\n'use strict';// Public API for Zone\r\nvar ng_zone_1 = require('./zone/ng_zone');\r\nexports.NgZone = ng_zone_1.NgZone;\r\nexports.NgZoneError = ng_zone_1.NgZoneError;\r\n},{\"./zone/ng_zone\":168}],168:[function(require,module,exports){\n'use strict';var collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar async_1 = require('angular2/src/facade/async');\r\nvar profile_1 = require('../profile/profile');\r\n/**\r\n * Stores error information; delivered via [NgZone.onError] stream.\r\n */\r\nvar NgZoneError = (function () {\r\n    function NgZoneError(error, stackTrace) {\r\n        this.error = error;\r\n        this.stackTrace = stackTrace;\r\n    }\r\n    return NgZoneError;\r\n})();\r\nexports.NgZoneError = NgZoneError;\r\n/**\r\n * An injectable service for executing work inside or outside of the Angular zone.\r\n *\r\n * The most common use of this service is to optimize performance when starting a work consisting of\r\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\r\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\r\n * can reenter the Angular zone via {@link #run}.\r\n *\r\n * <!-- TODO: add/fix links to:\r\n *   - docs explaining zones and the use of zones in Angular and change-detection\r\n *   - link to runOutsideAngular/run (throughout this file!)\r\n *   -->\r\n *\r\n * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))\r\n * ```\r\n * import {Component, View, NgZone} from 'angular2/core';\r\n * import {NgIf} from 'angular2/common';\r\n *\r\n * @Component({\r\n *   selector: 'ng-zone-demo'.\r\n *   template: `\r\n *     <h2>Demo: NgZone</h2>\r\n *\r\n *     <p>Progress: {{progress}}%</p>\r\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\r\n *\r\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\r\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\r\n *   `,\r\n *   directives: [NgIf]\r\n * })\r\n * export class NgZoneDemo {\r\n *   progress: number = 0;\r\n *   label: string;\r\n *\r\n *   constructor(private _ngZone: NgZone) {}\r\n *\r\n *   // Loop inside the Angular zone\r\n *   // so the UI DOES refresh after each setTimeout cycle\r\n *   processWithinAngularZone() {\r\n *     this.label = 'inside';\r\n *     this.progress = 0;\r\n *     this._increaseProgress(() => console.log('Inside Done!'));\r\n *   }\r\n *\r\n *   // Loop outside of the Angular zone\r\n *   // so the UI DOES NOT refresh after each setTimeout cycle\r\n *   processOutsideOfAngularZone() {\r\n *     this.label = 'outside';\r\n *     this.progress = 0;\r\n *     this._ngZone.runOutsideAngular(() => {\r\n *       this._increaseProgress(() => {\r\n *       // reenter the Angular zone and display done\r\n *       this._ngZone.run(() => {console.log('Outside Done!') });\r\n *     }}));\r\n *   }\r\n *\r\n *\r\n *   _increaseProgress(doneCallback: () => void) {\r\n *     this.progress += 1;\r\n *     console.log(`Current progress: ${this.progress}%`);\r\n *\r\n *     if (this.progress < 100) {\r\n *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)\r\n *     } else {\r\n *       doneCallback();\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n */\r\nvar NgZone = (function () {\r\n    /**\r\n     * @param {bool} enableLongStackTrace whether to enable long stack trace. They should only be\r\n     *               enabled in development mode as they significantly impact perf.\r\n     */\r\n    function NgZone(_a) {\r\n        var enableLongStackTrace = _a.enableLongStackTrace;\r\n        /** @internal */\r\n        this._runScope = profile_1.wtfCreateScope(\"NgZone#run()\");\r\n        /** @internal */\r\n        this._microtaskScope = profile_1.wtfCreateScope(\"NgZone#microtask()\");\r\n        // Number of microtasks pending from _innerZone (& descendants)\r\n        /** @internal */\r\n        this._pendingMicrotasks = 0;\r\n        // Whether some code has been executed in the _innerZone (& descendants) in the current turn\r\n        /** @internal */\r\n        this._hasExecutedCodeInInnerZone = false;\r\n        // run() call depth in _mountZone. 0 at the end of a macrotask\r\n        // zone.run(() => {         // top-level call\r\n        //   zone.run(() => {});    // nested call -> in-turn\r\n        // });\r\n        /** @internal */\r\n        this._nestedRun = 0;\r\n        /** @internal */\r\n        this._inVmTurnDone = false;\r\n        /** @internal */\r\n        this._pendingTimeouts = [];\r\n        if (lang_1.global.zone) {\r\n            this._disabled = false;\r\n            this._mountZone = lang_1.global.zone;\r\n            this._innerZone = this._createInnerZone(this._mountZone, enableLongStackTrace);\r\n        }\r\n        else {\r\n            this._disabled = true;\r\n            this._mountZone = null;\r\n        }\r\n        this._onTurnStartEvents = new async_1.EventEmitter(false);\r\n        this._onTurnDoneEvents = new async_1.EventEmitter(false);\r\n        this._onEventDoneEvents = new async_1.EventEmitter(false);\r\n        this._onErrorEvents = new async_1.EventEmitter(false);\r\n    }\r\n    /**\r\n     * Sets the zone hook that is called just before a browser task that is handled by Angular\r\n     * executes.\r\n     *\r\n     * The hook is called once per browser task that is handled by Angular.\r\n     *\r\n     * Setting the hook overrides any previously set hook.\r\n     *\r\n     * @deprecated this API will be removed in the future. Use `onTurnStart` instead.\r\n     */\r\n    NgZone.prototype.overrideOnTurnStart = function (onTurnStartHook) {\r\n        this._onTurnStart = lang_1.normalizeBlank(onTurnStartHook);\r\n    };\r\n    Object.defineProperty(NgZone.prototype, \"onTurnStart\", {\r\n        /**\r\n         * Notifies subscribers just before Angular event turn starts.\r\n         *\r\n         * Emits an event once per browser task that is handled by Angular.\r\n         */\r\n        get: function () { return this._onTurnStartEvents; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @internal */\r\n    NgZone.prototype._notifyOnTurnStart = function (parentRun) {\r\n        var _this = this;\r\n        parentRun.call(this._innerZone, function () { _this._onTurnStartEvents.emit(null); });\r\n    };\r\n    /**\r\n     * Sets the zone hook that is called immediately after Angular zone is done processing the current\r\n     * task and any microtasks scheduled from that task.\r\n     *\r\n     * This is where we typically do change-detection.\r\n     *\r\n     * The hook is called once per browser task that is handled by Angular.\r\n     *\r\n     * Setting the hook overrides any previously set hook.\r\n     *\r\n     * @deprecated this API will be removed in the future. Use `onTurnDone` instead.\r\n     */\r\n    NgZone.prototype.overrideOnTurnDone = function (onTurnDoneHook) {\r\n        this._onTurnDone = lang_1.normalizeBlank(onTurnDoneHook);\r\n    };\r\n    Object.defineProperty(NgZone.prototype, \"onTurnDone\", {\r\n        /**\r\n         * Notifies subscribers immediately after Angular zone is done processing\r\n         * the current turn and any microtasks scheduled from that turn.\r\n         *\r\n         * Used by Angular as a signal to kick off change-detection.\r\n         */\r\n        get: function () { return this._onTurnDoneEvents; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @internal */\r\n    NgZone.prototype._notifyOnTurnDone = function (parentRun) {\r\n        var _this = this;\r\n        parentRun.call(this._innerZone, function () { _this._onTurnDoneEvents.emit(null); });\r\n    };\r\n    /**\r\n     * Sets the zone hook that is called immediately after the `onTurnDone` callback is called and any\r\n     * microstasks scheduled from within that callback are drained.\r\n     *\r\n     * `onEventDoneFn` is executed outside Angular zone, which means that we will no longer attempt to\r\n     * sync the UI with any model changes that occur within this callback.\r\n     *\r\n     * This hook is useful for validating application state (e.g. in a test).\r\n     *\r\n     * Setting the hook overrides any previously set hook.\r\n     *\r\n     * @deprecated this API will be removed in the future. Use `onEventDone` instead.\r\n     */\r\n    NgZone.prototype.overrideOnEventDone = function (onEventDoneFn, opt_waitForAsync) {\r\n        var _this = this;\r\n        if (opt_waitForAsync === void 0) { opt_waitForAsync = false; }\r\n        var normalizedOnEventDone = lang_1.normalizeBlank(onEventDoneFn);\r\n        if (opt_waitForAsync) {\r\n            this._onEventDone = function () {\r\n                if (!_this._pendingTimeouts.length) {\r\n                    normalizedOnEventDone();\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            this._onEventDone = normalizedOnEventDone;\r\n        }\r\n    };\r\n    Object.defineProperty(NgZone.prototype, \"onEventDone\", {\r\n        /**\r\n         * Notifies subscribers immediately after the final `onTurnDone` callback\r\n         * before ending VM event.\r\n         *\r\n         * This event is useful for validating application state (e.g. in a test).\r\n         */\r\n        get: function () { return this._onEventDoneEvents; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @internal */\r\n    NgZone.prototype._notifyOnEventDone = function () {\r\n        var _this = this;\r\n        this.runOutsideAngular(function () { _this._onEventDoneEvents.emit(null); });\r\n    };\r\n    Object.defineProperty(NgZone.prototype, \"hasPendingMicrotasks\", {\r\n        /**\r\n         * Whether there are any outstanding microtasks.\r\n         */\r\n        get: function () { return this._pendingMicrotasks > 0; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgZone.prototype, \"hasPendingTimers\", {\r\n        /**\r\n         * Whether there are any outstanding timers.\r\n         */\r\n        get: function () { return this._pendingTimeouts.length > 0; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgZone.prototype, \"hasPendingAsyncTasks\", {\r\n        /**\r\n         * Whether there are any outstanding asynchronous tasks of any kind that are\r\n         * scheduled to run within Angular zone.\r\n         *\r\n         * Useful as a signal of UI stability. For example, when a test reaches a\r\n         * point when [hasPendingAsyncTasks] is `false` it might be a good time to run\r\n         * test expectations.\r\n         */\r\n        get: function () { return this.hasPendingMicrotasks || this.hasPendingTimers; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Sets the zone hook that is called when an error is thrown in the Angular zone.\r\n     *\r\n     * Setting the hook overrides any previously set hook.\r\n     *\r\n     * @deprecated this API will be removed in the future. Use `onError` instead.\r\n     */\r\n    NgZone.prototype.overrideOnErrorHandler = function (errorHandler) {\r\n        this._onErrorHandler = lang_1.normalizeBlank(errorHandler);\r\n    };\r\n    Object.defineProperty(NgZone.prototype, \"onError\", {\r\n        get: function () { return this._onErrorEvents; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Executes the `fn` function synchronously within the Angular zone and returns value returned by\r\n     * the function.\r\n     *\r\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\r\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\r\n     *\r\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\r\n     * within the Angular zone.\r\n     */\r\n    NgZone.prototype.run = function (fn) {\r\n        if (this._disabled) {\r\n            return fn();\r\n        }\r\n        else {\r\n            var s = this._runScope();\r\n            try {\r\n                return this._innerZone.run(fn);\r\n            }\r\n            finally {\r\n                profile_1.wtfLeave(s);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\r\n     * the function.\r\n     *\r\n     * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that\r\n     * doesn't trigger Angular change-detection or is subject to Angular's error handling.\r\n     *\r\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\r\n     * outside of the Angular zone.\r\n     *\r\n     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\r\n     */\r\n    NgZone.prototype.runOutsideAngular = function (fn) {\r\n        if (this._disabled) {\r\n            return fn();\r\n        }\r\n        else {\r\n            return this._mountZone.run(fn);\r\n        }\r\n    };\r\n    /** @internal */\r\n    NgZone.prototype._createInnerZone = function (zone, enableLongStackTrace) {\r\n        var microtaskScope = this._microtaskScope;\r\n        var ngZone = this;\r\n        var errorHandling;\r\n        if (enableLongStackTrace) {\r\n            errorHandling = collection_1.StringMapWrapper.merge(Zone.longStackTraceZone, { onError: function (e) { ngZone._notifyOnError(this, e); } });\r\n        }\r\n        else {\r\n            errorHandling = { onError: function (e) { ngZone._notifyOnError(this, e); } };\r\n        }\r\n        return zone.fork(errorHandling)\r\n            .fork({\r\n            '$run': function (parentRun) {\r\n                return function () {\r\n                    try {\r\n                        ngZone._nestedRun++;\r\n                        if (!ngZone._hasExecutedCodeInInnerZone) {\r\n                            ngZone._hasExecutedCodeInInnerZone = true;\r\n                            ngZone._notifyOnTurnStart(parentRun);\r\n                            if (ngZone._onTurnStart) {\r\n                                parentRun.call(ngZone._innerZone, ngZone._onTurnStart);\r\n                            }\r\n                        }\r\n                        return parentRun.apply(this, arguments);\r\n                    }\r\n                    finally {\r\n                        ngZone._nestedRun--;\r\n                        // If there are no more pending microtasks, we are at the end of a VM turn (or in\r\n                        // onTurnStart)\r\n                        // _nestedRun will be 0 at the end of a macrotasks (it could be > 0 when there are\r\n                        // nested calls\r\n                        // to run()).\r\n                        if (ngZone._pendingMicrotasks == 0 && ngZone._nestedRun == 0 &&\r\n                            !this._inVmTurnDone) {\r\n                            if (ngZone._hasExecutedCodeInInnerZone) {\r\n                                try {\r\n                                    this._inVmTurnDone = true;\r\n                                    ngZone._notifyOnTurnDone(parentRun);\r\n                                    if (ngZone._onTurnDone) {\r\n                                        parentRun.call(ngZone._innerZone, ngZone._onTurnDone);\r\n                                    }\r\n                                }\r\n                                finally {\r\n                                    this._inVmTurnDone = false;\r\n                                    ngZone._hasExecutedCodeInInnerZone = false;\r\n                                }\r\n                            }\r\n                            if (ngZone._pendingMicrotasks === 0) {\r\n                                ngZone._notifyOnEventDone();\r\n                                if (lang_1.isPresent(ngZone._onEventDone)) {\r\n                                    ngZone.runOutsideAngular(ngZone._onEventDone);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n            },\r\n            '$scheduleMicrotask': function (parentScheduleMicrotask) {\r\n                return function (fn) {\r\n                    ngZone._pendingMicrotasks++;\r\n                    var microtask = function () {\r\n                        var s = microtaskScope();\r\n                        try {\r\n                            fn();\r\n                        }\r\n                        finally {\r\n                            ngZone._pendingMicrotasks--;\r\n                            profile_1.wtfLeave(s);\r\n                        }\r\n                    };\r\n                    parentScheduleMicrotask.call(this, microtask);\r\n                };\r\n            },\r\n            '$setTimeout': function (parentSetTimeout) {\r\n                return function (fn, delay) {\r\n                    var args = [];\r\n                    for (var _i = 2; _i < arguments.length; _i++) {\r\n                        args[_i - 2] = arguments[_i];\r\n                    }\r\n                    var id;\r\n                    var cb = function () {\r\n                        fn();\r\n                        collection_1.ListWrapper.remove(ngZone._pendingTimeouts, id);\r\n                    };\r\n                    id = parentSetTimeout(cb, delay, args);\r\n                    ngZone._pendingTimeouts.push(id);\r\n                    return id;\r\n                };\r\n            },\r\n            '$clearTimeout': function (parentClearTimeout) {\r\n                return function (id) {\r\n                    parentClearTimeout(id);\r\n                    collection_1.ListWrapper.remove(ngZone._pendingTimeouts, id);\r\n                };\r\n            },\r\n            _innerZone: true\r\n        });\r\n    };\r\n    /** @internal */\r\n    NgZone.prototype._notifyOnError = function (zone, e) {\r\n        if (lang_1.isPresent(this._onErrorHandler) || async_1.ObservableWrapper.hasSubscribers(this._onErrorEvents)) {\r\n            var trace = [lang_1.normalizeBlank(e.stack)];\r\n            while (zone && zone.constructedAtException) {\r\n                trace.push(zone.constructedAtException.get());\r\n                zone = zone.parent;\r\n            }\r\n            if (async_1.ObservableWrapper.hasSubscribers(this._onErrorEvents)) {\r\n                async_1.ObservableWrapper.callEmit(this._onErrorEvents, new NgZoneError(e, trace));\r\n            }\r\n            if (lang_1.isPresent(this._onErrorHandler)) {\r\n                this._onErrorHandler(e, trace);\r\n            }\r\n        }\r\n        else {\r\n            console.log('## _notifyOnError ##');\r\n            console.log(e.stack);\r\n            throw e;\r\n        }\r\n    };\r\n    return NgZone;\r\n})();\r\nexports.NgZone = NgZone;\r\n},{\"../profile/profile\":155,\"angular2/src/facade/async\":169,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176}],169:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar promise_1 = require('angular2/src/facade/promise');\r\nexports.PromiseWrapper = promise_1.PromiseWrapper;\r\nexports.Promise = promise_1.Promise;\r\nvar Subject_1 = require('rxjs/Subject');\r\nvar fromPromise_1 = require('rxjs/observable/fromPromise');\r\nvar toPromise_1 = require('rxjs/operator/toPromise');\r\nvar Observable_1 = require('rxjs/Observable');\r\nexports.Observable = Observable_1.Observable;\r\nvar Subject_2 = require('rxjs/Subject');\r\nexports.Subject = Subject_2.Subject;\r\nvar TimerWrapper = (function () {\r\n    function TimerWrapper() {\r\n    }\r\n    TimerWrapper.setTimeout = function (fn, millis) {\r\n        return lang_1.global.setTimeout(fn, millis);\r\n    };\r\n    TimerWrapper.clearTimeout = function (id) { lang_1.global.clearTimeout(id); };\r\n    TimerWrapper.setInterval = function (fn, millis) {\r\n        return lang_1.global.setInterval(fn, millis);\r\n    };\r\n    TimerWrapper.clearInterval = function (id) { lang_1.global.clearInterval(id); };\r\n    return TimerWrapper;\r\n})();\r\nexports.TimerWrapper = TimerWrapper;\r\nvar ObservableWrapper = (function () {\r\n    function ObservableWrapper() {\r\n    }\r\n    // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg\r\n    ObservableWrapper.subscribe = function (emitter, onNext, onError, onComplete) {\r\n        if (onComplete === void 0) { onComplete = function () { }; }\r\n        onError = (typeof onError === \"function\") && onError || lang_1.noop;\r\n        onComplete = (typeof onComplete === \"function\") && onComplete || lang_1.noop;\r\n        return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });\r\n    };\r\n    ObservableWrapper.isObservable = function (obs) { return !!obs.subscribe; };\r\n    /**\r\n     * Returns whether `obs` has any subscribers listening to events.\r\n     */\r\n    ObservableWrapper.hasSubscribers = function (obs) { return obs.observers.length > 0; };\r\n    ObservableWrapper.dispose = function (subscription) { subscription.unsubscribe(); };\r\n    /**\r\n     * @deprecated - use callEmit() instead\r\n     */\r\n    ObservableWrapper.callNext = function (emitter, value) { emitter.next(value); };\r\n    ObservableWrapper.callEmit = function (emitter, value) { emitter.emit(value); };\r\n    ObservableWrapper.callError = function (emitter, error) { emitter.error(error); };\r\n    ObservableWrapper.callComplete = function (emitter) { emitter.complete(); };\r\n    ObservableWrapper.fromPromise = function (promise) {\r\n        return fromPromise_1.PromiseObservable.create(promise);\r\n    };\r\n    ObservableWrapper.toPromise = function (obj) { return toPromise_1.toPromise.call(obj); };\r\n    return ObservableWrapper;\r\n})();\r\nexports.ObservableWrapper = ObservableWrapper;\r\n/**\r\n * Use by directives and components to emit custom Events.\r\n *\r\n * ### Examples\r\n *\r\n * In the following example, `Zippy` alternatively emits `open` and `close` events when its\r\n * title gets clicked:\r\n *\r\n * ```\r\n * @Component({\r\n *   selector: 'zippy',\r\n *   template: `\r\n *   <div class=\"zippy\">\r\n *     <div (click)=\"toggle()\">Toggle</div>\r\n *     <div [hidden]=\"!visible\">\r\n *       <ng-content></ng-content>\r\n *     </div>\r\n *  </div>`})\r\n * export class Zippy {\r\n *   visible: boolean = true;\r\n *   @Output() open: EventEmitter<any> = new EventEmitter();\r\n *   @Output() close: EventEmitter<any> = new EventEmitter();\r\n *\r\n *   toggle() {\r\n *     this.visible = !this.visible;\r\n *     if (this.visible) {\r\n *       this.open.emit(null);\r\n *     } else {\r\n *       this.close.emit(null);\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Use Rx.Observable but provides an adapter to make it work as specified here:\r\n * https://github.com/jhusain/observable-spec\r\n *\r\n * Once a reference implementation of the spec is available, switch to it.\r\n */\r\nvar EventEmitter = (function (_super) {\r\n    __extends(EventEmitter, _super);\r\n    /**\r\n     * Creates an instance of [EventEmitter], which depending on [isAsync],\r\n     * delivers events synchronously or asynchronously.\r\n     */\r\n    function EventEmitter(isAsync) {\r\n        if (isAsync === void 0) { isAsync = true; }\r\n        _super.call(this);\r\n        this._isAsync = isAsync;\r\n    }\r\n    EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };\r\n    /**\r\n     * @deprecated - use .emit(value) instead\r\n     */\r\n    EventEmitter.prototype.next = function (value) { _super.prototype.next.call(this, value); };\r\n    EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {\r\n        var schedulerFn;\r\n        var errorFn = function (err) { return null; };\r\n        var completeFn = function () { return null; };\r\n        if (generatorOrNext && typeof generatorOrNext === 'object') {\r\n            schedulerFn = this._isAsync ? function (value) { setTimeout(function () { return generatorOrNext.next(value); }); } :\r\n                function (value) { generatorOrNext.next(value); };\r\n            if (generatorOrNext.error) {\r\n                errorFn = this._isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :\r\n                    function (err) { generatorOrNext.error(err); };\r\n            }\r\n            if (generatorOrNext.complete) {\r\n                completeFn = this._isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :\r\n                    function () { generatorOrNext.complete(); };\r\n            }\r\n        }\r\n        else {\r\n            schedulerFn = this._isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :\r\n                function (value) { generatorOrNext(value); };\r\n            if (error) {\r\n                errorFn =\r\n                    this._isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };\r\n            }\r\n            if (complete) {\r\n                completeFn =\r\n                    this._isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };\r\n            }\r\n        }\r\n        return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);\r\n    };\r\n    return EventEmitter;\r\n})(Subject_1.Subject);\r\nexports.EventEmitter = EventEmitter;\r\n},{\"angular2/src/facade/lang\":176,\"angular2/src/facade/promise\":178,\"rxjs/Observable\":323,\"rxjs/Subject\":325,\"rxjs/observable/fromPromise\":328,\"rxjs/operator/toPromise\":329}],170:[function(require,module,exports){\n'use strict';/**\r\n * JS version of browser APIs. This library can only run in the browser.\r\n */\r\nvar win = window;\r\nexports.window = win;\r\nexports.document = window.document;\r\nexports.location = window.location;\r\nexports.gc = window['gc'] ? function () { return window['gc'](); } : function () { return null; };\r\nexports.performance = window['performance'] ? window['performance'] : null;\r\nexports.Event = window['Event'];\r\nexports.MouseEvent = window['MouseEvent'];\r\nexports.KeyboardEvent = window['KeyboardEvent'];\r\nexports.EventTarget = window['EventTarget'];\r\nexports.History = window['History'];\r\nexports.Location = window['Location'];\r\nexports.EventListener = window['EventListener'];\r\n},{}],171:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nexports.Map = lang_1.global.Map;\r\nexports.Set = lang_1.global.Set;\r\n// Safari and Internet Explorer do not support the iterable parameter to the\r\n// Map constructor.  We work around that by manually adding the items.\r\nvar createMapFromPairs = (function () {\r\n    try {\r\n        if (new exports.Map([[1, 2]]).size === 1) {\r\n            return function createMapFromPairs(pairs) { return new exports.Map(pairs); };\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return function createMapAndPopulateFromPairs(pairs) {\r\n        var map = new exports.Map();\r\n        for (var i = 0; i < pairs.length; i++) {\r\n            var pair = pairs[i];\r\n            map.set(pair[0], pair[1]);\r\n        }\r\n        return map;\r\n    };\r\n})();\r\nvar createMapFromMap = (function () {\r\n    try {\r\n        if (new exports.Map(new exports.Map())) {\r\n            return function createMapFromMap(m) { return new exports.Map(m); };\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return function createMapAndPopulateFromMap(m) {\r\n        var map = new exports.Map();\r\n        m.forEach(function (v, k) { map.set(k, v); });\r\n        return map;\r\n    };\r\n})();\r\nvar _clearValues = (function () {\r\n    if ((new exports.Map()).keys().next) {\r\n        return function _clearValues(m) {\r\n            var keyIterator = m.keys();\r\n            var k;\r\n            while (!((k = keyIterator.next()).done)) {\r\n                m.set(k.value, null);\r\n            }\r\n        };\r\n    }\r\n    else {\r\n        return function _clearValuesWithForeEach(m) {\r\n            m.forEach(function (v, k) { m.set(k, null); });\r\n        };\r\n    }\r\n})();\r\n// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from\r\n// TODO(mlaval): remove the work around once we have a working polyfill of Array.from\r\nvar _arrayFromMap = (function () {\r\n    try {\r\n        if ((new exports.Map()).values().next) {\r\n            return function createArrayFromMap(m, getValues) {\r\n                return getValues ? Array.from(m.values()) : Array.from(m.keys());\r\n            };\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return function createArrayFromMapWithForeach(m, getValues) {\r\n        var res = ListWrapper.createFixedSize(m.size), i = 0;\r\n        m.forEach(function (v, k) {\r\n            res[i] = getValues ? v : k;\r\n            i++;\r\n        });\r\n        return res;\r\n    };\r\n})();\r\nvar MapWrapper = (function () {\r\n    function MapWrapper() {\r\n    }\r\n    MapWrapper.clone = function (m) { return createMapFromMap(m); };\r\n    MapWrapper.createFromStringMap = function (stringMap) {\r\n        var result = new exports.Map();\r\n        for (var prop in stringMap) {\r\n            result.set(prop, stringMap[prop]);\r\n        }\r\n        return result;\r\n    };\r\n    MapWrapper.toStringMap = function (m) {\r\n        var r = {};\r\n        m.forEach(function (v, k) { return r[k] = v; });\r\n        return r;\r\n    };\r\n    MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };\r\n    MapWrapper.clearValues = function (m) { _clearValues(m); };\r\n    MapWrapper.iterable = function (m) { return m; };\r\n    MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };\r\n    MapWrapper.values = function (m) { return _arrayFromMap(m, true); };\r\n    return MapWrapper;\r\n})();\r\nexports.MapWrapper = MapWrapper;\r\n/**\r\n * Wraps Javascript Objects\r\n */\r\nvar StringMapWrapper = (function () {\r\n    function StringMapWrapper() {\r\n    }\r\n    StringMapWrapper.create = function () {\r\n        // Note: We are not using Object.create(null) here due to\r\n        // performance!\r\n        // http://jsperf.com/ng2-object-create-null\r\n        return {};\r\n    };\r\n    StringMapWrapper.contains = function (map, key) {\r\n        return map.hasOwnProperty(key);\r\n    };\r\n    StringMapWrapper.get = function (map, key) {\r\n        return map.hasOwnProperty(key) ? map[key] : undefined;\r\n    };\r\n    StringMapWrapper.set = function (map, key, value) { map[key] = value; };\r\n    StringMapWrapper.keys = function (map) { return Object.keys(map); };\r\n    StringMapWrapper.isEmpty = function (map) {\r\n        for (var prop in map) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    StringMapWrapper.delete = function (map, key) { delete map[key]; };\r\n    StringMapWrapper.forEach = function (map, callback) {\r\n        for (var prop in map) {\r\n            if (map.hasOwnProperty(prop)) {\r\n                callback(map[prop], prop);\r\n            }\r\n        }\r\n    };\r\n    StringMapWrapper.merge = function (m1, m2) {\r\n        var m = {};\r\n        for (var attr in m1) {\r\n            if (m1.hasOwnProperty(attr)) {\r\n                m[attr] = m1[attr];\r\n            }\r\n        }\r\n        for (var attr in m2) {\r\n            if (m2.hasOwnProperty(attr)) {\r\n                m[attr] = m2[attr];\r\n            }\r\n        }\r\n        return m;\r\n    };\r\n    StringMapWrapper.equals = function (m1, m2) {\r\n        var k1 = Object.keys(m1);\r\n        var k2 = Object.keys(m2);\r\n        if (k1.length != k2.length) {\r\n            return false;\r\n        }\r\n        var key;\r\n        for (var i = 0; i < k1.length; i++) {\r\n            key = k1[i];\r\n            if (m1[key] !== m2[key]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    return StringMapWrapper;\r\n})();\r\nexports.StringMapWrapper = StringMapWrapper;\r\nvar ListWrapper = (function () {\r\n    function ListWrapper() {\r\n    }\r\n    // JS has no way to express a statically fixed size list, but dart does so we\r\n    // keep both methods.\r\n    ListWrapper.createFixedSize = function (size) { return new Array(size); };\r\n    ListWrapper.createGrowableSize = function (size) { return new Array(size); };\r\n    ListWrapper.clone = function (array) { return array.slice(0); };\r\n    ListWrapper.forEachWithIndex = function (array, fn) {\r\n        for (var i = 0; i < array.length; i++) {\r\n            fn(array[i], i);\r\n        }\r\n    };\r\n    ListWrapper.first = function (array) {\r\n        if (!array)\r\n            return null;\r\n        return array[0];\r\n    };\r\n    ListWrapper.last = function (array) {\r\n        if (!array || array.length == 0)\r\n            return null;\r\n        return array[array.length - 1];\r\n    };\r\n    ListWrapper.indexOf = function (array, value, startIndex) {\r\n        if (startIndex === void 0) { startIndex = 0; }\r\n        return array.indexOf(value, startIndex);\r\n    };\r\n    ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };\r\n    ListWrapper.reversed = function (array) {\r\n        var a = ListWrapper.clone(array);\r\n        return a.reverse();\r\n    };\r\n    ListWrapper.concat = function (a, b) { return a.concat(b); };\r\n    ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };\r\n    ListWrapper.removeAt = function (list, index) {\r\n        var res = list[index];\r\n        list.splice(index, 1);\r\n        return res;\r\n    };\r\n    ListWrapper.removeAll = function (list, items) {\r\n        for (var i = 0; i < items.length; ++i) {\r\n            var index = list.indexOf(items[i]);\r\n            list.splice(index, 1);\r\n        }\r\n    };\r\n    ListWrapper.remove = function (list, el) {\r\n        var index = list.indexOf(el);\r\n        if (index > -1) {\r\n            list.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    ListWrapper.clear = function (list) { list.length = 0; };\r\n    ListWrapper.isEmpty = function (list) { return list.length == 0; };\r\n    ListWrapper.fill = function (list, value, start, end) {\r\n        if (start === void 0) { start = 0; }\r\n        if (end === void 0) { end = null; }\r\n        list.fill(value, start, end === null ? list.length : end);\r\n    };\r\n    ListWrapper.equals = function (a, b) {\r\n        if (a.length != b.length)\r\n            return false;\r\n        for (var i = 0; i < a.length; ++i) {\r\n            if (a[i] !== b[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    ListWrapper.slice = function (l, from, to) {\r\n        if (from === void 0) { from = 0; }\r\n        if (to === void 0) { to = null; }\r\n        return l.slice(from, to === null ? undefined : to);\r\n    };\r\n    ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };\r\n    ListWrapper.sort = function (l, compareFn) {\r\n        if (lang_1.isPresent(compareFn)) {\r\n            l.sort(compareFn);\r\n        }\r\n        else {\r\n            l.sort();\r\n        }\r\n    };\r\n    ListWrapper.toString = function (l) { return l.toString(); };\r\n    ListWrapper.toJSON = function (l) { return JSON.stringify(l); };\r\n    ListWrapper.maximum = function (list, predicate) {\r\n        if (list.length == 0) {\r\n            return null;\r\n        }\r\n        var solution = null;\r\n        var maxValue = -Infinity;\r\n        for (var index = 0; index < list.length; index++) {\r\n            var candidate = list[index];\r\n            if (lang_1.isBlank(candidate)) {\r\n                continue;\r\n            }\r\n            var candidateValue = predicate(candidate);\r\n            if (candidateValue > maxValue) {\r\n                solution = candidate;\r\n                maxValue = candidateValue;\r\n            }\r\n        }\r\n        return solution;\r\n    };\r\n    return ListWrapper;\r\n})();\r\nexports.ListWrapper = ListWrapper;\r\nfunction isListLikeIterable(obj) {\r\n    if (!lang_1.isJsObject(obj))\r\n        return false;\r\n    return lang_1.isArray(obj) ||\r\n        (!(obj instanceof exports.Map) &&\r\n            lang_1.getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\r\n}\r\nexports.isListLikeIterable = isListLikeIterable;\r\nfunction iterateListLike(obj, fn) {\r\n    if (lang_1.isArray(obj)) {\r\n        for (var i = 0; i < obj.length; i++) {\r\n            fn(obj[i]);\r\n        }\r\n    }\r\n    else {\r\n        var iterator = obj[lang_1.getSymbolIterator()]();\r\n        var item;\r\n        while (!((item = iterator.next()).done)) {\r\n            fn(item.value);\r\n        }\r\n    }\r\n}\r\nexports.iterateListLike = iterateListLike;\r\n// Safari and Internet Explorer do not support the iterable parameter to the\r\n// Set constructor.  We work around that by manually adding the items.\r\nvar createSetFromList = (function () {\r\n    var test = new exports.Set([1, 2, 3]);\r\n    if (test.size === 3) {\r\n        return function createSetFromList(lst) { return new exports.Set(lst); };\r\n    }\r\n    else {\r\n        return function createSetAndPopulateFromList(lst) {\r\n            var res = new exports.Set(lst);\r\n            if (res.size !== lst.length) {\r\n                for (var i = 0; i < lst.length; i++) {\r\n                    res.add(lst[i]);\r\n                }\r\n            }\r\n            return res;\r\n        };\r\n    }\r\n})();\r\nvar SetWrapper = (function () {\r\n    function SetWrapper() {\r\n    }\r\n    SetWrapper.createFromList = function (lst) { return createSetFromList(lst); };\r\n    SetWrapper.has = function (s, key) { return s.has(key); };\r\n    SetWrapper.delete = function (m, k) { m.delete(k); };\r\n    return SetWrapper;\r\n})();\r\nexports.SetWrapper = SetWrapper;\r\n},{\"angular2/src/facade/lang\":176}],172:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar _ArrayLogger = (function () {\r\n    function _ArrayLogger() {\r\n        this.res = [];\r\n    }\r\n    _ArrayLogger.prototype.log = function (s) { this.res.push(s); };\r\n    _ArrayLogger.prototype.logError = function (s) { this.res.push(s); };\r\n    _ArrayLogger.prototype.logGroup = function (s) { this.res.push(s); };\r\n    _ArrayLogger.prototype.logGroupEnd = function () { };\r\n    ;\r\n    return _ArrayLogger;\r\n})();\r\n/**\r\n * Provides a hook for centralized exception handling.\r\n *\r\n * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To\r\n * intercept error handling,\r\n * write a custom exception handler that replaces this default as appropriate for your app.\r\n *\r\n * ### Example\r\n *\r\n * ```javascript\r\n *\r\n * class MyExceptionHandler implements ExceptionHandler {\r\n *   call(error, stackTrace = null, reason = null) {\r\n *     // do something with the exception\r\n *   }\r\n * }\r\n *\r\n * bootstrap(MyApp, [provide(ExceptionHandler, {useClass: MyExceptionHandler})])\r\n *\r\n * ```\r\n */\r\nvar ExceptionHandler = (function () {\r\n    function ExceptionHandler(_logger, _rethrowException) {\r\n        if (_rethrowException === void 0) { _rethrowException = true; }\r\n        this._logger = _logger;\r\n        this._rethrowException = _rethrowException;\r\n    }\r\n    ExceptionHandler.exceptionToString = function (exception, stackTrace, reason) {\r\n        if (stackTrace === void 0) { stackTrace = null; }\r\n        if (reason === void 0) { reason = null; }\r\n        var l = new _ArrayLogger();\r\n        var e = new ExceptionHandler(l, false);\r\n        e.call(exception, stackTrace, reason);\r\n        return l.res.join(\"\\n\");\r\n    };\r\n    ExceptionHandler.prototype.call = function (exception, stackTrace, reason) {\r\n        if (stackTrace === void 0) { stackTrace = null; }\r\n        if (reason === void 0) { reason = null; }\r\n        var originalException = this._findOriginalException(exception);\r\n        var originalStack = this._findOriginalStack(exception);\r\n        var context = this._findContext(exception);\r\n        this._logger.logGroup(\"EXCEPTION: \" + this._extractMessage(exception));\r\n        if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {\r\n            this._logger.logError(\"STACKTRACE:\");\r\n            this._logger.logError(this._longStackTrace(stackTrace));\r\n        }\r\n        if (lang_1.isPresent(reason)) {\r\n            this._logger.logError(\"REASON: \" + reason);\r\n        }\r\n        if (lang_1.isPresent(originalException)) {\r\n            this._logger.logError(\"ORIGINAL EXCEPTION: \" + this._extractMessage(originalException));\r\n        }\r\n        if (lang_1.isPresent(originalStack)) {\r\n            this._logger.logError(\"ORIGINAL STACKTRACE:\");\r\n            this._logger.logError(this._longStackTrace(originalStack));\r\n        }\r\n        if (lang_1.isPresent(context)) {\r\n            this._logger.logError(\"ERROR CONTEXT:\");\r\n            this._logger.logError(context);\r\n        }\r\n        this._logger.logGroupEnd();\r\n        // We rethrow exceptions, so operations like 'bootstrap' will result in an error\r\n        // when an exception happens. If we do not rethrow, bootstrap will always succeed.\r\n        if (this._rethrowException)\r\n            throw exception;\r\n    };\r\n    /** @internal */\r\n    ExceptionHandler.prototype._extractMessage = function (exception) {\r\n        return exception instanceof exceptions_1.WrappedException ? exception.wrapperMessage : exception.toString();\r\n    };\r\n    /** @internal */\r\n    ExceptionHandler.prototype._longStackTrace = function (stackTrace) {\r\n        return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join(\"\\n\\n-----async gap-----\\n\") :\r\n            stackTrace.toString();\r\n    };\r\n    /** @internal */\r\n    ExceptionHandler.prototype._findContext = function (exception) {\r\n        try {\r\n            if (!(exception instanceof exceptions_1.WrappedException))\r\n                return null;\r\n            return lang_1.isPresent(exception.context) ? exception.context :\r\n                this._findContext(exception.originalException);\r\n        }\r\n        catch (e) {\r\n            // exception.context can throw an exception. if it happens, we ignore the context.\r\n            return null;\r\n        }\r\n    };\r\n    /** @internal */\r\n    ExceptionHandler.prototype._findOriginalException = function (exception) {\r\n        if (!(exception instanceof exceptions_1.WrappedException))\r\n            return null;\r\n        var e = exception.originalException;\r\n        while (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {\r\n            e = e.originalException;\r\n        }\r\n        return e;\r\n    };\r\n    /** @internal */\r\n    ExceptionHandler.prototype._findOriginalStack = function (exception) {\r\n        if (!(exception instanceof exceptions_1.WrappedException))\r\n            return null;\r\n        var e = exception;\r\n        var stack = exception.originalStack;\r\n        while (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {\r\n            e = e.originalException;\r\n            if (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {\r\n                stack = e.originalStack;\r\n            }\r\n        }\r\n        return stack;\r\n    };\r\n    return ExceptionHandler;\r\n})();\r\nexports.ExceptionHandler = ExceptionHandler;\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],173:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar exception_handler_1 = require('./exception_handler');\r\nvar exception_handler_2 = require('./exception_handler');\r\nexports.ExceptionHandler = exception_handler_2.ExceptionHandler;\r\nvar BaseException = (function (_super) {\r\n    __extends(BaseException, _super);\r\n    function BaseException(message) {\r\n        if (message === void 0) { message = \"--\"; }\r\n        _super.call(this, message);\r\n        this.message = message;\r\n        this.stack = (new Error(message)).stack;\r\n    }\r\n    BaseException.prototype.toString = function () { return this.message; };\r\n    return BaseException;\r\n})(Error);\r\nexports.BaseException = BaseException;\r\n/**\r\n * Wraps an exception and provides additional context or information.\r\n */\r\nvar WrappedException = (function (_super) {\r\n    __extends(WrappedException, _super);\r\n    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {\r\n        _super.call(this, _wrapperMessage);\r\n        this._wrapperMessage = _wrapperMessage;\r\n        this._originalException = _originalException;\r\n        this._originalStack = _originalStack;\r\n        this._context = _context;\r\n        this._wrapperStack = (new Error(_wrapperMessage)).stack;\r\n    }\r\n    Object.defineProperty(WrappedException.prototype, \"wrapperMessage\", {\r\n        get: function () { return this._wrapperMessage; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WrappedException.prototype, \"wrapperStack\", {\r\n        get: function () { return this._wrapperStack; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WrappedException.prototype, \"originalException\", {\r\n        get: function () { return this._originalException; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WrappedException.prototype, \"originalStack\", {\r\n        get: function () { return this._originalStack; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WrappedException.prototype, \"context\", {\r\n        get: function () { return this._context; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WrappedException.prototype, \"message\", {\r\n        get: function () { return exception_handler_1.ExceptionHandler.exceptionToString(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    WrappedException.prototype.toString = function () { return this.message; };\r\n    return WrappedException;\r\n})(Error);\r\nexports.WrappedException = WrappedException;\r\nfunction makeTypeError(message) {\r\n    return new TypeError(message);\r\n}\r\nexports.makeTypeError = makeTypeError;\r\nfunction unimplemented() {\r\n    throw new BaseException('unimplemented');\r\n}\r\nexports.unimplemented = unimplemented;\r\n},{\"./exception_handler\":172}],174:[function(require,module,exports){\n'use strict';// Public API for Facade\r\nvar lang_1 = require('./lang');\r\nexports.Type = lang_1.Type;\r\nvar async_1 = require('./async');\r\nexports.EventEmitter = async_1.EventEmitter;\r\nvar exceptions_1 = require('./exceptions');\r\nexports.WrappedException = exceptions_1.WrappedException;\r\nvar exception_handler_1 = require('./exception_handler');\r\nexports.ExceptionHandler = exception_handler_1.ExceptionHandler;\r\n},{\"./async\":169,\"./exception_handler\":172,\"./exceptions\":173,\"./lang\":176}],175:[function(require,module,exports){\n'use strict';(function (NumberFormatStyle) {\r\n    NumberFormatStyle[NumberFormatStyle[\"Decimal\"] = 0] = \"Decimal\";\r\n    NumberFormatStyle[NumberFormatStyle[\"Percent\"] = 1] = \"Percent\";\r\n    NumberFormatStyle[NumberFormatStyle[\"Currency\"] = 2] = \"Currency\";\r\n})(exports.NumberFormatStyle || (exports.NumberFormatStyle = {}));\r\nvar NumberFormatStyle = exports.NumberFormatStyle;\r\nvar NumberFormatter = (function () {\r\n    function NumberFormatter() {\r\n    }\r\n    NumberFormatter.format = function (num, locale, style, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.minimumIntegerDigits, minimumIntegerDigits = _c === void 0 ? 1 : _c, _d = _b.minimumFractionDigits, minimumFractionDigits = _d === void 0 ? 0 : _d, _e = _b.maximumFractionDigits, maximumFractionDigits = _e === void 0 ? 3 : _e, currency = _b.currency, _f = _b.currencyAsSymbol, currencyAsSymbol = _f === void 0 ? false : _f;\r\n        var intlOptions = {\r\n            minimumIntegerDigits: minimumIntegerDigits,\r\n            minimumFractionDigits: minimumFractionDigits,\r\n            maximumFractionDigits: maximumFractionDigits\r\n        };\r\n        intlOptions.style = NumberFormatStyle[style].toLowerCase();\r\n        if (style == NumberFormatStyle.Currency) {\r\n            intlOptions.currency = currency;\r\n            intlOptions.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';\r\n        }\r\n        return new Intl.NumberFormat(locale, intlOptions).format(num);\r\n    };\r\n    return NumberFormatter;\r\n})();\r\nexports.NumberFormatter = NumberFormatter;\r\nfunction digitCondition(len) {\r\n    return len == 2 ? '2-digit' : 'numeric';\r\n}\r\nfunction nameCondition(len) {\r\n    return len < 4 ? 'short' : 'long';\r\n}\r\nfunction extractComponents(pattern) {\r\n    var ret = {};\r\n    var i = 0, j;\r\n    while (i < pattern.length) {\r\n        j = i;\r\n        while (j < pattern.length && pattern[j] == pattern[i])\r\n            j++;\r\n        var len = j - i;\r\n        switch (pattern[i]) {\r\n            case 'G':\r\n                ret.era = nameCondition(len);\r\n                break;\r\n            case 'y':\r\n                ret.year = digitCondition(len);\r\n                break;\r\n            case 'M':\r\n                if (len >= 3)\r\n                    ret.month = nameCondition(len);\r\n                else\r\n                    ret.month = digitCondition(len);\r\n                break;\r\n            case 'd':\r\n                ret.day = digitCondition(len);\r\n                break;\r\n            case 'E':\r\n                ret.weekday = nameCondition(len);\r\n                break;\r\n            case 'j':\r\n                ret.hour = digitCondition(len);\r\n                break;\r\n            case 'h':\r\n                ret.hour = digitCondition(len);\r\n                ret.hour12 = true;\r\n                break;\r\n            case 'H':\r\n                ret.hour = digitCondition(len);\r\n                ret.hour12 = false;\r\n                break;\r\n            case 'm':\r\n                ret.minute = digitCondition(len);\r\n                break;\r\n            case 's':\r\n                ret.second = digitCondition(len);\r\n                break;\r\n            case 'z':\r\n                ret.timeZoneName = 'long';\r\n                break;\r\n            case 'Z':\r\n                ret.timeZoneName = 'short';\r\n                break;\r\n        }\r\n        i = j;\r\n    }\r\n    return ret;\r\n}\r\nvar dateFormatterCache = new Map();\r\nvar DateFormatter = (function () {\r\n    function DateFormatter() {\r\n    }\r\n    DateFormatter.format = function (date, locale, pattern) {\r\n        var key = locale + pattern;\r\n        if (dateFormatterCache.has(key)) {\r\n            return dateFormatterCache.get(key).format(date);\r\n        }\r\n        var formatter = new Intl.DateTimeFormat(locale, extractComponents(pattern));\r\n        dateFormatterCache.set(key, formatter);\r\n        return formatter.format(date);\r\n    };\r\n    return DateFormatter;\r\n})();\r\nexports.DateFormatter = DateFormatter;\r\n},{}],176:[function(require,module,exports){\n(function (global){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar globalScope;\r\nif (typeof window === 'undefined') {\r\n    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\r\n        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\r\n        globalScope = self;\r\n    }\r\n    else {\r\n        globalScope = global;\r\n    }\r\n}\r\nelse {\r\n    globalScope = window;\r\n}\r\n;\r\nexports.IS_DART = false;\r\n// Need to declare a new variable for global here since TypeScript\r\n// exports the original value of the symbol.\r\nvar _global = globalScope;\r\nexports.global = _global;\r\nexports.Type = Function;\r\nfunction getTypeNameForDebugging(type) {\r\n    return type['name'];\r\n}\r\nexports.getTypeNameForDebugging = getTypeNameForDebugging;\r\nexports.Math = _global.Math;\r\nexports.Date = _global.Date;\r\nvar _devMode = true;\r\nvar _modeLocked = false;\r\nfunction lockMode() {\r\n    _modeLocked = true;\r\n}\r\nexports.lockMode = lockMode;\r\n/**\r\n * Disable Angular's development mode, which turns off assertions and other\r\n * checks within the framework.\r\n *\r\n * One important assertion this disables verifies that a change detection pass\r\n * does not result in additional changes to any bindings (also known as\r\n * unidirectional data flow).\r\n */\r\nfunction enableProdMode() {\r\n    if (_modeLocked) {\r\n        // Cannot use BaseException as that ends up importing from facade/lang.\r\n        throw 'Cannot enable prod mode after platform setup.';\r\n    }\r\n    _devMode = false;\r\n}\r\nexports.enableProdMode = enableProdMode;\r\nfunction assertionsEnabled() {\r\n    return _devMode;\r\n}\r\nexports.assertionsEnabled = assertionsEnabled;\r\n// TODO: remove calls to assert in production environment\r\n// Note: Can't just export this and import in in other files\r\n// as `assert` is a reserved keyword in Dart\r\n_global.assert = function assert(condition) {\r\n    // TODO: to be fixed properly via #2830, noop for now\r\n};\r\n// This function is needed only to properly support Dart's const expressions\r\n// see https://github.com/angular/ts2dart/pull/151 for more info\r\nfunction CONST_EXPR(expr) {\r\n    return expr;\r\n}\r\nexports.CONST_EXPR = CONST_EXPR;\r\nfunction CONST() {\r\n    return function (target) { return target; };\r\n}\r\nexports.CONST = CONST;\r\nfunction isPresent(obj) {\r\n    return obj !== undefined && obj !== null;\r\n}\r\nexports.isPresent = isPresent;\r\nfunction isBlank(obj) {\r\n    return obj === undefined || obj === null;\r\n}\r\nexports.isBlank = isBlank;\r\nfunction isString(obj) {\r\n    return typeof obj === \"string\";\r\n}\r\nexports.isString = isString;\r\nfunction isFunction(obj) {\r\n    return typeof obj === \"function\";\r\n}\r\nexports.isFunction = isFunction;\r\nfunction isType(obj) {\r\n    return isFunction(obj);\r\n}\r\nexports.isType = isType;\r\nfunction isStringMap(obj) {\r\n    return typeof obj === 'object' && obj !== null;\r\n}\r\nexports.isStringMap = isStringMap;\r\nfunction isPromise(obj) {\r\n    return obj instanceof _global.Promise;\r\n}\r\nexports.isPromise = isPromise;\r\nfunction isArray(obj) {\r\n    return Array.isArray(obj);\r\n}\r\nexports.isArray = isArray;\r\nfunction isNumber(obj) {\r\n    return typeof obj === 'number';\r\n}\r\nexports.isNumber = isNumber;\r\nfunction isDate(obj) {\r\n    return obj instanceof exports.Date && !isNaN(obj.valueOf());\r\n}\r\nexports.isDate = isDate;\r\nfunction noop() { }\r\nexports.noop = noop;\r\nfunction stringify(token) {\r\n    if (typeof token === 'string') {\r\n        return token;\r\n    }\r\n    if (token === undefined || token === null) {\r\n        return '' + token;\r\n    }\r\n    if (token.name) {\r\n        return token.name;\r\n    }\r\n    if (token.overriddenName) {\r\n        return token.overriddenName;\r\n    }\r\n    var res = token.toString();\r\n    var newLineIndex = res.indexOf(\"\\n\");\r\n    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);\r\n}\r\nexports.stringify = stringify;\r\n// serialize / deserialize enum exist only for consistency with dart API\r\n// enums in typescript don't need to be serialized\r\nfunction serializeEnum(val) {\r\n    return val;\r\n}\r\nexports.serializeEnum = serializeEnum;\r\nfunction deserializeEnum(val, values) {\r\n    return val;\r\n}\r\nexports.deserializeEnum = deserializeEnum;\r\nvar StringWrapper = (function () {\r\n    function StringWrapper() {\r\n    }\r\n    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };\r\n    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };\r\n    StringWrapper.split = function (s, regExp) { return s.split(regExp); };\r\n    StringWrapper.equals = function (s, s2) { return s === s2; };\r\n    StringWrapper.stripLeft = function (s, charVal) {\r\n        if (s && s.length) {\r\n            var pos = 0;\r\n            for (var i = 0; i < s.length; i++) {\r\n                if (s[i] != charVal)\r\n                    break;\r\n                pos++;\r\n            }\r\n            s = s.substring(pos);\r\n        }\r\n        return s;\r\n    };\r\n    StringWrapper.stripRight = function (s, charVal) {\r\n        if (s && s.length) {\r\n            var pos = s.length;\r\n            for (var i = s.length - 1; i >= 0; i--) {\r\n                if (s[i] != charVal)\r\n                    break;\r\n                pos--;\r\n            }\r\n            s = s.substring(0, pos);\r\n        }\r\n        return s;\r\n    };\r\n    StringWrapper.replace = function (s, from, replace) {\r\n        return s.replace(from, replace);\r\n    };\r\n    StringWrapper.replaceAll = function (s, from, replace) {\r\n        return s.replace(from, replace);\r\n    };\r\n    StringWrapper.slice = function (s, from, to) {\r\n        if (from === void 0) { from = 0; }\r\n        if (to === void 0) { to = null; }\r\n        return s.slice(from, to === null ? undefined : to);\r\n    };\r\n    StringWrapper.replaceAllMapped = function (s, from, cb) {\r\n        return s.replace(from, function () {\r\n            var matches = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                matches[_i - 0] = arguments[_i];\r\n            }\r\n            // Remove offset & string from the result array\r\n            matches.splice(-2, 2);\r\n            // The callback receives match, p1, ..., pn\r\n            return cb(matches);\r\n        });\r\n    };\r\n    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };\r\n    StringWrapper.compare = function (a, b) {\r\n        if (a < b) {\r\n            return -1;\r\n        }\r\n        else if (a > b) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    };\r\n    return StringWrapper;\r\n})();\r\nexports.StringWrapper = StringWrapper;\r\nvar StringJoiner = (function () {\r\n    function StringJoiner(parts) {\r\n        if (parts === void 0) { parts = []; }\r\n        this.parts = parts;\r\n    }\r\n    StringJoiner.prototype.add = function (part) { this.parts.push(part); };\r\n    StringJoiner.prototype.toString = function () { return this.parts.join(\"\"); };\r\n    return StringJoiner;\r\n})();\r\nexports.StringJoiner = StringJoiner;\r\nvar NumberParseError = (function (_super) {\r\n    __extends(NumberParseError, _super);\r\n    function NumberParseError(message) {\r\n        _super.call(this);\r\n        this.message = message;\r\n    }\r\n    NumberParseError.prototype.toString = function () { return this.message; };\r\n    return NumberParseError;\r\n})(Error);\r\nexports.NumberParseError = NumberParseError;\r\nvar NumberWrapper = (function () {\r\n    function NumberWrapper() {\r\n    }\r\n    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };\r\n    NumberWrapper.equal = function (a, b) { return a === b; };\r\n    NumberWrapper.parseIntAutoRadix = function (text) {\r\n        var result = parseInt(text);\r\n        if (isNaN(result)) {\r\n            throw new NumberParseError(\"Invalid integer literal when parsing \" + text);\r\n        }\r\n        return result;\r\n    };\r\n    NumberWrapper.parseInt = function (text, radix) {\r\n        if (radix == 10) {\r\n            if (/^(\\-|\\+)?[0-9]+$/.test(text)) {\r\n                return parseInt(text, radix);\r\n            }\r\n        }\r\n        else if (radix == 16) {\r\n            if (/^(\\-|\\+)?[0-9ABCDEFabcdef]+$/.test(text)) {\r\n                return parseInt(text, radix);\r\n            }\r\n        }\r\n        else {\r\n            var result = parseInt(text, radix);\r\n            if (!isNaN(result)) {\r\n                return result;\r\n            }\r\n        }\r\n        throw new NumberParseError(\"Invalid integer literal when parsing \" + text + \" in base \" +\r\n            radix);\r\n    };\r\n    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.\r\n    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };\r\n    Object.defineProperty(NumberWrapper, \"NaN\", {\r\n        get: function () { return NaN; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NumberWrapper.isNaN = function (value) { return isNaN(value); };\r\n    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };\r\n    return NumberWrapper;\r\n})();\r\nexports.NumberWrapper = NumberWrapper;\r\nexports.RegExp = _global.RegExp;\r\nvar RegExpWrapper = (function () {\r\n    function RegExpWrapper() {\r\n    }\r\n    RegExpWrapper.create = function (regExpStr, flags) {\r\n        if (flags === void 0) { flags = ''; }\r\n        flags = flags.replace(/g/g, '');\r\n        return new _global.RegExp(regExpStr, flags + 'g');\r\n    };\r\n    RegExpWrapper.firstMatch = function (regExp, input) {\r\n        // Reset multimatch regex state\r\n        regExp.lastIndex = 0;\r\n        return regExp.exec(input);\r\n    };\r\n    RegExpWrapper.test = function (regExp, input) {\r\n        regExp.lastIndex = 0;\r\n        return regExp.test(input);\r\n    };\r\n    RegExpWrapper.matcher = function (regExp, input) {\r\n        // Reset regex state for the case\r\n        // someone did not loop over all matches\r\n        // last time.\r\n        regExp.lastIndex = 0;\r\n        return { re: regExp, input: input };\r\n    };\r\n    return RegExpWrapper;\r\n})();\r\nexports.RegExpWrapper = RegExpWrapper;\r\nvar RegExpMatcherWrapper = (function () {\r\n    function RegExpMatcherWrapper() {\r\n    }\r\n    RegExpMatcherWrapper.next = function (matcher) {\r\n        return matcher.re.exec(matcher.input);\r\n    };\r\n    return RegExpMatcherWrapper;\r\n})();\r\nexports.RegExpMatcherWrapper = RegExpMatcherWrapper;\r\nvar FunctionWrapper = (function () {\r\n    function FunctionWrapper() {\r\n    }\r\n    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };\r\n    return FunctionWrapper;\r\n})();\r\nexports.FunctionWrapper = FunctionWrapper;\r\n// JS has NaN !== NaN\r\nfunction looseIdentical(a, b) {\r\n    return a === b || typeof a === \"number\" && typeof b === \"number\" && isNaN(a) && isNaN(b);\r\n}\r\nexports.looseIdentical = looseIdentical;\r\n// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)\r\n// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\r\nfunction getMapKey(value) {\r\n    return value;\r\n}\r\nexports.getMapKey = getMapKey;\r\nfunction normalizeBlank(obj) {\r\n    return isBlank(obj) ? null : obj;\r\n}\r\nexports.normalizeBlank = normalizeBlank;\r\nfunction normalizeBool(obj) {\r\n    return isBlank(obj) ? false : obj;\r\n}\r\nexports.normalizeBool = normalizeBool;\r\nfunction isJsObject(o) {\r\n    return o !== null && (typeof o === \"function\" || typeof o === \"object\");\r\n}\r\nexports.isJsObject = isJsObject;\r\nfunction print(obj) {\r\n    console.log(obj);\r\n}\r\nexports.print = print;\r\n// Can't be all uppercase as our transpiler would think it is a special directive...\r\nvar Json = (function () {\r\n    function Json() {\r\n    }\r\n    Json.parse = function (s) { return _global.JSON.parse(s); };\r\n    Json.stringify = function (data) {\r\n        // Dart doesn't take 3 arguments\r\n        return _global.JSON.stringify(data, null, 2);\r\n    };\r\n    return Json;\r\n})();\r\nexports.Json = Json;\r\nvar DateWrapper = (function () {\r\n    function DateWrapper() {\r\n    }\r\n    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {\r\n        if (month === void 0) { month = 1; }\r\n        if (day === void 0) { day = 1; }\r\n        if (hour === void 0) { hour = 0; }\r\n        if (minutes === void 0) { minutes = 0; }\r\n        if (seconds === void 0) { seconds = 0; }\r\n        if (milliseconds === void 0) { milliseconds = 0; }\r\n        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);\r\n    };\r\n    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };\r\n    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };\r\n    DateWrapper.toMillis = function (date) { return date.getTime(); };\r\n    DateWrapper.now = function () { return new exports.Date(); };\r\n    DateWrapper.toJson = function (date) { return date.toJSON(); };\r\n    return DateWrapper;\r\n})();\r\nexports.DateWrapper = DateWrapper;\r\nfunction setValueOnPath(global, path, value) {\r\n    var parts = path.split('.');\r\n    var obj = global;\r\n    while (parts.length > 1) {\r\n        var name = parts.shift();\r\n        if (obj.hasOwnProperty(name) && isPresent(obj[name])) {\r\n            obj = obj[name];\r\n        }\r\n        else {\r\n            obj = obj[name] = {};\r\n        }\r\n    }\r\n    if (obj === undefined || obj === null) {\r\n        obj = {};\r\n    }\r\n    obj[parts.shift()] = value;\r\n}\r\nexports.setValueOnPath = setValueOnPath;\r\nvar _symbolIterator = null;\r\nfunction getSymbolIterator() {\r\n    if (isBlank(_symbolIterator)) {\r\n        if (isPresent(Symbol) && isPresent(Symbol.iterator)) {\r\n            _symbolIterator = Symbol.iterator;\r\n        }\r\n        else {\r\n            // es6-shim specific logic\r\n            var keys = Object.getOwnPropertyNames(Map.prototype);\r\n            for (var i = 0; i < keys.length; ++i) {\r\n                var key = keys[i];\r\n                if (key !== 'entries' && key !== 'size' &&\r\n                    Map.prototype[key] === Map.prototype['entries']) {\r\n                    _symbolIterator = key;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return _symbolIterator;\r\n}\r\nexports.getSymbolIterator = getSymbolIterator;\r\nfunction evalExpression(sourceUrl, expr, declarations, vars) {\r\n    var fnBody = declarations + \"\\nreturn \" + expr + \"\\n//# sourceURL=\" + sourceUrl;\r\n    var fnArgNames = [];\r\n    var fnArgValues = [];\r\n    for (var argName in vars) {\r\n        fnArgNames.push(argName);\r\n        fnArgValues.push(vars[argName]);\r\n    }\r\n    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);\r\n}\r\nexports.evalExpression = evalExpression;\r\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],177:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nexports.Math = lang_1.global.Math;\r\nexports.NaN = typeof exports.NaN;\r\n},{\"angular2/src/facade/lang\":176}],178:[function(require,module,exports){\n'use strict';// Promises are put into their own facade file so that they can be used without\r\n// introducing a dependency on rxjs. They are re-exported through facade/async.\r\nvar PromiseWrapper = (function () {\r\n    function PromiseWrapper() {\r\n    }\r\n    PromiseWrapper.resolve = function (obj) { return Promise.resolve(obj); };\r\n    PromiseWrapper.reject = function (obj, _) { return Promise.reject(obj); };\r\n    // Note: We can't rename this method into `catch`, as this is not a valid\r\n    // method name in Dart.\r\n    PromiseWrapper.catchError = function (promise, onError) {\r\n        return promise.catch(onError);\r\n    };\r\n    PromiseWrapper.all = function (promises) {\r\n        if (promises.length == 0)\r\n            return Promise.resolve([]);\r\n        return Promise.all(promises);\r\n    };\r\n    PromiseWrapper.then = function (promise, success, rejection) {\r\n        return promise.then(success, rejection);\r\n    };\r\n    PromiseWrapper.wrap = function (computation) {\r\n        return new Promise(function (res, rej) {\r\n            try {\r\n                res(computation());\r\n            }\r\n            catch (e) {\r\n                rej(e);\r\n            }\r\n        });\r\n    };\r\n    PromiseWrapper.scheduleMicrotask = function (computation) {\r\n        PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function (_) { });\r\n    };\r\n    PromiseWrapper.isPromise = function (obj) { return obj instanceof Promise; };\r\n    PromiseWrapper.completer = function () {\r\n        var resolve;\r\n        var reject;\r\n        var p = new Promise(function (res, rej) {\r\n            resolve = res;\r\n            reject = rej;\r\n        });\r\n        return { promise: p, resolve: resolve, reject: reject };\r\n    };\r\n    return PromiseWrapper;\r\n})();\r\nexports.PromiseWrapper = PromiseWrapper;\r\n},{}],179:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar generic_browser_adapter_1 = require('./generic_browser_adapter');\r\nvar _attrToPropMap = {\r\n    'class': 'className',\r\n    'innerHtml': 'innerHTML',\r\n    'readonly': 'readOnly',\r\n    'tabindex': 'tabIndex'\r\n};\r\nvar DOM_KEY_LOCATION_NUMPAD = 3;\r\n// Map to convert some key or keyIdentifier values to what will be returned by getEventKey\r\nvar _keyMap = {\r\n    // The following values are here for cross-browser compatibility and to match the W3C standard\r\n    // cf http://www.w3.org/TR/DOM-Level-3-Events-key/\r\n    '\\b': 'Backspace',\r\n    '\\t': 'Tab',\r\n    '\\x7F': 'Delete',\r\n    '\\x1B': 'Escape',\r\n    'Del': 'Delete',\r\n    'Esc': 'Escape',\r\n    'Left': 'ArrowLeft',\r\n    'Right': 'ArrowRight',\r\n    'Up': 'ArrowUp',\r\n    'Down': 'ArrowDown',\r\n    'Menu': 'ContextMenu',\r\n    'Scroll': 'ScrollLock',\r\n    'Win': 'OS'\r\n};\r\n// There is a bug in Chrome for numeric keypad keys:\r\n// https://code.google.com/p/chromium/issues/detail?id=155654\r\n// 1, 2, 3 ... are reported as A, B, C ...\r\nvar _chromeNumKeyPadMap = {\r\n    'A': '1',\r\n    'B': '2',\r\n    'C': '3',\r\n    'D': '4',\r\n    'E': '5',\r\n    'F': '6',\r\n    'G': '7',\r\n    'H': '8',\r\n    'I': '9',\r\n    'J': '*',\r\n    'K': '+',\r\n    'M': '-',\r\n    'N': '.',\r\n    'O': '/',\r\n    '\\x60': '0',\r\n    '\\x90': 'NumLock'\r\n};\r\n/**\r\n * A `DomAdapter` powered by full browser DOM APIs.\r\n */\r\n/* tslint:disable:requireParameterType */\r\nvar BrowserDomAdapter = (function (_super) {\r\n    __extends(BrowserDomAdapter, _super);\r\n    function BrowserDomAdapter() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error(\"parse not implemented\"); };\r\n    BrowserDomAdapter.makeCurrent = function () { dom_adapter_1.setRootDomAdapter(new BrowserDomAdapter()); };\r\n    BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };\r\n    BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };\r\n    BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };\r\n    BrowserDomAdapter.prototype.invoke = function (el, methodName, args) {\r\n        el[methodName].apply(el, args);\r\n    };\r\n    // TODO(tbosch): move this into a separate environment class once we have it\r\n    BrowserDomAdapter.prototype.logError = function (error) {\r\n        if (window.console.error) {\r\n            window.console.error(error);\r\n        }\r\n        else {\r\n            window.console.log(error);\r\n        }\r\n    };\r\n    BrowserDomAdapter.prototype.log = function (error) { window.console.log(error); };\r\n    BrowserDomAdapter.prototype.logGroup = function (error) {\r\n        if (window.console.group) {\r\n            window.console.group(error);\r\n            this.logError(error);\r\n        }\r\n        else {\r\n            window.console.log(error);\r\n        }\r\n    };\r\n    BrowserDomAdapter.prototype.logGroupEnd = function () {\r\n        if (window.console.groupEnd) {\r\n            window.console.groupEnd();\r\n        }\r\n    };\r\n    Object.defineProperty(BrowserDomAdapter.prototype, \"attrToPropMap\", {\r\n        get: function () { return _attrToPropMap; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };\r\n    BrowserDomAdapter.prototype.querySelector = function (el, selector) { return el.querySelector(selector); };\r\n    BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };\r\n    BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };\r\n    BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {\r\n        el.addEventListener(evt, listener, false);\r\n        // Needed to follow Dart's subscription semantic, until fix of\r\n        // https://code.google.com/p/dart/issues/detail?id=17406\r\n        return function () { el.removeEventListener(evt, listener, false); };\r\n    };\r\n    BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };\r\n    BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {\r\n        var evt = document.createEvent('MouseEvent');\r\n        evt.initEvent(eventType, true, true);\r\n        return evt;\r\n    };\r\n    BrowserDomAdapter.prototype.createEvent = function (eventType) {\r\n        var evt = document.createEvent('Event');\r\n        evt.initEvent(eventType, true, true);\r\n        return evt;\r\n    };\r\n    BrowserDomAdapter.prototype.preventDefault = function (evt) {\r\n        evt.preventDefault();\r\n        evt.returnValue = false;\r\n    };\r\n    BrowserDomAdapter.prototype.isPrevented = function (evt) {\r\n        return evt.defaultPrevented || lang_1.isPresent(evt.returnValue) && !evt.returnValue;\r\n    };\r\n    BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };\r\n    BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };\r\n    BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };\r\n    BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };\r\n    BrowserDomAdapter.prototype.type = function (node) { return node.type; };\r\n    BrowserDomAdapter.prototype.content = function (node) {\r\n        if (this.hasProperty(node, \"content\")) {\r\n            return node.content;\r\n        }\r\n        else {\r\n            return node;\r\n        }\r\n    };\r\n    BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };\r\n    BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };\r\n    BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };\r\n    BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };\r\n    BrowserDomAdapter.prototype.childNodesAsList = function (el) {\r\n        var childNodes = el.childNodes;\r\n        var res = collection_1.ListWrapper.createFixedSize(childNodes.length);\r\n        for (var i = 0; i < childNodes.length; i++) {\r\n            res[i] = childNodes[i];\r\n        }\r\n        return res;\r\n    };\r\n    BrowserDomAdapter.prototype.clearNodes = function (el) {\r\n        while (el.firstChild) {\r\n            el.removeChild(el.firstChild);\r\n        }\r\n    };\r\n    BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };\r\n    BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };\r\n    BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };\r\n    BrowserDomAdapter.prototype.remove = function (node) {\r\n        if (node.parentNode) {\r\n            node.parentNode.removeChild(node);\r\n        }\r\n        return node;\r\n    };\r\n    BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };\r\n    BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) { nodes.forEach(function (n) { return el.parentNode.insertBefore(n, el); }); };\r\n    BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };\r\n    BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };\r\n    BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };\r\n    // TODO(vicb): removed Element type because it does not support StyleElement\r\n    BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };\r\n    BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };\r\n    BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };\r\n    BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };\r\n    BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };\r\n    BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };\r\n    BrowserDomAdapter.prototype.createTemplate = function (html) {\r\n        var t = document.createElement('template');\r\n        t.innerHTML = html;\r\n        return t;\r\n    };\r\n    BrowserDomAdapter.prototype.createElement = function (tagName, doc) {\r\n        if (doc === void 0) { doc = document; }\r\n        return doc.createElement(tagName);\r\n    };\r\n    BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {\r\n        if (doc === void 0) { doc = document; }\r\n        return doc.createElementNS(ns, tagName);\r\n    };\r\n    BrowserDomAdapter.prototype.createTextNode = function (text, doc) {\r\n        if (doc === void 0) { doc = document; }\r\n        return doc.createTextNode(text);\r\n    };\r\n    BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {\r\n        if (doc === void 0) { doc = document; }\r\n        var el = doc.createElement('SCRIPT');\r\n        el.setAttribute(attrName, attrValue);\r\n        return el;\r\n    };\r\n    BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {\r\n        if (doc === void 0) { doc = document; }\r\n        var style = doc.createElement('style');\r\n        this.appendChild(style, this.createTextNode(css));\r\n        return style;\r\n    };\r\n    BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };\r\n    BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };\r\n    BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };\r\n    BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };\r\n    BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {\r\n        return element.getElementsByClassName(name);\r\n    };\r\n    BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {\r\n        return element.getElementsByTagName(name);\r\n    };\r\n    BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };\r\n    BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };\r\n    BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };\r\n    BrowserDomAdapter.prototype.hasClass = function (element, className) { return element.classList.contains(className); };\r\n    BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {\r\n        element.style[styleName] = styleValue;\r\n    };\r\n    BrowserDomAdapter.prototype.removeStyle = function (element, stylename) { element.style[stylename] = null; };\r\n    BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };\r\n    BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {\r\n        if (styleValue === void 0) { styleValue = null; }\r\n        var value = this.getStyle(element, styleName) || '';\r\n        return styleValue ? value == styleValue : value.length > 0;\r\n    };\r\n    BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };\r\n    BrowserDomAdapter.prototype.attributeMap = function (element) {\r\n        var res = new Map();\r\n        var elAttrs = element.attributes;\r\n        for (var i = 0; i < elAttrs.length; i++) {\r\n            var attrib = elAttrs[i];\r\n            res.set(attrib.name, attrib.value);\r\n        }\r\n        return res;\r\n    };\r\n    BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) { return element.hasAttribute(attribute); };\r\n    BrowserDomAdapter.prototype.getAttribute = function (element, attribute) { return element.getAttribute(attribute); };\r\n    BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };\r\n    BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {\r\n        element.setAttributeNS(ns, name, value);\r\n    };\r\n    BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };\r\n    BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };\r\n    BrowserDomAdapter.prototype.createHtmlDocument = function () {\r\n        return document.implementation.createHTMLDocument('fakeTitle');\r\n    };\r\n    BrowserDomAdapter.prototype.defaultDoc = function () { return document; };\r\n    BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {\r\n        try {\r\n            return el.getBoundingClientRect();\r\n        }\r\n        catch (e) {\r\n            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };\r\n        }\r\n    };\r\n    BrowserDomAdapter.prototype.getTitle = function () { return document.title; };\r\n    BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };\r\n    BrowserDomAdapter.prototype.elementMatches = function (n, selector) {\r\n        var matches = false;\r\n        if (n instanceof HTMLElement) {\r\n            if (n.matches) {\r\n                matches = n.matches(selector);\r\n            }\r\n            else if (n.msMatchesSelector) {\r\n                matches = n.msMatchesSelector(selector);\r\n            }\r\n            else if (n.webkitMatchesSelector) {\r\n                matches = n.webkitMatchesSelector(selector);\r\n            }\r\n        }\r\n        return matches;\r\n    };\r\n    BrowserDomAdapter.prototype.isTemplateElement = function (el) {\r\n        return el instanceof HTMLElement && el.nodeName == \"TEMPLATE\";\r\n    };\r\n    BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };\r\n    BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };\r\n    BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };\r\n    BrowserDomAdapter.prototype.hasShadowRoot = function (node) { return node instanceof HTMLElement && lang_1.isPresent(node.shadowRoot); };\r\n    BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };\r\n    BrowserDomAdapter.prototype.importIntoDoc = function (node) {\r\n        var toImport = node;\r\n        if (this.isTemplateElement(node)) {\r\n            toImport = this.content(node);\r\n        }\r\n        return document.importNode(toImport, true);\r\n    };\r\n    BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };\r\n    BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };\r\n    BrowserDomAdapter.prototype.getEventKey = function (event) {\r\n        var key = event.key;\r\n        if (lang_1.isBlank(key)) {\r\n            key = event.keyIdentifier;\r\n            // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and\r\n            // Safari\r\n            // cf\r\n            // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces\r\n            if (lang_1.isBlank(key)) {\r\n                return 'Unidentified';\r\n            }\r\n            if (key.startsWith('U+')) {\r\n                key = String.fromCharCode(parseInt(key.substring(2), 16));\r\n                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {\r\n                    // There is a bug in Chrome for numeric keypad keys:\r\n                    // https://code.google.com/p/chromium/issues/detail?id=155654\r\n                    // 1, 2, 3 ... are reported as A, B, C ...\r\n                    key = _chromeNumKeyPadMap[key];\r\n                }\r\n            }\r\n        }\r\n        if (_keyMap.hasOwnProperty(key)) {\r\n            key = _keyMap[key];\r\n        }\r\n        return key;\r\n    };\r\n    BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {\r\n        if (target == \"window\") {\r\n            return window;\r\n        }\r\n        else if (target == \"document\") {\r\n            return document;\r\n        }\r\n        else if (target == \"body\") {\r\n            return document.body;\r\n        }\r\n    };\r\n    BrowserDomAdapter.prototype.getHistory = function () { return window.history; };\r\n    BrowserDomAdapter.prototype.getLocation = function () { return window.location; };\r\n    BrowserDomAdapter.prototype.getBaseHref = function () {\r\n        var href = getBaseElementHref();\r\n        if (lang_1.isBlank(href)) {\r\n            return null;\r\n        }\r\n        return relativePath(href);\r\n    };\r\n    BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };\r\n    BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };\r\n    BrowserDomAdapter.prototype.setData = function (element, name, value) {\r\n        this.setAttribute(element, 'data-' + name, value);\r\n    };\r\n    BrowserDomAdapter.prototype.getData = function (element, name) { return this.getAttribute(element, 'data-' + name); };\r\n    BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };\r\n    // TODO(tbosch): move this into a separate environment class once we have it\r\n    BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { lang_1.setValueOnPath(lang_1.global, path, value); };\r\n    BrowserDomAdapter.prototype.requestAnimationFrame = function (callback) { return window.requestAnimationFrame(callback); };\r\n    BrowserDomAdapter.prototype.cancelAnimationFrame = function (id) { window.cancelAnimationFrame(id); };\r\n    BrowserDomAdapter.prototype.performanceNow = function () {\r\n        // performance.now() is not available in all browsers, see\r\n        // http://caniuse.com/#search=performance.now\r\n        if (lang_1.isPresent(window.performance) && lang_1.isPresent(window.performance.now)) {\r\n            return window.performance.now();\r\n        }\r\n        else {\r\n            return lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now());\r\n        }\r\n    };\r\n    return BrowserDomAdapter;\r\n})(generic_browser_adapter_1.GenericBrowserDomAdapter);\r\nexports.BrowserDomAdapter = BrowserDomAdapter;\r\nvar baseElement = null;\r\nfunction getBaseElementHref() {\r\n    if (lang_1.isBlank(baseElement)) {\r\n        baseElement = document.querySelector('base');\r\n        if (lang_1.isBlank(baseElement)) {\r\n            return null;\r\n        }\r\n    }\r\n    return baseElement.getAttribute('href');\r\n}\r\n// based on urlUtils.js in AngularJS 1\r\nvar urlParsingNode = null;\r\nfunction relativePath(url) {\r\n    if (lang_1.isBlank(urlParsingNode)) {\r\n        urlParsingNode = document.createElement(\"a\");\r\n    }\r\n    urlParsingNode.setAttribute('href', url);\r\n    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :\r\n        '/' + urlParsingNode.pathname;\r\n}\r\n},{\"./generic_browser_adapter\":180,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176,\"angular2/src/platform/dom/dom_adapter\":189}],180:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar xhr_impl_1 = require('angular2/src/platform/browser/xhr_impl');\r\n/**\r\n * Provides DOM operations in any browser environment.\r\n */\r\nvar GenericBrowserDomAdapter = (function (_super) {\r\n    __extends(GenericBrowserDomAdapter, _super);\r\n    function GenericBrowserDomAdapter() {\r\n        var _this = this;\r\n        _super.call(this);\r\n        this._animationPrefix = null;\r\n        this._transitionEnd = null;\r\n        try {\r\n            var element = this.createElement('div', this.defaultDoc());\r\n            if (lang_1.isPresent(this.getStyle(element, 'animationName'))) {\r\n                this._animationPrefix = '';\r\n            }\r\n            else {\r\n                var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];\r\n                for (var i = 0; i < domPrefixes.length; i++) {\r\n                    if (lang_1.isPresent(this.getStyle(element, domPrefixes[i] + 'AnimationName'))) {\r\n                        this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            var transEndEventNames = {\r\n                WebkitTransition: 'webkitTransitionEnd',\r\n                MozTransition: 'transitionend',\r\n                OTransition: 'oTransitionEnd otransitionend',\r\n                transition: 'transitionend'\r\n            };\r\n            collection_1.StringMapWrapper.forEach(transEndEventNames, function (value, key) {\r\n                if (lang_1.isPresent(_this.getStyle(element, key))) {\r\n                    _this._transitionEnd = value;\r\n                }\r\n            });\r\n        }\r\n        catch (e) {\r\n            this._animationPrefix = null;\r\n            this._transitionEnd = null;\r\n        }\r\n    }\r\n    GenericBrowserDomAdapter.prototype.getXHR = function () { return xhr_impl_1.XHRImpl; };\r\n    GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };\r\n    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {\r\n        el.href = href == null ? baseUrl : baseUrl + '/../' + href;\r\n    };\r\n    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };\r\n    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {\r\n        return lang_1.isFunction(this.defaultDoc().body.createShadowRoot);\r\n    };\r\n    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () {\r\n        return lang_1.isPresent(this._animationPrefix) ? this._animationPrefix : \"\";\r\n    };\r\n    GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return lang_1.isPresent(this._transitionEnd) ? this._transitionEnd : \"\"; };\r\n    GenericBrowserDomAdapter.prototype.supportsAnimation = function () {\r\n        return lang_1.isPresent(this._animationPrefix) && lang_1.isPresent(this._transitionEnd);\r\n    };\r\n    return GenericBrowserDomAdapter;\r\n})(dom_adapter_1.DomAdapter);\r\nexports.GenericBrowserDomAdapter = GenericBrowserDomAdapter;\r\n},{\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176,\"angular2/src/platform/browser/xhr_impl\":185,\"angular2/src/platform/dom/dom_adapter\":189}],181:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar core_1 = require('angular2/core');\r\nvar PublicTestability = (function () {\r\n    function PublicTestability(testability) {\r\n        this._testability = testability;\r\n    }\r\n    PublicTestability.prototype.isStable = function () { return this._testability.isStable(); };\r\n    PublicTestability.prototype.whenStable = function (callback) { this._testability.whenStable(callback); };\r\n    PublicTestability.prototype.findBindings = function (using, provider, exactMatch) {\r\n        return this.findProviders(using, provider, exactMatch);\r\n    };\r\n    PublicTestability.prototype.findProviders = function (using, provider, exactMatch) {\r\n        return this._testability.findBindings(using, provider, exactMatch);\r\n    };\r\n    return PublicTestability;\r\n})();\r\nvar BrowserGetTestability = (function () {\r\n    function BrowserGetTestability() {\r\n    }\r\n    BrowserGetTestability.init = function () { core_1.setTestabilityGetter(new BrowserGetTestability()); };\r\n    BrowserGetTestability.prototype.addToWindow = function (registry) {\r\n        lang_1.global.getAngularTestability = function (elem, findInAncestors) {\r\n            if (findInAncestors === void 0) { findInAncestors = true; }\r\n            var testability = registry.findTestabilityInTree(elem, findInAncestors);\r\n            if (testability == null) {\r\n                throw new Error('Could not find testability for element.');\r\n            }\r\n            return new PublicTestability(testability);\r\n        };\r\n        lang_1.global.getAllAngularTestabilities = function () {\r\n            var testabilities = registry.getAllTestabilities();\r\n            return testabilities.map(function (testability) { return new PublicTestability(testability); });\r\n        };\r\n    };\r\n    BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {\r\n        if (elem == null) {\r\n            return null;\r\n        }\r\n        var t = registry.getTestability(elem);\r\n        if (lang_1.isPresent(t)) {\r\n            return t;\r\n        }\r\n        else if (!findInAncestors) {\r\n            return null;\r\n        }\r\n        if (dom_adapter_1.DOM.isShadowRoot(elem)) {\r\n            return this.findTestabilityInTree(registry, dom_adapter_1.DOM.getHost(elem), true);\r\n        }\r\n        return this.findTestabilityInTree(registry, dom_adapter_1.DOM.parentElement(elem), true);\r\n    };\r\n    return BrowserGetTestability;\r\n})();\r\nexports.BrowserGetTestability = BrowserGetTestability;\r\n},{\"angular2/core\":3,\"angular2/src/facade/lang\":176,\"angular2/src/platform/dom/dom_adapter\":189}],182:[function(require,module,exports){\n'use strict';var dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\n/**\r\n * A service that can be used to get and set the title of a current HTML document.\r\n *\r\n * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)\r\n * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements\r\n * (representing the `<title>` tag). Instead, this service can be used to set and get the current\r\n * title value.\r\n */\r\nvar Title = (function () {\r\n    function Title() {\r\n    }\r\n    /**\r\n     * Get the title of the current HTML document.\r\n     * @returns {string}\r\n     */\r\n    Title.prototype.getTitle = function () { return dom_adapter_1.DOM.getTitle(); };\r\n    /**\r\n     * Set the title of the current HTML document.\r\n     * @param newTitle\r\n     */\r\n    Title.prototype.setTitle = function (newTitle) { dom_adapter_1.DOM.setTitle(newTitle); };\r\n    return Title;\r\n})();\r\nexports.Title = Title;\r\n},{\"angular2/src/platform/dom/dom_adapter\":189}],183:[function(require,module,exports){\n'use strict';var application_ref_1 = require('angular2/src/core/application_ref');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar browser_1 = require('angular2/src/facade/browser');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\n/**\r\n * Entry point for all Angular debug tools. This object corresponds to the `ng`\r\n * global variable accessible in the dev console.\r\n */\r\nvar AngularTools = (function () {\r\n    function AngularTools(ref) {\r\n        this.profiler = new AngularProfiler(ref);\r\n    }\r\n    return AngularTools;\r\n})();\r\nexports.AngularTools = AngularTools;\r\n/**\r\n * Entry point for all Angular profiling-related debug tools. This object\r\n * corresponds to the `ng.profiler` in the dev console.\r\n */\r\nvar AngularProfiler = (function () {\r\n    function AngularProfiler(ref) {\r\n        this.appRef = ref.injector.get(application_ref_1.ApplicationRef);\r\n    }\r\n    /**\r\n     * Exercises change detection in a loop and then prints the average amount of\r\n     * time in milliseconds how long a single round of change detection takes for\r\n     * the current state of the UI. It runs a minimum of 5 rounds for a minimum\r\n     * of 500 milliseconds.\r\n     *\r\n     * Optionally, a user may pass a `config` parameter containing a map of\r\n     * options. Supported options are:\r\n     *\r\n     * `record` (boolean) - causes the profiler to record a CPU profile while\r\n     * it exercises the change detector. Example:\r\n     *\r\n     * ```\r\n     * ng.profiler.timeChangeDetection({record: true})\r\n     * ```\r\n     */\r\n    AngularProfiler.prototype.timeChangeDetection = function (config) {\r\n        var record = lang_1.isPresent(config) && config['record'];\r\n        var profileName = 'Change Detection';\r\n        // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened\r\n        var isProfilerAvailable = lang_1.isPresent(browser_1.window.console.profile);\r\n        if (record && isProfilerAvailable) {\r\n            browser_1.window.console.profile(profileName);\r\n        }\r\n        var start = dom_adapter_1.DOM.performanceNow();\r\n        var numTicks = 0;\r\n        while (numTicks < 5 || (dom_adapter_1.DOM.performanceNow() - start) < 500) {\r\n            this.appRef.tick();\r\n            numTicks++;\r\n        }\r\n        var end = dom_adapter_1.DOM.performanceNow();\r\n        if (record && isProfilerAvailable) {\r\n            // need to cast to <any> because type checker thinks there's no argument\r\n            // while in fact there is:\r\n            //\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd\r\n            browser_1.window.console.profileEnd(profileName);\r\n        }\r\n        var msPerTick = (end - start) / numTicks;\r\n        browser_1.window.console.log(\"ran \" + numTicks + \" change detection cycles\");\r\n        browser_1.window.console.log(lang_1.NumberWrapper.toFixed(msPerTick, 2) + \" ms per check\");\r\n    };\r\n    return AngularProfiler;\r\n})();\r\nexports.AngularProfiler = AngularProfiler;\r\n},{\"angular2/src/core/application_ref\":82,\"angular2/src/facade/browser\":170,\"angular2/src/facade/lang\":176,\"angular2/src/platform/dom/dom_adapter\":189}],184:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar common_tools_1 = require('./common_tools');\r\nvar context = lang_1.global;\r\n/**\r\n * Enabled Angular 2 debug tools that are accessible via your browser's\r\n * developer console.\r\n *\r\n * Usage:\r\n *\r\n * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)\r\n * 1. Type `ng.` (usually the console will show auto-complete suggestion)\r\n * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`\r\n *    then hit Enter.\r\n */\r\nfunction enableDebugTools(ref) {\r\n    context.ng = new common_tools_1.AngularTools(ref);\r\n}\r\nexports.enableDebugTools = enableDebugTools;\r\n/**\r\n * Disables Angular 2 tools.\r\n */\r\nfunction disableDebugTools() {\r\n    delete context.ng;\r\n}\r\nexports.disableDebugTools = disableDebugTools;\r\n},{\"./common_tools\":183,\"angular2/src/facade/lang\":176}],185:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar promise_1 = require('angular2/src/facade/promise');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar xhr_1 = require('angular2/src/compiler/xhr');\r\nvar XHRImpl = (function (_super) {\r\n    __extends(XHRImpl, _super);\r\n    function XHRImpl() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    XHRImpl.prototype.get = function (url) {\r\n        var completer = promise_1.PromiseWrapper.completer();\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url, true);\r\n        xhr.responseType = 'text';\r\n        xhr.onload = function () {\r\n            // responseText is the old-school way of retrieving response (supported by IE8 & 9)\r\n            // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)\r\n            var response = lang_1.isPresent(xhr.response) ? xhr.response : xhr.responseText;\r\n            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\r\n            var status = xhr.status === 1223 ? 204 : xhr.status;\r\n            // fix status code when it is 0 (0 status is undocumented).\r\n            // Occurs when accessing file resources or on Android 4.1 stock browser\r\n            // while retrieving files from application cache.\r\n            if (status === 0) {\r\n                status = response ? 200 : 0;\r\n            }\r\n            if (200 <= status && status <= 300) {\r\n                completer.resolve(response);\r\n            }\r\n            else {\r\n                completer.reject(\"Failed to load \" + url, null);\r\n            }\r\n        };\r\n        xhr.onerror = function () { completer.reject(\"Failed to load \" + url, null); };\r\n        xhr.send();\r\n        return completer.promise;\r\n    };\r\n    return XHRImpl;\r\n})(xhr_1.XHR);\r\nexports.XHRImpl = XHRImpl;\r\n},{\"angular2/src/compiler/xhr\":79,\"angular2/src/facade/lang\":176,\"angular2/src/facade/promise\":178}],186:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar core_1 = require(\"angular2/core\");\r\nvar common_1 = require(\"angular2/common\");\r\nvar testability_1 = require('angular2/src/core/testability/testability');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar dom_events_1 = require('angular2/src/platform/dom/events/dom_events');\r\nvar key_events_1 = require('angular2/src/platform/dom/events/key_events');\r\nvar hammer_gestures_1 = require('angular2/src/platform/dom/events/hammer_gestures');\r\nvar dom_tokens_1 = require('angular2/src/platform/dom/dom_tokens');\r\nvar dom_renderer_1 = require('angular2/src/platform/dom/dom_renderer');\r\nvar shared_styles_host_1 = require('angular2/src/platform/dom/shared_styles_host');\r\nvar shared_styles_host_2 = require(\"angular2/src/platform/dom/shared_styles_host\");\r\nvar browser_details_1 = require(\"angular2/src/animate/browser_details\");\r\nvar animation_builder_1 = require(\"angular2/src/animate/animation_builder\");\r\nvar browser_adapter_1 = require('./browser/browser_adapter');\r\nvar testability_2 = require('angular2/src/platform/browser/testability');\r\nvar wtf_init_1 = require('angular2/src/core/profile/wtf_init');\r\nvar event_manager_1 = require(\"angular2/src/platform/dom/events/event_manager\");\r\nvar dom_tokens_2 = require('angular2/src/platform/dom/dom_tokens');\r\nexports.DOCUMENT = dom_tokens_2.DOCUMENT;\r\nvar title_1 = require('angular2/src/platform/browser/title');\r\nexports.Title = title_1.Title;\r\nvar common_dom_1 = require('angular2/platform/common_dom');\r\nexports.DebugElementViewListener = common_dom_1.DebugElementViewListener;\r\nexports.ELEMENT_PROBE_PROVIDERS = common_dom_1.ELEMENT_PROBE_PROVIDERS;\r\nexports.ELEMENT_PROBE_BINDINGS = common_dom_1.ELEMENT_PROBE_BINDINGS;\r\nexports.inspectNativeElement = common_dom_1.inspectNativeElement;\r\nexports.By = common_dom_1.By;\r\nvar browser_adapter_2 = require('./browser/browser_adapter');\r\nexports.BrowserDomAdapter = browser_adapter_2.BrowserDomAdapter;\r\nvar tools_1 = require('angular2/src/platform/browser/tools/tools');\r\nexports.enableDebugTools = tools_1.enableDebugTools;\r\nexports.disableDebugTools = tools_1.disableDebugTools;\r\n/**\r\n * A set of providers to initialize the Angular platform in a web browser.\r\n *\r\n * Used automatically by `bootstrap`, or can be passed to {@link platform}.\r\n */\r\nexports.BROWSER_PROVIDERS = lang_1.CONST_EXPR([\r\n    core_1.PLATFORM_COMMON_PROVIDERS,\r\n    new di_1.Provider(core_1.PLATFORM_INITIALIZER, { useValue: initDomAdapter, multi: true }),\r\n]);\r\nfunction _exceptionHandler() {\r\n    // !IS_DART is required because we must rethrow exceptions in JS,\r\n    // but must not rethrow exceptions in Dart\r\n    return new core_1.ExceptionHandler(dom_adapter_1.DOM, !lang_1.IS_DART);\r\n}\r\nfunction _document() {\r\n    return dom_adapter_1.DOM.defaultDoc();\r\n}\r\n/**\r\n * A set of providers to initialize an Angular application in a web browser.\r\n *\r\n * Used automatically by `bootstrap`, or can be passed to {@link PlatformRef.application}.\r\n */\r\nexports.BROWSER_APP_COMMON_PROVIDERS = lang_1.CONST_EXPR([\r\n    core_1.APPLICATION_COMMON_PROVIDERS,\r\n    common_1.FORM_PROVIDERS,\r\n    new di_1.Provider(core_1.PLATFORM_PIPES, { useValue: common_1.COMMON_PIPES, multi: true }),\r\n    new di_1.Provider(core_1.PLATFORM_DIRECTIVES, { useValue: common_1.COMMON_DIRECTIVES, multi: true }),\r\n    new di_1.Provider(core_1.ExceptionHandler, { useFactory: _exceptionHandler, deps: [] }),\r\n    new di_1.Provider(dom_tokens_1.DOCUMENT, { useFactory: _document, deps: [] }),\r\n    new di_1.Provider(event_manager_1.EVENT_MANAGER_PLUGINS, { useClass: dom_events_1.DomEventsPlugin, multi: true }),\r\n    new di_1.Provider(event_manager_1.EVENT_MANAGER_PLUGINS, { useClass: key_events_1.KeyEventsPlugin, multi: true }),\r\n    new di_1.Provider(event_manager_1.EVENT_MANAGER_PLUGINS, { useClass: hammer_gestures_1.HammerGesturesPlugin, multi: true }),\r\n    new di_1.Provider(dom_renderer_1.DomRootRenderer, { useClass: dom_renderer_1.DomRootRenderer_ }),\r\n    new di_1.Provider(core_1.RootRenderer, { useExisting: dom_renderer_1.DomRootRenderer }),\r\n    new di_1.Provider(shared_styles_host_2.SharedStylesHost, { useExisting: shared_styles_host_1.DomSharedStylesHost }),\r\n    shared_styles_host_1.DomSharedStylesHost,\r\n    testability_1.Testability,\r\n    browser_details_1.BrowserDetails,\r\n    animation_builder_1.AnimationBuilder,\r\n    event_manager_1.EventManager\r\n]);\r\nfunction initDomAdapter() {\r\n    browser_adapter_1.BrowserDomAdapter.makeCurrent();\r\n    wtf_init_1.wtfInit();\r\n    testability_2.BrowserGetTestability.init();\r\n}\r\nexports.initDomAdapter = initDomAdapter;\r\n},{\"./browser/browser_adapter\":179,\"angular2/common\":1,\"angular2/core\":3,\"angular2/platform/common_dom\":5,\"angular2/src/animate/animation_builder\":7,\"angular2/src/animate/browser_details\":8,\"angular2/src/core/di\":117,\"angular2/src/core/profile/wtf_init\":157,\"angular2/src/core/testability/testability\":164,\"angular2/src/facade/lang\":176,\"angular2/src/platform/browser/testability\":181,\"angular2/src/platform/browser/title\":182,\"angular2/src/platform/browser/tools/tools\":184,\"angular2/src/platform/dom/dom_adapter\":189,\"angular2/src/platform/dom/dom_renderer\":190,\"angular2/src/platform/dom/dom_tokens\":191,\"angular2/src/platform/dom/events/dom_events\":192,\"angular2/src/platform/dom/events/event_manager\":193,\"angular2/src/platform/dom/events/hammer_gestures\":195,\"angular2/src/platform/dom/events/key_events\":196,\"angular2/src/platform/dom/shared_styles_host\":197}],187:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\n/**\r\n * Predicates for use with {@link DebugElement}'s query functions.\r\n */\r\nvar By = (function () {\r\n    function By() {\r\n    }\r\n    /**\r\n     * Match all elements.\r\n     *\r\n     * ## Example\r\n     *\r\n     * {@example platform/dom/debug/ts/by/by.ts region='by_all'}\r\n     */\r\n    By.all = function () { return function (debugElement) { return true; }; };\r\n    /**\r\n     * Match elements by the given CSS selector.\r\n     *\r\n     * ## Example\r\n     *\r\n     * {@example platform/dom/debug/ts/by/by.ts region='by_css'}\r\n     */\r\n    By.css = function (selector) {\r\n        return function (debugElement) {\r\n            return lang_1.isPresent(debugElement.nativeElement) ?\r\n                dom_adapter_1.DOM.elementMatches(debugElement.nativeElement, selector) :\r\n                false;\r\n        };\r\n    };\r\n    /**\r\n     * Match elements that have the given directive present.\r\n     *\r\n     * ## Example\r\n     *\r\n     * {@example platform/dom/debug/ts/by/by.ts region='by_directive'}\r\n     */\r\n    By.directive = function (type) {\r\n        return function (debugElement) { return debugElement.hasDirective(type); };\r\n    };\r\n    return By;\r\n})();\r\nexports.By = By;\r\n},{\"angular2/src/facade/lang\":176,\"angular2/src/platform/dom/dom_adapter\":189}],188:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar view_listener_1 = require('angular2/src/core/linker/view_listener');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar debug_element_1 = require('angular2/src/core/debug/debug_element');\r\nvar NG_ID_PROPERTY = 'ngid';\r\nvar INSPECT_GLOBAL_NAME = 'ng.probe';\r\nvar NG_ID_SEPARATOR = '#';\r\n// Need to keep the views in a global Map so that multiple angular apps are supported\r\nvar _allIdsByView = new collection_1.Map();\r\nvar _allViewsById = new collection_1.Map();\r\nvar _nextId = 0;\r\nfunction _setElementId(element, indices) {\r\n    if (lang_1.isPresent(element) && dom_adapter_1.DOM.isElementNode(element)) {\r\n        dom_adapter_1.DOM.setData(element, NG_ID_PROPERTY, indices.join(NG_ID_SEPARATOR));\r\n    }\r\n}\r\nfunction _getElementId(element) {\r\n    var elId = dom_adapter_1.DOM.getData(element, NG_ID_PROPERTY);\r\n    if (lang_1.isPresent(elId)) {\r\n        return elId.split(NG_ID_SEPARATOR).map(function (partStr) { return lang_1.NumberWrapper.parseInt(partStr, 10); });\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Returns a {@link DebugElement} for the given native DOM element, or\r\n * null if the given native element does not have an Angular view associated\r\n * with it.\r\n */\r\nfunction inspectNativeElement(element) {\r\n    var elId = _getElementId(element);\r\n    if (lang_1.isPresent(elId)) {\r\n        var view = _allViewsById.get(elId[0]);\r\n        if (lang_1.isPresent(view)) {\r\n            return new debug_element_1.DebugElement_(view.appElements[elId[1]]);\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.inspectNativeElement = inspectNativeElement;\r\nvar DebugElementViewListener = (function () {\r\n    function DebugElementViewListener() {\r\n        dom_adapter_1.DOM.setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);\r\n    }\r\n    DebugElementViewListener.prototype.onViewCreated = function (view) {\r\n        var viewId = _nextId++;\r\n        _allViewsById.set(viewId, view);\r\n        _allIdsByView.set(view, viewId);\r\n        for (var i = 0; i < view.appElements.length; i++) {\r\n            var el = view.appElements[i];\r\n            _setElementId(el.nativeElement, [viewId, i]);\r\n        }\r\n    };\r\n    DebugElementViewListener.prototype.onViewDestroyed = function (view) {\r\n        var viewId = _allIdsByView.get(view);\r\n        _allIdsByView.delete(view);\r\n        _allViewsById.delete(viewId);\r\n    };\r\n    DebugElementViewListener = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], DebugElementViewListener);\r\n    return DebugElementViewListener;\r\n})();\r\nexports.DebugElementViewListener = DebugElementViewListener;\r\n/**\r\n * Providers which support debugging Angular applications (e.g. via `ng.probe`).\r\n *\r\n * ## Example\r\n *\r\n * {@example platform/dom/debug/ts/debug_element_view_listener/providers.ts region='providers'}\r\n */\r\nexports.ELEMENT_PROBE_PROVIDERS = lang_1.CONST_EXPR([\r\n    DebugElementViewListener,\r\n    lang_1.CONST_EXPR(new di_1.Provider(view_listener_1.AppViewListener, { useExisting: DebugElementViewListener })),\r\n]);\r\n/**\r\n * Use {@link ELEMENT_PROBE_PROVIDERS}.\r\n *\r\n * @deprecated\r\n */\r\nexports.ELEMENT_PROBE_BINDINGS = exports.ELEMENT_PROBE_PROVIDERS;\r\n},{\"angular2/src/core/debug/debug_element\":116,\"angular2/src/core/di\":117,\"angular2/src/core/linker/view_listener\":141,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176,\"angular2/src/platform/dom/dom_adapter\":189}],189:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nexports.DOM = null;\r\nfunction setRootDomAdapter(adapter) {\r\n    if (lang_1.isBlank(exports.DOM)) {\r\n        exports.DOM = adapter;\r\n    }\r\n}\r\nexports.setRootDomAdapter = setRootDomAdapter;\r\n/* tslint:disable:requireParameterType */\r\n/**\r\n * Provides DOM operations in an environment-agnostic way.\r\n */\r\nvar DomAdapter = (function () {\r\n    function DomAdapter() {\r\n    }\r\n    return DomAdapter;\r\n})();\r\nexports.DomAdapter = DomAdapter;\r\n},{\"angular2/src/facade/lang\":176}],190:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar di_1 = require('angular2/src/core/di');\r\nvar animation_builder_1 = require('angular2/src/animate/animation_builder');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar shared_styles_host_1 = require('./shared_styles_host');\r\nvar event_manager_1 = require('./events/event_manager');\r\nvar dom_tokens_1 = require('./dom_tokens');\r\nvar metadata_1 = require('angular2/src/core/metadata');\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar util_1 = require('./util');\r\nvar NAMESPACE_URIS = lang_1.CONST_EXPR({ 'xlink': 'http://www.w3.org/1999/xlink', 'svg': 'http://www.w3.org/2000/svg' });\r\nvar TEMPLATE_COMMENT_TEXT = 'template bindings={}';\r\nvar TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/g;\r\nvar DomRootRenderer = (function () {\r\n    function DomRootRenderer(document, eventManager, sharedStylesHost, animate) {\r\n        this.document = document;\r\n        this.eventManager = eventManager;\r\n        this.sharedStylesHost = sharedStylesHost;\r\n        this.animate = animate;\r\n        this._registeredComponents = new Map();\r\n    }\r\n    DomRootRenderer.prototype.renderComponent = function (componentProto) {\r\n        var renderer = this._registeredComponents.get(componentProto.id);\r\n        if (lang_1.isBlank(renderer)) {\r\n            renderer = new DomRenderer(this, componentProto);\r\n            this._registeredComponents.set(componentProto.id, renderer);\r\n        }\r\n        return renderer;\r\n    };\r\n    return DomRootRenderer;\r\n})();\r\nexports.DomRootRenderer = DomRootRenderer;\r\nvar DomRootRenderer_ = (function (_super) {\r\n    __extends(DomRootRenderer_, _super);\r\n    function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animate) {\r\n        _super.call(this, _document, _eventManager, sharedStylesHost, animate);\r\n    }\r\n    DomRootRenderer_ = __decorate([\r\n        di_1.Injectable(),\r\n        __param(0, di_1.Inject(dom_tokens_1.DOCUMENT)), \r\n        __metadata('design:paramtypes', [Object, event_manager_1.EventManager, shared_styles_host_1.DomSharedStylesHost, animation_builder_1.AnimationBuilder])\r\n    ], DomRootRenderer_);\r\n    return DomRootRenderer_;\r\n})(DomRootRenderer);\r\nexports.DomRootRenderer_ = DomRootRenderer_;\r\nvar DomRenderer = (function () {\r\n    function DomRenderer(_rootRenderer, componentProto) {\r\n        this._rootRenderer = _rootRenderer;\r\n        this.componentProto = componentProto;\r\n        this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);\r\n        if (componentProto.encapsulation !== metadata_1.ViewEncapsulation.Native) {\r\n            this._rootRenderer.sharedStylesHost.addStyles(this._styles);\r\n        }\r\n        if (this.componentProto.encapsulation === metadata_1.ViewEncapsulation.Emulated) {\r\n            this._contentAttr = _shimContentAttribute(componentProto.id);\r\n            this._hostAttr = _shimHostAttribute(componentProto.id);\r\n        }\r\n        else {\r\n            this._contentAttr = null;\r\n            this._hostAttr = null;\r\n        }\r\n    }\r\n    DomRenderer.prototype.renderComponent = function (componentProto) {\r\n        return this._rootRenderer.renderComponent(componentProto);\r\n    };\r\n    DomRenderer.prototype.selectRootElement = function (selector) {\r\n        var el = dom_adapter_1.DOM.querySelector(this._rootRenderer.document, selector);\r\n        if (lang_1.isBlank(el)) {\r\n            throw new exceptions_1.BaseException(\"The selector \\\"\" + selector + \"\\\" did not match any elements\");\r\n        }\r\n        dom_adapter_1.DOM.clearNodes(el);\r\n        return el;\r\n    };\r\n    DomRenderer.prototype.createElement = function (parent, name) {\r\n        var nsAndName = splitNamespace(name);\r\n        var el = lang_1.isPresent(nsAndName[0]) ?\r\n            dom_adapter_1.DOM.createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) :\r\n            dom_adapter_1.DOM.createElement(nsAndName[1]);\r\n        if (lang_1.isPresent(this._contentAttr)) {\r\n            dom_adapter_1.DOM.setAttribute(el, this._contentAttr, '');\r\n        }\r\n        if (lang_1.isPresent(parent)) {\r\n            dom_adapter_1.DOM.appendChild(parent, el);\r\n        }\r\n        return el;\r\n    };\r\n    DomRenderer.prototype.createViewRoot = function (hostElement) {\r\n        var nodesParent;\r\n        if (this.componentProto.encapsulation === metadata_1.ViewEncapsulation.Native) {\r\n            nodesParent = dom_adapter_1.DOM.createShadowRoot(hostElement);\r\n            this._rootRenderer.sharedStylesHost.addHost(nodesParent);\r\n            for (var i = 0; i < this._styles.length; i++) {\r\n                dom_adapter_1.DOM.appendChild(nodesParent, dom_adapter_1.DOM.createStyleElement(this._styles[i]));\r\n            }\r\n        }\r\n        else {\r\n            if (lang_1.isPresent(this._hostAttr)) {\r\n                dom_adapter_1.DOM.setAttribute(hostElement, this._hostAttr, '');\r\n            }\r\n            nodesParent = hostElement;\r\n        }\r\n        return nodesParent;\r\n    };\r\n    DomRenderer.prototype.createTemplateAnchor = function (parentElement) {\r\n        var comment = dom_adapter_1.DOM.createComment(TEMPLATE_COMMENT_TEXT);\r\n        if (lang_1.isPresent(parentElement)) {\r\n            dom_adapter_1.DOM.appendChild(parentElement, comment);\r\n        }\r\n        return comment;\r\n    };\r\n    DomRenderer.prototype.createText = function (parentElement, value) {\r\n        var node = dom_adapter_1.DOM.createTextNode(value);\r\n        if (lang_1.isPresent(parentElement)) {\r\n            dom_adapter_1.DOM.appendChild(parentElement, node);\r\n        }\r\n        return node;\r\n    };\r\n    DomRenderer.prototype.projectNodes = function (parentElement, nodes) {\r\n        if (lang_1.isBlank(parentElement))\r\n            return;\r\n        appendNodes(parentElement, nodes);\r\n    };\r\n    DomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {\r\n        moveNodesAfterSibling(node, viewRootNodes);\r\n        for (var i = 0; i < viewRootNodes.length; i++)\r\n            this.animateNodeEnter(viewRootNodes[i]);\r\n    };\r\n    DomRenderer.prototype.detachView = function (viewRootNodes) {\r\n        for (var i = 0; i < viewRootNodes.length; i++) {\r\n            var node = viewRootNodes[i];\r\n            dom_adapter_1.DOM.remove(node);\r\n            this.animateNodeLeave(node);\r\n        }\r\n    };\r\n    DomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {\r\n        if (this.componentProto.encapsulation === metadata_1.ViewEncapsulation.Native && lang_1.isPresent(hostElement)) {\r\n            this._rootRenderer.sharedStylesHost.removeHost(dom_adapter_1.DOM.getShadowRoot(hostElement));\r\n        }\r\n    };\r\n    DomRenderer.prototype.listen = function (renderElement, name, callback) {\r\n        this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));\r\n    };\r\n    DomRenderer.prototype.listenGlobal = function (target, name, callback) {\r\n        return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));\r\n    };\r\n    DomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {\r\n        dom_adapter_1.DOM.setProperty(renderElement, propertyName, propertyValue);\r\n    };\r\n    DomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {\r\n        var attrNs;\r\n        var nsAndName = splitNamespace(attributeName);\r\n        if (lang_1.isPresent(nsAndName[0])) {\r\n            attributeName = nsAndName[0] + ':' + nsAndName[1];\r\n            attrNs = NAMESPACE_URIS[nsAndName[0]];\r\n        }\r\n        if (lang_1.isPresent(attributeValue)) {\r\n            if (lang_1.isPresent(attrNs)) {\r\n                dom_adapter_1.DOM.setAttributeNS(renderElement, attrNs, attributeName, attributeValue);\r\n            }\r\n            else {\r\n                dom_adapter_1.DOM.setAttribute(renderElement, nsAndName[1], attributeValue);\r\n            }\r\n        }\r\n        else {\r\n            dom_adapter_1.DOM.removeAttribute(renderElement, attributeName);\r\n        }\r\n    };\r\n    DomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {\r\n        var dashCasedPropertyName = util_1.camelCaseToDashCase(propertyName);\r\n        if (dom_adapter_1.DOM.isCommentNode(renderElement)) {\r\n            var existingBindings = lang_1.RegExpWrapper.firstMatch(TEMPLATE_BINDINGS_EXP, lang_1.StringWrapper.replaceAll(dom_adapter_1.DOM.getText(renderElement), /\\n/g, ''));\r\n            var parsedBindings = lang_1.Json.parse(existingBindings[1]);\r\n            parsedBindings[dashCasedPropertyName] = propertyValue;\r\n            dom_adapter_1.DOM.setText(renderElement, lang_1.StringWrapper.replace(TEMPLATE_COMMENT_TEXT, '{}', lang_1.Json.stringify(parsedBindings)));\r\n        }\r\n        else {\r\n            this.setElementAttribute(renderElement, propertyName, propertyValue);\r\n        }\r\n    };\r\n    DomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {\r\n        if (isAdd) {\r\n            dom_adapter_1.DOM.addClass(renderElement, className);\r\n        }\r\n        else {\r\n            dom_adapter_1.DOM.removeClass(renderElement, className);\r\n        }\r\n    };\r\n    DomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {\r\n        if (lang_1.isPresent(styleValue)) {\r\n            dom_adapter_1.DOM.setStyle(renderElement, styleName, lang_1.stringify(styleValue));\r\n        }\r\n        else {\r\n            dom_adapter_1.DOM.removeStyle(renderElement, styleName);\r\n        }\r\n    };\r\n    DomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {\r\n        dom_adapter_1.DOM.invoke(renderElement, methodName, args);\r\n    };\r\n    DomRenderer.prototype.setText = function (renderNode, text) { dom_adapter_1.DOM.setText(renderNode, text); };\r\n    /**\r\n     * Performs animations if necessary\r\n     * @param node\r\n     */\r\n    DomRenderer.prototype.animateNodeEnter = function (node) {\r\n        if (dom_adapter_1.DOM.isElementNode(node) && dom_adapter_1.DOM.hasClass(node, 'ng-animate')) {\r\n            dom_adapter_1.DOM.addClass(node, 'ng-enter');\r\n            this._rootRenderer.animate.css()\r\n                .addAnimationClass('ng-enter-active')\r\n                .start(node)\r\n                .onComplete(function () { dom_adapter_1.DOM.removeClass(node, 'ng-enter'); });\r\n        }\r\n    };\r\n    /**\r\n     * If animations are necessary, performs animations then removes the element; otherwise, it just\r\n     * removes the element.\r\n     * @param node\r\n     */\r\n    DomRenderer.prototype.animateNodeLeave = function (node) {\r\n        if (dom_adapter_1.DOM.isElementNode(node) && dom_adapter_1.DOM.hasClass(node, 'ng-animate')) {\r\n            dom_adapter_1.DOM.addClass(node, 'ng-leave');\r\n            this._rootRenderer.animate.css()\r\n                .addAnimationClass('ng-leave-active')\r\n                .start(node)\r\n                .onComplete(function () {\r\n                dom_adapter_1.DOM.removeClass(node, 'ng-leave');\r\n                dom_adapter_1.DOM.remove(node);\r\n            });\r\n        }\r\n        else {\r\n            dom_adapter_1.DOM.remove(node);\r\n        }\r\n    };\r\n    return DomRenderer;\r\n})();\r\nexports.DomRenderer = DomRenderer;\r\nfunction moveNodesAfterSibling(sibling, nodes) {\r\n    var parent = dom_adapter_1.DOM.parentElement(sibling);\r\n    if (nodes.length > 0 && lang_1.isPresent(parent)) {\r\n        var nextSibling = dom_adapter_1.DOM.nextSibling(sibling);\r\n        if (lang_1.isPresent(nextSibling)) {\r\n            for (var i = 0; i < nodes.length; i++) {\r\n                dom_adapter_1.DOM.insertBefore(nextSibling, nodes[i]);\r\n            }\r\n        }\r\n        else {\r\n            for (var i = 0; i < nodes.length; i++) {\r\n                dom_adapter_1.DOM.appendChild(parent, nodes[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction appendNodes(parent, nodes) {\r\n    for (var i = 0; i < nodes.length; i++) {\r\n        dom_adapter_1.DOM.appendChild(parent, nodes[i]);\r\n    }\r\n}\r\nfunction decoratePreventDefault(eventHandler) {\r\n    return function (event) {\r\n        var allowDefaultBehavior = eventHandler(event);\r\n        if (allowDefaultBehavior === false) {\r\n            // TODO(tbosch): move preventDefault into event plugins...\r\n            dom_adapter_1.DOM.preventDefault(event);\r\n        }\r\n    };\r\n}\r\nvar COMPONENT_REGEX = /%COMP%/g;\r\nexports.COMPONENT_VARIABLE = '%COMP%';\r\nexports.HOST_ATTR = \"_nghost-\" + exports.COMPONENT_VARIABLE;\r\nexports.CONTENT_ATTR = \"_ngcontent-\" + exports.COMPONENT_VARIABLE;\r\nfunction _shimContentAttribute(componentShortId) {\r\n    return lang_1.StringWrapper.replaceAll(exports.CONTENT_ATTR, COMPONENT_REGEX, componentShortId);\r\n}\r\nfunction _shimHostAttribute(componentShortId) {\r\n    return lang_1.StringWrapper.replaceAll(exports.HOST_ATTR, COMPONENT_REGEX, componentShortId);\r\n}\r\nfunction _flattenStyles(compId, styles, target) {\r\n    for (var i = 0; i < styles.length; i++) {\r\n        var style = styles[i];\r\n        if (lang_1.isArray(style)) {\r\n            _flattenStyles(compId, style, target);\r\n        }\r\n        else {\r\n            style = lang_1.StringWrapper.replaceAll(style, COMPONENT_REGEX, compId);\r\n            target.push(style);\r\n        }\r\n    }\r\n    return target;\r\n}\r\nvar NS_PREFIX_RE = /^@([^:]+):(.+)/g;\r\nfunction splitNamespace(name) {\r\n    if (name[0] != '@') {\r\n        return [null, name];\r\n    }\r\n    var match = lang_1.RegExpWrapper.firstMatch(NS_PREFIX_RE, name);\r\n    return [match[1], match[2]];\r\n}\r\n},{\"./dom_tokens\":191,\"./events/event_manager\":193,\"./shared_styles_host\":197,\"./util\":198,\"angular2/src/animate/animation_builder\":7,\"angular2/src/core/di\":117,\"angular2/src/core/metadata\":146,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176,\"angular2/src/platform/dom/dom_adapter\":189}],191:[function(require,module,exports){\n'use strict';var di_1 = require('angular2/src/core/di');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\n/**\r\n * A DI Token representing the main rendering context. In a browser this is the DOM Document.\r\n *\r\n * Note: Document might not be available in the Application Context when Application and Rendering\r\n * Contexts are not the same (e.g. when running the application into a Web Worker).\r\n */\r\nexports.DOCUMENT = lang_1.CONST_EXPR(new di_1.OpaqueToken('DocumentToken'));\r\n},{\"angular2/src/core/di\":117,\"angular2/src/facade/lang\":176}],192:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar core_1 = require('angular2/core');\r\nvar event_manager_1 = require('./event_manager');\r\nvar DomEventsPlugin = (function (_super) {\r\n    __extends(DomEventsPlugin, _super);\r\n    function DomEventsPlugin() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    // This plugin should come last in the list of plugins, because it accepts all\r\n    // events.\r\n    DomEventsPlugin.prototype.supports = function (eventName) { return true; };\r\n    DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {\r\n        var zone = this.manager.getZone();\r\n        var outsideHandler = function (event) { return zone.run(function () { return handler(event); }); };\r\n        this.manager.getZone().runOutsideAngular(function () { dom_adapter_1.DOM.on(element, eventName, outsideHandler); });\r\n    };\r\n    DomEventsPlugin.prototype.addGlobalEventListener = function (target, eventName, handler) {\r\n        var element = dom_adapter_1.DOM.getGlobalEventTarget(target);\r\n        var zone = this.manager.getZone();\r\n        var outsideHandler = function (event) { return zone.run(function () { return handler(event); }); };\r\n        return this.manager.getZone().runOutsideAngular(function () { return dom_adapter_1.DOM.onAndCancel(element, eventName, outsideHandler); });\r\n    };\r\n    DomEventsPlugin = __decorate([\r\n        core_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], DomEventsPlugin);\r\n    return DomEventsPlugin;\r\n})(event_manager_1.EventManagerPlugin);\r\nexports.DomEventsPlugin = DomEventsPlugin;\r\n},{\"./event_manager\":193,\"angular2/core\":3,\"angular2/src/platform/dom/dom_adapter\":189}],193:[function(require,module,exports){\n'use strict';var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar ng_zone_1 = require('angular2/src/core/zone/ng_zone');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nexports.EVENT_MANAGER_PLUGINS = lang_1.CONST_EXPR(new di_1.OpaqueToken(\"EventManagerPlugins\"));\r\nvar EventManager = (function () {\r\n    function EventManager(plugins, _zone) {\r\n        var _this = this;\r\n        this._zone = _zone;\r\n        plugins.forEach(function (p) { return p.manager = _this; });\r\n        this._plugins = collection_1.ListWrapper.reversed(plugins);\r\n    }\r\n    EventManager.prototype.addEventListener = function (element, eventName, handler) {\r\n        var plugin = this._findPluginFor(eventName);\r\n        plugin.addEventListener(element, eventName, handler);\r\n    };\r\n    EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {\r\n        var plugin = this._findPluginFor(eventName);\r\n        return plugin.addGlobalEventListener(target, eventName, handler);\r\n    };\r\n    EventManager.prototype.getZone = function () { return this._zone; };\r\n    /** @internal */\r\n    EventManager.prototype._findPluginFor = function (eventName) {\r\n        var plugins = this._plugins;\r\n        for (var i = 0; i < plugins.length; i++) {\r\n            var plugin = plugins[i];\r\n            if (plugin.supports(eventName)) {\r\n                return plugin;\r\n            }\r\n        }\r\n        throw new exceptions_1.BaseException(\"No event manager plugin found for event \" + eventName);\r\n    };\r\n    EventManager = __decorate([\r\n        di_1.Injectable(),\r\n        __param(0, di_1.Inject(exports.EVENT_MANAGER_PLUGINS)), \r\n        __metadata('design:paramtypes', [Array, ng_zone_1.NgZone])\r\n    ], EventManager);\r\n    return EventManager;\r\n})();\r\nexports.EventManager = EventManager;\r\nvar EventManagerPlugin = (function () {\r\n    function EventManagerPlugin() {\r\n    }\r\n    // That is equivalent to having supporting $event.target\r\n    EventManagerPlugin.prototype.supports = function (eventName) { return false; };\r\n    EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {\r\n        throw \"not implemented\";\r\n    };\r\n    EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {\r\n        throw \"not implemented\";\r\n    };\r\n    return EventManagerPlugin;\r\n})();\r\nexports.EventManagerPlugin = EventManagerPlugin;\r\n},{\"angular2/src/core/di\":117,\"angular2/src/core/zone/ng_zone\":168,\"angular2/src/facade/collection\":171,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],194:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar event_manager_1 = require('./event_manager');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar _eventNames = {\r\n    // pan\r\n    'pan': true,\r\n    'panstart': true,\r\n    'panmove': true,\r\n    'panend': true,\r\n    'pancancel': true,\r\n    'panleft': true,\r\n    'panright': true,\r\n    'panup': true,\r\n    'pandown': true,\r\n    // pinch\r\n    'pinch': true,\r\n    'pinchstart': true,\r\n    'pinchmove': true,\r\n    'pinchend': true,\r\n    'pinchcancel': true,\r\n    'pinchin': true,\r\n    'pinchout': true,\r\n    // press\r\n    'press': true,\r\n    'pressup': true,\r\n    // rotate\r\n    'rotate': true,\r\n    'rotatestart': true,\r\n    'rotatemove': true,\r\n    'rotateend': true,\r\n    'rotatecancel': true,\r\n    // swipe\r\n    'swipe': true,\r\n    'swipeleft': true,\r\n    'swiperight': true,\r\n    'swipeup': true,\r\n    'swipedown': true,\r\n    // tap\r\n    'tap': true,\r\n};\r\nvar HammerGesturesPluginCommon = (function (_super) {\r\n    __extends(HammerGesturesPluginCommon, _super);\r\n    function HammerGesturesPluginCommon() {\r\n        _super.call(this);\r\n    }\r\n    HammerGesturesPluginCommon.prototype.supports = function (eventName) {\r\n        eventName = eventName.toLowerCase();\r\n        return collection_1.StringMapWrapper.contains(_eventNames, eventName);\r\n    };\r\n    return HammerGesturesPluginCommon;\r\n})(event_manager_1.EventManagerPlugin);\r\nexports.HammerGesturesPluginCommon = HammerGesturesPluginCommon;\r\n},{\"./event_manager\":193,\"angular2/src/facade/collection\":171}],195:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar hammer_common_1 = require('./hammer_common');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar exceptions_1 = require('angular2/src/facade/exceptions');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar HammerGesturesPlugin = (function (_super) {\r\n    __extends(HammerGesturesPlugin, _super);\r\n    function HammerGesturesPlugin() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    HammerGesturesPlugin.prototype.supports = function (eventName) {\r\n        if (!_super.prototype.supports.call(this, eventName))\r\n            return false;\r\n        if (!lang_1.isPresent(window['Hammer'])) {\r\n            throw new exceptions_1.BaseException(\"Hammer.js is not loaded, can not bind \" + eventName + \" event\");\r\n        }\r\n        return true;\r\n    };\r\n    HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {\r\n        var zone = this.manager.getZone();\r\n        eventName = eventName.toLowerCase();\r\n        zone.runOutsideAngular(function () {\r\n            // Creating the manager bind events, must be done outside of angular\r\n            var mc = new Hammer(element);\r\n            mc.get('pinch').set({ enable: true });\r\n            mc.get('rotate').set({ enable: true });\r\n            mc.on(eventName, function (eventObj) { zone.run(function () { handler(eventObj); }); });\r\n        });\r\n    };\r\n    HammerGesturesPlugin = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], HammerGesturesPlugin);\r\n    return HammerGesturesPlugin;\r\n})(hammer_common_1.HammerGesturesPluginCommon);\r\nexports.HammerGesturesPlugin = HammerGesturesPlugin;\r\n},{\"./hammer_common\":194,\"angular2/src/core/di\":117,\"angular2/src/facade/exceptions\":173,\"angular2/src/facade/lang\":176}],196:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar lang_1 = require('angular2/src/facade/lang');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar event_manager_1 = require('./event_manager');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar modifierKeys = ['alt', 'control', 'meta', 'shift'];\r\nvar modifierKeyGetters = {\r\n    'alt': function (event) { return event.altKey; },\r\n    'control': function (event) { return event.ctrlKey; },\r\n    'meta': function (event) { return event.metaKey; },\r\n    'shift': function (event) { return event.shiftKey; }\r\n};\r\nvar KeyEventsPlugin = (function (_super) {\r\n    __extends(KeyEventsPlugin, _super);\r\n    function KeyEventsPlugin() {\r\n        _super.call(this);\r\n    }\r\n    KeyEventsPlugin.prototype.supports = function (eventName) {\r\n        return lang_1.isPresent(KeyEventsPlugin.parseEventName(eventName));\r\n    };\r\n    KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {\r\n        var parsedEvent = KeyEventsPlugin.parseEventName(eventName);\r\n        var outsideHandler = KeyEventsPlugin.eventCallback(element, collection_1.StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());\r\n        this.manager.getZone().runOutsideAngular(function () {\r\n            dom_adapter_1.DOM.on(element, collection_1.StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);\r\n        });\r\n    };\r\n    KeyEventsPlugin.parseEventName = function (eventName) {\r\n        var parts = eventName.toLowerCase().split('.');\r\n        var domEventName = parts.shift();\r\n        if ((parts.length === 0) ||\r\n            !(lang_1.StringWrapper.equals(domEventName, 'keydown') ||\r\n                lang_1.StringWrapper.equals(domEventName, 'keyup'))) {\r\n            return null;\r\n        }\r\n        var key = KeyEventsPlugin._normalizeKey(parts.pop());\r\n        var fullKey = '';\r\n        modifierKeys.forEach(function (modifierName) {\r\n            if (collection_1.ListWrapper.contains(parts, modifierName)) {\r\n                collection_1.ListWrapper.remove(parts, modifierName);\r\n                fullKey += modifierName + '.';\r\n            }\r\n        });\r\n        fullKey += key;\r\n        if (parts.length != 0 || key.length === 0) {\r\n            // returning null instead of throwing to let another plugin process the event\r\n            return null;\r\n        }\r\n        var result = collection_1.StringMapWrapper.create();\r\n        collection_1.StringMapWrapper.set(result, 'domEventName', domEventName);\r\n        collection_1.StringMapWrapper.set(result, 'fullKey', fullKey);\r\n        return result;\r\n    };\r\n    KeyEventsPlugin.getEventFullKey = function (event) {\r\n        var fullKey = '';\r\n        var key = dom_adapter_1.DOM.getEventKey(event);\r\n        key = key.toLowerCase();\r\n        if (lang_1.StringWrapper.equals(key, ' ')) {\r\n            key = 'space'; // for readability\r\n        }\r\n        else if (lang_1.StringWrapper.equals(key, '.')) {\r\n            key = 'dot'; // because '.' is used as a separator in event names\r\n        }\r\n        modifierKeys.forEach(function (modifierName) {\r\n            if (modifierName != key) {\r\n                var modifierGetter = collection_1.StringMapWrapper.get(modifierKeyGetters, modifierName);\r\n                if (modifierGetter(event)) {\r\n                    fullKey += modifierName + '.';\r\n                }\r\n            }\r\n        });\r\n        fullKey += key;\r\n        return fullKey;\r\n    };\r\n    KeyEventsPlugin.eventCallback = function (element, fullKey, handler, zone) {\r\n        return function (event) {\r\n            if (lang_1.StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {\r\n                zone.run(function () { return handler(event); });\r\n            }\r\n        };\r\n    };\r\n    /** @internal */\r\n    KeyEventsPlugin._normalizeKey = function (keyName) {\r\n        // TODO: switch to a StringMap if the mapping grows too much\r\n        switch (keyName) {\r\n            case 'esc':\r\n                return 'escape';\r\n            default:\r\n                return keyName;\r\n        }\r\n    };\r\n    KeyEventsPlugin = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], KeyEventsPlugin);\r\n    return KeyEventsPlugin;\r\n})(event_manager_1.EventManagerPlugin);\r\nexports.KeyEventsPlugin = KeyEventsPlugin;\r\n},{\"./event_manager\":193,\"angular2/src/core/di\":117,\"angular2/src/facade/collection\":171,\"angular2/src/facade/lang\":176,\"angular2/src/platform/dom/dom_adapter\":189}],197:[function(require,module,exports){\n'use strict';var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar dom_adapter_1 = require('angular2/src/platform/dom/dom_adapter');\r\nvar di_1 = require('angular2/src/core/di');\r\nvar collection_1 = require('angular2/src/facade/collection');\r\nvar dom_tokens_1 = require('./dom_tokens');\r\nvar SharedStylesHost = (function () {\r\n    function SharedStylesHost() {\r\n        /** @internal */\r\n        this._styles = [];\r\n        /** @internal */\r\n        this._stylesSet = new Set();\r\n    }\r\n    SharedStylesHost.prototype.addStyles = function (styles) {\r\n        var _this = this;\r\n        var additions = [];\r\n        styles.forEach(function (style) {\r\n            if (!collection_1.SetWrapper.has(_this._stylesSet, style)) {\r\n                _this._stylesSet.add(style);\r\n                _this._styles.push(style);\r\n                additions.push(style);\r\n            }\r\n        });\r\n        this.onStylesAdded(additions);\r\n    };\r\n    SharedStylesHost.prototype.onStylesAdded = function (additions) { };\r\n    SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };\r\n    SharedStylesHost = __decorate([\r\n        di_1.Injectable(), \r\n        __metadata('design:paramtypes', [])\r\n    ], SharedStylesHost);\r\n    return SharedStylesHost;\r\n})();\r\nexports.SharedStylesHost = SharedStylesHost;\r\nvar DomSharedStylesHost = (function (_super) {\r\n    __extends(DomSharedStylesHost, _super);\r\n    function DomSharedStylesHost(doc) {\r\n        _super.call(this);\r\n        this._hostNodes = new Set();\r\n        this._hostNodes.add(doc.head);\r\n    }\r\n    /** @internal */\r\n    DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {\r\n        for (var i = 0; i < styles.length; i++) {\r\n            var style = styles[i];\r\n            dom_adapter_1.DOM.appendChild(host, dom_adapter_1.DOM.createStyleElement(style));\r\n        }\r\n    };\r\n    DomSharedStylesHost.prototype.addHost = function (hostNode) {\r\n        this._addStylesToHost(this._styles, hostNode);\r\n        this._hostNodes.add(hostNode);\r\n    };\r\n    DomSharedStylesHost.prototype.removeHost = function (hostNode) { collection_1.SetWrapper.delete(this._hostNodes, hostNode); };\r\n    DomSharedStylesHost.prototype.onStylesAdded = function (additions) {\r\n        var _this = this;\r\n        this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });\r\n    };\r\n    DomSharedStylesHost = __decorate([\r\n        di_1.Injectable(),\r\n        __param(0, di_1.Inject(dom_tokens_1.DOCUMENT)), \r\n        __metadata('design:paramtypes', [Object])\r\n    ], DomSharedStylesHost);\r\n    return DomSharedStylesHost;\r\n})(SharedStylesHost);\r\nexports.DomSharedStylesHost = DomSharedStylesHost;\r\n},{\"./dom_tokens\":191,\"angular2/src/core/di\":117,\"angular2/src/facade/collection\":171,\"angular2/src/platform/dom/dom_adapter\":189}],198:[function(require,module,exports){\n'use strict';var lang_1 = require('angular2/src/facade/lang');\r\nvar CAMEL_CASE_REGEXP = /([A-Z])/g;\r\nvar DASH_CASE_REGEXP = /-([a-z])/g;\r\nfunction camelCaseToDashCase(input) {\r\n    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });\r\n}\r\nexports.camelCaseToDashCase = camelCaseToDashCase;\r\nfunction dashCaseToCamelCase(input) {\r\n    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });\r\n}\r\nexports.dashCaseToCamelCase = dashCaseToCamelCase;\r\n},{\"angular2/src/facade/lang\":176}],199:[function(require,module,exports){\n'use strict';// Note: This class is only here so that we can reference it from TypeScript code.\r\n// The actual implementation lives under modules_dart.\r\n// TODO(tbosch): Move the corresponding code into angular2/src/compiler once\r\n// the new compiler is done.\r\nvar Codegen = (function () {\r\n    function Codegen(moduleAlias) {\r\n    }\r\n    Codegen.prototype.generate = function (typeName, changeDetectorTypeName, def) {\r\n        throw \"Not implemented in JS\";\r\n    };\r\n    Codegen.prototype.toString = function () { throw \"Not implemented in JS\"; };\r\n    return Codegen;\r\n})();\r\nexports.Codegen = Codegen;\r\n},{}],200:[function(require,module,exports){\nvar asn1 = exports;\n\nasn1.bignum = require('bn.js');\n\nasn1.define = require('./asn1/api').define;\nasn1.base = require('./asn1/base');\nasn1.constants = require('./asn1/constants');\nasn1.decoders = require('./asn1/decoders');\nasn1.encoders = require('./asn1/encoders');\n\n},{\"./asn1/api\":201,\"./asn1/base\":203,\"./asn1/constants\":207,\"./asn1/decoders\":209,\"./asn1/encoders\":212,\"bn.js\":215}],201:[function(require,module,exports){\nvar asn1 = require('../asn1');\nvar inherits = require('inherits');\n\nvar api = exports;\n\napi.define = function define(name, body) {\n  return new Entity(name, body);\n};\n\nfunction Entity(name, body) {\n  this.name = name;\n  this.body = body;\n\n  this.decoders = {};\n  this.encoders = {};\n};\n\nEntity.prototype._createNamed = function createNamed(base) {\n  var named;\n  try {\n    named = require('vm').runInThisContext(\n      '(function ' + this.name + '(entity) {\\n' +\n      '  this._initNamed(entity);\\n' +\n      '})'\n    );\n  } catch (e) {\n    named = function (entity) {\n      this._initNamed(entity);\n    };\n  }\n  inherits(named, base);\n  named.prototype._initNamed = function initnamed(entity) {\n    base.call(this, entity);\n  };\n\n  return new named(this);\n};\n\nEntity.prototype._getDecoder = function _getDecoder(enc) {\n  // Lazily create decoder\n  if (!this.decoders.hasOwnProperty(enc))\n    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);\n  return this.decoders[enc];\n};\n\nEntity.prototype.decode = function decode(data, enc, options) {\n  return this._getDecoder(enc).decode(data, options);\n};\n\nEntity.prototype._getEncoder = function _getEncoder(enc) {\n  // Lazily create encoder\n  if (!this.encoders.hasOwnProperty(enc))\n    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);\n  return this.encoders[enc];\n};\n\nEntity.prototype.encode = function encode(data, enc, /* internal */ reporter) {\n  return this._getEncoder(enc).encode(data, reporter);\n};\n\n},{\"../asn1\":200,\"inherits\":292,\"vm\":352}],202:[function(require,module,exports){\nvar inherits = require('inherits');\nvar Reporter = require('../base').Reporter;\nvar Buffer = require('buffer').Buffer;\n\nfunction DecoderBuffer(base, options) {\n  Reporter.call(this, options);\n  if (!Buffer.isBuffer(base)) {\n    this.error('Input not Buffer');\n    return;\n  }\n\n  this.base = base;\n  this.offset = 0;\n  this.length = base.length;\n}\ninherits(DecoderBuffer, Reporter);\nexports.DecoderBuffer = DecoderBuffer;\n\nDecoderBuffer.prototype.save = function save() {\n  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };\n};\n\nDecoderBuffer.prototype.restore = function restore(save) {\n  // Return skipped data\n  var res = new DecoderBuffer(this.base);\n  res.offset = save.offset;\n  res.length = this.offset;\n\n  this.offset = save.offset;\n  Reporter.prototype.restore.call(this, save.reporter);\n\n  return res;\n};\n\nDecoderBuffer.prototype.isEmpty = function isEmpty() {\n  return this.offset === this.length;\n};\n\nDecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {\n  if (this.offset + 1 <= this.length)\n    return this.base.readUInt8(this.offset++, true);\n  else\n    return this.error(fail || 'DecoderBuffer overrun');\n}\n\nDecoderBuffer.prototype.skip = function skip(bytes, fail) {\n  if (!(this.offset + bytes <= this.length))\n    return this.error(fail || 'DecoderBuffer overrun');\n\n  var res = new DecoderBuffer(this.base);\n\n  // Share reporter state\n  res._reporterState = this._reporterState;\n\n  res.offset = this.offset;\n  res.length = this.offset + bytes;\n  this.offset += bytes;\n  return res;\n}\n\nDecoderBuffer.prototype.raw = function raw(save) {\n  return this.base.slice(save ? save.offset : this.offset, this.length);\n}\n\nfunction EncoderBuffer(value, reporter) {\n  if (Array.isArray(value)) {\n    this.length = 0;\n    this.value = value.map(function(item) {\n      if (!(item instanceof EncoderBuffer))\n        item = new EncoderBuffer(item, reporter);\n      this.length += item.length;\n      return item;\n    }, this);\n  } else if (typeof value === 'number') {\n    if (!(0 <= value && value <= 0xff))\n      return reporter.error('non-byte EncoderBuffer value');\n    this.value = value;\n    this.length = 1;\n  } else if (typeof value === 'string') {\n    this.value = value;\n    this.length = Buffer.byteLength(value);\n  } else if (Buffer.isBuffer(value)) {\n    this.value = value;\n    this.length = value.length;\n  } else {\n    return reporter.error('Unsupported type: ' + typeof value);\n  }\n}\nexports.EncoderBuffer = EncoderBuffer;\n\nEncoderBuffer.prototype.join = function join(out, offset) {\n  if (!out)\n    out = new Buffer(this.length);\n  if (!offset)\n    offset = 0;\n\n  if (this.length === 0)\n    return out;\n\n  if (Array.isArray(this.value)) {\n    this.value.forEach(function(item) {\n      item.join(out, offset);\n      offset += item.length;\n    });\n  } else {\n    if (typeof this.value === 'number')\n      out[offset] = this.value;\n    else if (typeof this.value === 'string')\n      out.write(this.value, offset);\n    else if (Buffer.isBuffer(this.value))\n      this.value.copy(out, offset);\n    offset += this.length;\n  }\n\n  return out;\n};\n\n},{\"../base\":203,\"buffer\":243,\"inherits\":292}],203:[function(require,module,exports){\nvar base = exports;\n\nbase.Reporter = require('./reporter').Reporter;\nbase.DecoderBuffer = require('./buffer').DecoderBuffer;\nbase.EncoderBuffer = require('./buffer').EncoderBuffer;\nbase.Node = require('./node');\n\n},{\"./buffer\":202,\"./node\":204,\"./reporter\":205}],204:[function(require,module,exports){\nvar Reporter = require('../base').Reporter;\nvar EncoderBuffer = require('../base').EncoderBuffer;\nvar assert = require('minimalistic-assert');\n\n// Supported tags\nvar tags = [\n  'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',\n  'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str', 'utf8str', 'bmpstr',\n  'numstr', 'printstr'\n];\n\n// Public methods list\nvar methods = [\n  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',\n  'any'\n].concat(tags);\n\n// Overrided methods list\nvar overrided = [\n  '_peekTag', '_decodeTag', '_use',\n  '_decodeStr', '_decodeObjid', '_decodeTime',\n  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',\n\n  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',\n  '_encodeNull', '_encodeInt', '_encodeBool'\n];\n\nfunction Node(enc, parent) {\n  var state = {};\n  this._baseState = state;\n\n  state.enc = enc;\n\n  state.parent = parent || null;\n  state.children = null;\n\n  // State\n  state.tag = null;\n  state.args = null;\n  state.reverseArgs = null;\n  state.choice = null;\n  state.optional = false;\n  state.any = false;\n  state.obj = false;\n  state.use = null;\n  state.useDecoder = null;\n  state.key = null;\n  state['default'] = null;\n  state.explicit = null;\n  state.implicit = null;\n\n  // Should create new instance on each method\n  if (!state.parent) {\n    state.children = [];\n    this._wrap();\n  }\n}\nmodule.exports = Node;\n\nvar stateProps = [\n  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',\n  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',\n  'implicit'\n];\n\nNode.prototype.clone = function clone() {\n  var state = this._baseState;\n  var cstate = {};\n  stateProps.forEach(function(prop) {\n    cstate[prop] = state[prop];\n  });\n  var res = new this.constructor(cstate.parent);\n  res._baseState = cstate;\n  return res;\n};\n\nNode.prototype._wrap = function wrap() {\n  var state = this._baseState;\n  methods.forEach(function(method) {\n    this[method] = function _wrappedMethod() {\n      var clone = new this.constructor(this);\n      state.children.push(clone);\n      return clone[method].apply(clone, arguments);\n    };\n  }, this);\n};\n\nNode.prototype._init = function init(body) {\n  var state = this._baseState;\n\n  assert(state.parent === null);\n  body.call(this);\n\n  // Filter children\n  state.children = state.children.filter(function(child) {\n    return child._baseState.parent === this;\n  }, this);\n  assert.equal(state.children.length, 1, 'Root node can have only one child');\n};\n\nNode.prototype._useArgs = function useArgs(args) {\n  var state = this._baseState;\n\n  // Filter children and args\n  var children = args.filter(function(arg) {\n    return arg instanceof this.constructor;\n  }, this);\n  args = args.filter(function(arg) {\n    return !(arg instanceof this.constructor);\n  }, this);\n\n  if (children.length !== 0) {\n    assert(state.children === null);\n    state.children = children;\n\n    // Replace parent to maintain backward link\n    children.forEach(function(child) {\n      child._baseState.parent = this;\n    }, this);\n  }\n  if (args.length !== 0) {\n    assert(state.args === null);\n    state.args = args;\n    state.reverseArgs = args.map(function(arg) {\n      if (typeof arg !== 'object' || arg.constructor !== Object)\n        return arg;\n\n      var res = {};\n      Object.keys(arg).forEach(function(key) {\n        if (key == (key | 0))\n          key |= 0;\n        var value = arg[key];\n        res[value] = key;\n      });\n      return res;\n    });\n  }\n};\n\n//\n// Overrided methods\n//\n\noverrided.forEach(function(method) {\n  Node.prototype[method] = function _overrided() {\n    var state = this._baseState;\n    throw new Error(method + ' not implemented for encoding: ' + state.enc);\n  };\n});\n\n//\n// Public methods\n//\n\ntags.forEach(function(tag) {\n  Node.prototype[tag] = function _tagMethod() {\n    var state = this._baseState;\n    var args = Array.prototype.slice.call(arguments);\n\n    assert(state.tag === null);\n    state.tag = tag;\n\n    this._useArgs(args);\n\n    return this;\n  };\n});\n\nNode.prototype.use = function use(item) {\n  var state = this._baseState;\n\n  assert(state.use === null);\n  state.use = item;\n\n  return this;\n};\n\nNode.prototype.optional = function optional() {\n  var state = this._baseState;\n\n  state.optional = true;\n\n  return this;\n};\n\nNode.prototype.def = function def(val) {\n  var state = this._baseState;\n\n  assert(state['default'] === null);\n  state['default'] = val;\n  state.optional = true;\n\n  return this;\n};\n\nNode.prototype.explicit = function explicit(num) {\n  var state = this._baseState;\n\n  assert(state.explicit === null && state.implicit === null);\n  state.explicit = num;\n\n  return this;\n};\n\nNode.prototype.implicit = function implicit(num) {\n  var state = this._baseState;\n\n  assert(state.explicit === null && state.implicit === null);\n  state.implicit = num;\n\n  return this;\n};\n\nNode.prototype.obj = function obj() {\n  var state = this._baseState;\n  var args = Array.prototype.slice.call(arguments);\n\n  state.obj = true;\n\n  if (args.length !== 0)\n    this._useArgs(args);\n\n  return this;\n};\n\nNode.prototype.key = function key(newKey) {\n  var state = this._baseState;\n\n  assert(state.key === null);\n  state.key = newKey;\n\n  return this;\n};\n\nNode.prototype.any = function any() {\n  var state = this._baseState;\n\n  state.any = true;\n\n  return this;\n};\n\nNode.prototype.choice = function choice(obj) {\n  var state = this._baseState;\n\n  assert(state.choice === null);\n  state.choice = obj;\n  this._useArgs(Object.keys(obj).map(function(key) {\n    return obj[key];\n  }));\n\n  return this;\n};\n\n//\n// Decoding\n//\n\nNode.prototype._decode = function decode(input) {\n  var state = this._baseState;\n\n  // Decode root node\n  if (state.parent === null)\n    return input.wrapResult(state.children[0]._decode(input));\n\n  var result = state['default'];\n  var present = true;\n\n  var prevKey;\n  if (state.key !== null)\n    prevKey = input.enterKey(state.key);\n\n  // Check if tag is there\n  if (state.optional) {\n    var tag = null;\n    if (state.explicit !== null)\n      tag = state.explicit;\n    else if (state.implicit !== null)\n      tag = state.implicit;\n    else if (state.tag !== null)\n      tag = state.tag;\n\n    if (tag === null && !state.any) {\n      // Trial and Error\n      var save = input.save();\n      try {\n        if (state.choice === null)\n          this._decodeGeneric(state.tag, input);\n        else\n          this._decodeChoice(input);\n        present = true;\n      } catch (e) {\n        present = false;\n      }\n      input.restore(save);\n    } else {\n      present = this._peekTag(input, tag, state.any);\n\n      if (input.isError(present))\n        return present;\n    }\n  }\n\n  // Push object on stack\n  var prevObj;\n  if (state.obj && present)\n    prevObj = input.enterObject();\n\n  if (present) {\n    // Unwrap explicit values\n    if (state.explicit !== null) {\n      var explicit = this._decodeTag(input, state.explicit);\n      if (input.isError(explicit))\n        return explicit;\n      input = explicit;\n    }\n\n    // Unwrap implicit and normal values\n    if (state.use === null && state.choice === null) {\n      if (state.any)\n        var save = input.save();\n      var body = this._decodeTag(\n        input,\n        state.implicit !== null ? state.implicit : state.tag,\n        state.any\n      );\n      if (input.isError(body))\n        return body;\n\n      if (state.any)\n        result = input.raw(save);\n      else\n        input = body;\n    }\n\n    // Select proper method for tag\n    if (state.any)\n      result = result;\n    else if (state.choice === null)\n      result = this._decodeGeneric(state.tag, input);\n    else\n      result = this._decodeChoice(input);\n\n    if (input.isError(result))\n      return result;\n\n    // Decode children\n    if (!state.any && state.choice === null && state.children !== null) {\n      var fail = state.children.some(function decodeChildren(child) {\n        // NOTE: We are ignoring errors here, to let parser continue with other\n        // parts of encoded data\n        child._decode(input);\n      });\n      if (fail)\n        return err;\n    }\n  }\n\n  // Pop object\n  if (state.obj && present)\n    result = input.leaveObject(prevObj);\n\n  // Set key\n  if (state.key !== null && (result !== null || present === true))\n    input.leaveKey(prevKey, state.key, result);\n\n  return result;\n};\n\nNode.prototype._decodeGeneric = function decodeGeneric(tag, input) {\n  var state = this._baseState;\n\n  if (tag === 'seq' || tag === 'set')\n    return null;\n  if (tag === 'seqof' || tag === 'setof')\n    return this._decodeList(input, tag, state.args[0]);\n  else if (tag === 'octstr' || tag === 'bitstr')\n    return this._decodeStr(input, tag);\n  else if (tag === 'ia5str' || tag === 'utf8str' || tag === 'bmpstr')\n    return this._decodeStr(input, tag);\n  else if (tag === 'numstr' || tag === 'printstr')\n    return this._decodeStr(input, tag);\n  else if (tag === 'objid' && state.args)\n    return this._decodeObjid(input, state.args[0], state.args[1]);\n  else if (tag === 'objid')\n    return this._decodeObjid(input, null, null);\n  else if (tag === 'gentime' || tag === 'utctime')\n    return this._decodeTime(input, tag);\n  else if (tag === 'null_')\n    return this._decodeNull(input);\n  else if (tag === 'bool')\n    return this._decodeBool(input);\n  else if (tag === 'int' || tag === 'enum')\n    return this._decodeInt(input, state.args && state.args[0]);\n  else if (state.use !== null)\n    return this._getUse(state.use, input._reporterState.obj)._decode(input);\n  else\n    return input.error('unknown tag: ' + tag);\n\n  return null;\n};\n\nNode.prototype._getUse = function _getUse(entity, obj) {\n\n  var state = this._baseState;\n  // Create altered use decoder if implicit is set\n  state.useDecoder = this._use(entity, obj);\n  assert(state.useDecoder._baseState.parent === null);\n  state.useDecoder = state.useDecoder._baseState.children[0];\n  if (state.implicit !== state.useDecoder._baseState.implicit) {\n    state.useDecoder = state.useDecoder.clone();\n    state.useDecoder._baseState.implicit = state.implicit;\n  }\n  return state.useDecoder;\n};\n\nNode.prototype._decodeChoice = function decodeChoice(input) {\n  var state = this._baseState;\n  var result = null;\n  var match = false;\n\n  Object.keys(state.choice).some(function(key) {\n    var save = input.save();\n    var node = state.choice[key];\n    try {\n      var value = node._decode(input);\n      if (input.isError(value))\n        return false;\n\n      result = { type: key, value: value };\n      match = true;\n    } catch (e) {\n      input.restore(save);\n      return false;\n    }\n    return true;\n  }, this);\n\n  if (!match)\n    return input.error('Choice not matched');\n\n  return result;\n};\n\n//\n// Encoding\n//\n\nNode.prototype._createEncoderBuffer = function createEncoderBuffer(data) {\n  return new EncoderBuffer(data, this.reporter);\n};\n\nNode.prototype._encode = function encode(data, reporter, parent) {\n  var state = this._baseState;\n  if (state['default'] !== null && state['default'] === data)\n    return;\n\n  var result = this._encodeValue(data, reporter, parent);\n  if (result === undefined)\n    return;\n\n  if (this._skipDefault(result, reporter, parent))\n    return;\n\n  return result;\n};\n\nNode.prototype._encodeValue = function encode(data, reporter, parent) {\n  var state = this._baseState;\n\n  // Decode root node\n  if (state.parent === null)\n    return state.children[0]._encode(data, reporter || new Reporter());\n\n  var result = null;\n  var present = true;\n\n  // Set reporter to share it with a child class\n  this.reporter = reporter;\n\n  // Check if data is there\n  if (state.optional && data === undefined) {\n    if (state['default'] !== null)\n      data = state['default']\n    else\n      return;\n  }\n\n  // For error reporting\n  var prevKey;\n\n  // Encode children first\n  var content = null;\n  var primitive = false;\n  if (state.any) {\n    // Anything that was given is translated to buffer\n    result = this._createEncoderBuffer(data);\n  } else if (state.choice) {\n    result = this._encodeChoice(data, reporter);\n  } else if (state.children) {\n    content = state.children.map(function(child) {\n      if (child._baseState.tag === 'null_')\n        return child._encode(null, reporter, data);\n\n      if (child._baseState.key === null)\n        return reporter.error('Child should have a key');\n      var prevKey = reporter.enterKey(child._baseState.key);\n\n      if (typeof data !== 'object')\n        return reporter.error('Child expected, but input is not object');\n\n      var res = child._encode(data[child._baseState.key], reporter, data);\n      reporter.leaveKey(prevKey);\n\n      return res;\n    }, this).filter(function(child) {\n      return child;\n    });\n\n    content = this._createEncoderBuffer(content);\n  } else {\n    if (state.tag === 'seqof' || state.tag === 'setof') {\n      // TODO(indutny): this should be thrown on DSL level\n      if (!(state.args && state.args.length === 1))\n        return reporter.error('Too many args for : ' + state.tag);\n\n      if (!Array.isArray(data))\n        return reporter.error('seqof/setof, but data is not Array');\n\n      var child = this.clone();\n      child._baseState.implicit = null;\n      content = this._createEncoderBuffer(data.map(function(item) {\n        var state = this._baseState;\n\n        return this._getUse(state.args[0], data)._encode(item, reporter);\n      }, child));\n    } else if (state.use !== null) {\n      result = this._getUse(state.use, parent)._encode(data, reporter);\n    } else {\n      content = this._encodePrimitive(state.tag, data);\n      primitive = true;\n    }\n  }\n\n  // Encode data itself\n  var result;\n  if (!state.any && state.choice === null) {\n    var tag = state.implicit !== null ? state.implicit : state.tag;\n    var cls = state.implicit === null ? 'universal' : 'context';\n\n    if (tag === null) {\n      if (state.use === null)\n        reporter.error('Tag could be ommited only for .use()');\n    } else {\n      if (state.use === null)\n        result = this._encodeComposite(tag, primitive, cls, content);\n    }\n  }\n\n  // Wrap in explicit\n  if (state.explicit !== null)\n    result = this._encodeComposite(state.explicit, false, 'context', result);\n\n  return result;\n};\n\nNode.prototype._encodeChoice = function encodeChoice(data, reporter) {\n  var state = this._baseState;\n\n  var node = state.choice[data.type];\n  if (!node) {\n    assert(\n        false,\n        data.type + ' not found in ' +\n            JSON.stringify(Object.keys(state.choice)));\n  }\n  return node._encode(data.value, reporter);\n};\n\nNode.prototype._encodePrimitive = function encodePrimitive(tag, data) {\n  var state = this._baseState;\n\n  if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')\n    return this._encodeStr(data, tag);\n  else if (tag === 'utf8str' || tag === 'bmpstr')\n    return this._encodeStr(data, tag);\n  else if (tag === 'numstr' || tag === 'printstr')\n    return this._encodeStr(data, tag);\n  else if (tag === 'objid' && state.args)\n    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);\n  else if (tag === 'objid')\n    return this._encodeObjid(data, null, null);\n  else if (tag === 'gentime' || tag === 'utctime')\n    return this._encodeTime(data, tag);\n  else if (tag === 'null_')\n    return this._encodeNull();\n  else if (tag === 'int' || tag === 'enum')\n    return this._encodeInt(data, state.args && state.reverseArgs[0]);\n  else if (tag === 'bool')\n    return this._encodeBool(data);\n  else\n    throw new Error('Unsupported tag: ' + tag);\n};\n\nNode.prototype._isNumstr = function isNumstr(str) {\n  return /^[0-9 ]*$/.test(str);\n};\n\nNode.prototype._isPrintstr = function isPrintstr(str) {\n  return /^[A-Za-z0-9 '\\(\\)\\+,\\-\\.\\/:=\\?]*$/.test(str);\n};\n},{\"../base\":203,\"minimalistic-assert\":296}],205:[function(require,module,exports){\nvar inherits = require('inherits');\n\nfunction Reporter(options) {\n  this._reporterState = {\n    obj: null,\n    path: [],\n    options: options || {},\n    errors: []\n  };\n}\nexports.Reporter = Reporter;\n\nReporter.prototype.isError = function isError(obj) {\n  return obj instanceof ReporterError;\n};\n\nReporter.prototype.save = function save() {\n  var state = this._reporterState;\n\n  return { obj: state.obj, pathLen: state.path.length };\n};\n\nReporter.prototype.restore = function restore(data) {\n  var state = this._reporterState;\n\n  state.obj = data.obj;\n  state.path = state.path.slice(0, data.pathLen);\n};\n\nReporter.prototype.enterKey = function enterKey(key) {\n  return this._reporterState.path.push(key);\n};\n\nReporter.prototype.leaveKey = function leaveKey(index, key, value) {\n  var state = this._reporterState;\n\n  state.path = state.path.slice(0, index - 1);\n  if (state.obj !== null)\n    state.obj[key] = value;\n};\n\nReporter.prototype.enterObject = function enterObject() {\n  var state = this._reporterState;\n\n  var prev = state.obj;\n  state.obj = {};\n  return prev;\n};\n\nReporter.prototype.leaveObject = function leaveObject(prev) {\n  var state = this._reporterState;\n\n  var now = state.obj;\n  state.obj = prev;\n  return now;\n};\n\nReporter.prototype.error = function error(msg) {\n  var err;\n  var state = this._reporterState;\n\n  var inherited = msg instanceof ReporterError;\n  if (inherited) {\n    err = msg;\n  } else {\n    err = new ReporterError(state.path.map(function(elem) {\n      return '[' + JSON.stringify(elem) + ']';\n    }).join(''), msg.message || msg, msg.stack);\n  }\n\n  if (!state.options.partial)\n    throw err;\n\n  if (!inherited)\n    state.errors.push(err);\n\n  return err;\n};\n\nReporter.prototype.wrapResult = function wrapResult(result) {\n  var state = this._reporterState;\n  if (!state.options.partial)\n    return result;\n\n  return {\n    result: this.isError(result) ? null : result,\n    errors: state.errors\n  };\n};\n\nfunction ReporterError(path, msg) {\n  this.path = path;\n  this.rethrow(msg);\n};\ninherits(ReporterError, Error);\n\nReporterError.prototype.rethrow = function rethrow(msg) {\n  this.message = msg + ' at: ' + (this.path || '(shallow)');\n  Error.captureStackTrace(this, ReporterError);\n\n  return this;\n};\n\n},{\"inherits\":292}],206:[function(require,module,exports){\nvar constants = require('../constants');\n\nexports.tagClass = {\n  0: 'universal',\n  1: 'application',\n  2: 'context',\n  3: 'private'\n};\nexports.tagClassByName = constants._reverse(exports.tagClass);\n\nexports.tag = {\n  0x00: 'end',\n  0x01: 'bool',\n  0x02: 'int',\n  0x03: 'bitstr',\n  0x04: 'octstr',\n  0x05: 'null_',\n  0x06: 'objid',\n  0x07: 'objDesc',\n  0x08: 'external',\n  0x09: 'real',\n  0x0a: 'enum',\n  0x0b: 'embed',\n  0x0c: 'utf8str',\n  0x0d: 'relativeOid',\n  0x10: 'seq',\n  0x11: 'set',\n  0x12: 'numstr',\n  0x13: 'printstr',\n  0x14: 't61str',\n  0x15: 'videostr',\n  0x16: 'ia5str',\n  0x17: 'utctime',\n  0x18: 'gentime',\n  0x19: 'graphstr',\n  0x1a: 'iso646str',\n  0x1b: 'genstr',\n  0x1c: 'unistr',\n  0x1d: 'charstr',\n  0x1e: 'bmpstr'\n};\nexports.tagByName = constants._reverse(exports.tag);\n\n},{\"../constants\":207}],207:[function(require,module,exports){\nvar constants = exports;\n\n// Helper\nconstants._reverse = function reverse(map) {\n  var res = {};\n\n  Object.keys(map).forEach(function(key) {\n    // Convert key to integer if it is stringified\n    if ((key | 0) == key)\n      key = key | 0;\n\n    var value = map[key];\n    res[value] = key;\n  });\n\n  return res;\n};\n\nconstants.der = require('./der');\n\n},{\"./der\":206}],208:[function(require,module,exports){\nvar inherits = require('inherits');\n\nvar asn1 = require('../../asn1');\nvar base = asn1.base;\nvar bignum = asn1.bignum;\n\n// Import DER constants\nvar der = asn1.constants.der;\n\nfunction DERDecoder(entity) {\n  this.enc = 'der';\n  this.name = entity.name;\n  this.entity = entity;\n\n  // Construct base tree\n  this.tree = new DERNode();\n  this.tree._init(entity.body);\n};\nmodule.exports = DERDecoder;\n\nDERDecoder.prototype.decode = function decode(data, options) {\n  if (!(data instanceof base.DecoderBuffer))\n    data = new base.DecoderBuffer(data, options);\n\n  return this.tree._decode(data, options);\n};\n\n// Tree methods\n\nfunction DERNode(parent) {\n  base.Node.call(this, 'der', parent);\n}\ninherits(DERNode, base.Node);\n\nDERNode.prototype._peekTag = function peekTag(buffer, tag, any) {\n  if (buffer.isEmpty())\n    return false;\n\n  var state = buffer.save();\n  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: \"' + tag + '\"');\n  if (buffer.isError(decodedTag))\n    return decodedTag;\n\n  buffer.restore(state);\n\n  return decodedTag.tag === tag || decodedTag.tagStr === tag || any;\n};\n\nDERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {\n  var decodedTag = derDecodeTag(buffer,\n                                'Failed to decode tag of \"' + tag + '\"');\n  if (buffer.isError(decodedTag))\n    return decodedTag;\n\n  var len = derDecodeLen(buffer,\n                         decodedTag.primitive,\n                         'Failed to get length of \"' + tag + '\"');\n\n  // Failure\n  if (buffer.isError(len))\n    return len;\n\n  if (!any &&\n      decodedTag.tag !== tag &&\n      decodedTag.tagStr !== tag &&\n      decodedTag.tagStr + 'of' !== tag) {\n    return buffer.error('Failed to match tag: \"' + tag + '\"');\n  }\n\n  if (decodedTag.primitive || len !== null)\n    return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n\n  // Indefinite length... find END tag\n  var state = buffer.save();\n  var res = this._skipUntilEnd(\n      buffer,\n      'Failed to skip indefinite length body: \"' + this.tag + '\"');\n  if (buffer.isError(res))\n    return res;\n\n  len = buffer.offset - state.offset;\n  buffer.restore(state);\n  return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n};\n\nDERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {\n  while (true) {\n    var tag = derDecodeTag(buffer, fail);\n    if (buffer.isError(tag))\n      return tag;\n    var len = derDecodeLen(buffer, tag.primitive, fail);\n    if (buffer.isError(len))\n      return len;\n\n    var res;\n    if (tag.primitive || len !== null)\n      res = buffer.skip(len)\n    else\n      res = this._skipUntilEnd(buffer, fail);\n\n    // Failure\n    if (buffer.isError(res))\n      return res;\n\n    if (tag.tagStr === 'end')\n      break;\n  }\n};\n\nDERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {\n  var result = [];\n  while (!buffer.isEmpty()) {\n    var possibleEnd = this._peekTag(buffer, 'end');\n    if (buffer.isError(possibleEnd))\n      return possibleEnd;\n\n    var res = decoder.decode(buffer, 'der');\n    if (buffer.isError(res) && possibleEnd)\n      break;\n    result.push(res);\n  }\n  return result;\n};\n\nDERNode.prototype._decodeStr = function decodeStr(buffer, tag) {\n  if (tag === 'octstr') {\n    return buffer.raw();\n  } else if (tag === 'bitstr') {\n    var unused = buffer.readUInt8();\n    if (buffer.isError(unused))\n      return unused;\n\n    return { unused: unused, data: buffer.raw() };\n  } else if (tag === 'ia5str' || tag === 'utf8str') {\n    return buffer.raw().toString();\n  } else if(tag === 'numstr') {\n    var numstr = buffer.raw().toString('ascii');\n    if (!this._isNumstr(numstr)) {\n      return buffer.error('Decoding of string type: ' +\n                          'numstr unsupported characters');\n    }\n\n    return numstr;\n  } else if (tag === 'printstr') {\n    var printstr = buffer.raw().toString('ascii');\n    if (!this._isPrintstr(printstr)) {\n      return buffer.error('Decoding of string type: ' +\n                          'printstr unsupported characters');\n    }\n\n    return printstr;\n  } else if(tag === 'bmpstr') {\n    var raw = buffer.raw();\n    if (raw.length % 2 === 1)\n      return buffer.error('Decoding of string type: bmpstr length mismatch');\n\n    var str = '';\n    for (var i = 0; i < raw.length / 2; i++) {\n      str += String.fromCharCode(raw.readUInt16BE(i * 2));\n    }\n    return str;\n  } else {\n    return buffer.error('Decoding of string type: ' + tag + ' unsupported');\n  }\n};\n\nDERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {\n  var identifiers = [];\n  var ident = 0;\n  while (!buffer.isEmpty()) {\n    var subident = buffer.readUInt8();\n    ident <<= 7;\n    ident |= subident & 0x7f;\n    if ((subident & 0x80) === 0) {\n      identifiers.push(ident);\n      ident = 0;\n    }\n  }\n  if (subident & 0x80)\n    identifiers.push(ident);\n\n  var first = (identifiers[0] / 40) | 0;\n  var second = identifiers[0] % 40;\n\n  if (relative)\n    result = identifiers;\n  else\n    result = [first, second].concat(identifiers.slice(1));\n\n  if (values) {\n    var tmp = values[result.join(' ')];\n    if (tmp === undefined)\n      tmp = values[result.join('.')];\n    if (tmp !== undefined)\n      result = tmp;\n  }\n\n  return result;\n};\n\nDERNode.prototype._decodeTime = function decodeTime(buffer, tag) {\n  var str = buffer.raw().toString();\n  if (tag === 'gentime') {\n    var year = str.slice(0, 4) | 0;\n    var mon = str.slice(4, 6) | 0;\n    var day = str.slice(6, 8) | 0;\n    var hour = str.slice(8, 10) | 0;\n    var min = str.slice(10, 12) | 0;\n    var sec = str.slice(12, 14) | 0;\n  } else if (tag === 'utctime') {\n    var year = str.slice(0, 2) | 0;\n    var mon = str.slice(2, 4) | 0;\n    var day = str.slice(4, 6) | 0;\n    var hour = str.slice(6, 8) | 0;\n    var min = str.slice(8, 10) | 0;\n    var sec = str.slice(10, 12) | 0;\n    if (year < 70)\n      year = 2000 + year;\n    else\n      year = 1900 + year;\n  } else {\n    return buffer.error('Decoding ' + tag + ' time is not supported yet');\n  }\n\n  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);\n};\n\nDERNode.prototype._decodeNull = function decodeNull(buffer) {\n  return null;\n};\n\nDERNode.prototype._decodeBool = function decodeBool(buffer) {\n  var res = buffer.readUInt8();\n  if (buffer.isError(res))\n    return res;\n  else\n    return res !== 0;\n};\n\nDERNode.prototype._decodeInt = function decodeInt(buffer, values) {\n  // Bigint, return as it is (assume big endian)\n  var raw = buffer.raw();\n  var res = new bignum(raw);\n\n  if (values)\n    res = values[res.toString(10)] || res;\n\n  return res;\n};\n\nDERNode.prototype._use = function use(entity, obj) {\n  if (typeof entity === 'function')\n    entity = entity(obj);\n  return entity._getDecoder('der').tree;\n};\n\n// Utility methods\n\nfunction derDecodeTag(buf, fail) {\n  var tag = buf.readUInt8(fail);\n  if (buf.isError(tag))\n    return tag;\n\n  var cls = der.tagClass[tag >> 6];\n  var primitive = (tag & 0x20) === 0;\n\n  // Multi-octet tag - load\n  if ((tag & 0x1f) === 0x1f) {\n    var oct = tag;\n    tag = 0;\n    while ((oct & 0x80) === 0x80) {\n      oct = buf.readUInt8(fail);\n      if (buf.isError(oct))\n        return oct;\n\n      tag <<= 7;\n      tag |= oct & 0x7f;\n    }\n  } else {\n    tag &= 0x1f;\n  }\n  var tagStr = der.tag[tag];\n\n  return {\n    cls: cls,\n    primitive: primitive,\n    tag: tag,\n    tagStr: tagStr\n  };\n}\n\nfunction derDecodeLen(buf, primitive, fail) {\n  var len = buf.readUInt8(fail);\n  if (buf.isError(len))\n    return len;\n\n  // Indefinite form\n  if (!primitive && len === 0x80)\n    return null;\n\n  // Definite form\n  if ((len & 0x80) === 0) {\n    // Short form\n    return len;\n  }\n\n  // Long form\n  var num = len & 0x7f;\n  if (num >= 4)\n    return buf.error('length octect is too long');\n\n  len = 0;\n  for (var i = 0; i < num; i++) {\n    len <<= 8;\n    var j = buf.readUInt8(fail);\n    if (buf.isError(j))\n      return j;\n    len |= j;\n  }\n\n  return len;\n}\n\n},{\"../../asn1\":200,\"inherits\":292}],209:[function(require,module,exports){\nvar decoders = exports;\n\ndecoders.der = require('./der');\ndecoders.pem = require('./pem');\n\n},{\"./der\":208,\"./pem\":210}],210:[function(require,module,exports){\nvar inherits = require('inherits');\nvar Buffer = require('buffer').Buffer;\n\nvar asn1 = require('../../asn1');\nvar DERDecoder = require('./der');\n\nfunction PEMDecoder(entity) {\n  DERDecoder.call(this, entity);\n  this.enc = 'pem';\n};\ninherits(PEMDecoder, DERDecoder);\nmodule.exports = PEMDecoder;\n\nPEMDecoder.prototype.decode = function decode(data, options) {\n  var lines = data.toString().split(/[\\r\\n]+/g);\n\n  var label = options.label.toUpperCase();\n\n  var re = /^-----(BEGIN|END) ([^-]+)-----$/;\n  var start = -1;\n  var end = -1;\n  for (var i = 0; i < lines.length; i++) {\n    var match = lines[i].match(re);\n    if (match === null)\n      continue;\n\n    if (match[2] !== label)\n      continue;\n\n    if (start === -1) {\n      if (match[1] !== 'BEGIN')\n        break;\n      start = i;\n    } else {\n      if (match[1] !== 'END')\n        break;\n      end = i;\n      break;\n    }\n  }\n  if (start === -1 || end === -1)\n    throw new Error('PEM section not found for: ' + label);\n\n  var base64 = lines.slice(start + 1, end).join('');\n  // Remove excessive symbols\n  base64.replace(/[^a-z0-9\\+\\/=]+/gi, '');\n\n  var input = new Buffer(base64, 'base64');\n  return DERDecoder.prototype.decode.call(this, input, options);\n};\n\n},{\"../../asn1\":200,\"./der\":208,\"buffer\":243,\"inherits\":292}],211:[function(require,module,exports){\nvar inherits = require('inherits');\nvar Buffer = require('buffer').Buffer;\n\nvar asn1 = require('../../asn1');\nvar base = asn1.base;\nvar bignum = asn1.bignum;\n\n// Import DER constants\nvar der = asn1.constants.der;\n\nfunction DEREncoder(entity) {\n  this.enc = 'der';\n  this.name = entity.name;\n  this.entity = entity;\n\n  // Construct base tree\n  this.tree = new DERNode();\n  this.tree._init(entity.body);\n};\nmodule.exports = DEREncoder;\n\nDEREncoder.prototype.encode = function encode(data, reporter) {\n  return this.tree._encode(data, reporter).join();\n};\n\n// Tree methods\n\nfunction DERNode(parent) {\n  base.Node.call(this, 'der', parent);\n}\ninherits(DERNode, base.Node);\n\nDERNode.prototype._encodeComposite = function encodeComposite(tag,\n                                                              primitive,\n                                                              cls,\n                                                              content) {\n  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);\n\n  // Short form\n  if (content.length < 0x80) {\n    var header = new Buffer(2);\n    header[0] = encodedTag;\n    header[1] = content.length;\n    return this._createEncoderBuffer([ header, content ]);\n  }\n\n  // Long form\n  // Count octets required to store length\n  var lenOctets = 1;\n  for (var i = content.length; i >= 0x100; i >>= 8)\n    lenOctets++;\n\n  var header = new Buffer(1 + 1 + lenOctets);\n  header[0] = encodedTag;\n  header[1] = 0x80 | lenOctets;\n\n  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)\n    header[i] = j & 0xff;\n\n  return this._createEncoderBuffer([ header, content ]);\n};\n\nDERNode.prototype._encodeStr = function encodeStr(str, tag) {\n  if (tag === 'octstr') {\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'bitstr') {\n    return this._createEncoderBuffer([ str.unused | 0, str.data ]);\n  } else if (tag === 'ia5str' || tag === 'utf8str') {\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'bmpstr') {\n    var buf = new Buffer(str.length * 2);\n    for (var i = 0; i < str.length; i++) {\n      buf.writeUInt16BE(str.charCodeAt(i), i * 2);\n    }\n    return this._createEncoderBuffer(buf);\n  } else if (tag === 'numstr') {\n    if (!this._isNumstr(str)) {\n      return this.reporter.error('Encoding of string type: numstr supports ' +\n                                 'only digits and space');\n    }\n\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'printstr') {\n    if (!this._isPrintstr(str)) {\n      return this.reporter.error('Encoding of string type: printstr supports ' +\n                                 'only latin upper and lower case letters, ' +\n                                 'digits, space, apostrophe, left and rigth ' +\n                                 'parenthesis, plus sign, comma, hyphen, ' +\n                                 'dot, slash, colon, equal sign, ' +\n                                 'question mark');\n    }\n\n    return this._createEncoderBuffer(str);\n  } else {\n    return this.reporter.error('Encoding of string type: ' + tag +\n                               ' unsupported');\n  }\n};\n\nDERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {\n  if (typeof id === 'string') {\n    if (!values)\n      return this.reporter.error('string objid given, but no values map found');\n    if (!values.hasOwnProperty(id))\n      return this.reporter.error('objid not found in values map');\n    id = values[id].split(/[\\s\\.]+/g);\n    for (var i = 0; i < id.length; i++)\n      id[i] |= 0;\n  } else if (Array.isArray(id)) {\n    id = id.slice();\n    for (var i = 0; i < id.length; i++)\n      id[i] |= 0;\n  }\n\n  if (!Array.isArray(id)) {\n    return this.reporter.error('objid() should be either array or string, ' +\n                               'got: ' + JSON.stringify(id));\n  }\n\n  if (!relative) {\n    if (id[1] >= 40)\n      return this.reporter.error('Second objid identifier OOB');\n    id.splice(0, 2, id[0] * 40 + id[1]);\n  }\n\n  // Count number of octets\n  var size = 0;\n  for (var i = 0; i < id.length; i++) {\n    var ident = id[i];\n    for (size++; ident >= 0x80; ident >>= 7)\n      size++;\n  }\n\n  var objid = new Buffer(size);\n  var offset = objid.length - 1;\n  for (var i = id.length - 1; i >= 0; i--) {\n    var ident = id[i];\n    objid[offset--] = ident & 0x7f;\n    while ((ident >>= 7) > 0)\n      objid[offset--] = 0x80 | (ident & 0x7f);\n  }\n\n  return this._createEncoderBuffer(objid);\n};\n\nfunction two(num) {\n  if (num < 10)\n    return '0' + num;\n  else\n    return num;\n}\n\nDERNode.prototype._encodeTime = function encodeTime(time, tag) {\n  var str;\n  var date = new Date(time);\n\n  if (tag === 'gentime') {\n    str = [\n      two(date.getFullYear()),\n      two(date.getUTCMonth() + 1),\n      two(date.getUTCDate()),\n      two(date.getUTCHours()),\n      two(date.getUTCMinutes()),\n      two(date.getUTCSeconds()),\n      'Z'\n    ].join('');\n  } else if (tag === 'utctime') {\n    str = [\n      two(date.getFullYear() % 100),\n      two(date.getUTCMonth() + 1),\n      two(date.getUTCDate()),\n      two(date.getUTCHours()),\n      two(date.getUTCMinutes()),\n      two(date.getUTCSeconds()),\n      'Z'\n    ].join('');\n  } else {\n    this.reporter.error('Encoding ' + tag + ' time is not supported yet');\n  }\n\n  return this._encodeStr(str, 'octstr');\n};\n\nDERNode.prototype._encodeNull = function encodeNull() {\n  return this._createEncoderBuffer('');\n};\n\nDERNode.prototype._encodeInt = function encodeInt(num, values) {\n  if (typeof num === 'string') {\n    if (!values)\n      return this.reporter.error('String int or enum given, but no values map');\n    if (!values.hasOwnProperty(num)) {\n      return this.reporter.error('Values map doesn\\'t contain: ' +\n                                 JSON.stringify(num));\n    }\n    num = values[num];\n  }\n\n  // Bignum, assume big endian\n  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {\n    var numArray = num.toArray();\n    if (!num.sign && numArray[0] & 0x80) {\n      numArray.unshift(0);\n    }\n    num = new Buffer(numArray);\n  }\n\n  if (Buffer.isBuffer(num)) {\n    var size = num.length;\n    if (num.length === 0)\n      size++;\n\n    var out = new Buffer(size);\n    num.copy(out);\n    if (num.length === 0)\n      out[0] = 0\n    return this._createEncoderBuffer(out);\n  }\n\n  if (num < 0x80)\n    return this._createEncoderBuffer(num);\n\n  if (num < 0x100)\n    return this._createEncoderBuffer([0, num]);\n\n  var size = 1;\n  for (var i = num; i >= 0x100; i >>= 8)\n    size++;\n\n  var out = new Array(size);\n  for (var i = out.length - 1; i >= 0; i--) {\n    out[i] = num & 0xff;\n    num >>= 8;\n  }\n  if(out[0] & 0x80) {\n    out.unshift(0);\n  }\n\n  return this._createEncoderBuffer(new Buffer(out));\n};\n\nDERNode.prototype._encodeBool = function encodeBool(value) {\n  return this._createEncoderBuffer(value ? 0xff : 0);\n};\n\nDERNode.prototype._use = function use(entity, obj) {\n  if (typeof entity === 'function')\n    entity = entity(obj);\n  return entity._getEncoder('der').tree;\n};\n\nDERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {\n  var state = this._baseState;\n  var i;\n  if (state['default'] === null)\n    return false;\n\n  var data = dataBuffer.join();\n  if (state.defaultBuffer === undefined)\n    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();\n\n  if (data.length !== state.defaultBuffer.length)\n    return false;\n\n  for (i=0; i < data.length; i++)\n    if (data[i] !== state.defaultBuffer[i])\n      return false;\n\n  return true;\n};\n\n// Utility methods\n\nfunction encodeTag(tag, primitive, cls, reporter) {\n  var res;\n\n  if (tag === 'seqof')\n    tag = 'seq';\n  else if (tag === 'setof')\n    tag = 'set';\n\n  if (der.tagByName.hasOwnProperty(tag))\n    res = der.tagByName[tag];\n  else if (typeof tag === 'number' && (tag | 0) === tag)\n    res = tag;\n  else\n    return reporter.error('Unknown tag: ' + tag);\n\n  if (res >= 0x1f)\n    return reporter.error('Multi-octet tag encoding unsupported');\n\n  if (!primitive)\n    res |= 0x20;\n\n  res |= (der.tagClassByName[cls || 'universal'] << 6);\n\n  return res;\n}\n\n},{\"../../asn1\":200,\"buffer\":243,\"inherits\":292}],212:[function(require,module,exports){\nvar encoders = exports;\n\nencoders.der = require('./der');\nencoders.pem = require('./pem');\n\n},{\"./der\":211,\"./pem\":213}],213:[function(require,module,exports){\nvar inherits = require('inherits');\nvar Buffer = require('buffer').Buffer;\n\nvar asn1 = require('../../asn1');\nvar DEREncoder = require('./der');\n\nfunction PEMEncoder(entity) {\n  DEREncoder.call(this, entity);\n  this.enc = 'pem';\n};\ninherits(PEMEncoder, DEREncoder);\nmodule.exports = PEMEncoder;\n\nPEMEncoder.prototype.encode = function encode(data, options) {\n  var buf = DEREncoder.prototype.encode.call(this, data);\n\n  var p = buf.toString('base64');\n  var out = [ '-----BEGIN ' + options.label + '-----' ];\n  for (var i = 0; i < p.length; i += 64)\n    out.push(p.slice(i, i + 64));\n  out.push('-----END ' + options.label + '-----');\n  return out.join('\\n');\n};\n\n},{\"../../asn1\":200,\"./der\":211,\"buffer\":243,\"inherits\":292}],214:[function(require,module,exports){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n},{}],215:[function(require,module,exports){\n(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    // May be `new BN(bn)` ?\n    if (number !== null &&\n      typeof number === 'object' &&\n      Array.isArray(number.words)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this.strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [ number & 0x3ffffff ];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [ 0 ];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this.strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        r |= c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        r |= c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r |= c & 0xf;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this.strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        r += c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        r += c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r += c;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [ 0 ];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype.strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    assert(this.bitLength() <= 53, 'Number can only safely store up to 53 bits');\n    return parseInt(this.toString(), 10);\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16);\n  };\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this.strip();\n    var littleEndian = endian === 'le';\n    var res = new Array(reqLength);\n\n    var b, i;\n    var q = this.clone();\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    if (this.isZero()) return this.clone();\n\n    var r = this.clone();\n    r.negative = this.negative ^ 1;\n    return r;\n  };\n\n  BN.prototype.ineg = function ineg () {\n    this.negative ^= 1;\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    while (this.length < bytesNeeded) {\n      this.words[this.length++] = 0;\n    }\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this.strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    while (this.length <= off) {\n      this.words[this.length++] = 0;\n    }\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this.strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this.strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid += Math.imul(ah0, bl0);\n    hi = Math.imul(ah0, bh0);\n    var w0 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w0 >>> 26);\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid += Math.imul(ah1, bl0);\n    hi = Math.imul(ah1, bh0);\n    lo += Math.imul(al0, bl1);\n    mid += Math.imul(al0, bh1);\n    mid += Math.imul(ah0, bl1);\n    hi += Math.imul(ah0, bh1);\n    var w1 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w1 >>> 26);\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid += Math.imul(ah2, bl0);\n    hi = Math.imul(ah2, bh0);\n    lo += Math.imul(al1, bl1);\n    mid += Math.imul(al1, bh1);\n    mid += Math.imul(ah1, bl1);\n    hi += Math.imul(ah1, bh1);\n    lo += Math.imul(al0, bl2);\n    mid += Math.imul(al0, bh2);\n    mid += Math.imul(ah0, bl2);\n    hi += Math.imul(ah0, bh2);\n    var w2 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w2 >>> 26);\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid += Math.imul(ah3, bl0);\n    hi = Math.imul(ah3, bh0);\n    lo += Math.imul(al2, bl1);\n    mid += Math.imul(al2, bh1);\n    mid += Math.imul(ah2, bl1);\n    hi += Math.imul(ah2, bh1);\n    lo += Math.imul(al1, bl2);\n    mid += Math.imul(al1, bh2);\n    mid += Math.imul(ah1, bl2);\n    hi += Math.imul(ah1, bh2);\n    lo += Math.imul(al0, bl3);\n    mid += Math.imul(al0, bh3);\n    mid += Math.imul(ah0, bl3);\n    hi += Math.imul(ah0, bh3);\n    var w3 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w3 >>> 26);\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid += Math.imul(ah4, bl0);\n    hi = Math.imul(ah4, bh0);\n    lo += Math.imul(al3, bl1);\n    mid += Math.imul(al3, bh1);\n    mid += Math.imul(ah3, bl1);\n    hi += Math.imul(ah3, bh1);\n    lo += Math.imul(al2, bl2);\n    mid += Math.imul(al2, bh2);\n    mid += Math.imul(ah2, bl2);\n    hi += Math.imul(ah2, bh2);\n    lo += Math.imul(al1, bl3);\n    mid += Math.imul(al1, bh3);\n    mid += Math.imul(ah1, bl3);\n    hi += Math.imul(ah1, bh3);\n    lo += Math.imul(al0, bl4);\n    mid += Math.imul(al0, bh4);\n    mid += Math.imul(ah0, bl4);\n    hi += Math.imul(ah0, bh4);\n    var w4 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w4 >>> 26);\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid += Math.imul(ah5, bl0);\n    hi = Math.imul(ah5, bh0);\n    lo += Math.imul(al4, bl1);\n    mid += Math.imul(al4, bh1);\n    mid += Math.imul(ah4, bl1);\n    hi += Math.imul(ah4, bh1);\n    lo += Math.imul(al3, bl2);\n    mid += Math.imul(al3, bh2);\n    mid += Math.imul(ah3, bl2);\n    hi += Math.imul(ah3, bh2);\n    lo += Math.imul(al2, bl3);\n    mid += Math.imul(al2, bh3);\n    mid += Math.imul(ah2, bl3);\n    hi += Math.imul(ah2, bh3);\n    lo += Math.imul(al1, bl4);\n    mid += Math.imul(al1, bh4);\n    mid += Math.imul(ah1, bl4);\n    hi += Math.imul(ah1, bh4);\n    lo += Math.imul(al0, bl5);\n    mid += Math.imul(al0, bh5);\n    mid += Math.imul(ah0, bl5);\n    hi += Math.imul(ah0, bh5);\n    var w5 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w5 >>> 26);\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid += Math.imul(ah6, bl0);\n    hi = Math.imul(ah6, bh0);\n    lo += Math.imul(al5, bl1);\n    mid += Math.imul(al5, bh1);\n    mid += Math.imul(ah5, bl1);\n    hi += Math.imul(ah5, bh1);\n    lo += Math.imul(al4, bl2);\n    mid += Math.imul(al4, bh2);\n    mid += Math.imul(ah4, bl2);\n    hi += Math.imul(ah4, bh2);\n    lo += Math.imul(al3, bl3);\n    mid += Math.imul(al3, bh3);\n    mid += Math.imul(ah3, bl3);\n    hi += Math.imul(ah3, bh3);\n    lo += Math.imul(al2, bl4);\n    mid += Math.imul(al2, bh4);\n    mid += Math.imul(ah2, bl4);\n    hi += Math.imul(ah2, bh4);\n    lo += Math.imul(al1, bl5);\n    mid += Math.imul(al1, bh5);\n    mid += Math.imul(ah1, bl5);\n    hi += Math.imul(ah1, bh5);\n    lo += Math.imul(al0, bl6);\n    mid += Math.imul(al0, bh6);\n    mid += Math.imul(ah0, bl6);\n    hi += Math.imul(ah0, bh6);\n    var w6 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w6 >>> 26);\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid += Math.imul(ah7, bl0);\n    hi = Math.imul(ah7, bh0);\n    lo += Math.imul(al6, bl1);\n    mid += Math.imul(al6, bh1);\n    mid += Math.imul(ah6, bl1);\n    hi += Math.imul(ah6, bh1);\n    lo += Math.imul(al5, bl2);\n    mid += Math.imul(al5, bh2);\n    mid += Math.imul(ah5, bl2);\n    hi += Math.imul(ah5, bh2);\n    lo += Math.imul(al4, bl3);\n    mid += Math.imul(al4, bh3);\n    mid += Math.imul(ah4, bl3);\n    hi += Math.imul(ah4, bh3);\n    lo += Math.imul(al3, bl4);\n    mid += Math.imul(al3, bh4);\n    mid += Math.imul(ah3, bl4);\n    hi += Math.imul(ah3, bh4);\n    lo += Math.imul(al2, bl5);\n    mid += Math.imul(al2, bh5);\n    mid += Math.imul(ah2, bl5);\n    hi += Math.imul(ah2, bh5);\n    lo += Math.imul(al1, bl6);\n    mid += Math.imul(al1, bh6);\n    mid += Math.imul(ah1, bl6);\n    hi += Math.imul(ah1, bh6);\n    lo += Math.imul(al0, bl7);\n    mid += Math.imul(al0, bh7);\n    mid += Math.imul(ah0, bl7);\n    hi += Math.imul(ah0, bh7);\n    var w7 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w7 >>> 26);\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid += Math.imul(ah8, bl0);\n    hi = Math.imul(ah8, bh0);\n    lo += Math.imul(al7, bl1);\n    mid += Math.imul(al7, bh1);\n    mid += Math.imul(ah7, bl1);\n    hi += Math.imul(ah7, bh1);\n    lo += Math.imul(al6, bl2);\n    mid += Math.imul(al6, bh2);\n    mid += Math.imul(ah6, bl2);\n    hi += Math.imul(ah6, bh2);\n    lo += Math.imul(al5, bl3);\n    mid += Math.imul(al5, bh3);\n    mid += Math.imul(ah5, bl3);\n    hi += Math.imul(ah5, bh3);\n    lo += Math.imul(al4, bl4);\n    mid += Math.imul(al4, bh4);\n    mid += Math.imul(ah4, bl4);\n    hi += Math.imul(ah4, bh4);\n    lo += Math.imul(al3, bl5);\n    mid += Math.imul(al3, bh5);\n    mid += Math.imul(ah3, bl5);\n    hi += Math.imul(ah3, bh5);\n    lo += Math.imul(al2, bl6);\n    mid += Math.imul(al2, bh6);\n    mid += Math.imul(ah2, bl6);\n    hi += Math.imul(ah2, bh6);\n    lo += Math.imul(al1, bl7);\n    mid += Math.imul(al1, bh7);\n    mid += Math.imul(ah1, bl7);\n    hi += Math.imul(ah1, bh7);\n    lo += Math.imul(al0, bl8);\n    mid += Math.imul(al0, bh8);\n    mid += Math.imul(ah0, bl8);\n    hi += Math.imul(ah0, bh8);\n    var w8 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w8 >>> 26);\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid += Math.imul(ah9, bl0);\n    hi = Math.imul(ah9, bh0);\n    lo += Math.imul(al8, bl1);\n    mid += Math.imul(al8, bh1);\n    mid += Math.imul(ah8, bl1);\n    hi += Math.imul(ah8, bh1);\n    lo += Math.imul(al7, bl2);\n    mid += Math.imul(al7, bh2);\n    mid += Math.imul(ah7, bl2);\n    hi += Math.imul(ah7, bh2);\n    lo += Math.imul(al6, bl3);\n    mid += Math.imul(al6, bh3);\n    mid += Math.imul(ah6, bl3);\n    hi += Math.imul(ah6, bh3);\n    lo += Math.imul(al5, bl4);\n    mid += Math.imul(al5, bh4);\n    mid += Math.imul(ah5, bl4);\n    hi += Math.imul(ah5, bh4);\n    lo += Math.imul(al4, bl5);\n    mid += Math.imul(al4, bh5);\n    mid += Math.imul(ah4, bl5);\n    hi += Math.imul(ah4, bh5);\n    lo += Math.imul(al3, bl6);\n    mid += Math.imul(al3, bh6);\n    mid += Math.imul(ah3, bl6);\n    hi += Math.imul(ah3, bh6);\n    lo += Math.imul(al2, bl7);\n    mid += Math.imul(al2, bh7);\n    mid += Math.imul(ah2, bl7);\n    hi += Math.imul(ah2, bh7);\n    lo += Math.imul(al1, bl8);\n    mid += Math.imul(al1, bh8);\n    mid += Math.imul(ah1, bl8);\n    hi += Math.imul(ah1, bh8);\n    lo += Math.imul(al0, bl9);\n    mid += Math.imul(al0, bh9);\n    mid += Math.imul(ah0, bl9);\n    hi += Math.imul(ah0, bh9);\n    var w9 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w9 >>> 26);\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid += Math.imul(ah9, bl1);\n    hi = Math.imul(ah9, bh1);\n    lo += Math.imul(al8, bl2);\n    mid += Math.imul(al8, bh2);\n    mid += Math.imul(ah8, bl2);\n    hi += Math.imul(ah8, bh2);\n    lo += Math.imul(al7, bl3);\n    mid += Math.imul(al7, bh3);\n    mid += Math.imul(ah7, bl3);\n    hi += Math.imul(ah7, bh3);\n    lo += Math.imul(al6, bl4);\n    mid += Math.imul(al6, bh4);\n    mid += Math.imul(ah6, bl4);\n    hi += Math.imul(ah6, bh4);\n    lo += Math.imul(al5, bl5);\n    mid += Math.imul(al5, bh5);\n    mid += Math.imul(ah5, bl5);\n    hi += Math.imul(ah5, bh5);\n    lo += Math.imul(al4, bl6);\n    mid += Math.imul(al4, bh6);\n    mid += Math.imul(ah4, bl6);\n    hi += Math.imul(ah4, bh6);\n    lo += Math.imul(al3, bl7);\n    mid += Math.imul(al3, bh7);\n    mid += Math.imul(ah3, bl7);\n    hi += Math.imul(ah3, bh7);\n    lo += Math.imul(al2, bl8);\n    mid += Math.imul(al2, bh8);\n    mid += Math.imul(ah2, bl8);\n    hi += Math.imul(ah2, bh8);\n    lo += Math.imul(al1, bl9);\n    mid += Math.imul(al1, bh9);\n    mid += Math.imul(ah1, bl9);\n    hi += Math.imul(ah1, bh9);\n    var w10 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w10 >>> 26);\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid += Math.imul(ah9, bl2);\n    hi = Math.imul(ah9, bh2);\n    lo += Math.imul(al8, bl3);\n    mid += Math.imul(al8, bh3);\n    mid += Math.imul(ah8, bl3);\n    hi += Math.imul(ah8, bh3);\n    lo += Math.imul(al7, bl4);\n    mid += Math.imul(al7, bh4);\n    mid += Math.imul(ah7, bl4);\n    hi += Math.imul(ah7, bh4);\n    lo += Math.imul(al6, bl5);\n    mid += Math.imul(al6, bh5);\n    mid += Math.imul(ah6, bl5);\n    hi += Math.imul(ah6, bh5);\n    lo += Math.imul(al5, bl6);\n    mid += Math.imul(al5, bh6);\n    mid += Math.imul(ah5, bl6);\n    hi += Math.imul(ah5, bh6);\n    lo += Math.imul(al4, bl7);\n    mid += Math.imul(al4, bh7);\n    mid += Math.imul(ah4, bl7);\n    hi += Math.imul(ah4, bh7);\n    lo += Math.imul(al3, bl8);\n    mid += Math.imul(al3, bh8);\n    mid += Math.imul(ah3, bl8);\n    hi += Math.imul(ah3, bh8);\n    lo += Math.imul(al2, bl9);\n    mid += Math.imul(al2, bh9);\n    mid += Math.imul(ah2, bl9);\n    hi += Math.imul(ah2, bh9);\n    var w11 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w11 >>> 26);\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid += Math.imul(ah9, bl3);\n    hi = Math.imul(ah9, bh3);\n    lo += Math.imul(al8, bl4);\n    mid += Math.imul(al8, bh4);\n    mid += Math.imul(ah8, bl4);\n    hi += Math.imul(ah8, bh4);\n    lo += Math.imul(al7, bl5);\n    mid += Math.imul(al7, bh5);\n    mid += Math.imul(ah7, bl5);\n    hi += Math.imul(ah7, bh5);\n    lo += Math.imul(al6, bl6);\n    mid += Math.imul(al6, bh6);\n    mid += Math.imul(ah6, bl6);\n    hi += Math.imul(ah6, bh6);\n    lo += Math.imul(al5, bl7);\n    mid += Math.imul(al5, bh7);\n    mid += Math.imul(ah5, bl7);\n    hi += Math.imul(ah5, bh7);\n    lo += Math.imul(al4, bl8);\n    mid += Math.imul(al4, bh8);\n    mid += Math.imul(ah4, bl8);\n    hi += Math.imul(ah4, bh8);\n    lo += Math.imul(al3, bl9);\n    mid += Math.imul(al3, bh9);\n    mid += Math.imul(ah3, bl9);\n    hi += Math.imul(ah3, bh9);\n    var w12 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w12 >>> 26);\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid += Math.imul(ah9, bl4);\n    hi = Math.imul(ah9, bh4);\n    lo += Math.imul(al8, bl5);\n    mid += Math.imul(al8, bh5);\n    mid += Math.imul(ah8, bl5);\n    hi += Math.imul(ah8, bh5);\n    lo += Math.imul(al7, bl6);\n    mid += Math.imul(al7, bh6);\n    mid += Math.imul(ah7, bl6);\n    hi += Math.imul(ah7, bh6);\n    lo += Math.imul(al6, bl7);\n    mid += Math.imul(al6, bh7);\n    mid += Math.imul(ah6, bl7);\n    hi += Math.imul(ah6, bh7);\n    lo += Math.imul(al5, bl8);\n    mid += Math.imul(al5, bh8);\n    mid += Math.imul(ah5, bl8);\n    hi += Math.imul(ah5, bh8);\n    lo += Math.imul(al4, bl9);\n    mid += Math.imul(al4, bh9);\n    mid += Math.imul(ah4, bl9);\n    hi += Math.imul(ah4, bh9);\n    var w13 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w13 >>> 26);\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid += Math.imul(ah9, bl5);\n    hi = Math.imul(ah9, bh5);\n    lo += Math.imul(al8, bl6);\n    mid += Math.imul(al8, bh6);\n    mid += Math.imul(ah8, bl6);\n    hi += Math.imul(ah8, bh6);\n    lo += Math.imul(al7, bl7);\n    mid += Math.imul(al7, bh7);\n    mid += Math.imul(ah7, bl7);\n    hi += Math.imul(ah7, bh7);\n    lo += Math.imul(al6, bl8);\n    mid += Math.imul(al6, bh8);\n    mid += Math.imul(ah6, bl8);\n    hi += Math.imul(ah6, bh8);\n    lo += Math.imul(al5, bl9);\n    mid += Math.imul(al5, bh9);\n    mid += Math.imul(ah5, bl9);\n    hi += Math.imul(ah5, bh9);\n    var w14 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w14 >>> 26);\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid += Math.imul(ah9, bl6);\n    hi = Math.imul(ah9, bh6);\n    lo += Math.imul(al8, bl7);\n    mid += Math.imul(al8, bh7);\n    mid += Math.imul(ah8, bl7);\n    hi += Math.imul(ah8, bh7);\n    lo += Math.imul(al7, bl8);\n    mid += Math.imul(al7, bh8);\n    mid += Math.imul(ah7, bl8);\n    hi += Math.imul(ah7, bh8);\n    lo += Math.imul(al6, bl9);\n    mid += Math.imul(al6, bh9);\n    mid += Math.imul(ah6, bl9);\n    hi += Math.imul(ah6, bh9);\n    var w15 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w15 >>> 26);\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid += Math.imul(ah9, bl7);\n    hi = Math.imul(ah9, bh7);\n    lo += Math.imul(al8, bl8);\n    mid += Math.imul(al8, bh8);\n    mid += Math.imul(ah8, bl8);\n    hi += Math.imul(ah8, bh8);\n    lo += Math.imul(al7, bl9);\n    mid += Math.imul(al7, bh9);\n    mid += Math.imul(ah7, bl9);\n    hi += Math.imul(ah7, bh9);\n    var w16 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w16 >>> 26);\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid += Math.imul(ah9, bl8);\n    hi = Math.imul(ah9, bh8);\n    lo += Math.imul(al8, bl9);\n    mid += Math.imul(al8, bh9);\n    mid += Math.imul(ah8, bl9);\n    hi += Math.imul(ah8, bh9);\n    var w17 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w17 >>> 26);\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid += Math.imul(ah9, bl9);\n    hi = Math.imul(ah9, bh9);\n    var w18 = c + lo + ((mid & 0x1fff) << 13);\n    c = hi + (mid >>> 13) + (w18 >>> 26);\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out.strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    assert(typeof num === 'number');\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this.strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    // Bigger storage is needed\n    var len = num.length + shift;\n    var i;\n    if (this.words.length < len) {\n      var t = new Array(len);\n      for (i = 0; i < this.length; i++) {\n        t[i] = this.words[i];\n      }\n      this.words = t;\n    } else {\n      i = this.length;\n    }\n\n    // Zeroify rest\n    this.length = Math.max(this.length, len);\n    for (; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this.strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this.strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q.strip();\n    }\n    a.strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return { div: q || null, mod: a };\n  };\n\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.neg) {\n          mod = mod.add(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return { div: div, mod: res.mod };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.neg) {\n          mod = mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return { div: new BN(0), mod: this };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return { div: this.divn(num.words[0]), mod: null };\n      }\n\n      if (mode === 'mod') {\n        return { div: null, mod: new BN(this.modn(num.words[0])) };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modn = function modn (num) {\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return acc;\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.clone();\n    if (num.isZero()) return this.clone();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      for (var i = this.length; i < s + 1; i++) {\n        this.words[i] = 0;\n      }\n      this.words[s] |= q;\n      this.length = s + 1;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this.strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) {\n      res = -res;\n    }\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res;\n\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.ushl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      r.strip();\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    input.words[i - 10] = prev >>> 22;\n    input.length -= 9;\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.umod(this.m)._forceRed(this);\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})(typeof module === 'undefined' || module, this);\n\n},{}],216:[function(require,module,exports){\nvar r;\n\nmodule.exports = function rand(len) {\n  if (!r)\n    r = new Rand(null);\n\n  return r.generate(len);\n};\n\nfunction Rand(rand) {\n  this.rand = rand;\n}\nmodule.exports.Rand = Rand;\n\nRand.prototype.generate = function generate(len) {\n  return this._rand(len);\n};\n\nif (typeof window === 'object') {\n  if (window.crypto && window.crypto.getRandomValues) {\n    // Modern browsers\n    Rand.prototype._rand = function _rand(n) {\n      var arr = new Uint8Array(n);\n      window.crypto.getRandomValues(arr);\n      return arr;\n    };\n  } else if (window.msCrypto && window.msCrypto.getRandomValues) {\n    // IE\n    Rand.prototype._rand = function _rand(n) {\n      var arr = new Uint8Array(n);\n      window.msCrypto.getRandomValues(arr);\n      return arr;\n    };\n  } else {\n    // Old junk\n    Rand.prototype._rand = function() {\n      throw new Error('Not implemented yet');\n    };\n  }\n} else {\n  // Node.js or Web worker\n  try {\n    var crypto = require('cry' + 'pto');\n\n    Rand.prototype._rand = function _rand(n) {\n      return crypto.randomBytes(n);\n    };\n  } catch (e) {\n    // Emulate crypto API using randy\n    Rand.prototype._rand = function _rand(n) {\n      var res = new Uint8Array(n);\n      for (var i = 0; i < res.length; i++)\n        res[i] = this.rand.getByte();\n      return res;\n    };\n  }\n}\n\n},{}],217:[function(require,module,exports){\n\n},{}],218:[function(require,module,exports){\n(function (Buffer){\n// based on the aes implimentation in triple sec\n// https://github.com/keybase/triplesec\n\n// which is in turn based on the one from crypto-js\n// https://code.google.com/p/crypto-js/\n\nvar uint_max = Math.pow(2, 32)\nfunction fixup_uint32 (x) {\n  var ret, x_pos\n  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x\n  return ret\n}\nfunction scrub_vec (v) {\n  for (var i = 0; i < v.length; v++) {\n    v[i] = 0\n  }\n  return false\n}\n\nfunction Global () {\n  this.SBOX = []\n  this.INV_SBOX = []\n  this.SUB_MIX = [[], [], [], []]\n  this.INV_SUB_MIX = [[], [], [], []]\n  this.init()\n  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]\n}\n\nGlobal.prototype.init = function () {\n  var d, i, sx, t, x, x2, x4, x8, xi, _i\n  d = (function () {\n    var _i, _results\n    _results = []\n    for (i = _i = 0; _i < 256; i = ++_i) {\n      if (i < 128) {\n        _results.push(i << 1)\n      } else {\n        _results.push((i << 1) ^ 0x11b)\n      }\n    }\n    return _results\n  })()\n  x = 0\n  xi = 0\n  for (i = _i = 0; _i < 256; i = ++_i) {\n    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)\n    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63\n    this.SBOX[x] = sx\n    this.INV_SBOX[sx] = x\n    x2 = d[x]\n    x4 = d[x2]\n    x8 = d[x4]\n    t = (d[sx] * 0x101) ^ (sx * 0x1010100)\n    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)\n    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)\n    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)\n    this.SUB_MIX[3][x] = t\n    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)\n    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)\n    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)\n    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)\n    this.INV_SUB_MIX[3][sx] = t\n    if (x === 0) {\n      x = xi = 1\n    } else {\n      x = x2 ^ d[d[d[x8 ^ x2]]]\n      xi ^= d[d[xi]]\n    }\n  }\n  return true\n}\n\nvar G = new Global()\n\nAES.blockSize = 4 * 4\n\nAES.prototype.blockSize = AES.blockSize\n\nAES.keySize = 256 / 8\n\nAES.prototype.keySize = AES.keySize\n\nfunction bufferToArray (buf) {\n  var len = buf.length / 4\n  var out = new Array(len)\n  var i = -1\n  while (++i < len) {\n    out[i] = buf.readUInt32BE(i * 4)\n  }\n  return out\n}\nfunction AES (key) {\n  this._key = bufferToArray(key)\n  this._doReset()\n}\n\nAES.prototype._doReset = function () {\n  var invKsRow, keySize, keyWords, ksRow, ksRows, t\n  keyWords = this._key\n  keySize = keyWords.length\n  this._nRounds = keySize + 6\n  ksRows = (this._nRounds + 1) * 4\n  this._keySchedule = []\n  for (ksRow = 0; ksRow < ksRows; ksRow++) {\n    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)\n  }\n  this._invKeySchedule = []\n  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n    ksRow = ksRows - invKsRow\n    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]\n    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]\n  }\n  return true\n}\n\nAES.prototype.encryptBlock = function (M) {\n  M = bufferToArray(new Buffer(M))\n  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)\n  var buf = new Buffer(16)\n  buf.writeUInt32BE(out[0], 0)\n  buf.writeUInt32BE(out[1], 4)\n  buf.writeUInt32BE(out[2], 8)\n  buf.writeUInt32BE(out[3], 12)\n  return buf\n}\n\nAES.prototype.decryptBlock = function (M) {\n  M = bufferToArray(new Buffer(M))\n  var temp = [M[3], M[1]]\n  M[1] = temp[0]\n  M[3] = temp[1]\n  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)\n  var buf = new Buffer(16)\n  buf.writeUInt32BE(out[0], 0)\n  buf.writeUInt32BE(out[3], 4)\n  buf.writeUInt32BE(out[2], 8)\n  buf.writeUInt32BE(out[1], 12)\n  return buf\n}\n\nAES.prototype.scrub = function () {\n  scrub_vec(this._keySchedule)\n  scrub_vec(this._invKeySchedule)\n  scrub_vec(this._key)\n}\n\nAES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {\n  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3\n\n  s0 = M[0] ^ keySchedule[0]\n  s1 = M[1] ^ keySchedule[1]\n  s2 = M[2] ^ keySchedule[2]\n  s3 = M[3] ^ keySchedule[3]\n  ksRow = 4\n  for (var round = 1; round < this._nRounds; round++) {\n    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]\n    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]\n    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]\n    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]\n    s0 = t0\n    s1 = t1\n    s2 = t2\n    s3 = t3\n  }\n  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]\n  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]\n  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]\n  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]\n  return [\n    fixup_uint32(t0),\n    fixup_uint32(t1),\n    fixup_uint32(t2),\n    fixup_uint32(t3)\n  ]\n}\n\nexports.AES = AES\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243}],219:[function(require,module,exports){\n(function (Buffer){\nvar aes = require('./aes')\nvar Transform = require('cipher-base')\nvar inherits = require('inherits')\nvar GHASH = require('./ghash')\nvar xor = require('buffer-xor')\ninherits(StreamCipher, Transform)\nmodule.exports = StreamCipher\n\nfunction StreamCipher (mode, key, iv, decrypt) {\n  if (!(this instanceof StreamCipher)) {\n    return new StreamCipher(mode, key, iv)\n  }\n  Transform.call(this)\n  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])\n  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])\n  this._cipher = new aes.AES(key)\n  this._prev = new Buffer(iv.length)\n  this._cache = new Buffer('')\n  this._secCache = new Buffer('')\n  this._decrypt = decrypt\n  this._alen = 0\n  this._len = 0\n  iv.copy(this._prev)\n  this._mode = mode\n  var h = new Buffer(4)\n  h.fill(0)\n  this._ghash = new GHASH(this._cipher.encryptBlock(h))\n  this._authTag = null\n  this._called = false\n}\nStreamCipher.prototype._update = function (chunk) {\n  if (!this._called && this._alen) {\n    var rump = 16 - (this._alen % 16)\n    if (rump < 16) {\n      rump = new Buffer(rump)\n      rump.fill(0)\n      this._ghash.update(rump)\n    }\n  }\n  this._called = true\n  var out = this._mode.encrypt(this, chunk)\n  if (this._decrypt) {\n    this._ghash.update(chunk)\n  } else {\n    this._ghash.update(out)\n  }\n  this._len += chunk.length\n  return out\n}\nStreamCipher.prototype._final = function () {\n  if (this._decrypt && !this._authTag) {\n    throw new Error('Unsupported state or unable to authenticate data')\n  }\n  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))\n  if (this._decrypt) {\n    if (xorTest(tag, this._authTag)) {\n      throw new Error('Unsupported state or unable to authenticate data')\n    }\n  } else {\n    this._authTag = tag\n  }\n  this._cipher.scrub()\n}\nStreamCipher.prototype.getAuthTag = function getAuthTag () {\n  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {\n    return this._authTag\n  } else {\n    throw new Error('Attempting to get auth tag in unsupported state')\n  }\n}\nStreamCipher.prototype.setAuthTag = function setAuthTag (tag) {\n  if (this._decrypt) {\n    this._authTag = tag\n  } else {\n    throw new Error('Attempting to set auth tag in unsupported state')\n  }\n}\nStreamCipher.prototype.setAAD = function setAAD (buf) {\n  if (!this._called) {\n    this._ghash.update(buf)\n    this._alen += buf.length\n  } else {\n    throw new Error('Attempting to set AAD in unsupported state')\n  }\n}\nfunction xorTest (a, b) {\n  var out = 0\n  if (a.length !== b.length) {\n    out++\n  }\n  var len = Math.min(a.length, b.length)\n  var i = -1\n  while (++i < len) {\n    out += (a[i] ^ b[i])\n  }\n  return out\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./aes\":218,\"./ghash\":223,\"buffer\":243,\"buffer-xor\":242,\"cipher-base\":245,\"inherits\":292}],220:[function(require,module,exports){\nvar ciphers = require('./encrypter')\nexports.createCipher = exports.Cipher = ciphers.createCipher\nexports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv\nvar deciphers = require('./decrypter')\nexports.createDecipher = exports.Decipher = deciphers.createDecipher\nexports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv\nvar modes = require('./modes')\nfunction getCiphers () {\n  return Object.keys(modes)\n}\nexports.listCiphers = exports.getCiphers = getCiphers\n\n},{\"./decrypter\":221,\"./encrypter\":222,\"./modes\":224}],221:[function(require,module,exports){\n(function (Buffer){\nvar aes = require('./aes')\nvar Transform = require('cipher-base')\nvar inherits = require('inherits')\nvar modes = require('./modes')\nvar StreamCipher = require('./streamCipher')\nvar AuthCipher = require('./authCipher')\nvar ebtk = require('evp_bytestokey')\n\ninherits(Decipher, Transform)\nfunction Decipher (mode, key, iv) {\n  if (!(this instanceof Decipher)) {\n    return new Decipher(mode, key, iv)\n  }\n  Transform.call(this)\n  this._cache = new Splitter()\n  this._last = void 0\n  this._cipher = new aes.AES(key)\n  this._prev = new Buffer(iv.length)\n  iv.copy(this._prev)\n  this._mode = mode\n  this._autopadding = true\n}\nDecipher.prototype._update = function (data) {\n  this._cache.add(data)\n  var chunk\n  var thing\n  var out = []\n  while ((chunk = this._cache.get(this._autopadding))) {\n    thing = this._mode.decrypt(this, chunk)\n    out.push(thing)\n  }\n  return Buffer.concat(out)\n}\nDecipher.prototype._final = function () {\n  var chunk = this._cache.flush()\n  if (this._autopadding) {\n    return unpad(this._mode.decrypt(this, chunk))\n  } else if (chunk) {\n    throw new Error('data not multiple of block length')\n  }\n}\nDecipher.prototype.setAutoPadding = function (setTo) {\n  this._autopadding = !!setTo\n  return this\n}\nfunction Splitter () {\n  if (!(this instanceof Splitter)) {\n    return new Splitter()\n  }\n  this.cache = new Buffer('')\n}\nSplitter.prototype.add = function (data) {\n  this.cache = Buffer.concat([this.cache, data])\n}\n\nSplitter.prototype.get = function (autoPadding) {\n  var out\n  if (autoPadding) {\n    if (this.cache.length > 16) {\n      out = this.cache.slice(0, 16)\n      this.cache = this.cache.slice(16)\n      return out\n    }\n  } else {\n    if (this.cache.length >= 16) {\n      out = this.cache.slice(0, 16)\n      this.cache = this.cache.slice(16)\n      return out\n    }\n  }\n  return null\n}\nSplitter.prototype.flush = function () {\n  if (this.cache.length) {\n    return this.cache\n  }\n}\nfunction unpad (last) {\n  var padded = last[15]\n  var i = -1\n  while (++i < padded) {\n    if (last[(i + (16 - padded))] !== padded) {\n      throw new Error('unable to decrypt data')\n    }\n  }\n  if (padded === 16) {\n    return\n  }\n  return last.slice(0, 16 - padded)\n}\n\nvar modelist = {\n  ECB: require('./modes/ecb'),\n  CBC: require('./modes/cbc'),\n  CFB: require('./modes/cfb'),\n  CFB8: require('./modes/cfb8'),\n  CFB1: require('./modes/cfb1'),\n  OFB: require('./modes/ofb'),\n  CTR: require('./modes/ctr'),\n  GCM: require('./modes/ctr')\n}\n\nfunction createDecipheriv (suite, password, iv) {\n  var config = modes[suite.toLowerCase()]\n  if (!config) {\n    throw new TypeError('invalid suite type')\n  }\n  if (typeof iv === 'string') {\n    iv = new Buffer(iv)\n  }\n  if (typeof password === 'string') {\n    password = new Buffer(password)\n  }\n  if (password.length !== config.key / 8) {\n    throw new TypeError('invalid key length ' + password.length)\n  }\n  if (iv.length !== config.iv) {\n    throw new TypeError('invalid iv length ' + iv.length)\n  }\n  if (config.type === 'stream') {\n    return new StreamCipher(modelist[config.mode], password, iv, true)\n  } else if (config.type === 'auth') {\n    return new AuthCipher(modelist[config.mode], password, iv, true)\n  }\n  return new Decipher(modelist[config.mode], password, iv)\n}\n\nfunction createDecipher (suite, password) {\n  var config = modes[suite.toLowerCase()]\n  if (!config) {\n    throw new TypeError('invalid suite type')\n  }\n  var keys = ebtk(password, false, config.key, config.iv)\n  return createDecipheriv(suite, keys.key, keys.iv)\n}\nexports.createDecipher = createDecipher\nexports.createDecipheriv = createDecipheriv\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./aes\":218,\"./authCipher\":219,\"./modes\":224,\"./modes/cbc\":225,\"./modes/cfb\":226,\"./modes/cfb1\":227,\"./modes/cfb8\":228,\"./modes/ctr\":229,\"./modes/ecb\":230,\"./modes/ofb\":231,\"./streamCipher\":232,\"buffer\":243,\"cipher-base\":245,\"evp_bytestokey\":283,\"inherits\":292}],222:[function(require,module,exports){\n(function (Buffer){\nvar aes = require('./aes')\nvar Transform = require('cipher-base')\nvar inherits = require('inherits')\nvar modes = require('./modes')\nvar ebtk = require('evp_bytestokey')\nvar StreamCipher = require('./streamCipher')\nvar AuthCipher = require('./authCipher')\ninherits(Cipher, Transform)\nfunction Cipher (mode, key, iv) {\n  if (!(this instanceof Cipher)) {\n    return new Cipher(mode, key, iv)\n  }\n  Transform.call(this)\n  this._cache = new Splitter()\n  this._cipher = new aes.AES(key)\n  this._prev = new Buffer(iv.length)\n  iv.copy(this._prev)\n  this._mode = mode\n  this._autopadding = true\n}\nCipher.prototype._update = function (data) {\n  this._cache.add(data)\n  var chunk\n  var thing\n  var out = []\n  while ((chunk = this._cache.get())) {\n    thing = this._mode.encrypt(this, chunk)\n    out.push(thing)\n  }\n  return Buffer.concat(out)\n}\nCipher.prototype._final = function () {\n  var chunk = this._cache.flush()\n  if (this._autopadding) {\n    chunk = this._mode.encrypt(this, chunk)\n    this._cipher.scrub()\n    return chunk\n  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {\n    this._cipher.scrub()\n    throw new Error('data not multiple of block length')\n  }\n}\nCipher.prototype.setAutoPadding = function (setTo) {\n  this._autopadding = !!setTo\n  return this\n}\n\nfunction Splitter () {\n  if (!(this instanceof Splitter)) {\n    return new Splitter()\n  }\n  this.cache = new Buffer('')\n}\nSplitter.prototype.add = function (data) {\n  this.cache = Buffer.concat([this.cache, data])\n}\n\nSplitter.prototype.get = function () {\n  if (this.cache.length > 15) {\n    var out = this.cache.slice(0, 16)\n    this.cache = this.cache.slice(16)\n    return out\n  }\n  return null\n}\nSplitter.prototype.flush = function () {\n  var len = 16 - this.cache.length\n  var padBuff = new Buffer(len)\n\n  var i = -1\n  while (++i < len) {\n    padBuff.writeUInt8(len, i)\n  }\n  var out = Buffer.concat([this.cache, padBuff])\n  return out\n}\nvar modelist = {\n  ECB: require('./modes/ecb'),\n  CBC: require('./modes/cbc'),\n  CFB: require('./modes/cfb'),\n  CFB8: require('./modes/cfb8'),\n  CFB1: require('./modes/cfb1'),\n  OFB: require('./modes/ofb'),\n  CTR: require('./modes/ctr'),\n  GCM: require('./modes/ctr')\n}\n\nfunction createCipheriv (suite, password, iv) {\n  var config = modes[suite.toLowerCase()]\n  if (!config) {\n    throw new TypeError('invalid suite type')\n  }\n  if (typeof iv === 'string') {\n    iv = new Buffer(iv)\n  }\n  if (typeof password === 'string') {\n    password = new Buffer(password)\n  }\n  if (password.length !== config.key / 8) {\n    throw new TypeError('invalid key length ' + password.length)\n  }\n  if (iv.length !== config.iv) {\n    throw new TypeError('invalid iv length ' + iv.length)\n  }\n  if (config.type === 'stream') {\n    return new StreamCipher(modelist[config.mode], password, iv)\n  } else if (config.type === 'auth') {\n    return new AuthCipher(modelist[config.mode], password, iv)\n  }\n  return new Cipher(modelist[config.mode], password, iv)\n}\nfunction createCipher (suite, password) {\n  var config = modes[suite.toLowerCase()]\n  if (!config) {\n    throw new TypeError('invalid suite type')\n  }\n  var keys = ebtk(password, false, config.key, config.iv)\n  return createCipheriv(suite, keys.key, keys.iv)\n}\n\nexports.createCipheriv = createCipheriv\nexports.createCipher = createCipher\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./aes\":218,\"./authCipher\":219,\"./modes\":224,\"./modes/cbc\":225,\"./modes/cfb\":226,\"./modes/cfb1\":227,\"./modes/cfb8\":228,\"./modes/ctr\":229,\"./modes/ecb\":230,\"./modes/ofb\":231,\"./streamCipher\":232,\"buffer\":243,\"cipher-base\":245,\"evp_bytestokey\":283,\"inherits\":292}],223:[function(require,module,exports){\n(function (Buffer){\nvar zeros = new Buffer(16)\nzeros.fill(0)\nmodule.exports = GHASH\nfunction GHASH (key) {\n  this.h = key\n  this.state = new Buffer(16)\n  this.state.fill(0)\n  this.cache = new Buffer('')\n}\n// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html\n// by Juho Vähä-Herttua\nGHASH.prototype.ghash = function (block) {\n  var i = -1\n  while (++i < block.length) {\n    this.state[i] ^= block[i]\n  }\n  this._multiply()\n}\n\nGHASH.prototype._multiply = function () {\n  var Vi = toArray(this.h)\n  var Zi = [0, 0, 0, 0]\n  var j, xi, lsb_Vi\n  var i = -1\n  while (++i < 128) {\n    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0\n    if (xi) {\n      // Z_i+1 = Z_i ^ V_i\n      Zi = xor(Zi, Vi)\n    }\n\n    // Store the value of LSB(V_i)\n    lsb_Vi = (Vi[3] & 1) !== 0\n\n    // V_i+1 = V_i >> 1\n    for (j = 3; j > 0; j--) {\n      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)\n    }\n    Vi[0] = Vi[0] >>> 1\n\n    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R\n    if (lsb_Vi) {\n      Vi[0] = Vi[0] ^ (0xe1 << 24)\n    }\n  }\n  this.state = fromArray(Zi)\n}\nGHASH.prototype.update = function (buf) {\n  this.cache = Buffer.concat([this.cache, buf])\n  var chunk\n  while (this.cache.length >= 16) {\n    chunk = this.cache.slice(0, 16)\n    this.cache = this.cache.slice(16)\n    this.ghash(chunk)\n  }\n}\nGHASH.prototype.final = function (abl, bl) {\n  if (this.cache.length) {\n    this.ghash(Buffer.concat([this.cache, zeros], 16))\n  }\n  this.ghash(fromArray([\n    0, abl,\n    0, bl\n  ]))\n  return this.state\n}\n\nfunction toArray (buf) {\n  return [\n    buf.readUInt32BE(0),\n    buf.readUInt32BE(4),\n    buf.readUInt32BE(8),\n    buf.readUInt32BE(12)\n  ]\n}\nfunction fromArray (out) {\n  out = out.map(fixup_uint32)\n  var buf = new Buffer(16)\n  buf.writeUInt32BE(out[0], 0)\n  buf.writeUInt32BE(out[1], 4)\n  buf.writeUInt32BE(out[2], 8)\n  buf.writeUInt32BE(out[3], 12)\n  return buf\n}\nvar uint_max = Math.pow(2, 32)\nfunction fixup_uint32 (x) {\n  var ret, x_pos\n  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x\n  return ret\n}\nfunction xor (a, b) {\n  return [\n    a[0] ^ b[0],\n    a[1] ^ b[1],\n    a[2] ^ b[2],\n    a[3] ^ b[3]\n  ]\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243}],224:[function(require,module,exports){\nexports['aes-128-ecb'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 0,\n  mode: 'ECB',\n  type: 'block'\n}\nexports['aes-192-ecb'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 0,\n  mode: 'ECB',\n  type: 'block'\n}\nexports['aes-256-ecb'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 0,\n  mode: 'ECB',\n  type: 'block'\n}\nexports['aes-128-cbc'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 16,\n  mode: 'CBC',\n  type: 'block'\n}\nexports['aes-192-cbc'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 16,\n  mode: 'CBC',\n  type: 'block'\n}\nexports['aes-256-cbc'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 16,\n  mode: 'CBC',\n  type: 'block'\n}\nexports['aes128'] = exports['aes-128-cbc']\nexports['aes192'] = exports['aes-192-cbc']\nexports['aes256'] = exports['aes-256-cbc']\nexports['aes-128-cfb'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 16,\n  mode: 'CFB',\n  type: 'stream'\n}\nexports['aes-192-cfb'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 16,\n  mode: 'CFB',\n  type: 'stream'\n}\nexports['aes-256-cfb'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 16,\n  mode: 'CFB',\n  type: 'stream'\n}\nexports['aes-128-cfb8'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 16,\n  mode: 'CFB8',\n  type: 'stream'\n}\nexports['aes-192-cfb8'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 16,\n  mode: 'CFB8',\n  type: 'stream'\n}\nexports['aes-256-cfb8'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 16,\n  mode: 'CFB8',\n  type: 'stream'\n}\nexports['aes-128-cfb1'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 16,\n  mode: 'CFB1',\n  type: 'stream'\n}\nexports['aes-192-cfb1'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 16,\n  mode: 'CFB1',\n  type: 'stream'\n}\nexports['aes-256-cfb1'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 16,\n  mode: 'CFB1',\n  type: 'stream'\n}\nexports['aes-128-ofb'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 16,\n  mode: 'OFB',\n  type: 'stream'\n}\nexports['aes-192-ofb'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 16,\n  mode: 'OFB',\n  type: 'stream'\n}\nexports['aes-256-ofb'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 16,\n  mode: 'OFB',\n  type: 'stream'\n}\nexports['aes-128-ctr'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 16,\n  mode: 'CTR',\n  type: 'stream'\n}\nexports['aes-192-ctr'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 16,\n  mode: 'CTR',\n  type: 'stream'\n}\nexports['aes-256-ctr'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 16,\n  mode: 'CTR',\n  type: 'stream'\n}\nexports['aes-128-gcm'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 12,\n  mode: 'GCM',\n  type: 'auth'\n}\nexports['aes-192-gcm'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 12,\n  mode: 'GCM',\n  type: 'auth'\n}\nexports['aes-256-gcm'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 12,\n  mode: 'GCM',\n  type: 'auth'\n}\n\n},{}],225:[function(require,module,exports){\nvar xor = require('buffer-xor')\n\nexports.encrypt = function (self, block) {\n  var data = xor(block, self._prev)\n\n  self._prev = self._cipher.encryptBlock(data)\n  return self._prev\n}\n\nexports.decrypt = function (self, block) {\n  var pad = self._prev\n\n  self._prev = block\n  var out = self._cipher.decryptBlock(block)\n\n  return xor(out, pad)\n}\n\n},{\"buffer-xor\":242}],226:[function(require,module,exports){\n(function (Buffer){\nvar xor = require('buffer-xor')\n\nexports.encrypt = function (self, data, decrypt) {\n  var out = new Buffer('')\n  var len\n\n  while (data.length) {\n    if (self._cache.length === 0) {\n      self._cache = self._cipher.encryptBlock(self._prev)\n      self._prev = new Buffer('')\n    }\n\n    if (self._cache.length <= data.length) {\n      len = self._cache.length\n      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])\n      data = data.slice(len)\n    } else {\n      out = Buffer.concat([out, encryptStart(self, data, decrypt)])\n      break\n    }\n  }\n\n  return out\n}\nfunction encryptStart (self, data, decrypt) {\n  var len = data.length\n  var out = xor(data, self._cache)\n  self._cache = self._cache.slice(len)\n  self._prev = Buffer.concat([self._prev, decrypt ? data : out])\n  return out\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243,\"buffer-xor\":242}],227:[function(require,module,exports){\n(function (Buffer){\nfunction encryptByte (self, byteParam, decrypt) {\n  var pad\n  var i = -1\n  var len = 8\n  var out = 0\n  var bit, value\n  while (++i < len) {\n    pad = self._cipher.encryptBlock(self._prev)\n    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0\n    value = pad[0] ^ bit\n    out += ((value & 0x80) >> (i % 8))\n    self._prev = shiftIn(self._prev, decrypt ? bit : value)\n  }\n  return out\n}\nexports.encrypt = function (self, chunk, decrypt) {\n  var len = chunk.length\n  var out = new Buffer(len)\n  var i = -1\n  while (++i < len) {\n    out[i] = encryptByte(self, chunk[i], decrypt)\n  }\n  return out\n}\nfunction shiftIn (buffer, value) {\n  var len = buffer.length\n  var i = -1\n  var out = new Buffer(buffer.length)\n  buffer = Buffer.concat([buffer, new Buffer([value])])\n  while (++i < len) {\n    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)\n  }\n  return out\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243}],228:[function(require,module,exports){\n(function (Buffer){\nfunction encryptByte (self, byteParam, decrypt) {\n  var pad = self._cipher.encryptBlock(self._prev)\n  var out = pad[0] ^ byteParam\n  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])\n  return out\n}\nexports.encrypt = function (self, chunk, decrypt) {\n  var len = chunk.length\n  var out = new Buffer(len)\n  var i = -1\n  while (++i < len) {\n    out[i] = encryptByte(self, chunk[i], decrypt)\n  }\n  return out\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243}],229:[function(require,module,exports){\n(function (Buffer){\nvar xor = require('buffer-xor')\n\nfunction incr32 (iv) {\n  var len = iv.length\n  var item\n  while (len--) {\n    item = iv.readUInt8(len)\n    if (item === 255) {\n      iv.writeUInt8(0, len)\n    } else {\n      item++\n      iv.writeUInt8(item, len)\n      break\n    }\n  }\n}\n\nfunction getBlock (self) {\n  var out = self._cipher.encryptBlock(self._prev)\n  incr32(self._prev)\n  return out\n}\n\nexports.encrypt = function (self, chunk) {\n  while (self._cache.length < chunk.length) {\n    self._cache = Buffer.concat([self._cache, getBlock(self)])\n  }\n  var pad = self._cache.slice(0, chunk.length)\n  self._cache = self._cache.slice(chunk.length)\n  return xor(chunk, pad)\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243,\"buffer-xor\":242}],230:[function(require,module,exports){\nexports.encrypt = function (self, block) {\n  return self._cipher.encryptBlock(block)\n}\nexports.decrypt = function (self, block) {\n  return self._cipher.decryptBlock(block)\n}\n\n},{}],231:[function(require,module,exports){\n(function (Buffer){\nvar xor = require('buffer-xor')\n\nfunction getBlock (self) {\n  self._prev = self._cipher.encryptBlock(self._prev)\n  return self._prev\n}\n\nexports.encrypt = function (self, chunk) {\n  while (self._cache.length < chunk.length) {\n    self._cache = Buffer.concat([self._cache, getBlock(self)])\n  }\n\n  var pad = self._cache.slice(0, chunk.length)\n  self._cache = self._cache.slice(chunk.length)\n  return xor(chunk, pad)\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243,\"buffer-xor\":242}],232:[function(require,module,exports){\n(function (Buffer){\nvar aes = require('./aes')\nvar Transform = require('cipher-base')\nvar inherits = require('inherits')\n\ninherits(StreamCipher, Transform)\nmodule.exports = StreamCipher\nfunction StreamCipher (mode, key, iv, decrypt) {\n  if (!(this instanceof StreamCipher)) {\n    return new StreamCipher(mode, key, iv)\n  }\n  Transform.call(this)\n  this._cipher = new aes.AES(key)\n  this._prev = new Buffer(iv.length)\n  this._cache = new Buffer('')\n  this._secCache = new Buffer('')\n  this._decrypt = decrypt\n  iv.copy(this._prev)\n  this._mode = mode\n}\nStreamCipher.prototype._update = function (chunk) {\n  return this._mode.encrypt(this, chunk, this._decrypt)\n}\nStreamCipher.prototype._final = function () {\n  this._cipher.scrub()\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./aes\":218,\"buffer\":243,\"cipher-base\":245,\"inherits\":292}],233:[function(require,module,exports){\nvar ebtk = require('evp_bytestokey')\nvar aes = require('browserify-aes/browser')\nvar DES = require('browserify-des')\nvar desModes = require('browserify-des/modes')\nvar aesModes = require('browserify-aes/modes')\nfunction createCipher (suite, password) {\n  var keyLen, ivLen\n  suite = suite.toLowerCase()\n  if (aesModes[suite]) {\n    keyLen = aesModes[suite].key\n    ivLen = aesModes[suite].iv\n  } else if (desModes[suite]) {\n    keyLen = desModes[suite].key * 8\n    ivLen = desModes[suite].iv\n  } else {\n    throw new TypeError('invalid suite type')\n  }\n  var keys = ebtk(password, false, keyLen, ivLen)\n  return createCipheriv(suite, keys.key, keys.iv)\n}\nfunction createDecipher (suite, password) {\n  var keyLen, ivLen\n  suite = suite.toLowerCase()\n  if (aesModes[suite]) {\n    keyLen = aesModes[suite].key\n    ivLen = aesModes[suite].iv\n  } else if (desModes[suite]) {\n    keyLen = desModes[suite].key * 8\n    ivLen = desModes[suite].iv\n  } else {\n    throw new TypeError('invalid suite type')\n  }\n  var keys = ebtk(password, false, keyLen, ivLen)\n  return createDecipheriv(suite, keys.key, keys.iv)\n}\n\nfunction createCipheriv (suite, key, iv) {\n  suite = suite.toLowerCase()\n  if (aesModes[suite]) {\n    return aes.createCipheriv(suite, key, iv)\n  } else if (desModes[suite]) {\n    return new DES({\n      key: key,\n      iv: iv,\n      mode: suite\n    })\n  } else {\n    throw new TypeError('invalid suite type')\n  }\n}\nfunction createDecipheriv (suite, key, iv) {\n  suite = suite.toLowerCase()\n  if (aesModes[suite]) {\n    return aes.createDecipheriv(suite, key, iv)\n  } else if (desModes[suite]) {\n    return new DES({\n      key: key,\n      iv: iv,\n      mode: suite,\n      decrypt: true\n    })\n  } else {\n    throw new TypeError('invalid suite type')\n  }\n}\nexports.createCipher = exports.Cipher = createCipher\nexports.createCipheriv = exports.Cipheriv = createCipheriv\nexports.createDecipher = exports.Decipher = createDecipher\nexports.createDecipheriv = exports.Decipheriv = createDecipheriv\nfunction getCiphers () {\n  return Object.keys(desModes).concat(aes.getCiphers())\n}\nexports.listCiphers = exports.getCiphers = getCiphers\n\n},{\"browserify-aes/browser\":220,\"browserify-aes/modes\":224,\"browserify-des\":234,\"browserify-des/modes\":235,\"evp_bytestokey\":283}],234:[function(require,module,exports){\n(function (Buffer){\nvar CipherBase = require('cipher-base')\nvar des = require('des.js')\nvar inherits = require('inherits')\n\nvar modes = {\n  'des-ede3-cbc': des.CBC.instantiate(des.EDE),\n  'des-ede3': des.EDE,\n  'des-ede-cbc': des.CBC.instantiate(des.EDE),\n  'des-ede': des.EDE,\n  'des-cbc': des.CBC.instantiate(des.DES),\n  'des-ecb': des.DES\n}\nmodes.des = modes['des-cbc']\nmodes.des3 = modes['des-ede3-cbc']\nmodule.exports = DES\ninherits(DES, CipherBase)\nfunction DES (opts) {\n  CipherBase.call(this)\n  var modeName = opts.mode.toLowerCase()\n  var mode = modes[modeName]\n  var type\n  if (opts.decrypt) {\n    type = 'decrypt'\n  } else {\n    type = 'encrypt'\n  }\n  var key = opts.key\n  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {\n    key = Buffer.concat([key, key.slice(0, 8)])\n  }\n  var iv = opts.iv\n  this._des = mode.create({\n    key: key,\n    iv: iv,\n    type: type\n  })\n}\nDES.prototype._update = function (data) {\n  return new Buffer(this._des.update(data))\n}\nDES.prototype._final = function () {\n  return new Buffer(this._des.final())\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243,\"cipher-base\":245,\"des.js\":253,\"inherits\":292}],235:[function(require,module,exports){\nexports['des-ecb'] = {\n  key: 8,\n  iv: 0\n}\nexports['des-cbc'] = exports.des = {\n  key: 8,\n  iv: 8\n}\nexports['des-ede3-cbc'] = exports.des3 = {\n  key: 24,\n  iv: 8\n}\nexports['des-ede3'] = {\n  key: 24,\n  iv: 0\n}\nexports['des-ede-cbc'] = {\n  key: 16,\n  iv: 8\n}\nexports['des-ede'] = {\n  key: 16,\n  iv: 0\n}\n\n},{}],236:[function(require,module,exports){\n(function (Buffer){\nvar bn = require('bn.js');\nvar randomBytes = require('randombytes');\nmodule.exports = crt;\nfunction blind(priv) {\n  var r = getr(priv);\n  var blinder = r.toRed(bn.mont(priv.modulus))\n  .redPow(new bn(priv.publicExponent)).fromRed();\n  return {\n    blinder: blinder,\n    unblinder:r.invm(priv.modulus)\n  };\n}\nfunction crt(msg, priv) {\n  var blinds = blind(priv);\n  var len = priv.modulus.byteLength();\n  var mod = bn.mont(priv.modulus);\n  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);\n  var c1 = blinded.toRed(bn.mont(priv.prime1));\n  var c2 = blinded.toRed(bn.mont(priv.prime2));\n  var qinv = priv.coefficient;\n  var p = priv.prime1;\n  var q = priv.prime2;\n  var m1 = c1.redPow(priv.exponent1);\n  var m2 = c2.redPow(priv.exponent2);\n  m1 = m1.fromRed();\n  m2 = m2.fromRed();\n  var h = m1.isub(m2).imul(qinv).umod(p);\n  h.imul(q);\n  m2.iadd(h);\n  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));\n}\ncrt.getr = getr;\nfunction getr(priv) {\n  var len = priv.modulus.byteLength();\n  var r = new bn(randomBytes(len));\n  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {\n    r = new bn(randomBytes(len));\n  }\n  return r;\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"bn.js\":215,\"buffer\":243,\"randombytes\":310}],237:[function(require,module,exports){\n(function (Buffer){\n'use strict'\nexports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {\n  sign: 'rsa',\n  hash: 'sha224',\n  id: new Buffer('302d300d06096086480165030402040500041c', 'hex')\n}\nexports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {\n  sign: 'rsa',\n  hash: 'sha256',\n  id: new Buffer('3031300d060960864801650304020105000420', 'hex')\n}\nexports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {\n  sign: 'rsa',\n  hash: 'sha384',\n  id: new Buffer('3041300d060960864801650304020205000430', 'hex')\n}\nexports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {\n  sign: 'rsa',\n  hash: 'sha512',\n  id: new Buffer('3051300d060960864801650304020305000440', 'hex')\n}\nexports['RSA-SHA1'] = {\n  sign: 'rsa',\n  hash: 'sha1',\n  id: new Buffer('3021300906052b0e03021a05000414', 'hex')\n}\nexports['ecdsa-with-SHA1'] = {\n  sign: 'ecdsa',\n  hash: 'sha1',\n  id: new Buffer('', 'hex')\n}\n\nexports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {\n  sign: 'dsa',\n  hash: 'sha1',\n  id: new Buffer('', 'hex')\n}\nexports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {\n  sign: 'dsa',\n  hash: 'sha224',\n  id: new Buffer('', 'hex')\n}\nexports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {\n  sign: 'dsa',\n  hash: 'sha256',\n  id: new Buffer('', 'hex')\n}\nexports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {\n  sign: 'dsa',\n  hash: 'sha384',\n  id: new Buffer('', 'hex')\n}\nexports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {\n  sign: 'dsa',\n  hash: 'sha512',\n  id: new Buffer('', 'hex')\n}\nexports['DSA-RIPEMD160'] = {\n  sign: 'dsa',\n  hash: 'rmd160',\n  id: new Buffer('', 'hex')\n}\nexports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {\n  sign: 'rsa',\n  hash: 'rmd160',\n  id: new Buffer('3021300906052b2403020105000414', 'hex')\n}\nexports['RSA-MD5'] = exports.md5WithRSAEncryption = {\n  sign: 'rsa',\n  hash: 'md5',\n  id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243}],238:[function(require,module,exports){\n(function (Buffer){\nvar _algos = require('./algos')\nvar createHash = require('create-hash')\nvar inherits = require('inherits')\nvar sign = require('./sign')\nvar stream = require('stream')\nvar verify = require('./verify')\n\nvar algos = {}\nObject.keys(_algos).forEach(function (key) {\n  algos[key] = algos[key.toLowerCase()] = _algos[key]\n})\n\nfunction Sign (algorithm) {\n  stream.Writable.call(this)\n\n  var data = algos[algorithm]\n  if (!data) {\n    throw new Error('Unknown message digest')\n  }\n\n  this._hashType = data.hash\n  this._hash = createHash(data.hash)\n  this._tag = data.id\n  this._signType = data.sign\n}\ninherits(Sign, stream.Writable)\n\nSign.prototype._write = function _write (data, _, done) {\n  this._hash.update(data)\n  done()\n}\n\nSign.prototype.update = function update (data, enc) {\n  if (typeof data === 'string') {\n    data = new Buffer(data, enc)\n  }\n\n  this._hash.update(data)\n  return this\n}\n\nSign.prototype.sign = function signMethod (key, enc) {\n  this.end()\n  var hash = this._hash.digest()\n  var sig = sign(Buffer.concat([this._tag, hash]), key, this._hashType, this._signType)\n\n  return enc ? sig.toString(enc) : sig\n}\n\nfunction Verify (algorithm) {\n  stream.Writable.call(this)\n\n  var data = algos[algorithm]\n  if (!data) {\n    throw new Error('Unknown message digest')\n  }\n\n  this._hash = createHash(data.hash)\n  this._tag = data.id\n  this._signType = data.sign\n}\ninherits(Verify, stream.Writable)\n\nVerify.prototype._write = function _write (data, _, done) {\n  this._hash.update(data)\n\n  done()\n}\n\nVerify.prototype.update = function update (data, enc) {\n  if (typeof data === 'string') {\n    data = new Buffer(data, enc)\n  }\n\n  this._hash.update(data)\n  return this\n}\n\nVerify.prototype.verify = function verifyMethod (key, sig, enc) {\n  if (typeof sig === 'string') {\n    sig = new Buffer(sig, enc)\n  }\n\n  this.end()\n  var hash = this._hash.digest()\n\n  return verify(sig, Buffer.concat([this._tag, hash]), key, this._signType)\n}\n\nfunction createSign (algorithm) {\n  return new Sign(algorithm)\n}\n\nfunction createVerify (algorithm) {\n  return new Verify(algorithm)\n}\n\nmodule.exports = {\n  Sign: createSign,\n  Verify: createVerify,\n  createSign: createSign,\n  createVerify: createVerify\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./algos\":237,\"./sign\":240,\"./verify\":241,\"buffer\":243,\"create-hash\":248,\"inherits\":292,\"stream\":349}],239:[function(require,module,exports){\n'use strict'\nexports['1.3.132.0.10'] = 'secp256k1'\n\nexports['1.3.132.0.33'] = 'p224'\n\nexports['1.2.840.10045.3.1.1'] = 'p192'\n\nexports['1.2.840.10045.3.1.7'] = 'p256'\n\nexports['1.3.132.0.34'] = 'p384'\n\nexports['1.3.132.0.35'] = 'p521'\n\n},{}],240:[function(require,module,exports){\n(function (Buffer){\n// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\nvar createHmac = require('create-hmac')\nvar crt = require('browserify-rsa')\nvar curves = require('./curves')\nvar elliptic = require('elliptic')\nvar parseKeys = require('parse-asn1')\n\nvar BN = require('bn.js')\nvar EC = elliptic.ec\n\nfunction sign (hash, key, hashType, signType) {\n  var priv = parseKeys(key)\n  if (priv.curve) {\n    if (signType !== 'ecdsa') throw new Error('wrong private key type')\n\n    return ecSign(hash, priv)\n  } else if (priv.type === 'dsa') {\n    if (signType !== 'dsa') {\n      throw new Error('wrong private key type')\n    }\n    return dsaSign(hash, priv, hashType)\n  } else {\n    if (signType !== 'rsa') throw new Error('wrong private key type')\n  }\n\n  var len = priv.modulus.byteLength()\n  var pad = [ 0, 1 ]\n  while (hash.length + pad.length + 1 < len) {\n    pad.push(0xff)\n  }\n  pad.push(0x00)\n  var i = -1\n  while (++i < hash.length) {\n    pad.push(hash[i])\n  }\n\n  var out = crt(pad, priv)\n  return out\n}\n\nfunction ecSign (hash, priv) {\n  var curveId = curves[priv.curve.join('.')]\n  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))\n\n  var curve = new EC(curveId)\n  var key = curve.genKeyPair()\n\n  key._importPrivate(priv.privateKey)\n  var out = key.sign(hash)\n\n  return new Buffer(out.toDER())\n}\n\nfunction dsaSign (hash, priv, algo) {\n  var x = priv.params.priv_key\n  var p = priv.params.p\n  var q = priv.params.q\n  var g = priv.params.g\n  var r = new BN(0)\n  var k\n  var H = bits2int(hash, q).mod(q)\n  var s = false\n  var kv = getKey(x, q, hash, algo)\n  while (s === false) {\n    k = makeKey(q, kv, algo)\n    r = makeR(g, k, p, q)\n    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)\n    if (!s.cmpn(0)) {\n      s = false\n      r = new BN(0)\n    }\n  }\n  return toDER(r, s)\n}\n\nfunction toDER (r, s) {\n  r = r.toArray()\n  s = s.toArray()\n\n  // Pad values\n  if (r[0] & 0x80) {\n    r = [ 0 ].concat(r)\n  }\n  // Pad values\n  if (s[0] & 0x80) {\n    s = [0].concat(s)\n  }\n\n  var total = r.length + s.length + 4\n  var res = [ 0x30, total, 0x02, r.length ]\n  res = res.concat(r, [ 0x02, s.length ], s)\n  return new Buffer(res)\n}\n\nfunction getKey (x, q, hash, algo) {\n  x = new Buffer(x.toArray())\n  if (x.length < q.byteLength()) {\n    var zeros = new Buffer(q.byteLength() - x.length)\n    zeros.fill(0)\n    x = Buffer.concat([zeros, x])\n  }\n  var hlen = hash.length\n  var hbits = bits2octets(hash, q)\n  var v = new Buffer(hlen)\n  v.fill(1)\n  var k = new Buffer(hlen)\n  k.fill(0)\n  k = createHmac(algo, k)\n    .update(v)\n    .update(new Buffer([0]))\n    .update(x)\n    .update(hbits)\n    .digest()\n  v = createHmac(algo, k)\n    .update(v)\n    .digest()\n  k = createHmac(algo, k)\n    .update(v)\n    .update(new Buffer([1]))\n    .update(x)\n    .update(hbits)\n    .digest()\n  v = createHmac(algo, k)\n    .update(v)\n    .digest()\n  return {\n    k: k,\n    v: v\n  }\n}\n\nfunction bits2int (obits, q) {\n  var bits = new BN(obits)\n  var shift = (obits.length << 3) - q.bitLength()\n  if (shift > 0) {\n    bits.ishrn(shift)\n  }\n  return bits\n}\n\nfunction bits2octets (bits, q) {\n  bits = bits2int(bits, q)\n  bits = bits.mod(q)\n  var out = new Buffer(bits.toArray())\n  if (out.length < q.byteLength()) {\n    var zeros = new Buffer(q.byteLength() - out.length)\n    zeros.fill(0)\n    out = Buffer.concat([zeros, out])\n  }\n  return out\n}\n\nfunction makeKey (q, kv, algo) {\n  var t, k\n\n  do {\n    t = new Buffer('')\n\n    while (t.length * 8 < q.bitLength()) {\n      kv.v = createHmac(algo, kv.k)\n        .update(kv.v)\n        .digest()\n      t = Buffer.concat([t, kv.v])\n    }\n\n    k = bits2int(t, q)\n    kv.k = createHmac(algo, kv.k)\n      .update(kv.v)\n      .update(new Buffer([0]))\n      .digest()\n    kv.v = createHmac(algo, kv.k)\n      .update(kv.v)\n      .digest()\n  } while (k.cmp(q) !== -1)\n\n  return k\n}\n\nfunction makeR (g, k, p, q) {\n  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)\n}\n\nmodule.exports = sign\nmodule.exports.getKey = getKey\nmodule.exports.makeKey = makeKey\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./curves\":239,\"bn.js\":215,\"browserify-rsa\":236,\"buffer\":243,\"create-hmac\":251,\"elliptic\":263,\"parse-asn1\":300}],241:[function(require,module,exports){\n(function (Buffer){\n// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\nvar curves = require('./curves')\nvar elliptic = require('elliptic')\nvar parseKeys = require('parse-asn1')\n\nvar BN = require('bn.js')\nvar EC = elliptic.ec\n\nfunction verify (sig, hash, key, signType) {\n  var pub = parseKeys(key)\n  if (pub.type === 'ec') {\n    if (signType !== 'ecdsa') {\n      throw new Error('wrong public key type')\n    }\n    return ecVerify(sig, hash, pub)\n  } else if (pub.type === 'dsa') {\n    if (signType !== 'dsa') {\n      throw new Error('wrong public key type')\n    }\n    return dsaVerify(sig, hash, pub)\n  } else {\n    if (signType !== 'rsa') {\n      throw new Error('wrong public key type')\n    }\n  }\n  var len = pub.modulus.byteLength()\n  var pad = [ 1 ]\n  var padNum = 0\n  while (hash.length + pad.length + 2 < len) {\n    pad.push(0xff)\n    padNum++\n  }\n  pad.push(0x00)\n  var i = -1\n  while (++i < hash.length) {\n    pad.push(hash[i])\n  }\n  pad = new Buffer(pad)\n  var red = BN.mont(pub.modulus)\n  sig = new BN(sig).toRed(red)\n\n  sig = sig.redPow(new BN(pub.publicExponent))\n\n  sig = new Buffer(sig.fromRed().toArray())\n  var out = 0\n  if (padNum < 8) {\n    out = 1\n  }\n  len = Math.min(sig.length, pad.length)\n  if (sig.length !== pad.length) {\n    out = 1\n  }\n\n  i = -1\n  while (++i < len) {\n    out |= (sig[i] ^ pad[i])\n  }\n  return out === 0\n}\n\nfunction ecVerify (sig, hash, pub) {\n  var curveId = curves[pub.data.algorithm.curve.join('.')]\n  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))\n\n  var curve = new EC(curveId)\n  var pubkey = pub.data.subjectPrivateKey.data\n\n  return curve.verify(hash, sig, pubkey)\n}\n\nfunction dsaVerify (sig, hash, pub) {\n  var p = pub.data.p\n  var q = pub.data.q\n  var g = pub.data.g\n  var y = pub.data.pub_key\n  var unpacked = parseKeys.signature.decode(sig, 'der')\n  var s = unpacked.s\n  var r = unpacked.r\n  checkValue(s, q)\n  checkValue(r, q)\n  var montp = BN.mont(p)\n  var w = s.invm(q)\n  var v = g.toRed(montp)\n    .redPow(new BN(hash).mul(w).mod(q))\n    .fromRed()\n    .mul(\n      y.toRed(montp)\n        .redPow(r.mul(w).mod(q))\n        .fromRed()\n  ).mod(p).mod(q)\n  return !v.cmp(r)\n}\n\nfunction checkValue (b, q) {\n  if (b.cmpn(0) <= 0) {\n    throw new Error('invalid sig')\n  }\n  if (b.cmp(q) >= q) {\n    throw new Error('invalid sig')\n  }\n}\n\nmodule.exports = verify\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./curves\":239,\"bn.js\":215,\"buffer\":243,\"elliptic\":263,\"parse-asn1\":300}],242:[function(require,module,exports){\n(function (Buffer){\nmodule.exports = function xor (a, b) {\n  var length = Math.min(a.length, b.length)\n  var buffer = new Buffer(length)\n\n  for (var i = 0; i < length; ++i) {\n    buffer[i] = a[i] ^ b[i]\n  }\n\n  return buffer\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243}],243:[function(require,module,exports){\n(function (global){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"base64-js\":214,\"ieee754\":290,\"isarray\":244}],244:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],245:[function(require,module,exports){\n(function (Buffer){\nvar Transform = require('stream').Transform\nvar inherits = require('inherits')\nvar StringDecoder = require('string_decoder').StringDecoder\nmodule.exports = CipherBase\ninherits(CipherBase, Transform)\nfunction CipherBase (hashMode) {\n  Transform.call(this)\n  this.hashMode = typeof hashMode === 'string'\n  if (this.hashMode) {\n    this[hashMode] = this._finalOrDigest\n  } else {\n    this.final = this._finalOrDigest\n  }\n  this._decoder = null\n  this._encoding = null\n}\nCipherBase.prototype.update = function (data, inputEnc, outputEnc) {\n  if (typeof data === 'string') {\n    data = new Buffer(data, inputEnc)\n  }\n  var outData = this._update(data)\n  if (this.hashMode) {\n    return this\n  }\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc)\n  }\n  return outData\n}\n\nCipherBase.prototype.setAutoPadding = function () {}\n\nCipherBase.prototype.getAuthTag = function () {\n  throw new Error('trying to get auth tag in unsupported state')\n}\n\nCipherBase.prototype.setAuthTag = function () {\n  throw new Error('trying to set auth tag in unsupported state')\n}\n\nCipherBase.prototype.setAAD = function () {\n  throw new Error('trying to set aad in unsupported state')\n}\n\nCipherBase.prototype._transform = function (data, _, next) {\n  var err\n  try {\n    if (this.hashMode) {\n      this._update(data)\n    } else {\n      this.push(this._update(data))\n    }\n  } catch (e) {\n    err = e\n  } finally {\n    next(err)\n  }\n}\nCipherBase.prototype._flush = function (done) {\n  var err\n  try {\n    this.push(this._final())\n  } catch (e) {\n    err = e\n  } finally {\n    done(err)\n  }\n}\nCipherBase.prototype._finalOrDigest = function (outputEnc) {\n  var outData = this._final() || new Buffer('')\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc, true)\n  }\n  return outData\n}\n\nCipherBase.prototype._toString = function (value, enc, final) {\n  if (!this._decoder) {\n    this._decoder = new StringDecoder(enc)\n    this._encoding = enc\n  }\n  if (this._encoding !== enc) {\n    throw new Error('can\\'t switch encodings')\n  }\n  var out = this._decoder.write(value)\n  if (final) {\n    out += this._decoder.end()\n  }\n  return out\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243,\"inherits\":292,\"stream\":349,\"string_decoder\":350}],246:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n}).call(this,{\"isBuffer\":require(\"../../is-buffer/index.js\")})\n},{\"../../is-buffer/index.js\":293}],247:[function(require,module,exports){\n(function (Buffer){\nvar elliptic = require('elliptic');\nvar BN = require('bn.js');\n\nmodule.exports = function createECDH(curve) {\n\treturn new ECDH(curve);\n};\n\nvar aliases = {\n\tsecp256k1: {\n\t\tname: 'secp256k1',\n\t\tbyteLength: 32\n\t},\n\tsecp224r1: {\n\t\tname: 'p224',\n\t\tbyteLength: 28\n\t},\n\tprime256v1: {\n\t\tname: 'p256',\n\t\tbyteLength: 32\n\t},\n\tprime192v1: {\n\t\tname: 'p192',\n\t\tbyteLength: 24\n\t},\n\ted25519: {\n\t\tname: 'ed25519',\n\t\tbyteLength: 32\n\t},\n\tsecp384r1: {\n\t\tname: 'p384',\n\t\tbyteLength: 48\n\t},\n\tsecp521r1: {\n\t\tname: 'p521',\n\t\tbyteLength: 66\n\t}\n};\n\naliases.p224 = aliases.secp224r1;\naliases.p256 = aliases.secp256r1 = aliases.prime256v1;\naliases.p192 = aliases.secp192r1 = aliases.prime192v1;\naliases.p384 = aliases.secp384r1;\naliases.p521 = aliases.secp521r1;\n\nfunction ECDH(curve) {\n\tthis.curveType = aliases[curve];\n\tif (!this.curveType ) {\n\t\tthis.curveType = {\n\t\t\tname: curve\n\t\t};\n\t}\n\tthis.curve = new elliptic.ec(this.curveType.name);\n\tthis.keys = void 0;\n}\n\nECDH.prototype.generateKeys = function (enc, format) {\n\tthis.keys = this.curve.genKeyPair();\n\treturn this.getPublicKey(enc, format);\n};\n\nECDH.prototype.computeSecret = function (other, inenc, enc) {\n\tinenc = inenc || 'utf8';\n\tif (!Buffer.isBuffer(other)) {\n\t\tother = new Buffer(other, inenc);\n\t}\n\tvar otherPub = this.curve.keyFromPublic(other).getPublic();\n\tvar out = otherPub.mul(this.keys.getPrivate()).getX();\n\treturn formatReturnValue(out, enc, this.curveType.byteLength);\n};\n\nECDH.prototype.getPublicKey = function (enc, format) {\n\tvar key = this.keys.getPublic(format === 'compressed', true);\n\tif (format === 'hybrid') {\n\t\tif (key[key.length - 1] % 2) {\n\t\t\tkey[0] = 7;\n\t\t} else {\n\t\t\tkey [0] = 6;\n\t\t}\n\t}\n\treturn formatReturnValue(key, enc);\n};\n\nECDH.prototype.getPrivateKey = function (enc) {\n\treturn formatReturnValue(this.keys.getPrivate(), enc);\n};\n\nECDH.prototype.setPublicKey = function (pub, enc) {\n\tenc = enc || 'utf8';\n\tif (!Buffer.isBuffer(pub)) {\n\t\tpub = new Buffer(pub, enc);\n\t}\n\tthis.keys._importPublic(pub);\n\treturn this;\n};\n\nECDH.prototype.setPrivateKey = function (priv, enc) {\n\tenc = enc || 'utf8';\n\tif (!Buffer.isBuffer(priv)) {\n\t\tpriv = new Buffer(priv, enc);\n\t}\n\tvar _priv = new BN(priv);\n\t_priv = _priv.toString(16);\n\tthis.keys._importPrivate(_priv);\n\treturn this;\n};\n\nfunction formatReturnValue(bn, enc, len) {\n\tif (!Array.isArray(bn)) {\n\t\tbn = bn.toArray();\n\t}\n\tvar buf = new Buffer(bn);\n\tif (len && buf.length < len) {\n\t\tvar zeros = new Buffer(len - buf.length);\n\t\tzeros.fill(0);\n\t\tbuf = Buffer.concat([zeros, buf]);\n\t}\n\tif (!enc) {\n\t\treturn buf;\n\t} else {\n\t\treturn buf.toString(enc);\n\t}\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"bn.js\":215,\"buffer\":243,\"elliptic\":263}],248:[function(require,module,exports){\n(function (Buffer){\n'use strict';\nvar inherits = require('inherits')\nvar md5 = require('./md5')\nvar rmd160 = require('ripemd160')\nvar sha = require('sha.js')\n\nvar Base = require('cipher-base')\n\nfunction HashNoConstructor(hash) {\n  Base.call(this, 'digest')\n\n  this._hash = hash\n  this.buffers = []\n}\n\ninherits(HashNoConstructor, Base)\n\nHashNoConstructor.prototype._update = function (data) {\n  this.buffers.push(data)\n}\n\nHashNoConstructor.prototype._final = function () {\n  var buf = Buffer.concat(this.buffers)\n  var r = this._hash(buf)\n  this.buffers = null\n\n  return r\n}\n\nfunction Hash(hash) {\n  Base.call(this, 'digest')\n\n  this._hash = hash\n}\n\ninherits(Hash, Base)\n\nHash.prototype._update = function (data) {\n  this._hash.update(data)\n}\n\nHash.prototype._final = function () {\n  return this._hash.digest()\n}\n\nmodule.exports = function createHash (alg) {\n  alg = alg.toLowerCase()\n  if ('md5' === alg) return new HashNoConstructor(md5)\n  if ('rmd160' === alg || 'ripemd160' === alg) return new HashNoConstructor(rmd160)\n\n  return new Hash(sha(alg))\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./md5\":250,\"buffer\":243,\"cipher-base\":245,\"inherits\":292,\"ripemd160\":322,\"sha.js\":342}],249:[function(require,module,exports){\n(function (Buffer){\n'use strict';\nvar intSize = 4;\nvar zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);\nvar chrsz = 8;\n\nfunction toArray(buf, bigEndian) {\n  if ((buf.length % intSize) !== 0) {\n    var len = buf.length + (intSize - (buf.length % intSize));\n    buf = Buffer.concat([buf, zeroBuffer], len);\n  }\n\n  var arr = [];\n  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;\n  for (var i = 0; i < buf.length; i += intSize) {\n    arr.push(fn.call(buf, i));\n  }\n  return arr;\n}\n\nfunction toBuffer(arr, size, bigEndian) {\n  var buf = new Buffer(size);\n  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;\n  for (var i = 0; i < arr.length; i++) {\n    fn.call(buf, arr[i], i * 4, true);\n  }\n  return buf;\n}\n\nfunction hash(buf, fn, hashSize, bigEndian) {\n  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);\n  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);\n  return toBuffer(arr, hashSize, bigEndian);\n}\nexports.hash = hash;\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243}],250:[function(require,module,exports){\n'use strict';\n/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\nvar helpers = require('./helpers');\n\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length\n */\nfunction core_md5(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << ((len) % 32);\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n  }\n  return Array(a, b, c, d);\n\n}\n\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\nfunction md5_cmn(q, a, b, x, s, t)\n{\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\n}\nfunction md5_ff(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n}\nfunction md5_gg(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n}\nfunction md5_hh(a, b, c, d, x, s, t)\n{\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5_ii(a, b, c, d, x, s, t)\n{\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction bit_rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\nmodule.exports = function md5(buf) {\n  return helpers.hash(buf, core_md5, 16);\n};\n},{\"./helpers\":249}],251:[function(require,module,exports){\n(function (Buffer){\n'use strict';\nvar createHash = require('create-hash/browser');\nvar inherits = require('inherits')\n\nvar Transform = require('stream').Transform\n\nvar ZEROS = new Buffer(128)\nZEROS.fill(0)\n\nfunction Hmac(alg, key) {\n  Transform.call(this)\n  alg = alg.toLowerCase()\n  if (typeof key === 'string') {\n    key = new Buffer(key)\n  }\n\n  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64\n\n  this._alg = alg\n  this._key = key\n\n  if (key.length > blocksize) {\n    key = createHash(alg).update(key).digest()\n\n  } else if (key.length < blocksize) {\n    key = Buffer.concat([key, ZEROS], blocksize)\n  }\n\n  var ipad = this._ipad = new Buffer(blocksize)\n  var opad = this._opad = new Buffer(blocksize)\n\n  for (var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  this._hash = createHash(alg).update(ipad)\n}\n\ninherits(Hmac, Transform)\n\nHmac.prototype.update = function (data, enc) {\n  this._hash.update(data, enc)\n\n  return this\n}\n\nHmac.prototype._transform = function (data, _, next) {\n  this._hash.update(data)\n\n  next()\n}\n\nHmac.prototype._flush = function (next) {\n  this.push(this.digest())\n\n  next()\n}\n\nHmac.prototype.digest = function (enc) {\n  var h = this._hash.digest()\n\n  return createHash(this._alg).update(this._opad).update(h).digest(enc)\n}\n\nmodule.exports = function createHmac(alg, key) {\n  return new Hmac(alg, key)\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243,\"create-hash/browser\":248,\"inherits\":292,\"stream\":349}],252:[function(require,module,exports){\n'use strict'\n\nexports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')\nexports.createHash = exports.Hash = require('create-hash')\nexports.createHmac = exports.Hmac = require('create-hmac')\n\nvar hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require('browserify-sign/algos')))\nexports.getHashes = function () {\n  return hashes\n}\n\nvar p = require('pbkdf2')\nexports.pbkdf2 = p.pbkdf2\nexports.pbkdf2Sync = p.pbkdf2Sync\n\nvar aes = require('browserify-cipher')\n;[\n  'Cipher',\n  'createCipher',\n  'Cipheriv',\n  'createCipheriv',\n  'Decipher',\n  'createDecipher',\n  'Decipheriv',\n  'createDecipheriv',\n  'getCiphers',\n  'listCiphers'\n].forEach(function (key) {\n  exports[key] = aes[key]\n})\n\nvar dh = require('diffie-hellman')\n;[\n  'DiffieHellmanGroup',\n  'createDiffieHellmanGroup',\n  'getDiffieHellman',\n  'createDiffieHellman',\n  'DiffieHellman'\n].forEach(function (key) {\n  exports[key] = dh[key]\n})\n\nvar sign = require('browserify-sign')\n;[\n  'createSign',\n  'Sign',\n  'createVerify',\n  'Verify'\n].forEach(function (key) {\n  exports[key] = sign[key]\n})\n\nexports.createECDH = require('create-ecdh')\n\nvar publicEncrypt = require('public-encrypt')\n\n;[\n  'publicEncrypt',\n  'privateEncrypt',\n  'publicDecrypt',\n  'privateDecrypt'\n].forEach(function (key) {\n  exports[key] = publicEncrypt[key]\n})\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n;[\n  'createCredentials'\n].forEach(function (name) {\n  exports[name] = function () {\n    throw new Error([\n      'sorry, ' + name + ' is not implemented yet',\n      'we accept pull requests',\n      'https://github.com/crypto-browserify/crypto-browserify'\n    ].join('\\n'))\n  }\n})\n\n},{\"browserify-cipher\":233,\"browserify-sign\":238,\"browserify-sign/algos\":237,\"create-ecdh\":247,\"create-hash\":248,\"create-hmac\":251,\"diffie-hellman\":259,\"pbkdf2\":301,\"public-encrypt\":304,\"randombytes\":310}],253:[function(require,module,exports){\n'use strict';\n\nexports.utils = require('./des/utils');\nexports.Cipher = require('./des/cipher');\nexports.DES = require('./des/des');\nexports.CBC = require('./des/cbc');\nexports.EDE = require('./des/ede');\n\n},{\"./des/cbc\":254,\"./des/cipher\":255,\"./des/des\":256,\"./des/ede\":257,\"./des/utils\":258}],254:[function(require,module,exports){\n'use strict';\n\nvar assert = require('minimalistic-assert');\nvar inherits = require('inherits');\n\nvar proto = {};\n\nfunction CBCState(iv) {\n  assert.equal(iv.length, 8, 'Invalid IV length');\n\n  this.iv = new Array(8);\n  for (var i = 0; i < this.iv.length; i++)\n    this.iv[i] = iv[i];\n}\n\nfunction instantiate(Base) {\n  function CBC(options) {\n    Base.call(this, options);\n    this._cbcInit();\n  }\n  inherits(CBC, Base);\n\n  var keys = Object.keys(proto);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    CBC.prototype[key] = proto[key];\n  }\n\n  CBC.create = function create(options) {\n    return new CBC(options);\n  };\n\n  return CBC;\n}\n\nexports.instantiate = instantiate;\n\nproto._cbcInit = function _cbcInit() {\n  var state = new CBCState(this.options.iv);\n  this._cbcState = state;\n};\n\nproto._update = function _update(inp, inOff, out, outOff) {\n  var state = this._cbcState;\n  var superProto = this.constructor.super_.prototype;\n\n  var iv = state.iv;\n  if (this.type === 'encrypt') {\n    for (var i = 0; i < this.blockSize; i++)\n      iv[i] ^= inp[inOff + i];\n\n    superProto._update.call(this, iv, 0, out, outOff);\n\n    for (var i = 0; i < this.blockSize; i++)\n      iv[i] = out[outOff + i];\n  } else {\n    superProto._update.call(this, inp, inOff, out, outOff);\n\n    for (var i = 0; i < this.blockSize; i++)\n      out[outOff + i] ^= iv[i];\n\n    for (var i = 0; i < this.blockSize; i++)\n      iv[i] = inp[inOff + i];\n  }\n};\n\n},{\"inherits\":292,\"minimalistic-assert\":296}],255:[function(require,module,exports){\n'use strict';\n\nvar assert = require('minimalistic-assert');\n\nfunction Cipher(options) {\n  this.options = options;\n\n  this.type = this.options.type;\n  this.blockSize = 8;\n  this._init();\n\n  this.buffer = new Array(this.blockSize);\n  this.bufferOff = 0;\n}\nmodule.exports = Cipher;\n\nCipher.prototype._init = function _init() {\n  // Might be overrided\n};\n\nCipher.prototype.update = function update(data) {\n  if (data.length === 0)\n    return [];\n\n  if (this.type === 'decrypt')\n    return this._updateDecrypt(data);\n  else\n    return this._updateEncrypt(data);\n};\n\nCipher.prototype._buffer = function _buffer(data, off) {\n  // Append data to buffer\n  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);\n  for (var i = 0; i < min; i++)\n    this.buffer[this.bufferOff + i] = data[off + i];\n  this.bufferOff += min;\n\n  // Shift next\n  return min;\n};\n\nCipher.prototype._flushBuffer = function _flushBuffer(out, off) {\n  this._update(this.buffer, 0, out, off);\n  this.bufferOff = 0;\n  return this.blockSize;\n};\n\nCipher.prototype._updateEncrypt = function _updateEncrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;\n  var out = new Array(count * this.blockSize);\n\n  if (this.bufferOff !== 0) {\n    inputOff += this._buffer(data, inputOff);\n\n    if (this.bufferOff === this.buffer.length)\n      outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Write blocks\n  var max = data.length - ((data.length - inputOff) % this.blockSize);\n  for (; inputOff < max; inputOff += this.blockSize) {\n    this._update(data, inputOff, out, outputOff);\n    outputOff += this.blockSize;\n  }\n\n  // Queue rest\n  for (; inputOff < data.length; inputOff++, this.bufferOff++)\n    this.buffer[this.bufferOff] = data[inputOff];\n\n  return out;\n};\n\nCipher.prototype._updateDecrypt = function _updateDecrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;\n  var out = new Array(count * this.blockSize);\n\n  // TODO(indutny): optimize it, this is far from optimal\n  for (; count > 0; count--) {\n    inputOff += this._buffer(data, inputOff);\n    outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Buffer rest of the input\n  inputOff += this._buffer(data, inputOff);\n\n  return out;\n};\n\nCipher.prototype.final = function final(buffer) {\n  var first;\n  if (buffer)\n    first = this.update(buffer);\n\n  var last;\n  if (this.type === 'encrypt')\n    last = this._finalEncrypt();\n  else\n    last = this._finalDecrypt();\n\n  if (first)\n    return first.concat(last);\n  else\n    return last;\n};\n\nCipher.prototype._pad = function _pad(buffer, off) {\n  if (off === 0)\n    return false;\n\n  while (off < buffer.length)\n    buffer[off++] = 0;\n\n  return true;\n};\n\nCipher.prototype._finalEncrypt = function _finalEncrypt() {\n  if (!this._pad(this.buffer, this.bufferOff))\n    return [];\n\n  var out = new Array(this.blockSize);\n  this._update(this.buffer, 0, out, 0);\n  return out;\n};\n\nCipher.prototype._unpad = function _unpad(buffer) {\n  return buffer;\n};\n\nCipher.prototype._finalDecrypt = function _finalDecrypt() {\n  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');\n  var out = new Array(this.blockSize);\n  this._flushBuffer(out, 0);\n\n  return this._unpad(out);\n};\n\n},{\"minimalistic-assert\":296}],256:[function(require,module,exports){\n'use strict';\n\nvar assert = require('minimalistic-assert');\nvar inherits = require('inherits');\n\nvar des = require('../des');\nvar utils = des.utils;\nvar Cipher = des.Cipher;\n\nfunction DESState() {\n  this.tmp = new Array(2);\n  this.keys = null;\n}\n\nfunction DES(options) {\n  Cipher.call(this, options);\n\n  var state = new DESState();\n  this._desState = state;\n\n  this.deriveKeys(state, options.key);\n}\ninherits(DES, Cipher);\nmodule.exports = DES;\n\nDES.create = function create(options) {\n  return new DES(options);\n};\n\nvar shiftTable = [\n  1, 1, 2, 2, 2, 2, 2, 2,\n  1, 2, 2, 2, 2, 2, 2, 1\n];\n\nDES.prototype.deriveKeys = function deriveKeys(state, key) {\n  state.keys = new Array(16 * 2);\n\n  assert.equal(key.length, this.blockSize, 'Invalid key length');\n\n  var kL = utils.readUInt32BE(key, 0);\n  var kR = utils.readUInt32BE(key, 4);\n\n  utils.pc1(kL, kR, state.tmp, 0);\n  kL = state.tmp[0];\n  kR = state.tmp[1];\n  for (var i = 0; i < state.keys.length; i += 2) {\n    var shift = shiftTable[i >>> 1];\n    kL = utils.r28shl(kL, shift);\n    kR = utils.r28shl(kR, shift);\n    utils.pc2(kL, kR, state.keys, i);\n  }\n};\n\nDES.prototype._update = function _update(inp, inOff, out, outOff) {\n  var state = this._desState;\n\n  var l = utils.readUInt32BE(inp, inOff);\n  var r = utils.readUInt32BE(inp, inOff + 4);\n\n  // Initial Permutation\n  utils.ip(l, r, state.tmp, 0);\n  l = state.tmp[0];\n  r = state.tmp[1];\n\n  if (this.type === 'encrypt')\n    this._encrypt(state, l, r, state.tmp, 0);\n  else\n    this._decrypt(state, l, r, state.tmp, 0);\n\n  l = state.tmp[0];\n  r = state.tmp[1];\n\n  utils.writeUInt32BE(out, l, outOff);\n  utils.writeUInt32BE(out, r, outOff + 4);\n};\n\nDES.prototype._pad = function _pad(buffer, off) {\n  var value = buffer.length - off;\n  for (var i = off; i < buffer.length; i++)\n    buffer[i] = value;\n\n  return true;\n};\n\nDES.prototype._unpad = function _unpad(buffer) {\n  var pad = buffer[buffer.length - 1];\n  for (var i = buffer.length - pad; i < buffer.length; i++)\n    assert.equal(buffer[i], pad);\n\n  return buffer.slice(0, buffer.length - pad);\n};\n\nDES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {\n  var l = lStart;\n  var r = rStart;\n\n  // Apply f() x16 times\n  for (var i = 0; i < state.keys.length; i += 2) {\n    var keyL = state.keys[i];\n    var keyR = state.keys[i + 1];\n\n    // f(r, k)\n    utils.expand(r, state.tmp, 0);\n\n    keyL ^= state.tmp[0];\n    keyR ^= state.tmp[1];\n    var s = utils.substitute(keyL, keyR);\n    var f = utils.permute(s);\n\n    var t = r;\n    r = (l ^ f) >>> 0;\n    l = t;\n  }\n\n  // Reverse Initial Permutation\n  utils.rip(r, l, out, off);\n};\n\nDES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {\n  var l = rStart;\n  var r = lStart;\n\n  // Apply f() x16 times\n  for (var i = state.keys.length - 2; i >= 0; i -= 2) {\n    var keyL = state.keys[i];\n    var keyR = state.keys[i + 1];\n\n    // f(r, k)\n    utils.expand(l, state.tmp, 0);\n\n    keyL ^= state.tmp[0];\n    keyR ^= state.tmp[1];\n    var s = utils.substitute(keyL, keyR);\n    var f = utils.permute(s);\n\n    var t = l;\n    l = (r ^ f) >>> 0;\n    r = t;\n  }\n\n  // Reverse Initial Permutation\n  utils.rip(l, r, out, off);\n};\n\n},{\"../des\":253,\"inherits\":292,\"minimalistic-assert\":296}],257:[function(require,module,exports){\n'use strict';\n\nvar assert = require('minimalistic-assert');\nvar inherits = require('inherits');\n\nvar des = require('../des');\nvar Cipher = des.Cipher;\nvar DES = des.DES;\n\nfunction EDEState(type, key) {\n  assert.equal(key.length, 24, 'Invalid key length');\n\n  var k1 = key.slice(0, 8);\n  var k2 = key.slice(8, 16);\n  var k3 = key.slice(16, 24);\n\n  if (type === 'encrypt') {\n    this.ciphers = [\n      DES.create({ type: 'encrypt', key: k1 }),\n      DES.create({ type: 'decrypt', key: k2 }),\n      DES.create({ type: 'encrypt', key: k3 })\n    ];\n  } else {\n    this.ciphers = [\n      DES.create({ type: 'decrypt', key: k3 }),\n      DES.create({ type: 'encrypt', key: k2 }),\n      DES.create({ type: 'decrypt', key: k1 })\n    ];\n  }\n}\n\nfunction EDE(options) {\n  Cipher.call(this, options);\n\n  var state = new EDEState(this.type, this.options.key);\n  this._edeState = state;\n}\ninherits(EDE, Cipher);\n\nmodule.exports = EDE;\n\nEDE.create = function create(options) {\n  return new EDE(options);\n};\n\nEDE.prototype._update = function _update(inp, inOff, out, outOff) {\n  var state = this._edeState;\n\n  state.ciphers[0]._update(inp, inOff, out, outOff);\n  state.ciphers[1]._update(out, outOff, out, outOff);\n  state.ciphers[2]._update(out, outOff, out, outOff);\n};\n\nEDE.prototype._pad = DES.prototype._pad;\nEDE.prototype._unpad = DES.prototype._unpad;\n\n},{\"../des\":253,\"inherits\":292,\"minimalistic-assert\":296}],258:[function(require,module,exports){\n'use strict';\n\nexports.readUInt32BE = function readUInt32BE(bytes, off) {\n  var res =  (bytes[0 + off] << 24) |\n             (bytes[1 + off] << 16) |\n             (bytes[2 + off] << 8) |\n             bytes[3 + off];\n  return res >>> 0;\n};\n\nexports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {\n  bytes[0 + off] = value >>> 24;\n  bytes[1 + off] = (value >>> 16) & 0xff;\n  bytes[2 + off] = (value >>> 8) & 0xff;\n  bytes[3 + off] = value & 0xff;\n};\n\nexports.ip = function ip(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  for (var i = 6; i >= 0; i -= 2) {\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inR >>> (j + i)) & 1;\n    }\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inL >>> (j + i)) & 1;\n    }\n  }\n\n  for (var i = 6; i >= 0; i -= 2) {\n    for (var j = 1; j <= 25; j += 8) {\n      outR <<= 1;\n      outR |= (inR >>> (j + i)) & 1;\n    }\n    for (var j = 1; j <= 25; j += 8) {\n      outR <<= 1;\n      outR |= (inL >>> (j + i)) & 1;\n    }\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.rip = function rip(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  for (var i = 0; i < 4; i++) {\n    for (var j = 24; j >= 0; j -= 8) {\n      outL <<= 1;\n      outL |= (inR >>> (j + i)) & 1;\n      outL <<= 1;\n      outL |= (inL >>> (j + i)) & 1;\n    }\n  }\n  for (var i = 4; i < 8; i++) {\n    for (var j = 24; j >= 0; j -= 8) {\n      outR <<= 1;\n      outR |= (inR >>> (j + i)) & 1;\n      outR <<= 1;\n      outR |= (inL >>> (j + i)) & 1;\n    }\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.pc1 = function pc1(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  // 7, 15, 23, 31, 39, 47, 55, 63\n  // 6, 14, 22, 30, 39, 47, 55, 63\n  // 5, 13, 21, 29, 39, 47, 55, 63\n  // 4, 12, 20, 28\n  for (var i = 7; i >= 5; i--) {\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inR >> (j + i)) & 1;\n    }\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inL >> (j + i)) & 1;\n    }\n  }\n  for (var j = 0; j <= 24; j += 8) {\n    outL <<= 1;\n    outL |= (inR >> (j + i)) & 1;\n  }\n\n  // 1, 9, 17, 25, 33, 41, 49, 57\n  // 2, 10, 18, 26, 34, 42, 50, 58\n  // 3, 11, 19, 27, 35, 43, 51, 59\n  // 36, 44, 52, 60\n  for (var i = 1; i <= 3; i++) {\n    for (var j = 0; j <= 24; j += 8) {\n      outR <<= 1;\n      outR |= (inR >> (j + i)) & 1;\n    }\n    for (var j = 0; j <= 24; j += 8) {\n      outR <<= 1;\n      outR |= (inL >> (j + i)) & 1;\n    }\n  }\n  for (var j = 0; j <= 24; j += 8) {\n    outR <<= 1;\n    outR |= (inL >> (j + i)) & 1;\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.r28shl = function r28shl(num, shift) {\n  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));\n};\n\nvar pc2table = [\n  // inL => outL\n  14, 11, 17, 4, 27, 23, 25, 0,\n  13, 22, 7, 18, 5, 9, 16, 24,\n  2, 20, 12, 21, 1, 8, 15, 26,\n\n  // inR => outR\n  15, 4, 25, 19, 9, 1, 26, 16,\n  5, 11, 23, 8, 12, 7, 17, 0,\n  22, 3, 10, 14, 6, 20, 27, 24\n];\n\nexports.pc2 = function pc2(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  var len = pc2table.length >>> 1;\n  for (var i = 0; i < len; i++) {\n    outL <<= 1;\n    outL |= (inL >>> pc2table[i]) & 0x1;\n  }\n  for (var i = len; i < pc2table.length; i++) {\n    outR <<= 1;\n    outR |= (inR >>> pc2table[i]) & 0x1;\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.expand = function expand(r, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  outL = ((r & 1) << 5) | (r >>> 27);\n  for (var i = 23; i >= 15; i -= 4) {\n    outL <<= 6;\n    outL |= (r >>> i) & 0x3f;\n  }\n  for (var i = 11; i >= 3; i -= 4) {\n    outR |= (r >>> i) & 0x3f;\n    outR <<= 6;\n  }\n  outR |= ((r & 0x1f) << 1) | (r >>> 31);\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nvar sTable = [\n  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,\n  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,\n  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,\n  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,\n\n  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,\n  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,\n  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,\n  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,\n\n  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,\n  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,\n  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,\n  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,\n\n  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,\n  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,\n  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,\n  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,\n\n  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,\n  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,\n  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,\n  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,\n\n  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,\n  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,\n  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,\n  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,\n\n  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,\n  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,\n  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,\n  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,\n\n  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,\n  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,\n  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,\n  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11\n];\n\nexports.substitute = function substitute(inL, inR) {\n  var out = 0;\n  for (var i = 0; i < 4; i++) {\n    var b = (inL >>> (18 - i * 6)) & 0x3f;\n    var sb = sTable[i * 0x40 + b];\n\n    out <<= 4;\n    out |= sb;\n  }\n  for (var i = 0; i < 4; i++) {\n    var b = (inR >>> (18 - i * 6)) & 0x3f;\n    var sb = sTable[4 * 0x40 + i * 0x40 + b];\n\n    out <<= 4;\n    out |= sb;\n  }\n  return out >>> 0;\n};\n\nvar permuteTable = [\n  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,\n  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7\n];\n\nexports.permute = function permute(num) {\n  var out = 0;\n  for (var i = 0; i < permuteTable.length; i++) {\n    out <<= 1;\n    out |= (num >>> permuteTable[i]) & 0x1;\n  }\n  return out >>> 0;\n};\n\nexports.padSplit = function padSplit(num, size, group) {\n  var str = num.toString(2);\n  while (str.length < size)\n    str = '0' + str;\n\n  var out = [];\n  for (var i = 0; i < size; i += group)\n    out.push(str.slice(i, i + group));\n  return out.join(' ');\n};\n\n},{}],259:[function(require,module,exports){\n(function (Buffer){\nvar generatePrime = require('./lib/generatePrime')\nvar primes = require('./lib/primes')\n\nvar DH = require('./lib/dh')\n\nfunction getDiffieHellman (mod) {\n  var prime = new Buffer(primes[mod].prime, 'hex')\n  var gen = new Buffer(primes[mod].gen, 'hex')\n\n  return new DH(prime, gen)\n}\n\nvar ENCODINGS = {\n  'binary': true, 'hex': true, 'base64': true\n}\n\nfunction createDiffieHellman (prime, enc, generator, genc) {\n  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {\n    return createDiffieHellman(prime, 'binary', enc, generator)\n  }\n\n  enc = enc || 'binary'\n  genc = genc || 'binary'\n  generator = generator || new Buffer([2])\n\n  if (!Buffer.isBuffer(generator)) {\n    generator = new Buffer(generator, genc)\n  }\n\n  if (typeof prime === 'number') {\n    return new DH(generatePrime(prime, generator), generator, true)\n  }\n\n  if (!Buffer.isBuffer(prime)) {\n    prime = new Buffer(prime, enc)\n  }\n\n  return new DH(prime, generator, true)\n}\n\nexports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman\nexports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./lib/dh\":260,\"./lib/generatePrime\":261,\"./lib/primes\":262,\"buffer\":243}],260:[function(require,module,exports){\n(function (Buffer){\nvar BN = require('bn.js');\nvar MillerRabin = require('miller-rabin');\nvar millerRabin = new MillerRabin();\nvar TWENTYFOUR = new BN(24);\nvar ELEVEN = new BN(11);\nvar TEN = new BN(10);\nvar THREE = new BN(3);\nvar SEVEN = new BN(7);\nvar primes = require('./generatePrime');\nvar randomBytes = require('randombytes');\nmodule.exports = DH;\n\nfunction setPublicKey(pub, enc) {\n  enc = enc || 'utf8';\n  if (!Buffer.isBuffer(pub)) {\n    pub = new Buffer(pub, enc);\n  }\n  this._pub = new BN(pub);\n  return this;\n}\n\nfunction setPrivateKey(priv, enc) {\n  enc = enc || 'utf8';\n  if (!Buffer.isBuffer(priv)) {\n    priv = new Buffer(priv, enc);\n  }\n  this._priv = new BN(priv);\n  return this;\n}\n\nvar primeCache = {};\nfunction checkPrime(prime, generator) {\n  var gen = generator.toString('hex');\n  var hex = [gen, prime.toString(16)].join('_');\n  if (hex in primeCache) {\n    return primeCache[hex];\n  }\n  var error = 0;\n\n  if (prime.isEven() ||\n    !primes.simpleSieve ||\n    !primes.fermatTest(prime) ||\n    !millerRabin.test(prime)) {\n    //not a prime so +1\n    error += 1;\n\n    if (gen === '02' || gen === '05') {\n      // we'd be able to check the generator\n      // it would fail so +8\n      error += 8;\n    } else {\n      //we wouldn't be able to test the generator\n      // so +4\n      error += 4;\n    }\n    primeCache[hex] = error;\n    return error;\n  }\n  if (!millerRabin.test(prime.shrn(1))) {\n    //not a safe prime\n    error += 2;\n  }\n  var rem;\n  switch (gen) {\n    case '02':\n      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {\n        // unsuidable generator\n        error += 8;\n      }\n      break;\n    case '05':\n      rem = prime.mod(TEN);\n      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {\n        // prime mod 10 needs to equal 3 or 7\n        error += 8;\n      }\n      break;\n    default:\n      error += 4;\n  }\n  primeCache[hex] = error;\n  return error;\n}\n\nfunction DH(prime, generator, malleable) {\n  this.setGenerator(generator);\n  this.__prime = new BN(prime);\n  this._prime = BN.mont(this.__prime);\n  this._primeLen = prime.length;\n  this._pub = undefined;\n  this._priv = undefined;\n  this._primeCode = undefined;\n  if (malleable) {\n    this.setPublicKey = setPublicKey;\n    this.setPrivateKey = setPrivateKey;\n  } else {\n    this._primeCode = 8;\n  }\n}\nObject.defineProperty(DH.prototype, 'verifyError', {\n  enumerable: true,\n  get: function () {\n    if (typeof this._primeCode !== 'number') {\n      this._primeCode = checkPrime(this.__prime, this.__gen);\n    }\n    return this._primeCode;\n  }\n});\nDH.prototype.generateKeys = function () {\n  if (!this._priv) {\n    this._priv = new BN(randomBytes(this._primeLen));\n  }\n  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();\n  return this.getPublicKey();\n};\n\nDH.prototype.computeSecret = function (other) {\n  other = new BN(other);\n  other = other.toRed(this._prime);\n  var secret = other.redPow(this._priv).fromRed();\n  var out = new Buffer(secret.toArray());\n  var prime = this.getPrime();\n  if (out.length < prime.length) {\n    var front = new Buffer(prime.length - out.length);\n    front.fill(0);\n    out = Buffer.concat([front, out]);\n  }\n  return out;\n};\n\nDH.prototype.getPublicKey = function getPublicKey(enc) {\n  return formatReturnValue(this._pub, enc);\n};\n\nDH.prototype.getPrivateKey = function getPrivateKey(enc) {\n  return formatReturnValue(this._priv, enc);\n};\n\nDH.prototype.getPrime = function (enc) {\n  return formatReturnValue(this.__prime, enc);\n};\n\nDH.prototype.getGenerator = function (enc) {\n  return formatReturnValue(this._gen, enc);\n};\n\nDH.prototype.setGenerator = function (gen, enc) {\n  enc = enc || 'utf8';\n  if (!Buffer.isBuffer(gen)) {\n    gen = new Buffer(gen, enc);\n  }\n  this.__gen = gen;\n  this._gen = new BN(gen);\n  return this;\n};\n\nfunction formatReturnValue(bn, enc) {\n  var buf = new Buffer(bn.toArray());\n  if (!enc) {\n    return buf;\n  } else {\n    return buf.toString(enc);\n  }\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./generatePrime\":261,\"bn.js\":215,\"buffer\":243,\"miller-rabin\":295,\"randombytes\":310}],261:[function(require,module,exports){\nvar randomBytes = require('randombytes');\nmodule.exports = findPrime;\nfindPrime.simpleSieve = simpleSieve;\nfindPrime.fermatTest = fermatTest;\nvar BN = require('bn.js');\nvar TWENTYFOUR = new BN(24);\nvar MillerRabin = require('miller-rabin');\nvar millerRabin = new MillerRabin();\nvar ONE = new BN(1);\nvar TWO = new BN(2);\nvar FIVE = new BN(5);\nvar SIXTEEN = new BN(16);\nvar EIGHT = new BN(8);\nvar TEN = new BN(10);\nvar THREE = new BN(3);\nvar SEVEN = new BN(7);\nvar ELEVEN = new BN(11);\nvar FOUR = new BN(4);\nvar TWELVE = new BN(12);\nvar primes = null;\n\nfunction _getPrimes() {\n  if (primes !== null)\n    return primes;\n\n  var limit = 0x100000;\n  var res = [];\n  res[0] = 2;\n  for (var i = 1, k = 3; k < limit; k += 2) {\n    var sqrt = Math.ceil(Math.sqrt(k));\n    for (var j = 0; j < i && res[j] <= sqrt; j++)\n      if (k % res[j] === 0)\n        break;\n\n    if (i !== j && res[j] <= sqrt)\n      continue;\n\n    res[i++] = k;\n  }\n  primes = res;\n  return res;\n}\n\nfunction simpleSieve(p) {\n  var primes = _getPrimes();\n\n  for (var i = 0; i < primes.length; i++)\n    if (p.modn(primes[i]) === 0) {\n      if (p.cmpn(primes[i]) === 0) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n  return true;\n}\n\nfunction fermatTest(p) {\n  var red = BN.mont(p);\n  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;\n}\n\nfunction findPrime(bits, gen) {\n  if (bits < 16) {\n    // this is what openssl does\n    if (gen === 2 || gen === 5) {\n      return new BN([0x8c, 0x7b]);\n    } else {\n      return new BN([0x8c, 0x27]);\n    }\n  }\n  gen = new BN(gen);\n\n  var num, n2;\n\n  while (true) {\n    num = new BN(randomBytes(Math.ceil(bits / 8)));\n    while (num.bitLength() > bits) {\n      num.ishrn(1);\n    }\n    if (num.isEven()) {\n      num.iadd(ONE);\n    }\n    if (!num.testn(1)) {\n      num.iadd(TWO);\n    }\n    if (!gen.cmp(TWO)) {\n      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {\n        num.iadd(FOUR);\n      }\n    } else if (!gen.cmp(FIVE)) {\n      while (num.mod(TEN).cmp(THREE)) {\n        num.iadd(FOUR);\n      }\n    }\n    n2 = num.shrn(1);\n    if (simpleSieve(n2) && simpleSieve(num) &&\n      fermatTest(n2) && fermatTest(num) &&\n      millerRabin.test(n2) && millerRabin.test(num)) {\n      return num;\n    }\n  }\n\n}\n\n},{\"bn.js\":215,\"miller-rabin\":295,\"randombytes\":310}],262:[function(require,module,exports){\nmodule.exports={\n    \"modp1\": {\n        \"gen\": \"02\",\n        \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff\"\n    },\n    \"modp2\": {\n        \"gen\": \"02\",\n        \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff\"\n    },\n    \"modp5\": {\n        \"gen\": \"02\",\n        \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff\"\n    },\n    \"modp14\": {\n        \"gen\": \"02\",\n        \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff\"\n    },\n    \"modp15\": {\n        \"gen\": \"02\",\n        \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff\"\n    },\n    \"modp16\": {\n        \"gen\": \"02\",\n        \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff\"\n    },\n    \"modp17\": {\n        \"gen\": \"02\",\n        \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff\"\n    },\n    \"modp18\": {\n        \"gen\": \"02\",\n        \"prime\": \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff\"\n    }\n}\n},{}],263:[function(require,module,exports){\n'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.hmacDRBG = require('./elliptic/hmac-drbg');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n\n},{\"../package.json\":279,\"./elliptic/curve\":266,\"./elliptic/curves\":269,\"./elliptic/ec\":270,\"./elliptic/eddsa\":273,\"./elliptic/hmac-drbg\":276,\"./elliptic/utils\":278,\"brorand\":216}],264:[function(require,module,exports){\n'use strict';\n\nvar BN = require('bn.js');\nvar elliptic = require('../../elliptic');\nvar utils = elliptic.utils;\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  for (var j = 0; j < naf.length; j += doubles.step) {\n    var nafW = 0;\n    for (var k = j + doubles.step - 1; k >= j; k--)\n      nafW = (nafW << 1) + naf[k];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (var j = 0; j < repr.length; j++) {\n      var nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var k = 0; i >= 0 && naf[i] === 0; i--)\n      k++;\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n                                                       points,\n                                                       coeffs,\n                                                       len) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  for (var i = 0; i < len; i++) {\n    var p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (var i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a]);\n      naf[b] = getNAF(coeffs[b], wndWidth[b]);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b] /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (var j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (var i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (var j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (var j = 0; j < len; j++) {\n      var z = tmp[j];\n      var p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (var i = 0; i < len; i++)\n    wnd[i] = null;\n  return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n  if (bytes[0] === 0x04 && bytes.length - 1 === 2 * len) {\n    return this.point(bytes.slice(1, 1 + len),\n                      bytes.slice(1 + len, 1 + 2 * len));\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n\n},{\"../../elliptic\":263,\"bn.js\":215}],265:[function(require,module,exports){\n'use strict';\n\nvar curve = require('../curve');\nvar elliptic = require('../../elliptic');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = curve.base;\n\nvar assert = elliptic.utils.assert;\n\nfunction EdwardsCurve(conf) {\n  // NOTE: Important as we are creating point in Base.call()\n  this.twisted = (conf.a | 0) !== 1;\n  this.mOneA = this.twisted && (conf.a | 0) === -1;\n  this.extended = this.mOneA;\n\n  Base.call(this, 'edwards', conf);\n\n  this.a = new BN(conf.a, 16).umod(this.red.m);\n  this.a = this.a.toRed(this.red);\n  this.c = new BN(conf.c, 16).toRed(this.red);\n  this.c2 = this.c.redSqr();\n  this.d = new BN(conf.d, 16).toRed(this.red);\n  this.dd = this.d.redAdd(this.d);\n\n  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);\n  this.oneC = (conf.c | 0) === 1;\n}\ninherits(EdwardsCurve, Base);\nmodule.exports = EdwardsCurve;\n\nEdwardsCurve.prototype._mulA = function _mulA(num) {\n  if (this.mOneA)\n    return num.redNeg();\n  else\n    return this.a.redMul(num);\n};\n\nEdwardsCurve.prototype._mulC = function _mulC(num) {\n  if (this.oneC)\n    return num;\n  else\n    return this.c.redMul(num);\n};\n\n// Just for compatibility with Short curve\nEdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {\n  return this.point(x, y, z, t);\n};\n\nEdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var x2 = x.redSqr();\n  var rhs = this.c2.redSub(this.a.redMul(x2));\n  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));\n\n  var y = rhs.redMul(lhs.redInvm()).redSqrt();\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nEdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {\n  y = new BN(y, 16);\n  if (!y.red)\n    y = y.toRed(this.red);\n\n  // x^2 = (y^2 - 1) / (d y^2 + 1)\n  var y2 = y.redSqr();\n  var lhs = y2.redSub(this.one);\n  var rhs = y2.redMul(this.d).redAdd(this.one);\n  var x2 = lhs.redMul(rhs.redInvm());\n\n  if (x2.cmp(this.zero) === 0) {\n    if (odd)\n      throw new Error('invalid point');\n    else\n      return this.point(this.zero, y);\n  }\n\n  var x = x2.redSqrt();\n  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  if (x.isOdd() !== odd)\n    x = x.redNeg();\n\n  return this.point(x, y);\n};\n\nEdwardsCurve.prototype.validate = function validate(point) {\n  if (point.isInfinity())\n    return true;\n\n  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)\n  point.normalize();\n\n  var x2 = point.x.redSqr();\n  var y2 = point.y.redSqr();\n  var lhs = x2.redMul(this.a).redAdd(y2);\n  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));\n\n  return lhs.cmp(rhs) === 0;\n};\n\nfunction Point(curve, x, y, z, t) {\n  Base.BasePoint.call(this, curve, 'projective');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.zero;\n    this.y = this.curve.one;\n    this.z = this.curve.one;\n    this.t = this.curve.zero;\n    this.zOne = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = z ? new BN(z, 16) : this.curve.one;\n    this.t = t && new BN(t, 16);\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n    if (this.t && !this.t.red)\n      this.t = this.t.toRed(this.curve.red);\n    this.zOne = this.z === this.curve.one;\n\n    // Use extended coordinates\n    if (this.curve.extended && !this.t) {\n      this.t = this.x.redMul(this.y);\n      if (!this.zOne)\n        this.t = this.t.redMul(this.z.redInvm());\n    }\n  }\n}\ninherits(Point, Base.BasePoint);\n\nEdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\n  return Point.fromJSON(this, obj);\n};\n\nEdwardsCurve.prototype.point = function point(x, y, z, t) {\n  return new Point(this, x, y, z, t);\n};\n\nPoint.fromJSON = function fromJSON(curve, obj) {\n  return new Point(curve, obj[0], obj[1], obj[2]);\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) +\n      ' z: ' + this.z.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.x.cmpn(0) === 0 &&\n         this.y.cmp(this.z) === 0;\n};\n\nPoint.prototype._extDbl = function _extDbl() {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html\n  //     #doubling-dbl-2008-hwcd\n  // 4M + 4S\n\n  // A = X1^2\n  var a = this.x.redSqr();\n  // B = Y1^2\n  var b = this.y.redSqr();\n  // C = 2 * Z1^2\n  var c = this.z.redSqr();\n  c = c.redIAdd(c);\n  // D = a * A\n  var d = this.curve._mulA(a);\n  // E = (X1 + Y1)^2 - A - B\n  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);\n  // G = D + B\n  var g = d.redAdd(b);\n  // F = G - C\n  var f = g.redSub(c);\n  // H = D - B\n  var h = d.redSub(b);\n  // X3 = E * F\n  var nx = e.redMul(f);\n  // Y3 = G * H\n  var ny = g.redMul(h);\n  // T3 = E * H\n  var nt = e.redMul(h);\n  // Z3 = F * G\n  var nz = f.redMul(g);\n  return this.curve.point(nx, ny, nz, nt);\n};\n\nPoint.prototype._projDbl = function _projDbl() {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html\n  //     #doubling-dbl-2008-bbjlp\n  //     #doubling-dbl-2007-bl\n  // and others\n  // Generally 3M + 4S or 2M + 4S\n\n  // B = (X1 + Y1)^2\n  var b = this.x.redAdd(this.y).redSqr();\n  // C = X1^2\n  var c = this.x.redSqr();\n  // D = Y1^2\n  var d = this.y.redSqr();\n\n  var nx;\n  var ny;\n  var nz;\n  if (this.curve.twisted) {\n    // E = a * C\n    var e = this.curve._mulA(c);\n    // F = E + D\n    var f = e.redAdd(d);\n    if (this.zOne) {\n      // X3 = (B - C - D) * (F - 2)\n      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));\n      // Y3 = F * (E - D)\n      ny = f.redMul(e.redSub(d));\n      // Z3 = F^2 - 2 * F\n      nz = f.redSqr().redSub(f).redSub(f);\n    } else {\n      // H = Z1^2\n      var h = this.z.redSqr();\n      // J = F - 2 * H\n      var j = f.redSub(h).redISub(h);\n      // X3 = (B-C-D)*J\n      nx = b.redSub(c).redISub(d).redMul(j);\n      // Y3 = F * (E - D)\n      ny = f.redMul(e.redSub(d));\n      // Z3 = F * J\n      nz = f.redMul(j);\n    }\n  } else {\n    // E = C + D\n    var e = c.redAdd(d);\n    // H = (c * Z1)^2\n    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();\n    // J = E - 2 * H\n    var j = e.redSub(h).redSub(h);\n    // X3 = c * (B - E) * J\n    nx = this.curve._mulC(b.redISub(e)).redMul(j);\n    // Y3 = c * E * (C - D)\n    ny = this.curve._mulC(e).redMul(c.redISub(d));\n    // Z3 = E * J\n    nz = e.redMul(j);\n  }\n  return this.curve.point(nx, ny, nz);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  // Double in extended coordinates\n  if (this.curve.extended)\n    return this._extDbl();\n  else\n    return this._projDbl();\n};\n\nPoint.prototype._extAdd = function _extAdd(p) {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html\n  //     #addition-add-2008-hwcd-3\n  // 8M\n\n  // A = (Y1 - X1) * (Y2 - X2)\n  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));\n  // B = (Y1 + X1) * (Y2 + X2)\n  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));\n  // C = T1 * k * T2\n  var c = this.t.redMul(this.curve.dd).redMul(p.t);\n  // D = Z1 * 2 * Z2\n  var d = this.z.redMul(p.z.redAdd(p.z));\n  // E = B - A\n  var e = b.redSub(a);\n  // F = D - C\n  var f = d.redSub(c);\n  // G = D + C\n  var g = d.redAdd(c);\n  // H = B + A\n  var h = b.redAdd(a);\n  // X3 = E * F\n  var nx = e.redMul(f);\n  // Y3 = G * H\n  var ny = g.redMul(h);\n  // T3 = E * H\n  var nt = e.redMul(h);\n  // Z3 = F * G\n  var nz = f.redMul(g);\n  return this.curve.point(nx, ny, nz, nt);\n};\n\nPoint.prototype._projAdd = function _projAdd(p) {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html\n  //     #addition-add-2008-bbjlp\n  //     #addition-add-2007-bl\n  // 10M + 1S\n\n  // A = Z1 * Z2\n  var a = this.z.redMul(p.z);\n  // B = A^2\n  var b = a.redSqr();\n  // C = X1 * X2\n  var c = this.x.redMul(p.x);\n  // D = Y1 * Y2\n  var d = this.y.redMul(p.y);\n  // E = d * C * D\n  var e = this.curve.d.redMul(c).redMul(d);\n  // F = B - E\n  var f = b.redSub(e);\n  // G = B + E\n  var g = b.redAdd(e);\n  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)\n  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);\n  var nx = a.redMul(f).redMul(tmp);\n  var ny;\n  var nz;\n  if (this.curve.twisted) {\n    // Y3 = A * G * (D - a * C)\n    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));\n    // Z3 = F * G\n    nz = f.redMul(g);\n  } else {\n    // Y3 = A * G * (D - C)\n    ny = a.redMul(g).redMul(d.redSub(c));\n    // Z3 = c * F * G\n    nz = this.curve._mulC(f).redMul(g);\n  }\n  return this.curve.point(nx, ny, nz);\n};\n\nPoint.prototype.add = function add(p) {\n  if (this.isInfinity())\n    return p;\n  if (p.isInfinity())\n    return this;\n\n  if (this.curve.extended)\n    return this._extAdd(p);\n  else\n    return this._projAdd(p);\n};\n\nPoint.prototype.mul = function mul(k) {\n  if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p, k2) {\n  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2);\n};\n\nPoint.prototype.normalize = function normalize() {\n  if (this.zOne)\n    return this;\n\n  // Normalize coordinates\n  var zi = this.z.redInvm();\n  this.x = this.x.redMul(zi);\n  this.y = this.y.redMul(zi);\n  if (this.t)\n    this.t = this.t.redMul(zi);\n  this.z = this.curve.one;\n  this.zOne = true;\n  return this;\n};\n\nPoint.prototype.neg = function neg() {\n  return this.curve.point(this.x.redNeg(),\n                          this.y,\n                          this.z,\n                          this.t && this.t.redNeg());\n};\n\nPoint.prototype.getX = function getX() {\n  this.normalize();\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  this.normalize();\n  return this.y.fromRed();\n};\n\nPoint.prototype.eq = function eq(other) {\n  return this === other ||\n         this.getX().cmp(other.getX()) === 0 &&\n         this.getY().cmp(other.getY()) === 0;\n};\n\n// Compatibility with BaseCurve\nPoint.prototype.toP = Point.prototype.normalize;\nPoint.prototype.mixedAdd = Point.prototype.add;\n\n},{\"../../elliptic\":263,\"../curve\":266,\"bn.js\":215,\"inherits\":292}],266:[function(require,module,exports){\n'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n\n},{\"./base\":264,\"./edwards\":265,\"./mont\":267,\"./short\":268}],267:[function(require,module,exports){\n'use strict';\n\nvar curve = require('../curve');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = curve.base;\n\nvar elliptic = require('../../elliptic');\nvar utils = elliptic.utils;\n\nfunction MontCurve(conf) {\n  Base.call(this, 'mont', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.i4 = new BN(4).toRed(this.red).redInvm();\n  this.two = new BN(2).toRed(this.red);\n  this.a24 = this.i4.redMul(this.a.redAdd(this.two));\n}\ninherits(MontCurve, Base);\nmodule.exports = MontCurve;\n\nMontCurve.prototype.validate = function validate(point) {\n  var x = point.normalize().x;\n  var x2 = x.redSqr();\n  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);\n  var y = rhs.redSqrt();\n\n  return y.redSqr().cmp(rhs) === 0;\n};\n\nfunction Point(curve, x, z) {\n  Base.BasePoint.call(this, curve, 'projective');\n  if (x === null && z === null) {\n    this.x = this.curve.one;\n    this.z = this.curve.zero;\n  } else {\n    this.x = new BN(x, 16);\n    this.z = new BN(z, 16);\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n  }\n}\ninherits(Point, Base.BasePoint);\n\nMontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  return this.point(utils.toArray(bytes, enc), 1);\n};\n\nMontCurve.prototype.point = function point(x, z) {\n  return new Point(this, x, z);\n};\n\nMontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\n  return Point.fromJSON(this, obj);\n};\n\nPoint.prototype.precompute = function precompute() {\n  // No-op\n};\n\nPoint.prototype._encode = function _encode() {\n  return this.getX().toArray('be', this.curve.p.byteLength());\n};\n\nPoint.fromJSON = function fromJSON(curve, obj) {\n  return new Point(curve, obj[0], obj[1] || curve.one);\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' z: ' + this.z.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\nPoint.prototype.dbl = function dbl() {\n  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3\n  // 2M + 2S + 4A\n\n  // A = X1 + Z1\n  var a = this.x.redAdd(this.z);\n  // AA = A^2\n  var aa = a.redSqr();\n  // B = X1 - Z1\n  var b = this.x.redSub(this.z);\n  // BB = B^2\n  var bb = b.redSqr();\n  // C = AA - BB\n  var c = aa.redSub(bb);\n  // X3 = AA * BB\n  var nx = aa.redMul(bb);\n  // Z3 = C * (BB + A24 * C)\n  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));\n  return this.curve.point(nx, nz);\n};\n\nPoint.prototype.add = function add() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\nPoint.prototype.diffAdd = function diffAdd(p, diff) {\n  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3\n  // 4M + 2S + 6A\n\n  // A = X2 + Z2\n  var a = this.x.redAdd(this.z);\n  // B = X2 - Z2\n  var b = this.x.redSub(this.z);\n  // C = X3 + Z3\n  var c = p.x.redAdd(p.z);\n  // D = X3 - Z3\n  var d = p.x.redSub(p.z);\n  // DA = D * A\n  var da = d.redMul(a);\n  // CB = C * B\n  var cb = c.redMul(b);\n  // X5 = Z1 * (DA + CB)^2\n  var nx = diff.z.redMul(da.redAdd(cb).redSqr());\n  // Z5 = X1 * (DA - CB)^2\n  var nz = diff.x.redMul(da.redISub(cb).redSqr());\n  return this.curve.point(nx, nz);\n};\n\nPoint.prototype.mul = function mul(k) {\n  var t = k.clone();\n  var a = this; // (N / 2) * Q + Q\n  var b = this.curve.point(null, null); // (N / 2) * Q\n  var c = this; // Q\n\n  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))\n    bits.push(t.andln(1));\n\n  for (var i = bits.length - 1; i >= 0; i--) {\n    if (bits[i] === 0) {\n      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q\n      a = a.diffAdd(b, c);\n      // N * Q = 2 * ((N / 2) * Q + Q))\n      b = b.dbl();\n    } else {\n      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)\n      b = a.diffAdd(b, c);\n      // N * Q + Q = 2 * ((N / 2) * Q + Q)\n      a = a.dbl();\n    }\n  }\n  return b;\n};\n\nPoint.prototype.mulAdd = function mulAdd() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\nPoint.prototype.eq = function eq(other) {\n  return this.getX().cmp(other.getX()) === 0;\n};\n\nPoint.prototype.normalize = function normalize() {\n  this.x = this.x.redMul(this.z.redInvm());\n  this.z = this.curve.one;\n  return this;\n};\n\nPoint.prototype.getX = function getX() {\n  // Normalize coordinates\n  this.normalize();\n\n  return this.x.fromRed();\n};\n\n},{\"../../elliptic\":263,\"../curve\":266,\"bn.js\":215,\"inherits\":292}],268:[function(require,module,exports){\n'use strict';\n\nvar curve = require('../curve');\nvar elliptic = require('../../elliptic');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = curve.base;\n\nvar assert = elliptic.utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16)\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 }\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs) {\n  var npoints = this._endoWnafT1;\n  var ncoeffs = this._endoWnafT2;\n  for (var i = 0; i < points.length; i++) {\n    var split = this._endoSplit(coeffs[i]);\n    var p = points[i];\n    var beta = p._getBeta();\n\n    if (split.k1.negative) {\n      split.k1.ineg();\n      p = p.neg(true);\n    }\n    if (split.k2.negative) {\n      split.k2.ineg();\n      beta = beta.neg(true);\n    }\n\n    npoints[i * 2] = p;\n    npoints[i * 2 + 1] = beta;\n    ncoeffs[i * 2] = split.k1;\n    ncoeffs[i * 2 + 1] = split.k2;\n  }\n  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);\n\n  // Clean-up references to points and coefficients\n  for (var j = 0; j < i * 2; j++) {\n    npoints[j] = null;\n    ncoeffs[j] = null;\n  }\n  return res;\n};\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul)\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul)\n      }\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1)\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1)\n    }\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point))\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point))\n    }\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n\n  if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate)\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate)\n      }\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (var i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (var i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\n},{\"../../elliptic\":263,\"../curve\":266,\"bn.js\":215,\"inherits\":292}],269:[function(require,module,exports){\n'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar elliptic = require('../elliptic');\n\nvar assert = elliptic.utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new elliptic.curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new elliptic.curve.edwards(options);\n  else\n    this.curve = new elliptic.curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve\n      });\n      return curve;\n    }\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'\n  ]\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'\n  ]\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'\n  ]\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'\n  ]\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650'\n  ]\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '0',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9'\n  ]\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658'\n  ]\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3'\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15'\n    }\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre\n  ]\n});\n\n},{\"../elliptic\":263,\"./precomputed/secp256k1\":277,\"hash.js\":284}],270:[function(require,module,exports){\n'use strict';\n\nvar BN = require('bn.js');\nvar elliptic = require('../../elliptic');\nvar utils = elliptic.utils;\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);\n\n    options = elliptic.curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof elliptic.curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new elliptic.hmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),\n    nonce: this.n.toArray()\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  do {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  } while (true);\n};\n\nEC.prototype._truncateToN = function truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new elliptic.hmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; true; iter++) {\n    var k = options.k ?\n        options.k(iter) :\n        new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n\n  var p = this.g.mulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  return p.getX().umod(this.n).cmp(r) === 0;\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var eNeg = n.sub(e);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  var rInv = signature.r.invm(n);\n  return r.mul(s).add(this.g.mul(eNeg)).mul(rInv);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime = this.recoverPubKey(e, signature, i);\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n\n},{\"../../elliptic\":263,\"./key\":271,\"./signature\":272,\"bn.js\":215}],271:[function(require,module,exports){\n'use strict';\n\nvar BN = require('bn.js');\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n\n},{\"bn.js\":215}],272:[function(require,module,exports){\n'use strict';\n\nvar BN = require('bn.js');\n\nvar elliptic = require('../../elliptic');\nvar utils = elliptic.utils;\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam !== null)\n    this.recoveryParam = options.recoveryParam;\n  else\n    this.recoveryParam = null;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n  }\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0 && (r[1] & 0x80)) {\n    r = r.slice(1);\n  }\n  if (s[0] === 0 && (s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n\n},{\"../../elliptic\":263,\"bn.js\":215}],273:[function(require,module,exports){\n'use strict';\n\nvar hash = require('hash.js');\nvar elliptic = require('../../elliptic');\nvar utils = elliptic.utils;\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EDDSA(curve) {\n  assert(curve === 'ed25519', 'only tested with ed25519 so far');\n\n  if (!(this instanceof EDDSA))\n    return new EDDSA(curve);\n\n  var curve = elliptic.curves[curve].curve;\n  this.curve = curve;\n  this.g = curve.g;\n  this.g.precompute(curve.n.bitLength() + 1);\n\n  this.pointClass = curve.point().constructor;\n  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\n  this.hash = hash.sha512;\n}\n\nmodule.exports = EDDSA;\n\n/**\n* @param {Array|String} message - message bytes\n* @param {Array|String|KeyPair} secret - secret bytes or a keypair\n* @returns {Signature} - signature\n*/\nEDDSA.prototype.sign = function sign(message, secret) {\n  message = parseBytes(message);\n  var key = this.keyFromSecret(secret);\n  var r = this.hashInt(key.messagePrefix(), message);\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint(R);\n  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)\n               .mul(key.priv());\n  var S = r.add(s_).umod(this.curve.n);\n  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });\n};\n\n/**\n* @param {Array} message - message bytes\n* @param {Array|String|Signature} sig - sig bytes\n* @param {Array|String|Point|KeyPair} pub - public key\n* @returns {Boolean} - true if public key matches sig of message\n*/\nEDDSA.prototype.verify = function verify(message, sig, pub) {\n  message = parseBytes(message);\n  sig = this.makeSignature(sig);\n  var key = this.keyFromPublic(pub);\n  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\n  var SG = this.g.mul(sig.S());\n  var RplusAh = sig.R().add(key.pub().mul(h));\n  return RplusAh.eq(SG);\n};\n\nEDDSA.prototype.hashInt = function hashInt() {\n  var hash = this.hash();\n  for (var i = 0; i < arguments.length; i++)\n    hash.update(arguments[i]);\n  return utils.intFromLE(hash.digest()).umod(this.curve.n);\n};\n\nEDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\n  return KeyPair.fromPublic(this, pub);\n};\n\nEDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\n  return KeyPair.fromSecret(this, secret);\n};\n\nEDDSA.prototype.makeSignature = function makeSignature(sig) {\n  if (sig instanceof Signature)\n    return sig;\n  return new Signature(this, sig);\n};\n\n/**\n* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\n*\n* EDDSA defines methods for encoding and decoding points and integers. These are\n* helper convenience methods, that pass along to utility functions implied\n* parameters.\n*\n*/\nEDDSA.prototype.encodePoint = function encodePoint(point) {\n  var enc = point.getY().toArray('le', this.encodingLength);\n  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n  return enc;\n};\n\nEDDSA.prototype.decodePoint = function decodePoint(bytes) {\n  bytes = utils.parseBytes(bytes);\n\n  var lastIx = bytes.length - 1;\n  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\n  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\n\n  var y = utils.intFromLE(normed);\n  return this.curve.pointFromY(y, xIsOdd);\n};\n\nEDDSA.prototype.encodeInt = function encodeInt(num) {\n  return num.toArray('le', this.encodingLength);\n};\n\nEDDSA.prototype.decodeInt = function decodeInt(bytes) {\n  return utils.intFromLE(bytes);\n};\n\nEDDSA.prototype.isPoint = function isPoint(val) {\n  return val instanceof this.pointClass;\n};\n\n},{\"../../elliptic\":263,\"./key\":274,\"./signature\":275,\"hash.js\":284}],274:[function(require,module,exports){\n'use strict';\n\nvar elliptic = require('../../elliptic');\nvar utils = elliptic.utils;\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar cachedProperty = utils.cachedProperty;\n\n/**\n* @param {EDDSA} eddsa - instance\n* @param {Object} params - public/private key parameters\n*\n* @param {Array<Byte>} [params.secret] - secret seed bytes\n* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)\n* @param {Array<Byte>} [params.pub] - public key point encoded as bytes\n*\n*/\nfunction KeyPair(eddsa, params) {\n  this.eddsa = eddsa;\n  this._secret = parseBytes(params.secret);\n  if (eddsa.isPoint(params.pub))\n    this._pub = params.pub;\n  else\n    this._pubBytes = parseBytes(params.pub);\n}\n\nKeyPair.fromPublic = function fromPublic(eddsa, pub) {\n  if (pub instanceof KeyPair)\n    return pub;\n  return new KeyPair(eddsa, { pub: pub });\n};\n\nKeyPair.fromSecret = function fromSecret(eddsa, secret) {\n  if (secret instanceof KeyPair)\n    return secret;\n  return new KeyPair(eddsa, { secret: secret });\n};\n\nKeyPair.prototype.secret = function secret() {\n  return this._secret;\n};\n\ncachedProperty(KeyPair, function pubBytes() {\n  return this.eddsa.encodePoint(this.pub());\n});\n\ncachedProperty(KeyPair, function pub() {\n  if (this._pubBytes)\n    return this.eddsa.decodePoint(this._pubBytes);\n  return this.eddsa.g.mul(this.priv());\n});\n\ncachedProperty(KeyPair, function privBytes() {\n  var eddsa = this.eddsa;\n  var hash = this.hash();\n  var lastIx = eddsa.encodingLength - 1;\n\n  var a = hash.slice(0, eddsa.encodingLength);\n  a[0] &= 248;\n  a[lastIx] &= 127;\n  a[lastIx] |= 64;\n\n  return a;\n});\n\ncachedProperty(KeyPair, function priv() {\n  return this.eddsa.decodeInt(this.privBytes());\n});\n\ncachedProperty(KeyPair, function hash() {\n  return this.eddsa.hash().update(this.secret()).digest();\n});\n\ncachedProperty(KeyPair, function messagePrefix() {\n  return this.hash().slice(this.eddsa.encodingLength);\n});\n\nKeyPair.prototype.sign = function sign(message) {\n  assert(this._secret, 'KeyPair can only verify');\n  return this.eddsa.sign(message, this);\n};\n\nKeyPair.prototype.verify = function verify(message, sig) {\n  return this.eddsa.verify(message, sig, this);\n};\n\nKeyPair.prototype.getSecret = function getSecret(enc) {\n  assert(this._secret, 'KeyPair is public only');\n  return utils.encode(this.secret(), enc);\n};\n\nKeyPair.prototype.getPublic = function getPublic(enc) {\n  return utils.encode(this.pubBytes(), enc);\n};\n\nmodule.exports = KeyPair;\n\n},{\"../../elliptic\":263}],275:[function(require,module,exports){\n'use strict';\n\nvar BN = require('bn.js');\nvar elliptic = require('../../elliptic');\nvar utils = elliptic.utils;\nvar assert = utils.assert;\nvar cachedProperty = utils.cachedProperty;\nvar parseBytes = utils.parseBytes;\n\n/**\n* @param {EDDSA} eddsa - eddsa instance\n* @param {Array<Bytes>|Object} sig -\n* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes\n* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes\n* @param {Array<Bytes>} [sig.Rencoded] - R point encoded\n* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded\n*/\nfunction Signature(eddsa, sig) {\n  this.eddsa = eddsa;\n\n  if (typeof sig !== 'object')\n    sig = parseBytes(sig);\n\n  if (Array.isArray(sig)) {\n    sig = {\n      R: sig.slice(0, eddsa.encodingLength),\n      S: sig.slice(eddsa.encodingLength)\n    };\n  }\n\n  assert(sig.R && sig.S, 'Signature without R or S');\n\n  if (eddsa.isPoint(sig.R))\n    this._R = sig.R;\n  if (sig.S instanceof BN)\n    this._S = sig.S;\n\n  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;\n  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;\n}\n\ncachedProperty(Signature, function S() {\n  return this.eddsa.decodeInt(this.Sencoded());\n});\n\ncachedProperty(Signature, function R() {\n  return this.eddsa.decodePoint(this.Rencoded());\n});\n\ncachedProperty(Signature, function Rencoded() {\n  return this.eddsa.encodePoint(this.R());\n});\n\ncachedProperty(Signature, function Sencoded() {\n  return this.eddsa.encodeInt(this.S());\n});\n\nSignature.prototype.toBytes = function toBytes() {\n  return this.Rencoded().concat(this.Sencoded());\n};\n\nSignature.prototype.toHex = function toHex() {\n  return utils.encode(this.toBytes(), 'hex').toUpperCase();\n};\n\nmodule.exports = Signature;\n\n},{\"../../elliptic\":263,\"bn.js\":215}],276:[function(require,module,exports){\n'use strict';\n\nvar hash = require('hash.js');\nvar elliptic = require('../elliptic');\nvar utils = elliptic.utils;\nvar assert = utils.assert;\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this.reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc);\n  var nonce = utils.toArray(options.nonce, options.nonceEnc);\n  var pers = utils.toArray(options.pers, options.persEnc);\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this.reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toBuffer(entropy, entropyEnc);\n  add = utils.toBuffer(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this.reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this.reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc);\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this.reseed++;\n  return utils.encode(res, enc);\n};\n\n},{\"../elliptic\":263,\"hash.js\":284}],277:[function(require,module,exports){\nmodule.exports = {\n  doubles: {\n    step: 4,\n    points: [\n      [\n        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',\n        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'\n      ],\n      [\n        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',\n        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'\n      ],\n      [\n        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',\n        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'\n      ],\n      [\n        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',\n        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'\n      ],\n      [\n        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',\n        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'\n      ],\n      [\n        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',\n        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'\n      ],\n      [\n        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',\n        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'\n      ],\n      [\n        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',\n        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'\n      ],\n      [\n        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',\n        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'\n      ],\n      [\n        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',\n        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'\n      ],\n      [\n        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',\n        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'\n      ],\n      [\n        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',\n        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'\n      ],\n      [\n        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',\n        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'\n      ],\n      [\n        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',\n        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'\n      ],\n      [\n        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',\n        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'\n      ],\n      [\n        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',\n        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'\n      ],\n      [\n        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',\n        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'\n      ],\n      [\n        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',\n        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'\n      ],\n      [\n        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',\n        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'\n      ],\n      [\n        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',\n        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'\n      ],\n      [\n        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',\n        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'\n      ],\n      [\n        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',\n        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'\n      ],\n      [\n        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',\n        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'\n      ],\n      [\n        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',\n        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'\n      ],\n      [\n        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',\n        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'\n      ],\n      [\n        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',\n        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'\n      ],\n      [\n        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',\n        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'\n      ],\n      [\n        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',\n        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'\n      ],\n      [\n        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',\n        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'\n      ],\n      [\n        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',\n        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'\n      ],\n      [\n        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',\n        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'\n      ],\n      [\n        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',\n        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'\n      ],\n      [\n        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',\n        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'\n      ],\n      [\n        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',\n        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'\n      ],\n      [\n        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',\n        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'\n      ],\n      [\n        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',\n        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'\n      ],\n      [\n        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',\n        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'\n      ],\n      [\n        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',\n        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'\n      ],\n      [\n        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',\n        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'\n      ],\n      [\n        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',\n        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'\n      ],\n      [\n        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',\n        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'\n      ],\n      [\n        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',\n        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'\n      ],\n      [\n        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',\n        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'\n      ],\n      [\n        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',\n        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'\n      ],\n      [\n        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',\n        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'\n      ],\n      [\n        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',\n        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'\n      ],\n      [\n        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',\n        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'\n      ],\n      [\n        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',\n        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'\n      ],\n      [\n        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',\n        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'\n      ],\n      [\n        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',\n        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'\n      ],\n      [\n        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',\n        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'\n      ],\n      [\n        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',\n        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'\n      ],\n      [\n        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',\n        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'\n      ],\n      [\n        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',\n        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'\n      ],\n      [\n        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',\n        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'\n      ],\n      [\n        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',\n        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'\n      ],\n      [\n        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',\n        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'\n      ],\n      [\n        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',\n        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'\n      ],\n      [\n        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',\n        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'\n      ],\n      [\n        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',\n        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'\n      ],\n      [\n        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',\n        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'\n      ],\n      [\n        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',\n        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'\n      ],\n      [\n        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',\n        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'\n      ],\n      [\n        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',\n        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'\n      ],\n      [\n        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',\n        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'\n      ]\n    ]\n  },\n  naf: {\n    wnd: 7,\n    points: [\n      [\n        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',\n        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'\n      ],\n      [\n        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',\n        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'\n      ],\n      [\n        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',\n        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'\n      ],\n      [\n        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',\n        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'\n      ],\n      [\n        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',\n        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'\n      ],\n      [\n        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',\n        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'\n      ],\n      [\n        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',\n        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'\n      ],\n      [\n        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',\n        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'\n      ],\n      [\n        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',\n        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'\n      ],\n      [\n        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',\n        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'\n      ],\n      [\n        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',\n        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'\n      ],\n      [\n        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',\n        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'\n      ],\n      [\n        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',\n        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'\n      ],\n      [\n        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',\n        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'\n      ],\n      [\n        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',\n        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'\n      ],\n      [\n        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',\n        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'\n      ],\n      [\n        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',\n        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'\n      ],\n      [\n        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',\n        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'\n      ],\n      [\n        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',\n        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'\n      ],\n      [\n        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',\n        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'\n      ],\n      [\n        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',\n        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'\n      ],\n      [\n        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',\n        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'\n      ],\n      [\n        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',\n        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'\n      ],\n      [\n        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',\n        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'\n      ],\n      [\n        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',\n        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'\n      ],\n      [\n        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',\n        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'\n      ],\n      [\n        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',\n        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'\n      ],\n      [\n        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',\n        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'\n      ],\n      [\n        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',\n        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'\n      ],\n      [\n        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',\n        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'\n      ],\n      [\n        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',\n        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'\n      ],\n      [\n        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',\n        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'\n      ],\n      [\n        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',\n        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'\n      ],\n      [\n        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',\n        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'\n      ],\n      [\n        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',\n        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'\n      ],\n      [\n        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',\n        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'\n      ],\n      [\n        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',\n        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'\n      ],\n      [\n        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',\n        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'\n      ],\n      [\n        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',\n        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'\n      ],\n      [\n        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',\n        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'\n      ],\n      [\n        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',\n        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'\n      ],\n      [\n        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',\n        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'\n      ],\n      [\n        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',\n        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'\n      ],\n      [\n        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',\n        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'\n      ],\n      [\n        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',\n        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'\n      ],\n      [\n        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',\n        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'\n      ],\n      [\n        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',\n        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'\n      ],\n      [\n        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',\n        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'\n      ],\n      [\n        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',\n        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'\n      ],\n      [\n        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',\n        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'\n      ],\n      [\n        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',\n        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'\n      ],\n      [\n        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',\n        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'\n      ],\n      [\n        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',\n        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'\n      ],\n      [\n        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',\n        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'\n      ],\n      [\n        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',\n        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'\n      ],\n      [\n        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',\n        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'\n      ],\n      [\n        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',\n        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'\n      ],\n      [\n        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',\n        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'\n      ],\n      [\n        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',\n        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'\n      ],\n      [\n        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',\n        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'\n      ],\n      [\n        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',\n        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'\n      ],\n      [\n        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',\n        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'\n      ],\n      [\n        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',\n        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'\n      ],\n      [\n        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',\n        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'\n      ],\n      [\n        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',\n        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'\n      ],\n      [\n        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',\n        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'\n      ],\n      [\n        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',\n        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'\n      ],\n      [\n        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',\n        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'\n      ],\n      [\n        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',\n        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'\n      ],\n      [\n        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',\n        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'\n      ],\n      [\n        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',\n        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'\n      ],\n      [\n        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',\n        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'\n      ],\n      [\n        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',\n        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'\n      ],\n      [\n        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',\n        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'\n      ],\n      [\n        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',\n        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'\n      ],\n      [\n        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',\n        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'\n      ],\n      [\n        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',\n        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'\n      ],\n      [\n        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',\n        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'\n      ],\n      [\n        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',\n        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'\n      ],\n      [\n        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',\n        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'\n      ],\n      [\n        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',\n        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'\n      ],\n      [\n        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',\n        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'\n      ],\n      [\n        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',\n        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'\n      ],\n      [\n        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',\n        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'\n      ],\n      [\n        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',\n        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'\n      ],\n      [\n        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',\n        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'\n      ],\n      [\n        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',\n        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'\n      ],\n      [\n        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',\n        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'\n      ],\n      [\n        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',\n        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'\n      ],\n      [\n        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',\n        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'\n      ],\n      [\n        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',\n        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'\n      ],\n      [\n        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',\n        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'\n      ],\n      [\n        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',\n        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'\n      ],\n      [\n        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',\n        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'\n      ],\n      [\n        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',\n        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'\n      ],\n      [\n        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',\n        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'\n      ],\n      [\n        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',\n        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'\n      ],\n      [\n        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',\n        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'\n      ],\n      [\n        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',\n        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'\n      ],\n      [\n        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',\n        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'\n      ],\n      [\n        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',\n        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'\n      ],\n      [\n        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',\n        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'\n      ],\n      [\n        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',\n        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'\n      ],\n      [\n        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',\n        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'\n      ],\n      [\n        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',\n        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'\n      ],\n      [\n        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',\n        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'\n      ],\n      [\n        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',\n        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'\n      ],\n      [\n        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',\n        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'\n      ],\n      [\n        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',\n        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'\n      ],\n      [\n        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',\n        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'\n      ],\n      [\n        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',\n        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'\n      ],\n      [\n        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',\n        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'\n      ],\n      [\n        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',\n        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'\n      ],\n      [\n        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',\n        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'\n      ],\n      [\n        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',\n        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'\n      ],\n      [\n        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',\n        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'\n      ],\n      [\n        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',\n        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'\n      ],\n      [\n        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',\n        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'\n      ],\n      [\n        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',\n        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'\n      ],\n      [\n        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',\n        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'\n      ],\n      [\n        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',\n        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'\n      ],\n      [\n        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',\n        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'\n      ],\n      [\n        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',\n        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'\n      ],\n      [\n        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',\n        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'\n      ],\n      [\n        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',\n        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'\n      ],\n      [\n        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',\n        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'\n      ],\n      [\n        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',\n        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'\n      ]\n    ]\n  }\n};\n\n},{}],278:[function(require,module,exports){\n'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\n\nutils.assert = function assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n};\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (!enc) {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  } else if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w) {\n  var naf = [];\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n  while (k.cmpn(1) >= 0) {\n    var z;\n    if (k.isOdd()) {\n      var mod = k.andln(ws - 1);\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n    naf.push(z);\n\n    // Optimization, shift by word if possible\n    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;\n    for (var i = 1; i < shift; i++)\n      naf.push(0);\n    k.iushrn(shift);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    []\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      var m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      var m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, computer) {\n  var name = computer.name;\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n           this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n                                     bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n\n},{\"bn.js\":215}],279:[function(require,module,exports){\nmodule.exports={\n  \"_args\": [\n    [\n      \"elliptic@^6.0.0\",\n      \"/home/select/Dev/Angular2-ES6-Babel-Browserify-Starter/node_modules/browserify-sign\"\n    ]\n  ],\n  \"_from\": \"elliptic@>=6.0.0 <7.0.0\",\n  \"_id\": \"elliptic@6.1.0\",\n  \"_inCache\": true,\n  \"_installable\": true,\n  \"_location\": \"/elliptic\",\n  \"_nodeVersion\": \"5.2.0\",\n  \"_npmUser\": {\n    \"email\": \"fedor@indutny.com\",\n    \"name\": \"indutny\"\n  },\n  \"_npmVersion\": \"3.3.12\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"name\": \"elliptic\",\n    \"raw\": \"elliptic@^6.0.0\",\n    \"rawSpec\": \"^6.0.0\",\n    \"scope\": null,\n    \"spec\": \">=6.0.0 <7.0.0\",\n    \"type\": \"range\"\n  },\n  \"_requiredBy\": [\n    \"/browserify-sign\",\n    \"/create-ecdh\"\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/elliptic/-/elliptic-6.1.0.tgz\",\n  \"_shasum\": \"68130e03823b4ce024955ad1be195e148099d654\",\n  \"_shrinkwrap\": null,\n  \"_spec\": \"elliptic@^6.0.0\",\n  \"_where\": \"/home/select/Dev/Angular2-ES6-Babel-Browserify-Starter/node_modules/browserify-sign\",\n  \"author\": {\n    \"email\": \"fedor@indutny.com\",\n    \"name\": \"Fedor Indutny\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/indutny/elliptic/issues\"\n  },\n  \"dependencies\": {\n    \"bn.js\": \"^4.0.0\",\n    \"brorand\": \"^1.0.1\",\n    \"hash.js\": \"^1.0.0\",\n    \"inherits\": \"^2.0.1\"\n  },\n  \"description\": \"EC cryptography\",\n  \"devDependencies\": {\n    \"browserify\": \"^3.44.2\",\n    \"coveralls\": \"^2.11.3\",\n    \"istanbul\": \"^0.3.17\",\n    \"jscs\": \"^1.11.3\",\n    \"jshint\": \"^2.6.0\",\n    \"mocha\": \"^2.1.0\",\n    \"uglify-js\": \"^2.4.13\"\n  },\n  \"directories\": {},\n  \"dist\": {\n    \"shasum\": \"68130e03823b4ce024955ad1be195e148099d654\",\n    \"tarball\": \"http://registry.npmjs.org/elliptic/-/elliptic-6.1.0.tgz\"\n  },\n  \"files\": [\n    \"lib\"\n  ],\n  \"gitHead\": \"b465fea90447f3b6c0b3f55e5fd6ecdedc1282f2\",\n  \"homepage\": \"https://github.com/indutny/elliptic\",\n  \"keywords\": [\n    \"Cryptography\",\n    \"EC\",\n    \"Elliptic\",\n    \"curve\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"lib/elliptic.js\",\n  \"maintainers\": [\n    {\n      \"name\": \"indutny\",\n      \"email\": \"fedor@indutny.com\"\n    }\n  ],\n  \"name\": \"elliptic\",\n  \"optionalDependencies\": {},\n  \"readme\": \"ERROR: No README data found!\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+ssh://git@github.com/indutny/elliptic.git\"\n  },\n  \"scripts\": {\n    \"coveralls\": \"cat ./coverage/lcov.info | coveralls\",\n    \"test\": \"make lint && istanbul test _mocha --reporter=spec test/*-test.js\"\n  },\n  \"version\": \"6.1.0\"\n}\n\n},{}],280:[function(require,module,exports){\n(function (process,global){\n/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.0.2\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$toString = {}.toString;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n      if (maybeThenable.constructor === promise.constructor) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      var enumerator = this;\n\n      enumerator._instanceConstructor = Constructor;\n      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (enumerator._validateInput(input)) {\n        enumerator._input     = input;\n        enumerator.length     = input.length;\n        enumerator._remaining = input.length;\n\n        enumerator._init();\n\n        if (enumerator.length === 0) {\n          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n        } else {\n          enumerator.length = enumerator.length || 0;\n          enumerator._enumerate();\n          if (enumerator._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n      }\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n      return lib$es6$promise$utils$$isArray(input);\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n      this._result = new Array(this.length);\n    };\n\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var enumerator = this;\n\n      var length  = enumerator.length;\n      var promise = enumerator.promise;\n      var input   = enumerator._input;\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        enumerator._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var enumerator = this;\n      var c = enumerator._instanceConstructor;\n\n      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n          entry._onerror = null;\n          enumerator._settledAt(entry._state, i, entry._result);\n        } else {\n          enumerator._willSettleAt(c.resolve(entry), i);\n        }\n      } else {\n        enumerator._remaining--;\n        enumerator._result[i] = entry;\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var enumerator = this;\n      var promise = enumerator.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        enumerator._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          enumerator._result[i] = value;\n        }\n      }\n\n      if (enumerator._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n    var lib$es6$promise$promise$$counter = 0;\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this._id = lib$es6$promise$promise$$counter++;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n          lib$es6$promise$promise$$needsResolver();\n        }\n\n        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n          lib$es6$promise$promise$$needsNew();\n        }\n\n        lib$es6$promise$$internal$$initializePromise(this, resolver);\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: function(onFulfillment, onRejection) {\n        var parent = this;\n        var state = parent._state;\n\n        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n          return this;\n        }\n\n        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n        var result = parent._result;\n\n        if (state) {\n          var callback = arguments[state - 1];\n          lib$es6$promise$asap$$asap(function(){\n            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n          });\n        } else {\n          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n        }\n\n        return child;\n      },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"_process\":303}],281:[function(require,module,exports){\n(function (process,global){\n /*!\n  * https://github.com/paulmillr/es6-shim\n  * @license es6-shim Copyright 2013-2015 by Paul Miller (http://paulmillr.com)\n  *   and contributors,  MIT License\n  * es6-shim: v0.34.1\n  * see https://github.com/paulmillr/es6-shim/blob/0.34.1/LICENSE\n  * Details and documentation:\n  * https://github.com/paulmillr/es6-shim/\n  */\n\n// UMD (Universal Module Definition)\n// see https://github.com/umdjs/umd/blob/master/returnExports.js\n(function (root, factory) {\n  /*global define, module, exports */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.returnExports = factory();\n  }\n}(this, function () {\n  'use strict';\n\n  var _apply = Function.call.bind(Function.apply);\n  var _call = Function.call.bind(Function.call);\n  var isArray = Array.isArray;\n  var keys = Object.keys;\n\n  var not = function notThunker(func) {\n    return function notThunk() { return !_apply(func, this, arguments); };\n  };\n  var throwsError = function (func) {\n    try {\n      func();\n      return false;\n    } catch (e) {\n      return true;\n    }\n  };\n  var valueOrFalseIfThrows = function valueOrFalseIfThrows(func) {\n    try {\n      return func();\n    } catch (e) {\n      return false;\n    }\n  };\n\n  var isCallableWithoutNew = not(throwsError);\n  var arePropertyDescriptorsSupported = function () {\n    // if Object.defineProperty exists but throws, it's IE 8\n    return !throwsError(function () { Object.defineProperty({}, 'x', { get: function () {} }); });\n  };\n  var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();\n  var functionsHaveNames = (function foo() {}).name === 'foo';\n\n  var _forEach = Function.call.bind(Array.prototype.forEach);\n  var _reduce = Function.call.bind(Array.prototype.reduce);\n  var _filter = Function.call.bind(Array.prototype.filter);\n  var _some = Function.call.bind(Array.prototype.some);\n\n  var defineProperty = function (object, name, value, force) {\n    if (!force && name in object) { return; }\n    if (supportsDescriptors) {\n      Object.defineProperty(object, name, {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: value\n      });\n    } else {\n      object[name] = value;\n    }\n  };\n\n  // Define configurable, writable and non-enumerable props\n  // if they don’t exist.\n  var defineProperties = function (object, map, forceOverride) {\n    _forEach(keys(map), function (name) {\n      var method = map[name];\n      defineProperty(object, name, method, !!forceOverride);\n    });\n  };\n\n  var _toString = Function.call.bind(Object.prototype.toString);\n  var isCallable = typeof /abc/ === 'function' ? function IsCallableSlow(x) {\n    // Some old browsers (IE, FF) say that typeof /abc/ === 'function'\n    return typeof x === 'function' && _toString(x) === '[object Function]';\n  } : function IsCallableFast(x) { return typeof x === 'function'; };\n\n  var Value = {\n    getter: function (object, name, getter) {\n      if (!supportsDescriptors) {\n        throw new TypeError('getters require true ES5 support');\n      }\n      Object.defineProperty(object, name, {\n        configurable: true,\n        enumerable: false,\n        get: getter\n      });\n    },\n    proxy: function (originalObject, key, targetObject) {\n      if (!supportsDescriptors) {\n        throw new TypeError('getters require true ES5 support');\n      }\n      var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);\n      Object.defineProperty(targetObject, key, {\n        configurable: originalDescriptor.configurable,\n        enumerable: originalDescriptor.enumerable,\n        get: function getKey() { return originalObject[key]; },\n        set: function setKey(value) { originalObject[key] = value; }\n      });\n    },\n    redefine: function (object, property, newValue) {\n      if (supportsDescriptors) {\n        var descriptor = Object.getOwnPropertyDescriptor(object, property);\n        descriptor.value = newValue;\n        Object.defineProperty(object, property, descriptor);\n      } else {\n        object[property] = newValue;\n      }\n    },\n    defineByDescriptor: function (object, property, descriptor) {\n      if (supportsDescriptors) {\n        Object.defineProperty(object, property, descriptor);\n      } else if ('value' in descriptor) {\n        object[property] = descriptor.value;\n      }\n    },\n    preserveToString: function (target, source) {\n      if (source && isCallable(source.toString)) {\n        defineProperty(target, 'toString', source.toString.bind(source), true);\n      }\n    }\n  };\n\n  // Simple shim for Object.create on ES3 browsers\n  // (unlike real shim, no attempt to support `prototype === null`)\n  var create = Object.create || function (prototype, properties) {\n    var Prototype = function Prototype() {};\n    Prototype.prototype = prototype;\n    var object = new Prototype();\n    if (typeof properties !== 'undefined') {\n      keys(properties).forEach(function (key) {\n        Value.defineByDescriptor(object, key, properties[key]);\n      });\n    }\n    return object;\n  };\n\n  var supportsSubclassing = function (C, f) {\n    if (!Object.setPrototypeOf) { return false; /* skip test on IE < 11 */ }\n    return valueOrFalseIfThrows(function () {\n      var Sub = function Subclass(arg) {\n        var o = new C(arg);\n        Object.setPrototypeOf(o, Subclass.prototype);\n        return o;\n      };\n      Object.setPrototypeOf(Sub, C);\n      Sub.prototype = create(C.prototype, {\n        constructor: { value: Sub }\n      });\n      return f(Sub);\n    });\n  };\n\n  var getGlobal = function () {\n    /* global self, window, global */\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') { return self; }\n    if (typeof window !== 'undefined') { return window; }\n    if (typeof global !== 'undefined') { return global; }\n    throw new Error('unable to locate global object');\n  };\n\n  var globals = getGlobal();\n  var globalIsFinite = globals.isFinite;\n  var _indexOf = Function.call.bind(String.prototype.indexOf);\n  var _concat = Function.call.bind(Array.prototype.concat);\n  var _sort = Function.call.bind(Array.prototype.sort);\n  var _strSlice = Function.call.bind(String.prototype.slice);\n  var _push = Function.call.bind(Array.prototype.push);\n  var _pushApply = Function.apply.bind(Array.prototype.push);\n  var _shift = Function.call.bind(Array.prototype.shift);\n  var _max = Math.max;\n  var _min = Math.min;\n  var _floor = Math.floor;\n  var _abs = Math.abs;\n  var _log = Math.log;\n  var _sqrt = Math.sqrt;\n  var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n  var ArrayIterator; // make our implementation private\n  var noop = function () {};\n\n  var Symbol = globals.Symbol || {};\n  var symbolSpecies = Symbol.species || '@@species';\n\n  var numberIsNaN = Number.isNaN || function isNaN(value) {\n    // NaN !== NaN, but they are identical.\n    // NaNs are the only non-reflexive value, i.e., if x !== x,\n    // then x is NaN.\n    // isNaN is broken: it converts its argument to number, so\n    // isNaN('foo') => true\n    return value !== value;\n  };\n  var numberIsFinite = Number.isFinite || function isFinite(value) {\n    return typeof value === 'number' && globalIsFinite(value);\n  };\n\n  // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js\n  // can be replaced with require('is-arguments') if we ever use a build process instead\n  var isStandardArguments = function isArguments(value) {\n    return _toString(value) === '[object Arguments]';\n  };\n  var isLegacyArguments = function isArguments(value) {\n    return value !== null &&\n      typeof value === 'object' &&\n      typeof value.length === 'number' &&\n      value.length >= 0 &&\n      _toString(value) !== '[object Array]' &&\n      _toString(value.callee) === '[object Function]';\n  };\n  var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;\n\n  var Type = {\n    primitive: function (x) { return x === null || (typeof x !== 'function' && typeof x !== 'object'); },\n    object: function (x) { return x !== null && typeof x === 'object'; },\n    string: function (x) { return _toString(x) === '[object String]'; },\n    regex: function (x) { return _toString(x) === '[object RegExp]'; },\n    symbol: function (x) {\n      return typeof globals.Symbol === 'function' && typeof x === 'symbol';\n    }\n  };\n\n  var overrideNative = function overrideNative(object, property, replacement) {\n    var original = object[property];\n    defineProperty(object, property, replacement, true);\n    Value.preserveToString(object[property], original);\n  };\n\n  var hasSymbols = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' && Type.symbol(Symbol());\n\n  // This is a private name in the es6 spec, equal to '[Symbol.iterator]'\n  // we're going to use an arbitrary _-prefixed name to make our shims\n  // work properly with each other, even though we don't have full Iterator\n  // support.  That is, `Array.from(map.keys())` will work, but we don't\n  // pretend to export a \"real\" Iterator interface.\n  var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_';\n  // Firefox ships a partial implementation using the name @@iterator.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14\n  // So use that name if we detect it.\n  if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {\n    $iterator$ = '@@iterator';\n  }\n\n  // Reflect\n  if (!globals.Reflect) {\n    defineProperty(globals, 'Reflect', {});\n  }\n  var Reflect = globals.Reflect;\n\n  var $String = String;\n\n  var ES = {\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args\n    Call: function Call(F, V) {\n      var args = arguments.length > 2 ? arguments[2] : [];\n      if (!ES.IsCallable(F)) {\n        throw new TypeError(F + ' is not a function');\n      }\n      return _apply(F, V, args);\n    },\n\n    RequireObjectCoercible: function (x, optMessage) {\n      /* jshint eqnull:true */\n      if (x == null) {\n        throw new TypeError(optMessage || 'Cannot call method on ' + x);\n      }\n      return x;\n    },\n\n    // This might miss the \"(non-standard exotic and does not implement\n    // [[Call]])\" case from\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation\n    // but we can't find any evidence these objects exist in practice.\n    // If we find some in the future, you could test `Object(x) === x`,\n    // which is reliable according to\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toobject\n    // but is not well optimized by runtimes and creates an object\n    // whenever it returns false, and thus is very slow.\n    TypeIsObject: function (x) {\n      if (x === void 0 || x === null || x === true || x === false) {\n        return false;\n      }\n      return typeof x === 'function' || typeof x === 'object';\n    },\n\n    ToObject: function (o, optMessage) {\n      return Object(ES.RequireObjectCoercible(o, optMessage));\n    },\n\n    IsCallable: isCallable,\n\n    IsConstructor: function (x) {\n      // We can't tell callables from constructors in ES5\n      return ES.IsCallable(x);\n    },\n\n    ToInt32: function (x) {\n      return ES.ToNumber(x) >> 0;\n    },\n\n    ToUint32: function (x) {\n      return ES.ToNumber(x) >>> 0;\n    },\n\n    ToNumber: function (value) {\n      if (_toString(value) === '[object Symbol]') {\n        throw new TypeError('Cannot convert a Symbol value to a number');\n      }\n      return +value;\n    },\n\n    ToInteger: function (value) {\n      var number = ES.ToNumber(value);\n      if (numberIsNaN(number)) { return 0; }\n      if (number === 0 || !numberIsFinite(number)) { return number; }\n      return (number > 0 ? 1 : -1) * _floor(_abs(number));\n    },\n\n    ToLength: function (value) {\n      var len = ES.ToInteger(value);\n      if (len <= 0) { return 0; } // includes converting -0 to +0\n      if (len > Number.MAX_SAFE_INTEGER) { return Number.MAX_SAFE_INTEGER; }\n      return len;\n    },\n\n    SameValue: function (a, b) {\n      if (a === b) {\n        // 0 === -0, but they are not identical.\n        if (a === 0) { return 1 / a === 1 / b; }\n        return true;\n      }\n      return numberIsNaN(a) && numberIsNaN(b);\n    },\n\n    SameValueZero: function (a, b) {\n      // same as SameValue except for SameValueZero(+0, -0) == true\n      return (a === b) || (numberIsNaN(a) && numberIsNaN(b));\n    },\n\n    IsIterable: function (o) {\n      return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));\n    },\n\n    GetIterator: function (o) {\n      if (isArguments(o)) {\n        // special case support for `arguments`\n        return new ArrayIterator(o, 'value');\n      }\n      var itFn = ES.GetMethod(o, $iterator$);\n      if (!ES.IsCallable(itFn)) {\n        // Better diagnostics if itFn is null or undefined\n        throw new TypeError('value is not an iterable');\n      }\n      var it = ES.Call(itFn, o);\n      if (!ES.TypeIsObject(it)) {\n        throw new TypeError('bad iterator');\n      }\n      return it;\n    },\n\n    GetMethod: function (o, p) {\n      var func = ES.ToObject(o)[p];\n      if (func === void 0 || func === null) {\n        return void 0;\n      }\n      if (!ES.IsCallable(func)) {\n        throw new TypeError('Method not callable: ' + p);\n      }\n      return func;\n    },\n\n    IteratorComplete: function (iterResult) {\n      return !!(iterResult.done);\n    },\n\n    IteratorClose: function (iterator, completionIsThrow) {\n      var returnMethod = ES.GetMethod(iterator, 'return');\n      if (returnMethod === void 0) {\n        return;\n      }\n      var innerResult, innerException;\n      try {\n        innerResult = ES.Call(returnMethod, iterator);\n      } catch (e) {\n        innerException = e;\n      }\n      if (completionIsThrow) {\n        return;\n      }\n      if (innerException) {\n        throw innerException;\n      }\n      if (!ES.TypeIsObject(innerResult)) {\n        throw new TypeError(\"Iterator's return method returned a non-object.\");\n      }\n    },\n\n    IteratorNext: function (it) {\n      var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();\n      if (!ES.TypeIsObject(result)) {\n        throw new TypeError('bad iterator');\n      }\n      return result;\n    },\n\n    IteratorStep: function (it) {\n      var result = ES.IteratorNext(it);\n      var done = ES.IteratorComplete(result);\n      return done ? false : result;\n    },\n\n    Construct: function (C, args, newTarget, isES6internal) {\n      var target = typeof newTarget === 'undefined' ? C : newTarget;\n\n      if (!isES6internal && Reflect.construct) {\n        // Try to use Reflect.construct if available\n        return Reflect.construct(C, args, target);\n      }\n      // OK, we have to fake it.  This will only work if the\n      // C.[[ConstructorKind]] == \"base\" -- but that's the only\n      // kind we can make in ES5 code anyway.\n\n      // OrdinaryCreateFromConstructor(target, \"%ObjectPrototype%\")\n      var proto = target.prototype;\n      if (!ES.TypeIsObject(proto)) {\n        proto = Object.prototype;\n      }\n      var obj = create(proto);\n      // Call the constructor.\n      var result = ES.Call(C, obj, args);\n      return ES.TypeIsObject(result) ? result : obj;\n    },\n\n    SpeciesConstructor: function (O, defaultConstructor) {\n      var C = O.constructor;\n      if (C === void 0) {\n        return defaultConstructor;\n      }\n      if (!ES.TypeIsObject(C)) {\n        throw new TypeError('Bad constructor');\n      }\n      var S = C[symbolSpecies];\n      if (S === void 0 || S === null) {\n        return defaultConstructor;\n      }\n      if (!ES.IsConstructor(S)) {\n        throw new TypeError('Bad @@species');\n      }\n      return S;\n    },\n\n    CreateHTML: function (string, tag, attribute, value) {\n      var S = ES.ToString(string);\n      var p1 = '<' + tag;\n      if (attribute !== '') {\n        var V = ES.ToString(value);\n        var escapedV = V.replace(/\"/g, '&quot;');\n        p1 += ' ' + attribute + '=\"' + escapedV + '\"';\n      }\n      var p2 = p1 + '>';\n      var p3 = p2 + S;\n      return p3 + '</' + tag + '>';\n    },\n\n    IsRegExp: function IsRegExp(argument) {\n      if (!ES.TypeIsObject(argument)) {\n        return false;\n      }\n      var isRegExp = argument[Symbol.match];\n      if (typeof isRegExp !== 'undefined') {\n        return !!isRegExp;\n      }\n      return Type.regex(argument);\n    },\n\n    ToString: function ToString(string) {\n      return $String(string);\n    }\n  };\n\n  // Well-known Symbol shims\n  if (supportsDescriptors && hasSymbols) {\n    var defineWellKnownSymbol = function defineWellKnownSymbol(name) {\n      if (Type.symbol(Symbol[name])) {\n        return Symbol[name];\n      }\n      var sym = Symbol['for']('Symbol.' + name);\n      Object.defineProperty(Symbol, name, {\n        configurable: false,\n        enumerable: false,\n        writable: false,\n        value: sym\n      });\n      return sym;\n    };\n    if (!Type.symbol(Symbol.search)) {\n      var symbolSearch = defineWellKnownSymbol('search');\n      var originalSearch = String.prototype.search;\n      defineProperty(RegExp.prototype, symbolSearch, function search(string) {\n        return ES.Call(originalSearch, string, [this]);\n      });\n      var searchShim = function search(regexp) {\n        var O = ES.RequireObjectCoercible(this);\n        if (regexp !== null && typeof regexp !== 'undefined') {\n          var searcher = ES.GetMethod(regexp, symbolSearch);\n          if (typeof searcher !== 'undefined') {\n            return ES.Call(searcher, regexp, [O]);\n          }\n        }\n        return ES.Call(originalSearch, O, [ES.ToString(regexp)]);\n      };\n      overrideNative(String.prototype, 'search', searchShim);\n    }\n    if (!Type.symbol(Symbol.replace)) {\n      var symbolReplace = defineWellKnownSymbol('replace');\n      var originalReplace = String.prototype.replace;\n      defineProperty(RegExp.prototype, symbolReplace, function replace(string, replaceValue) {\n        return ES.Call(originalReplace, string, [this, replaceValue]);\n      });\n      var replaceShim = function replace(searchValue, replaceValue) {\n        var O = ES.RequireObjectCoercible(this);\n        if (searchValue !== null && typeof searchValue !== 'undefined') {\n          var replacer = ES.GetMethod(searchValue, symbolReplace);\n          if (typeof replacer !== 'undefined') {\n            return ES.Call(replacer, searchValue, [O, replaceValue]);\n          }\n        }\n        return ES.Call(originalReplace, O, [ES.ToString(searchValue), replaceValue]);\n      };\n      overrideNative(String.prototype, 'replace', replaceShim);\n    }\n    if (!Type.symbol(Symbol.split)) {\n      var symbolSplit = defineWellKnownSymbol('split');\n      var originalSplit = String.prototype.split;\n      defineProperty(RegExp.prototype, symbolSplit, function split(string, limit) {\n        return ES.Call(originalSplit, string, [this, limit]);\n      });\n      var splitShim = function split(separator, limit) {\n        var O = ES.RequireObjectCoercible(this);\n        if (separator !== null && typeof separator !== 'undefined') {\n          var splitter = ES.GetMethod(separator, symbolSplit);\n          if (typeof splitter !== 'undefined') {\n            return ES.Call(splitter, separator, [O, limit]);\n          }\n        }\n        return ES.Call(originalSplit, O, [ES.ToString(separator), limit]);\n      };\n      overrideNative(String.prototype, 'split', splitShim);\n    }\n    var symbolMatchExists = Type.symbol(Symbol.match);\n    var stringMatchIgnoresSymbolMatch = symbolMatchExists && (function () {\n      // Firefox 41, through Nightly 45 has Symbol.match, but String#match ignores it.\n      // Firefox 40 and below have Symbol.match but String#match works fine.\n      var o = {};\n      o[Symbol.match] = function () { return 42; };\n      return 'a'.match(o) !== 42;\n    }());\n    if (!symbolMatchExists || stringMatchIgnoresSymbolMatch) {\n      var symbolMatch = defineWellKnownSymbol('match');\n\n      var originalMatch = String.prototype.match;\n      defineProperty(RegExp.prototype, symbolMatch, function match(string) {\n        return ES.Call(originalMatch, string, [this]);\n      });\n\n      var matchShim = function match(regexp) {\n        var O = ES.RequireObjectCoercible(this);\n        if (regexp !== null && typeof regexp !== 'undefined') {\n          var matcher = ES.GetMethod(regexp, symbolMatch);\n          if (typeof matcher !== 'undefined') {\n            return ES.Call(matcher, regexp, [O]);\n          }\n        }\n        return ES.Call(originalMatch, O, [ES.ToString(regexp)]);\n      };\n      overrideNative(String.prototype, 'match', matchShim);\n    }\n  }\n\n  var wrapConstructor = function wrapConstructor(original, replacement, keysToSkip) {\n    Value.preserveToString(replacement, original);\n    if (Object.setPrototypeOf) {\n      // sets up proper prototype chain where possible\n      Object.setPrototypeOf(original, replacement);\n    }\n    if (supportsDescriptors) {\n      _forEach(Object.getOwnPropertyNames(original), function (key) {\n        if (key in noop || keysToSkip[key]) { return; }\n        Value.proxy(original, key, replacement);\n      });\n    } else {\n      _forEach(Object.keys(original), function (key) {\n        if (key in noop || keysToSkip[key]) { return; }\n        replacement[key] = original[key];\n      });\n    }\n    replacement.prototype = original.prototype;\n    Value.redefine(original.prototype, 'constructor', replacement);\n  };\n\n  var defaultSpeciesGetter = function () { return this; };\n  var addDefaultSpecies = function (C) {\n    if (supportsDescriptors && !_hasOwnProperty(C, symbolSpecies)) {\n      Value.getter(C, symbolSpecies, defaultSpeciesGetter);\n    }\n  };\n\n  var addIterator = function (prototype, impl) {\n    var implementation = impl || function iterator() { return this; };\n    defineProperty(prototype, $iterator$, implementation);\n    if (!prototype[$iterator$] && Type.symbol($iterator$)) {\n      // implementations are buggy when $iterator$ is a Symbol\n      prototype[$iterator$] = implementation;\n    }\n  };\n\n  var createDataProperty = function createDataProperty(object, name, value) {\n    if (supportsDescriptors) {\n      Object.defineProperty(object, name, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: value\n      });\n    } else {\n      object[name] = value;\n    }\n  };\n  var createDataPropertyOrThrow = function createDataPropertyOrThrow(object, name, value) {\n    createDataProperty(object, name, value);\n    if (!ES.SameValue(object[name], value)) {\n      throw new TypeError('property is nonconfigurable');\n    }\n  };\n\n  var emulateES6construct = function (o, defaultNewTarget, defaultProto, slots) {\n    // This is an es5 approximation to es6 construct semantics.  in es6,\n    // 'new Foo' invokes Foo.[[Construct]] which (for almost all objects)\n    // just sets the internal variable NewTarget (in es6 syntax `new.target`)\n    // to Foo and then returns Foo().\n\n    // Many ES6 object then have constructors of the form:\n    // 1. If NewTarget is undefined, throw a TypeError exception\n    // 2. Let xxx by OrdinaryCreateFromConstructor(NewTarget, yyy, zzz)\n\n    // So we're going to emulate those first two steps.\n    if (!ES.TypeIsObject(o)) {\n      throw new TypeError('Constructor requires `new`: ' + defaultNewTarget.name);\n    }\n    var proto = defaultNewTarget.prototype;\n    if (!ES.TypeIsObject(proto)) {\n      proto = defaultProto;\n    }\n    var obj = create(proto);\n    for (var name in slots) {\n      if (_hasOwnProperty(slots, name)) {\n        var value = slots[name];\n        defineProperty(obj, name, value, true);\n      }\n    }\n    return obj;\n  };\n\n  // Firefox 31 reports this function's length as 0\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484\n  if (String.fromCodePoint && String.fromCodePoint.length !== 1) {\n    var originalFromCodePoint = String.fromCodePoint;\n    overrideNative(String, 'fromCodePoint', function fromCodePoint(codePoints) { return ES.Call(originalFromCodePoint, this, arguments); });\n  }\n\n  var StringShims = {\n    fromCodePoint: function fromCodePoint(codePoints) {\n      var result = [];\n      var next;\n      for (var i = 0, length = arguments.length; i < length; i++) {\n        next = Number(arguments[i]);\n        if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {\n          throw new RangeError('Invalid code point ' + next);\n        }\n\n        if (next < 0x10000) {\n          _push(result, String.fromCharCode(next));\n        } else {\n          next -= 0x10000;\n          _push(result, String.fromCharCode((next >> 10) + 0xD800));\n          _push(result, String.fromCharCode((next % 0x400) + 0xDC00));\n        }\n      }\n      return result.join('');\n    },\n\n    raw: function raw(callSite) {\n      var cooked = ES.ToObject(callSite, 'bad callSite');\n      var rawString = ES.ToObject(cooked.raw, 'bad raw value');\n      var len = rawString.length;\n      var literalsegments = ES.ToLength(len);\n      if (literalsegments <= 0) {\n        return '';\n      }\n\n      var stringElements = [];\n      var nextIndex = 0;\n      var nextKey, next, nextSeg, nextSub;\n      while (nextIndex < literalsegments) {\n        nextKey = ES.ToString(nextIndex);\n        nextSeg = ES.ToString(rawString[nextKey]);\n        _push(stringElements, nextSeg);\n        if (nextIndex + 1 >= literalsegments) {\n          break;\n        }\n        next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : '';\n        nextSub = ES.ToString(next);\n        _push(stringElements, nextSub);\n        nextIndex += 1;\n      }\n      return stringElements.join('');\n    }\n  };\n  if (String.raw && String.raw({ raw: { 0: 'x', 1: 'y', length: 2 } }) !== 'xy') {\n    // IE 11 TP has a broken String.raw implementation\n    overrideNative(String, 'raw', StringShims.raw);\n  }\n  defineProperties(String, StringShims);\n\n  // Fast repeat, uses the `Exponentiation by squaring` algorithm.\n  // Perf: http://jsperf.com/string-repeat2/2\n  var stringRepeat = function repeat(s, times) {\n    if (times < 1) { return ''; }\n    if (times % 2) { return repeat(s, times - 1) + s; }\n    var half = repeat(s, times / 2);\n    return half + half;\n  };\n  var stringMaxLength = Infinity;\n\n  var StringPrototypeShims = {\n    repeat: function repeat(times) {\n      var thisStr = ES.ToString(ES.RequireObjectCoercible(this));\n      var numTimes = ES.ToInteger(times);\n      if (numTimes < 0 || numTimes >= stringMaxLength) {\n        throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');\n      }\n      return stringRepeat(thisStr, numTimes);\n    },\n\n    startsWith: function startsWith(searchString) {\n      var S = ES.ToString(ES.RequireObjectCoercible(this));\n      if (ES.IsRegExp(searchString)) {\n        throw new TypeError('Cannot call method \"startsWith\" with a regex');\n      }\n      var searchStr = ES.ToString(searchString);\n      var position;\n      if (arguments.length > 1) {\n        position = arguments[1];\n      }\n      var start = _max(ES.ToInteger(position), 0);\n      return _strSlice(S, start, start + searchStr.length) === searchStr;\n    },\n\n    endsWith: function endsWith(searchString) {\n      var S = ES.ToString(ES.RequireObjectCoercible(this));\n      if (ES.IsRegExp(searchString)) {\n        throw new TypeError('Cannot call method \"endsWith\" with a regex');\n      }\n      var searchStr = ES.ToString(searchString);\n      var len = S.length;\n      var endPosition;\n      if (arguments.length > 1) {\n        endPosition = arguments[1];\n      }\n      var pos = typeof endPosition === 'undefined' ? len : ES.ToInteger(endPosition);\n      var end = _min(_max(pos, 0), len);\n      return _strSlice(S, end - searchStr.length, end) === searchStr;\n    },\n\n    includes: function includes(searchString) {\n      if (ES.IsRegExp(searchString)) {\n        throw new TypeError('\"includes\" does not accept a RegExp');\n      }\n      var searchStr = ES.ToString(searchString);\n      var position;\n      if (arguments.length > 1) {\n        position = arguments[1];\n      }\n      // Somehow this trick makes method 100% compat with the spec.\n      return _indexOf(this, searchStr, position) !== -1;\n    },\n\n    codePointAt: function codePointAt(pos) {\n      var thisStr = ES.ToString(ES.RequireObjectCoercible(this));\n      var position = ES.ToInteger(pos);\n      var length = thisStr.length;\n      if (position >= 0 && position < length) {\n        var first = thisStr.charCodeAt(position);\n        var isEnd = (position + 1 === length);\n        if (first < 0xD800 || first > 0xDBFF || isEnd) { return first; }\n        var second = thisStr.charCodeAt(position + 1);\n        if (second < 0xDC00 || second > 0xDFFF) { return first; }\n        return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;\n      }\n    }\n  };\n  if (String.prototype.includes && 'a'.includes('a', Infinity) !== false) {\n    overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);\n  }\n\n  if (String.prototype.startsWith && String.prototype.endsWith) {\n    var startsWithRejectsRegex = throwsError(function () {\n      /* throws if spec-compliant */\n      '/a/'.startsWith(/a/);\n    });\n    var startsWithHandlesInfinity = 'abc'.startsWith('a', Infinity) === false;\n    if (!startsWithRejectsRegex || !startsWithHandlesInfinity) {\n      // Firefox (< 37?) and IE 11 TP have a noncompliant startsWith implementation\n      overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);\n      overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);\n    }\n  }\n  if (hasSymbols) {\n    var startsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {\n      var re = /a/;\n      re[Symbol.match] = false;\n      return '/a/'.startsWith(re);\n    });\n    if (!startsWithSupportsSymbolMatch) {\n      overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);\n    }\n    var endsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {\n      var re = /a/;\n      re[Symbol.match] = false;\n      return '/a/'.endsWith(re);\n    });\n    if (!endsWithSupportsSymbolMatch) {\n      overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);\n    }\n    var includesSupportsSymbolMatch = valueOrFalseIfThrows(function () {\n      var re = /a/;\n      re[Symbol.match] = false;\n      return '/a/'.includes(re);\n    });\n    if (!includesSupportsSymbolMatch) {\n      overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);\n    }\n  }\n\n  defineProperties(String.prototype, StringPrototypeShims);\n\n  // whitespace from: http://es5.github.io/#x15.5.4.20\n  // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324\n  var ws = [\n    '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003',\n    '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028',\n    '\\u2029\\uFEFF'\n  ].join('');\n  var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');\n  var trimShim = function trim() {\n    return ES.ToString(ES.RequireObjectCoercible(this)).replace(trimRegexp, '');\n  };\n  var nonWS = ['\\u0085', '\\u200b', '\\ufffe'].join('');\n  var nonWSregex = new RegExp('[' + nonWS + ']', 'g');\n  var isBadHexRegex = /^[\\-+]0x[0-9a-f]+$/i;\n  var hasStringTrimBug = nonWS.trim().length !== nonWS.length;\n  defineProperty(String.prototype, 'trim', trimShim, hasStringTrimBug);\n\n  // see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype-@@iterator\n  var StringIterator = function (s) {\n    ES.RequireObjectCoercible(s);\n    this._s = ES.ToString(s);\n    this._i = 0;\n  };\n  StringIterator.prototype.next = function () {\n    var s = this._s, i = this._i;\n    if (typeof s === 'undefined' || i >= s.length) {\n      this._s = void 0;\n      return { value: void 0, done: true };\n    }\n    var first = s.charCodeAt(i), second, len;\n    if (first < 0xD800 || first > 0xDBFF || (i + 1) === s.length) {\n      len = 1;\n    } else {\n      second = s.charCodeAt(i + 1);\n      len = (second < 0xDC00 || second > 0xDFFF) ? 1 : 2;\n    }\n    this._i = i + len;\n    return { value: s.substr(i, len), done: false };\n  };\n  addIterator(StringIterator.prototype);\n  addIterator(String.prototype, function () {\n    return new StringIterator(this);\n  });\n\n  var ArrayShims = {\n    from: function from(items) {\n      var C = this;\n      var mapFn;\n      if (arguments.length > 1) {\n        mapFn = arguments[1];\n      }\n      var mapping, T;\n      if (typeof mapFn === 'undefined') {\n        mapping = false;\n      } else {\n        if (!ES.IsCallable(mapFn)) {\n          throw new TypeError('Array.from: when provided, the second argument must be a function');\n        }\n        if (arguments.length > 2) {\n          T = arguments[2];\n        }\n        mapping = true;\n      }\n\n      // Note that that Arrays will use ArrayIterator:\n      // https://bugs.ecmascript.org/show_bug.cgi?id=2416\n      var usingIterator = typeof (isArguments(items) || ES.GetMethod(items, $iterator$)) !== 'undefined';\n\n      var length, result, i;\n      if (usingIterator) {\n        result = ES.IsConstructor(C) ? Object(new C()) : [];\n        var iterator = ES.GetIterator(items);\n        var next, nextValue;\n\n        i = 0;\n        while (true) {\n          next = ES.IteratorStep(iterator);\n          if (next === false) {\n            break;\n          }\n          nextValue = next.value;\n          try {\n            if (mapping) {\n              nextValue = typeof T === 'undefined' ? mapFn(nextValue, i) : _call(mapFn, T, nextValue, i);\n            }\n            result[i] = nextValue;\n          } catch (e) {\n            ES.IteratorClose(iterator, true);\n            throw e;\n          }\n          i += 1;\n        }\n        length = i;\n      } else {\n        var arrayLike = ES.ToObject(items);\n        length = ES.ToLength(arrayLike.length);\n        result = ES.IsConstructor(C) ? Object(new C(length)) : new Array(length);\n        var value;\n        for (i = 0; i < length; ++i) {\n          value = arrayLike[i];\n          if (mapping) {\n            value = typeof T === 'undefined' ? mapFn(value, i) : _call(mapFn, T, value, i);\n          }\n          result[i] = value;\n        }\n      }\n\n      result.length = length;\n      return result;\n    },\n\n    of: function of() {\n      var len = arguments.length;\n      var C = this;\n      var A = isArray(C) || !ES.IsCallable(C) ? new Array(len) : ES.Construct(C, [len]);\n      for (var k = 0; k < len; ++k) {\n        createDataPropertyOrThrow(A, k, arguments[k]);\n      }\n      A.length = len;\n      return A;\n    }\n  };\n  defineProperties(Array, ArrayShims);\n  addDefaultSpecies(Array);\n\n  // Given an argument x, it will return an IteratorResult object,\n  // with value set to x and done to false.\n  // Given no arguments, it will return an iterator completion object.\n  var iteratorResult = function (x) {\n    return { value: x, done: arguments.length === 0 };\n  };\n\n  // Our ArrayIterator is private; see\n  // https://github.com/paulmillr/es6-shim/issues/252\n  ArrayIterator = function (array, kind) {\n      this.i = 0;\n      this.array = array;\n      this.kind = kind;\n  };\n\n  defineProperties(ArrayIterator.prototype, {\n    next: function () {\n      var i = this.i, array = this.array;\n      if (!(this instanceof ArrayIterator)) {\n        throw new TypeError('Not an ArrayIterator');\n      }\n      if (typeof array !== 'undefined') {\n        var len = ES.ToLength(array.length);\n        for (; i < len; i++) {\n          var kind = this.kind;\n          var retval;\n          if (kind === 'key') {\n            retval = i;\n          } else if (kind === 'value') {\n            retval = array[i];\n          } else if (kind === 'entry') {\n            retval = [i, array[i]];\n          }\n          this.i = i + 1;\n          return { value: retval, done: false };\n        }\n      }\n      this.array = void 0;\n      return { value: void 0, done: true };\n    }\n  });\n  addIterator(ArrayIterator.prototype);\n\n  var orderKeys = function orderKeys(a, b) {\n    var aNumeric = String(ES.ToInteger(a)) === a;\n    var bNumeric = String(ES.ToInteger(b)) === b;\n    if (aNumeric && bNumeric) {\n      return b - a;\n    } else if (aNumeric && !bNumeric) {\n      return -1;\n    } else if (!aNumeric && bNumeric) {\n      return 1;\n    } else {\n      return a.localeCompare(b);\n    }\n  };\n  var getAllKeys = function getAllKeys(object) {\n    var ownKeys = [];\n    var keys = [];\n\n    for (var key in object) {\n      _push(_hasOwnProperty(object, key) ? ownKeys : keys, key);\n    }\n    _sort(ownKeys, orderKeys);\n    _sort(keys, orderKeys);\n\n    return _concat(ownKeys, keys);\n  };\n\n  var ObjectIterator = function (object, kind) {\n    defineProperties(this, {\n      object: object,\n      array: getAllKeys(object),\n      kind: kind\n    });\n  };\n\n  defineProperties(ObjectIterator.prototype, {\n    next: function next() {\n      var key;\n      var array = this.array;\n\n      if (!(this instanceof ObjectIterator)) {\n        throw new TypeError('Not an ObjectIterator');\n      }\n\n      // Find next key in the object\n      while (array.length > 0) {\n        key = _shift(array);\n\n        // The candidate key isn't defined on object.\n        // Must have been deleted, or object[[Prototype]]\n        // has been modified.\n        if (!(key in this.object)) {\n          continue;\n        }\n\n        if (this.kind === 'key') {\n          return iteratorResult(key);\n        } else if (this.kind === 'value') {\n          return iteratorResult(this.object[key]);\n        } else {\n          return iteratorResult([key, this.object[key]]);\n        }\n      }\n\n      return iteratorResult();\n    }\n  });\n  addIterator(ObjectIterator.prototype);\n\n  // note: this is positioned here because it depends on ArrayIterator\n  var arrayOfSupportsSubclassing = Array.of === ArrayShims.of || (function () {\n    // Detects a bug in Webkit nightly r181886\n    var Foo = function Foo(len) { this.length = len; };\n    Foo.prototype = [];\n    var fooArr = Array.of.apply(Foo, [1, 2]);\n    return fooArr instanceof Foo && fooArr.length === 2;\n  }());\n  if (!arrayOfSupportsSubclassing) {\n    overrideNative(Array, 'of', ArrayShims.of);\n  }\n\n  var ArrayPrototypeShims = {\n    copyWithin: function copyWithin(target, start) {\n      var o = ES.ToObject(this);\n      var len = ES.ToLength(o.length);\n      var relativeTarget = ES.ToInteger(target);\n      var relativeStart = ES.ToInteger(start);\n      var to = relativeTarget < 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);\n      var from = relativeStart < 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);\n      var end;\n      if (arguments.length > 2) {\n        end = arguments[2];\n      }\n      var relativeEnd = typeof end === 'undefined' ? len : ES.ToInteger(end);\n      var finalItem = relativeEnd < 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);\n      var count = _min(finalItem - from, len - to);\n      var direction = 1;\n      if (from < to && to < (from + count)) {\n        direction = -1;\n        from += count - 1;\n        to += count - 1;\n      }\n      while (count > 0) {\n        if (_hasOwnProperty(o, from)) {\n          o[to] = o[from];\n        } else {\n          delete o[from];\n        }\n        from += direction;\n        to += direction;\n        count -= 1;\n      }\n      return o;\n    },\n\n    fill: function fill(value) {\n      var start;\n      if (arguments.length > 1) {\n        start = arguments[1];\n      }\n      var end;\n      if (arguments.length > 2) {\n        end = arguments[2];\n      }\n      var O = ES.ToObject(this);\n      var len = ES.ToLength(O.length);\n      start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);\n      end = ES.ToInteger(typeof end === 'undefined' ? len : end);\n\n      var relativeStart = start < 0 ? _max(len + start, 0) : _min(start, len);\n      var relativeEnd = end < 0 ? len + end : end;\n\n      for (var i = relativeStart; i < len && i < relativeEnd; ++i) {\n        O[i] = value;\n      }\n      return O;\n    },\n\n    find: function find(predicate) {\n      var list = ES.ToObject(this);\n      var length = ES.ToLength(list.length);\n      if (!ES.IsCallable(predicate)) {\n        throw new TypeError('Array#find: predicate must be a function');\n      }\n      var thisArg = arguments.length > 1 ? arguments[1] : null;\n      for (var i = 0, value; i < length; i++) {\n        value = list[i];\n        if (thisArg) {\n          if (_call(predicate, thisArg, value, i, list)) { return value; }\n        } else if (predicate(value, i, list)) {\n          return value;\n        }\n      }\n    },\n\n    findIndex: function findIndex(predicate) {\n      var list = ES.ToObject(this);\n      var length = ES.ToLength(list.length);\n      if (!ES.IsCallable(predicate)) {\n        throw new TypeError('Array#findIndex: predicate must be a function');\n      }\n      var thisArg = arguments.length > 1 ? arguments[1] : null;\n      for (var i = 0; i < length; i++) {\n        if (thisArg) {\n          if (_call(predicate, thisArg, list[i], i, list)) { return i; }\n        } else if (predicate(list[i], i, list)) {\n          return i;\n        }\n      }\n      return -1;\n    },\n\n    keys: function keys() {\n      return new ArrayIterator(this, 'key');\n    },\n\n    values: function values() {\n      return new ArrayIterator(this, 'value');\n    },\n\n    entries: function entries() {\n      return new ArrayIterator(this, 'entry');\n    }\n  };\n  // Safari 7.1 defines Array#keys and Array#entries natively,\n  // but the resulting ArrayIterator objects don't have a \"next\" method.\n  if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {\n    delete Array.prototype.keys;\n  }\n  if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {\n    delete Array.prototype.entries;\n  }\n\n  // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values\n  if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {\n    defineProperties(Array.prototype, {\n      values: Array.prototype[$iterator$]\n    });\n    if (Type.symbol(Symbol.unscopables)) {\n      Array.prototype[Symbol.unscopables].values = true;\n    }\n  }\n  // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name\n  if (functionsHaveNames && Array.prototype.values && Array.prototype.values.name !== 'values') {\n    var originalArrayPrototypeValues = Array.prototype.values;\n    overrideNative(Array.prototype, 'values', function values() { return ES.Call(originalArrayPrototypeValues, this, arguments); });\n    defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);\n  }\n  defineProperties(Array.prototype, ArrayPrototypeShims);\n\n  addIterator(Array.prototype, function () { return this.values(); });\n  // Chrome defines keys/values/entries on Array, but doesn't give us\n  // any way to identify its iterator.  So add our own shimmed field.\n  if (Object.getPrototypeOf) {\n    addIterator(Object.getPrototypeOf([].values()));\n  }\n\n  // note: this is positioned here because it relies on Array#entries\n  var arrayFromSwallowsNegativeLengths = (function () {\n    // Detects a Firefox bug in v32\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993\n    return valueOrFalseIfThrows(function () { return Array.from({ length: -1 }).length === 0; });\n  }());\n  var arrayFromHandlesIterables = (function () {\n    // Detects a bug in Webkit nightly r181886\n    var arr = Array.from([0].entries());\n    return arr.length === 1 && isArray(arr[0]) && arr[0][0] === 0 && arr[0][1] === 0;\n  }());\n  if (!arrayFromSwallowsNegativeLengths || !arrayFromHandlesIterables) {\n    overrideNative(Array, 'from', ArrayShims.from);\n  }\n  var arrayFromHandlesUndefinedMapFunction = (function () {\n    // Microsoft Edge v0.11 throws if the mapFn argument is *provided* but undefined,\n    // but the spec doesn't care if it's provided or not - undefined doesn't throw.\n    return valueOrFalseIfThrows(function () { return Array.from([0], void 0); });\n  }());\n  if (!arrayFromHandlesUndefinedMapFunction) {\n    var origArrayFrom = Array.from;\n    overrideNative(Array, 'from', function from(items) {\n      if (arguments.length > 1 && typeof arguments[1] !== 'undefined') {\n        return ES.Call(origArrayFrom, this, arguments);\n      } else {\n        return _call(origArrayFrom, this, items);\n      }\n    });\n  }\n\n  var int32sAsOne = -(Math.pow(2, 32) - 1);\n  var toLengthsCorrectly = function (method, reversed) {\n    var obj = { length: int32sAsOne };\n    obj[reversed ? ((obj.length >>> 0) - 1) : 0] = true;\n    return valueOrFalseIfThrows(function () {\n      _call(method, obj, function () {\n        // note: in nonconforming browsers, this will be called\n        // -1 >>> 0 times, which is 4294967295, so the throw matters.\n        throw new RangeError('should not reach here');\n      }, []);\n      return true;\n    });\n  };\n  if (!toLengthsCorrectly(Array.prototype.forEach)) {\n    var originalForEach = Array.prototype.forEach;\n    overrideNative(Array.prototype, 'forEach', function forEach(callbackFn) {\n      return ES.Call(originalForEach, this.length >= 0 ? this : [], arguments);\n    }, true);\n  }\n  if (!toLengthsCorrectly(Array.prototype.map)) {\n    var originalMap = Array.prototype.map;\n    overrideNative(Array.prototype, 'map', function map(callbackFn) {\n      return ES.Call(originalMap, this.length >= 0 ? this : [], arguments);\n    }, true);\n  }\n  if (!toLengthsCorrectly(Array.prototype.filter)) {\n    var originalFilter = Array.prototype.filter;\n    overrideNative(Array.prototype, 'filter', function filter(callbackFn) {\n      return ES.Call(originalFilter, this.length >= 0 ? this : [], arguments);\n    }, true);\n  }\n  if (!toLengthsCorrectly(Array.prototype.some)) {\n    var originalSome = Array.prototype.some;\n    overrideNative(Array.prototype, 'some', function some(callbackFn) {\n      return ES.Call(originalSome, this.length >= 0 ? this : [], arguments);\n    }, true);\n  }\n  if (!toLengthsCorrectly(Array.prototype.every)) {\n    var originalEvery = Array.prototype.every;\n    overrideNative(Array.prototype, 'every', function every(callbackFn) {\n      return ES.Call(originalEvery, this.length >= 0 ? this : [], arguments);\n    }, true);\n  }\n  if (!toLengthsCorrectly(Array.prototype.reduce)) {\n    var originalReduce = Array.prototype.reduce;\n    overrideNative(Array.prototype, 'reduce', function reduce(callbackFn) {\n      return ES.Call(originalReduce, this.length >= 0 ? this : [], arguments);\n    }, true);\n  }\n  if (!toLengthsCorrectly(Array.prototype.reduceRight, true)) {\n    var originalReduceRight = Array.prototype.reduceRight;\n    overrideNative(Array.prototype, 'reduceRight', function reduceRight(callbackFn) {\n      return ES.Call(originalReduceRight, this.length >= 0 ? this : [], arguments);\n    }, true);\n  }\n\n  var lacksOctalSupport = Number('0o10') !== 8;\n  var lacksBinarySupport = Number('0b10') !== 2;\n  var trimsNonWhitespace = _some(nonWS, function (c) {\n    return Number(c + 0 + c) === 0;\n  });\n  if (lacksOctalSupport || lacksBinarySupport || trimsNonWhitespace) {\n    var OrigNumber = Number;\n    var binaryRegex = /^0b[01]+$/i;\n    var octalRegex = /^0o[0-7]+$/i;\n    // Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, \"test\" is an own property of regexes. wtf.\n    var isBinary = binaryRegex.test.bind(binaryRegex);\n    var isOctal = octalRegex.test.bind(octalRegex);\n    var toPrimitive = function (O) { // need to replace this with `es-to-primitive/es6`\n      var result;\n      if (typeof O.valueOf === 'function') {\n        result = O.valueOf();\n        if (Type.primitive(result)) {\n          return result;\n        }\n      }\n      if (typeof O.toString === 'function') {\n        result = O.toString();\n        if (Type.primitive(result)) {\n          return result;\n        }\n      }\n      throw new TypeError('No default value');\n    };\n    var hasNonWS = nonWSregex.test.bind(nonWSregex);\n    var isBadHex = isBadHexRegex.test.bind(isBadHexRegex);\n    var NumberShim = (function () {\n      // this is wrapped in an IIFE because of IE 6-8's wacky scoping issues with named function expressions.\n      var NumberShim = function Number(value) {\n        var primValue;\n        if (arguments.length > 0) {\n          primValue = Type.primitive(value) ? value : toPrimitive(value, 'number');\n        } else {\n          primValue = 0;\n        }\n        if (typeof primValue === 'string') {\n          primValue = ES.Call(trimShim, primValue);\n          if (isBinary(primValue)) {\n            primValue = parseInt(_strSlice(primValue, 2), 2);\n          } else if (isOctal(primValue)) {\n            primValue = parseInt(_strSlice(primValue, 2), 8);\n          } else if (hasNonWS(primValue) || isBadHex(primValue)) {\n            primValue = NaN;\n          }\n        }\n        var receiver = this;\n        var valueOfSucceeds = valueOrFalseIfThrows(function () {\n          OrigNumber.prototype.valueOf.call(receiver);\n          return true;\n        });\n        if (receiver instanceof NumberShim && !valueOfSucceeds) {\n          return new OrigNumber(primValue);\n        }\n        /* jshint newcap: false */\n        return OrigNumber(primValue);\n        /* jshint newcap: true */\n      };\n      return NumberShim;\n    }());\n    wrapConstructor(OrigNumber, NumberShim, {});\n    /*globals Number: true */\n    /* eslint-disable no-undef */\n    Number = NumberShim;\n    Value.redefine(globals, 'Number', NumberShim);\n    /* eslint-enable no-undef */\n    /*globals Number: false */\n  }\n\n  var maxSafeInteger = Math.pow(2, 53) - 1;\n  defineProperties(Number, {\n    MAX_SAFE_INTEGER: maxSafeInteger,\n    MIN_SAFE_INTEGER: -maxSafeInteger,\n    EPSILON: 2.220446049250313e-16,\n\n    parseInt: globals.parseInt,\n    parseFloat: globals.parseFloat,\n\n    isFinite: numberIsFinite,\n\n    isInteger: function isInteger(value) {\n      return numberIsFinite(value) && ES.ToInteger(value) === value;\n    },\n\n    isSafeInteger: function isSafeInteger(value) {\n      return Number.isInteger(value) && _abs(value) <= Number.MAX_SAFE_INTEGER;\n    },\n\n    isNaN: numberIsNaN\n  });\n  // Firefox 37 has a conforming Number.parseInt, but it's not === to the global parseInt (fixed in v40)\n  defineProperty(Number, 'parseInt', globals.parseInt, Number.parseInt !== globals.parseInt);\n\n  // Work around bugs in Array#find and Array#findIndex -- early\n  // implementations skipped holes in sparse arrays. (Note that the\n  // implementations of find/findIndex indirectly use shimmed\n  // methods of Number, so this test has to happen down here.)\n  /*jshint elision: true */\n  /* eslint-disable no-sparse-arrays */\n  if (![, 1].find(function (item, idx) { return idx === 0; })) {\n    overrideNative(Array.prototype, 'find', ArrayPrototypeShims.find);\n  }\n  if ([, 1].findIndex(function (item, idx) { return idx === 0; }) !== 0) {\n    overrideNative(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex);\n  }\n  /* eslint-enable no-sparse-arrays */\n  /*jshint elision: false */\n\n  var isEnumerableOn = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);\n  var ensureEnumerable = function ensureEnumerable(obj, prop) {\n    if (supportsDescriptors && isEnumerableOn(obj, prop)) {\n      Object.defineProperty(obj, prop, { enumerable: false });\n    }\n  };\n  var sliceArgs = function sliceArgs() {\n    // per https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n    // and https://gist.github.com/WebReflection/4327762cb87a8c634a29\n    var initial = Number(this);\n    var len = arguments.length;\n    var desiredArgCount = len - initial;\n    var args = new Array(desiredArgCount < 0 ? 0 : desiredArgCount);\n    for (var i = initial; i < len; ++i) {\n      args[i - initial] = arguments[i];\n    }\n    return args;\n  };\n  var assignTo = function assignTo(source) {\n    return function assignToSource(target, key) {\n      target[key] = source[key];\n      return target;\n    };\n  };\n  var assignReducer = function (target, source) {\n    var sourceKeys = keys(Object(source));\n    var symbols;\n    if (ES.IsCallable(Object.getOwnPropertySymbols)) {\n      symbols = _filter(Object.getOwnPropertySymbols(Object(source)), isEnumerableOn(source));\n    }\n    return _reduce(_concat(sourceKeys, symbols || []), assignTo(source), target);\n  };\n\n  var ObjectShims = {\n    // 19.1.3.1\n    assign: function (target, source) {\n      var to = ES.ToObject(target, 'Cannot convert undefined or null to object');\n      return _reduce(ES.Call(sliceArgs, 1, arguments), assignReducer, to);\n    },\n\n    // Added in WebKit in https://bugs.webkit.org/show_bug.cgi?id=143865\n    is: function is(a, b) {\n      return ES.SameValue(a, b);\n    }\n  };\n  var assignHasPendingExceptions = Object.assign && Object.preventExtensions && (function () {\n    // Firefox 37 still has \"pending exception\" logic in its Object.assign implementation,\n    // which is 72% slower than our shim, and Firefox 40's native implementation.\n    var thrower = Object.preventExtensions({ 1: 2 });\n    try {\n      Object.assign(thrower, 'xy');\n    } catch (e) {\n      return thrower[1] === 'y';\n    }\n  }());\n  if (assignHasPendingExceptions) {\n    overrideNative(Object, 'assign', ObjectShims.assign);\n  }\n  defineProperties(Object, ObjectShims);\n\n  if (supportsDescriptors) {\n    var ES5ObjectShims = {\n      // 19.1.3.9\n      // shim from https://gist.github.com/WebReflection/5593554\n      setPrototypeOf: (function (Object, magic) {\n        var set;\n\n        var checkArgs = function (O, proto) {\n          if (!ES.TypeIsObject(O)) {\n            throw new TypeError('cannot set prototype on a non-object');\n          }\n          if (!(proto === null || ES.TypeIsObject(proto))) {\n            throw new TypeError('can only set prototype to an object or null' + proto);\n          }\n        };\n\n        var setPrototypeOf = function (O, proto) {\n          checkArgs(O, proto);\n          _call(set, O, proto);\n          return O;\n        };\n\n        try {\n          // this works already in Firefox and Safari\n          set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;\n          _call(set, {}, null);\n        } catch (e) {\n          if (Object.prototype !== {}[magic]) {\n            // IE < 11 cannot be shimmed\n            return;\n          }\n          // probably Chrome or some old Mobile stock browser\n          set = function (proto) {\n            this[magic] = proto;\n          };\n          // please note that this will **not** work\n          // in those browsers that do not inherit\n          // __proto__ by mistake from Object.prototype\n          // in these cases we should probably throw an error\n          // or at least be informed about the issue\n          setPrototypeOf.polyfill = setPrototypeOf(\n            setPrototypeOf({}, null),\n            Object.prototype\n          ) instanceof Object;\n          // setPrototypeOf.polyfill === true means it works as meant\n          // setPrototypeOf.polyfill === false means it's not 100% reliable\n          // setPrototypeOf.polyfill === undefined\n          // or\n          // setPrototypeOf.polyfill ==  null means it's not a polyfill\n          // which means it works as expected\n          // we can even delete Object.prototype.__proto__;\n        }\n        return setPrototypeOf;\n      }(Object, '__proto__'))\n    };\n\n    defineProperties(Object, ES5ObjectShims);\n  }\n\n  // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,\n  // but Object.create(null) does.\n  if (Object.setPrototypeOf && Object.getPrototypeOf &&\n      Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null &&\n      Object.getPrototypeOf(Object.create(null)) === null) {\n    (function () {\n      var FAKENULL = Object.create(null);\n      var gpo = Object.getPrototypeOf, spo = Object.setPrototypeOf;\n      Object.getPrototypeOf = function (o) {\n        var result = gpo(o);\n        return result === FAKENULL ? null : result;\n      };\n      Object.setPrototypeOf = function (o, p) {\n        var proto = p === null ? FAKENULL : p;\n        return spo(o, proto);\n      };\n      Object.setPrototypeOf.polyfill = false;\n    }());\n  }\n\n  var objectKeysAcceptsPrimitives = !throwsError(function () { Object.keys('foo'); });\n  if (!objectKeysAcceptsPrimitives) {\n    var originalObjectKeys = Object.keys;\n    overrideNative(Object, 'keys', function keys(value) {\n      return originalObjectKeys(ES.ToObject(value));\n    });\n    keys = Object.keys;\n  }\n\n  if (Object.getOwnPropertyNames) {\n    var objectGOPNAcceptsPrimitives = !throwsError(function () { Object.getOwnPropertyNames('foo'); });\n    if (!objectGOPNAcceptsPrimitives) {\n      var cachedWindowNames = typeof window === 'object' ? Object.getOwnPropertyNames(window) : [];\n      var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;\n      overrideNative(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {\n        var val = ES.ToObject(value);\n        if (_toString(val) === '[object Window]') {\n          try {\n            return originalObjectGetOwnPropertyNames(val);\n          } catch (e) {\n            // IE bug where layout engine calls userland gOPN for cross-domain `window` objects\n            return _concat([], cachedWindowNames);\n          }\n        }\n        return originalObjectGetOwnPropertyNames(val);\n      });\n    }\n  }\n  if (Object.getOwnPropertyDescriptor) {\n    var objectGOPDAcceptsPrimitives = !throwsError(function () { Object.getOwnPropertyDescriptor('foo', 'bar'); });\n    if (!objectGOPDAcceptsPrimitives) {\n      var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n      overrideNative(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {\n        return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);\n      });\n    }\n  }\n  if (Object.seal) {\n    var objectSealAcceptsPrimitives = !throwsError(function () { Object.seal('foo'); });\n    if (!objectSealAcceptsPrimitives) {\n      var originalObjectSeal = Object.seal;\n      overrideNative(Object, 'seal', function seal(value) {\n        if (!Type.object(value)) { return value; }\n        return originalObjectSeal(value);\n      });\n    }\n  }\n  if (Object.isSealed) {\n    var objectIsSealedAcceptsPrimitives = !throwsError(function () { Object.isSealed('foo'); });\n    if (!objectIsSealedAcceptsPrimitives) {\n      var originalObjectIsSealed = Object.isSealed;\n      overrideNative(Object, 'isSealed', function isSealed(value) {\n        if (!Type.object(value)) { return true; }\n        return originalObjectIsSealed(value);\n      });\n    }\n  }\n  if (Object.freeze) {\n    var objectFreezeAcceptsPrimitives = !throwsError(function () { Object.freeze('foo'); });\n    if (!objectFreezeAcceptsPrimitives) {\n      var originalObjectFreeze = Object.freeze;\n      overrideNative(Object, 'freeze', function freeze(value) {\n        if (!Type.object(value)) { return value; }\n        return originalObjectFreeze(value);\n      });\n    }\n  }\n  if (Object.isFrozen) {\n    var objectIsFrozenAcceptsPrimitives = !throwsError(function () { Object.isFrozen('foo'); });\n    if (!objectIsFrozenAcceptsPrimitives) {\n      var originalObjectIsFrozen = Object.isFrozen;\n      overrideNative(Object, 'isFrozen', function isFrozen(value) {\n        if (!Type.object(value)) { return true; }\n        return originalObjectIsFrozen(value);\n      });\n    }\n  }\n  if (Object.preventExtensions) {\n    var objectPreventExtensionsAcceptsPrimitives = !throwsError(function () { Object.preventExtensions('foo'); });\n    if (!objectPreventExtensionsAcceptsPrimitives) {\n      var originalObjectPreventExtensions = Object.preventExtensions;\n      overrideNative(Object, 'preventExtensions', function preventExtensions(value) {\n        if (!Type.object(value)) { return value; }\n        return originalObjectPreventExtensions(value);\n      });\n    }\n  }\n  if (Object.isExtensible) {\n    var objectIsExtensibleAcceptsPrimitives = !throwsError(function () { Object.isExtensible('foo'); });\n    if (!objectIsExtensibleAcceptsPrimitives) {\n      var originalObjectIsExtensible = Object.isExtensible;\n      overrideNative(Object, 'isExtensible', function isExtensible(value) {\n        if (!Type.object(value)) { return false; }\n        return originalObjectIsExtensible(value);\n      });\n    }\n  }\n  if (Object.getPrototypeOf) {\n    var objectGetProtoAcceptsPrimitives = !throwsError(function () { Object.getPrototypeOf('foo'); });\n    if (!objectGetProtoAcceptsPrimitives) {\n      var originalGetProto = Object.getPrototypeOf;\n      overrideNative(Object, 'getPrototypeOf', function getPrototypeOf(value) {\n        return originalGetProto(ES.ToObject(value));\n      });\n    }\n  }\n\n  var hasFlags = supportsDescriptors && (function () {\n    var desc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags');\n    return desc && ES.IsCallable(desc.get);\n  }());\n  if (supportsDescriptors && !hasFlags) {\n    var regExpFlagsGetter = function flags() {\n      if (!ES.TypeIsObject(this)) {\n        throw new TypeError('Method called on incompatible type: must be an object.');\n      }\n      var result = '';\n      if (this.global) {\n        result += 'g';\n      }\n      if (this.ignoreCase) {\n        result += 'i';\n      }\n      if (this.multiline) {\n        result += 'm';\n      }\n      if (this.unicode) {\n        result += 'u';\n      }\n      if (this.sticky) {\n        result += 'y';\n      }\n      return result;\n    };\n\n    Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);\n  }\n\n  var regExpSupportsFlagsWithRegex = supportsDescriptors && valueOrFalseIfThrows(function () {\n    return String(new RegExp(/a/g, 'i')) === '/a/i';\n  });\n  var regExpNeedsToSupportSymbolMatch = hasSymbols && supportsDescriptors && (function () {\n    // Edge 0.12 supports flags fully, but does not support Symbol.match\n    var regex = /./;\n    regex[Symbol.match] = false;\n    return RegExp(regex) === regex;\n  }());\n\n  if (supportsDescriptors && (!regExpSupportsFlagsWithRegex || regExpNeedsToSupportSymbolMatch)) {\n    var flagsGetter = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags').get;\n    var sourceDesc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'source') || {};\n    var legacySourceGetter = function () { return this.source; }; // prior to it being a getter, it's own + nonconfigurable\n    var sourceGetter = ES.IsCallable(sourceDesc.get) ? sourceDesc.get : legacySourceGetter;\n\n    var OrigRegExp = RegExp;\n    var RegExpShim = (function () {\n      return function RegExp(pattern, flags) {\n        var patternIsRegExp = ES.IsRegExp(pattern);\n        var calledWithNew = this instanceof RegExp;\n        if (!calledWithNew && patternIsRegExp && typeof flags === 'undefined' && pattern.constructor === RegExp) {\n          return pattern;\n        }\n\n        var P = pattern;\n        var F = flags;\n        if (Type.regex(pattern)) {\n          P = ES.Call(sourceGetter, pattern);\n          F = typeof flags === 'undefined' ? ES.Call(flagsGetter, pattern) : flags;\n          return new RegExp(P, F);\n        } else if (patternIsRegExp) {\n          P = pattern.source;\n          F = typeof flags === 'undefined' ? pattern.flags : flags;\n        }\n        return new OrigRegExp(pattern, flags);\n      };\n    }());\n    wrapConstructor(OrigRegExp, RegExpShim, {\n      $input: true // Chrome < v39 & Opera < 26 have a nonstandard \"$input\" property\n    });\n    /*globals RegExp: true */\n    /* eslint-disable no-undef */\n    RegExp = RegExpShim;\n    Value.redefine(globals, 'RegExp', RegExpShim);\n    /* eslint-enable no-undef */\n    /*globals RegExp: false */\n  }\n\n  if (supportsDescriptors) {\n    var regexGlobals = {\n      input: '$_',\n      lastMatch: '$&',\n      lastParen: '$+',\n      leftContext: '$`',\n      rightContext: '$\\''\n    };\n    _forEach(keys(regexGlobals), function (prop) {\n      if (prop in RegExp && !(regexGlobals[prop] in RegExp)) {\n        Value.getter(RegExp, regexGlobals[prop], function get() {\n          return RegExp[prop];\n        });\n      }\n    });\n  }\n  addDefaultSpecies(RegExp);\n\n  var inverseEpsilon = 1 / Number.EPSILON;\n  var roundTiesToEven = function roundTiesToEven(n) {\n    // Even though this reduces down to `return n`, it takes advantage of built-in rounding.\n    return (n + inverseEpsilon) - inverseEpsilon;\n  };\n  var BINARY_32_EPSILON = Math.pow(2, -23);\n  var BINARY_32_MAX_VALUE = Math.pow(2, 127) * (2 - BINARY_32_EPSILON);\n  var BINARY_32_MIN_VALUE = Math.pow(2, -126);\n  var numberCLZ = Number.prototype.clz;\n  delete Number.prototype.clz; // Safari 8 has Number#clz\n\n  var MathShims = {\n    acosh: function acosh(value) {\n      var x = Number(value);\n      if (Number.isNaN(x) || value < 1) { return NaN; }\n      if (x === 1) { return 0; }\n      if (x === Infinity) { return x; }\n      return _log(x / Math.E + _sqrt(x + 1) * _sqrt(x - 1) / Math.E) + 1;\n    },\n\n    asinh: function asinh(value) {\n      var x = Number(value);\n      if (x === 0 || !globalIsFinite(x)) {\n        return x;\n      }\n      return x < 0 ? -Math.asinh(-x) : _log(x + _sqrt(x * x + 1));\n    },\n\n    atanh: function atanh(value) {\n      var x = Number(value);\n      if (Number.isNaN(x) || x < -1 || x > 1) {\n        return NaN;\n      }\n      if (x === -1) { return -Infinity; }\n      if (x === 1) { return Infinity; }\n      if (x === 0) { return x; }\n      return 0.5 * _log((1 + x) / (1 - x));\n    },\n\n    cbrt: function cbrt(value) {\n      var x = Number(value);\n      if (x === 0) { return x; }\n      var negate = x < 0, result;\n      if (negate) { x = -x; }\n      if (x === Infinity) {\n        result = Infinity;\n      } else {\n        result = Math.exp(_log(x) / 3);\n        // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods\n        result = (x / (result * result) + (2 * result)) / 3;\n      }\n      return negate ? -result : result;\n    },\n\n    clz32: function clz32(value) {\n      // See https://bugs.ecmascript.org/show_bug.cgi?id=2465\n      var x = Number(value);\n      var number = ES.ToUint32(x);\n      if (number === 0) {\n        return 32;\n      }\n      return numberCLZ ? ES.Call(numberCLZ, number) : 31 - _floor(_log(number + 0.5) * Math.LOG2E);\n    },\n\n    cosh: function cosh(value) {\n      var x = Number(value);\n      if (x === 0) { return 1; } // +0 or -0\n      if (Number.isNaN(x)) { return NaN; }\n      if (!globalIsFinite(x)) { return Infinity; }\n      if (x < 0) { x = -x; }\n      if (x > 21) { return Math.exp(x) / 2; }\n      return (Math.exp(x) + Math.exp(-x)) / 2;\n    },\n\n    expm1: function expm1(value) {\n      var x = Number(value);\n      if (x === -Infinity) { return -1; }\n      if (!globalIsFinite(x) || x === 0) { return x; }\n      if (_abs(x) > 0.5) {\n        return Math.exp(x) - 1;\n      }\n      // A more precise approximation using Taylor series expansion\n      // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986\n      var t = x;\n      var sum = 0;\n      var n = 1;\n      while (sum + t !== sum) {\n        sum += t;\n        n += 1;\n        t *= x / n;\n      }\n      return sum;\n    },\n\n    hypot: function hypot(x, y) {\n      var result = 0;\n      var largest = 0;\n      for (var i = 0; i < arguments.length; ++i) {\n        var value = _abs(Number(arguments[i]));\n        if (largest < value) {\n          result *= (largest / value) * (largest / value);\n          result += 1;\n          largest = value;\n        } else {\n          result += (value > 0 ? (value / largest) * (value / largest) : value);\n        }\n      }\n      return largest === Infinity ? Infinity : largest * _sqrt(result);\n    },\n\n    log2: function log2(value) {\n      return _log(value) * Math.LOG2E;\n    },\n\n    log10: function log10(value) {\n      return _log(value) * Math.LOG10E;\n    },\n\n    log1p: function log1p(value) {\n      var x = Number(value);\n      if (x < -1 || Number.isNaN(x)) { return NaN; }\n      if (x === 0 || x === Infinity) { return x; }\n      if (x === -1) { return -Infinity; }\n\n      return (1 + x) - 1 === 0 ? x : x * (_log(1 + x) / ((1 + x) - 1));\n    },\n\n    sign: function sign(value) {\n      var number = Number(value);\n      if (number === 0) { return number; }\n      if (Number.isNaN(number)) { return number; }\n      return number < 0 ? -1 : 1;\n    },\n\n    sinh: function sinh(value) {\n      var x = Number(value);\n      if (!globalIsFinite(x) || x === 0) { return x; }\n\n      if (_abs(x) < 1) {\n        return (Math.expm1(x) - Math.expm1(-x)) / 2;\n      }\n      return (Math.exp(x - 1) - Math.exp(-x - 1)) * Math.E / 2;\n    },\n\n    tanh: function tanh(value) {\n      var x = Number(value);\n      if (Number.isNaN(x) || x === 0) { return x; }\n      if (x === Infinity) { return 1; }\n      if (x === -Infinity) { return -1; }\n      var a = Math.expm1(x);\n      var b = Math.expm1(-x);\n      if (a === Infinity) { return 1; }\n      if (b === Infinity) { return -1; }\n      return (a - b) / (Math.exp(x) + Math.exp(-x));\n    },\n\n    trunc: function trunc(value) {\n      var x = Number(value);\n      return x < 0 ? -_floor(-x) : _floor(x);\n    },\n\n    imul: function imul(x, y) {\n      // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n      var a = ES.ToUint32(x);\n      var b = ES.ToUint32(y);\n      var ah = (a >>> 16) & 0xffff;\n      var al = a & 0xffff;\n      var bh = (b >>> 16) & 0xffff;\n      var bl = b & 0xffff;\n      // the shift by 0 fixes the sign on the high part\n      // the final |0 converts the unsigned value into a signed value\n      return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n    },\n\n    fround: function fround(x) {\n      var v = Number(x);\n      if (v === 0 || v === Infinity || v === -Infinity || numberIsNaN(v)) {\n        return v;\n      }\n      var sign = Math.sign(v);\n      var abs = _abs(v);\n      if (abs < BINARY_32_MIN_VALUE) {\n        return sign * roundTiesToEven(abs / BINARY_32_MIN_VALUE / BINARY_32_EPSILON) * BINARY_32_MIN_VALUE * BINARY_32_EPSILON;\n      }\n      // Veltkamp's splitting (?)\n      var a = (1 + BINARY_32_EPSILON / Number.EPSILON) * abs;\n      var result = a - (a - abs);\n      if (result > BINARY_32_MAX_VALUE || numberIsNaN(result)) {\n        return sign * Infinity;\n      }\n      return sign * result;\n    }\n  };\n  defineProperties(Math, MathShims);\n  // IE 11 TP has an imprecise log1p: reports Math.log1p(-1e-17) as 0\n  defineProperty(Math, 'log1p', MathShims.log1p, Math.log1p(-1e-17) !== -1e-17);\n  // IE 11 TP has an imprecise asinh: reports Math.asinh(-1e7) as not exactly equal to -Math.asinh(1e7)\n  defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));\n  // Chrome 40 has an imprecise Math.tanh with very small numbers\n  defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);\n  // Chrome 40 loses Math.acosh precision with high numbers\n  defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);\n  // Firefox 38 on Windows\n  defineProperty(Math, 'cbrt', MathShims.cbrt, Math.abs(1 - Math.cbrt(1e-300) / 1e-100) / Number.EPSILON > 8);\n  // node 0.11 has an imprecise Math.sinh with very small numbers\n  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);\n  // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)\n  var expm1OfTen = Math.expm1(10);\n  defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);\n\n  var origMathRound = Math.round;\n  // breaks in e.g. Safari 8, Internet Explorer 11, Opera 12\n  var roundHandlesBoundaryConditions = Math.round(0.5 - Number.EPSILON / 4) === 0 && Math.round(-0.5 + Number.EPSILON / 3.99) === 1;\n\n  // When engines use Math.floor(x + 0.5) internally, Math.round can be buggy for large integers.\n  // This behavior should be governed by \"round to nearest, ties to even mode\"\n  // see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-number-type\n  // These are the boundary cases where it breaks.\n  var smallestPositiveNumberWhereRoundBreaks = inverseEpsilon + 1;\n  var largestPositiveNumberWhereRoundBreaks = 2 * inverseEpsilon - 1;\n  var roundDoesNotIncreaseIntegers = [smallestPositiveNumberWhereRoundBreaks, largestPositiveNumberWhereRoundBreaks].every(function (num) {\n    return Math.round(num) === num;\n  });\n  defineProperty(Math, 'round', function round(x) {\n    var floor = _floor(x);\n    var ceil = floor === -1 ? -0 : floor + 1;\n    return x - floor < 0.5 ? floor : ceil;\n  }, !roundHandlesBoundaryConditions || !roundDoesNotIncreaseIntegers);\n  Value.preserveToString(Math.round, origMathRound);\n\n  var origImul = Math.imul;\n  if (Math.imul(0xffffffff, 5) !== -5) {\n    // Safari 6.1, at least, reports \"0\" for this value\n    Math.imul = MathShims.imul;\n    Value.preserveToString(Math.imul, origImul);\n  }\n  if (Math.imul.length !== 2) {\n    // Safari 8.0.4 has a length of 1\n    // fixed in https://bugs.webkit.org/show_bug.cgi?id=143658\n    overrideNative(Math, 'imul', function imul(x, y) {\n      return ES.Call(origImul, Math, arguments);\n    });\n  }\n\n  // Promises\n  // Simplest possible implementation; use a 3rd-party library if you\n  // want the best possible speed and/or long stack traces.\n  var PromiseShim = (function () {\n    var setTimeout = globals.setTimeout;\n    // some environments don't have setTimeout - no way to shim here.\n    if (typeof setTimeout !== 'function' && typeof setTimeout !== 'object') { return; }\n\n    ES.IsPromise = function (promise) {\n      if (!ES.TypeIsObject(promise)) {\n        return false;\n      }\n      if (typeof promise._promise === 'undefined') {\n        return false; // uninitialized, or missing our hidden field.\n      }\n      return true;\n    };\n\n    // \"PromiseCapability\" in the spec is what most promise implementations\n    // call a \"deferred\".\n    var PromiseCapability = function (C) {\n      if (!ES.IsConstructor(C)) {\n        throw new TypeError('Bad promise constructor');\n      }\n      var capability = this;\n      var resolver = function (resolve, reject) {\n        if (capability.resolve !== void 0 || capability.reject !== void 0) {\n          throw new TypeError('Bad Promise implementation!');\n        }\n        capability.resolve = resolve;\n        capability.reject = reject;\n      };\n      // Initialize fields to inform optimizers about the object shape.\n      capability.resolve = void 0;\n      capability.reject = void 0;\n      capability.promise = new C(resolver);\n      if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {\n        throw new TypeError('Bad promise constructor');\n      }\n    };\n\n    // find an appropriate setImmediate-alike\n    var makeZeroTimeout;\n    /*global window */\n    if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {\n      makeZeroTimeout = function () {\n        // from http://dbaron.org/log/20100309-faster-timeouts\n        var timeouts = [];\n        var messageName = 'zero-timeout-message';\n        var setZeroTimeout = function (fn) {\n          _push(timeouts, fn);\n          window.postMessage(messageName, '*');\n        };\n        var handleMessage = function (event) {\n          if (event.source === window && event.data === messageName) {\n            event.stopPropagation();\n            if (timeouts.length === 0) { return; }\n            var fn = _shift(timeouts);\n            fn();\n          }\n        };\n        window.addEventListener('message', handleMessage, true);\n        return setZeroTimeout;\n      };\n    }\n    var makePromiseAsap = function () {\n      // An efficient task-scheduler based on a pre-existing Promise\n      // implementation, which we can use even if we override the\n      // global Promise below (in order to workaround bugs)\n      // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671\n      var P = globals.Promise;\n      var pr = P && P.resolve && P.resolve();\n      return pr && function (task) {\n        return pr.then(task);\n      };\n    };\n    /*global process */\n    /* jscs:disable disallowMultiLineTernary */\n    var enqueue = ES.IsCallable(globals.setImmediate) ?\n      globals.setImmediate :\n      typeof process === 'object' && process.nextTick ? process.nextTick :\n      makePromiseAsap() ||\n      (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() :\n      function (task) { setTimeout(task, 0); }); // fallback\n    /* jscs:enable disallowMultiLineTernary */\n\n    // Constants for Promise implementation\n    var PROMISE_IDENTITY = function (x) { return x; };\n    var PROMISE_THROWER = function (e) { throw e; };\n    var PROMISE_PENDING = 0;\n    var PROMISE_FULFILLED = 1;\n    var PROMISE_REJECTED = 2;\n    // We store fulfill/reject handlers and capabilities in a single array.\n    var PROMISE_FULFILL_OFFSET = 0;\n    var PROMISE_REJECT_OFFSET = 1;\n    var PROMISE_CAPABILITY_OFFSET = 2;\n    // This is used in an optimization for chaining promises via then.\n    var PROMISE_FAKE_CAPABILITY = {};\n\n    var enqueuePromiseReactionJob = function (handler, capability, argument) {\n      enqueue(function () {\n        promiseReactionJob(handler, capability, argument);\n      });\n    };\n\n    var promiseReactionJob = function (handler, promiseCapability, argument) {\n      var handlerResult, f;\n      if (promiseCapability === PROMISE_FAKE_CAPABILITY) {\n        // Fast case, when we don't actually need to chain through to a\n        // (real) promiseCapability.\n        return handler(argument);\n      }\n      try {\n        handlerResult = handler(argument);\n        f = promiseCapability.resolve;\n      } catch (e) {\n        handlerResult = e;\n        f = promiseCapability.reject;\n      }\n      f(handlerResult);\n    };\n\n    var fulfillPromise = function (promise, value) {\n      var _promise = promise._promise;\n      var length = _promise.reactionLength;\n      if (length > 0) {\n        enqueuePromiseReactionJob(\n          _promise.fulfillReactionHandler0,\n          _promise.reactionCapability0,\n          value\n        );\n        _promise.fulfillReactionHandler0 = void 0;\n        _promise.rejectReactions0 = void 0;\n        _promise.reactionCapability0 = void 0;\n        if (length > 1) {\n          for (var i = 1, idx = 0; i < length; i++, idx += 3) {\n            enqueuePromiseReactionJob(\n              _promise[idx + PROMISE_FULFILL_OFFSET],\n              _promise[idx + PROMISE_CAPABILITY_OFFSET],\n              value\n            );\n            promise[idx + PROMISE_FULFILL_OFFSET] = void 0;\n            promise[idx + PROMISE_REJECT_OFFSET] = void 0;\n            promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;\n          }\n        }\n      }\n      _promise.result = value;\n      _promise.state = PROMISE_FULFILLED;\n      _promise.reactionLength = 0;\n    };\n\n    var rejectPromise = function (promise, reason) {\n      var _promise = promise._promise;\n      var length = _promise.reactionLength;\n      if (length > 0) {\n        enqueuePromiseReactionJob(\n          _promise.rejectReactionHandler0,\n          _promise.reactionCapability0,\n          reason\n        );\n        _promise.fulfillReactionHandler0 = void 0;\n        _promise.rejectReactions0 = void 0;\n        _promise.reactionCapability0 = void 0;\n        if (length > 1) {\n          for (var i = 1, idx = 0; i < length; i++, idx += 3) {\n            enqueuePromiseReactionJob(\n              _promise[idx + PROMISE_REJECT_OFFSET],\n              _promise[idx + PROMISE_CAPABILITY_OFFSET],\n              reason\n            );\n            promise[idx + PROMISE_FULFILL_OFFSET] = void 0;\n            promise[idx + PROMISE_REJECT_OFFSET] = void 0;\n            promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;\n          }\n        }\n      }\n      _promise.result = reason;\n      _promise.state = PROMISE_REJECTED;\n      _promise.reactionLength = 0;\n    };\n\n    var createResolvingFunctions = function (promise) {\n      var alreadyResolved = false;\n      var resolve = function (resolution) {\n        var then;\n        if (alreadyResolved) { return; }\n        alreadyResolved = true;\n        if (resolution === promise) {\n          return rejectPromise(promise, new TypeError('Self resolution'));\n        }\n        if (!ES.TypeIsObject(resolution)) {\n          return fulfillPromise(promise, resolution);\n        }\n        try {\n          then = resolution.then;\n        } catch (e) {\n          return rejectPromise(promise, e);\n        }\n        if (!ES.IsCallable(then)) {\n          return fulfillPromise(promise, resolution);\n        }\n        enqueue(function () {\n          promiseResolveThenableJob(promise, resolution, then);\n        });\n      };\n      var reject = function (reason) {\n        if (alreadyResolved) { return; }\n        alreadyResolved = true;\n        return rejectPromise(promise, reason);\n      };\n      return { resolve: resolve, reject: reject };\n    };\n\n    var optimizedThen = function (then, thenable, resolve, reject) {\n      // Optimization: since we discard the result, we can pass our\n      // own then implementation a special hint to let it know it\n      // doesn't have to create it.  (The PROMISE_FAKE_CAPABILITY\n      // object is local to this implementation and unforgeable outside.)\n      if (then === Promise$prototype$then) {\n        _call(then, thenable, resolve, reject, PROMISE_FAKE_CAPABILITY);\n      } else {\n        _call(then, thenable, resolve, reject);\n      }\n    };\n    var promiseResolveThenableJob = function (promise, thenable, then) {\n      var resolvingFunctions = createResolvingFunctions(promise);\n      var resolve = resolvingFunctions.resolve;\n      var reject = resolvingFunctions.reject;\n      try {\n        optimizedThen(then, thenable, resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var Promise$prototype, Promise$prototype$then;\n    var Promise = (function () {\n      var PromiseShim = function Promise(resolver) {\n        if (!(this instanceof PromiseShim)) {\n          throw new TypeError('Constructor Promise requires \"new\"');\n        }\n        if (this && this._promise) {\n          throw new TypeError('Bad construction');\n        }\n        // see https://bugs.ecmascript.org/show_bug.cgi?id=2482\n        if (!ES.IsCallable(resolver)) {\n          throw new TypeError('not a valid resolver');\n        }\n        var promise = emulateES6construct(this, PromiseShim, Promise$prototype, {\n          _promise: {\n            result: void 0,\n            state: PROMISE_PENDING,\n            // The first member of the \"reactions\" array is inlined here,\n            // since most promises only have one reaction.\n            // We've also exploded the 'reaction' object to inline the\n            // \"handler\" and \"capability\" fields, since both fulfill and\n            // reject reactions share the same capability.\n            reactionLength: 0,\n            fulfillReactionHandler0: void 0,\n            rejectReactionHandler0: void 0,\n            reactionCapability0: void 0\n          }\n        });\n        var resolvingFunctions = createResolvingFunctions(promise);\n        var reject = resolvingFunctions.reject;\n        try {\n          resolver(resolvingFunctions.resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n        return promise;\n      };\n      return PromiseShim;\n    }());\n    Promise$prototype = Promise.prototype;\n\n    var _promiseAllResolver = function (index, values, capability, remaining) {\n      var alreadyCalled = false;\n      return function (x) {\n        if (alreadyCalled) { return; }\n        alreadyCalled = true;\n        values[index] = x;\n        if ((--remaining.count) === 0) {\n          var resolve = capability.resolve;\n          resolve(values); // call w/ this===undefined\n        }\n      };\n    };\n\n    var performPromiseAll = function (iteratorRecord, C, resultCapability) {\n      var it = iteratorRecord.iterator;\n      var values = [], remaining = { count: 1 }, next, nextValue;\n      var index = 0;\n      while (true) {\n        try {\n          next = ES.IteratorStep(it);\n          if (next === false) {\n            iteratorRecord.done = true;\n            break;\n          }\n          nextValue = next.value;\n        } catch (e) {\n          iteratorRecord.done = true;\n          throw e;\n        }\n        values[index] = void 0;\n        var nextPromise = C.resolve(nextValue);\n        var resolveElement = _promiseAllResolver(\n          index, values, resultCapability, remaining\n        );\n        remaining.count += 1;\n        optimizedThen(nextPromise.then, nextPromise, resolveElement, resultCapability.reject);\n        index += 1;\n      }\n      if ((--remaining.count) === 0) {\n        var resolve = resultCapability.resolve;\n        resolve(values); // call w/ this===undefined\n      }\n      return resultCapability.promise;\n    };\n\n    var performPromiseRace = function (iteratorRecord, C, resultCapability) {\n      var it = iteratorRecord.iterator, next, nextValue, nextPromise;\n      while (true) {\n        try {\n          next = ES.IteratorStep(it);\n          if (next === false) {\n            // NOTE: If iterable has no items, resulting promise will never\n            // resolve; see:\n            // https://github.com/domenic/promises-unwrapping/issues/75\n            // https://bugs.ecmascript.org/show_bug.cgi?id=2515\n            iteratorRecord.done = true;\n            break;\n          }\n          nextValue = next.value;\n        } catch (e) {\n          iteratorRecord.done = true;\n          throw e;\n        }\n        nextPromise = C.resolve(nextValue);\n        optimizedThen(nextPromise.then, nextPromise, resultCapability.resolve, resultCapability.reject);\n      }\n      return resultCapability.promise;\n    };\n\n    defineProperties(Promise, {\n      all: function all(iterable) {\n        var C = this;\n        if (!ES.TypeIsObject(C)) {\n          throw new TypeError('Promise is not object');\n        }\n        var capability = new PromiseCapability(C);\n        var iterator, iteratorRecord;\n        try {\n          iterator = ES.GetIterator(iterable);\n          iteratorRecord = { iterator: iterator, done: false };\n          return performPromiseAll(iteratorRecord, C, capability);\n        } catch (e) {\n          var exception = e;\n          if (iteratorRecord && !iteratorRecord.done) {\n            try {\n              ES.IteratorClose(iterator, true);\n            } catch (ee) {\n              exception = ee;\n            }\n          }\n          var reject = capability.reject;\n          reject(exception);\n          return capability.promise;\n        }\n      },\n\n      race: function race(iterable) {\n        var C = this;\n        if (!ES.TypeIsObject(C)) {\n          throw new TypeError('Promise is not object');\n        }\n        var capability = new PromiseCapability(C);\n        var iterator, iteratorRecord;\n        try {\n          iterator = ES.GetIterator(iterable);\n          iteratorRecord = { iterator: iterator, done: false };\n          return performPromiseRace(iteratorRecord, C, capability);\n        } catch (e) {\n          var exception = e;\n          if (iteratorRecord && !iteratorRecord.done) {\n            try {\n              ES.IteratorClose(iterator, true);\n            } catch (ee) {\n              exception = ee;\n            }\n          }\n          var reject = capability.reject;\n          reject(exception);\n          return capability.promise;\n        }\n      },\n\n      reject: function reject(reason) {\n        var C = this;\n        if (!ES.TypeIsObject(C)) {\n          throw new TypeError('Bad promise constructor');\n        }\n        var capability = new PromiseCapability(C);\n        var rejectFunc = capability.reject;\n        rejectFunc(reason); // call with this===undefined\n        return capability.promise;\n      },\n\n      resolve: function resolve(v) {\n        // See https://esdiscuss.org/topic/fixing-promise-resolve for spec\n        var C = this;\n        if (!ES.TypeIsObject(C)) {\n          throw new TypeError('Bad promise constructor');\n        }\n        if (ES.IsPromise(v)) {\n          var constructor = v.constructor;\n          if (constructor === C) { return v; }\n        }\n        var capability = new PromiseCapability(C);\n        var resolveFunc = capability.resolve;\n        resolveFunc(v); // call with this===undefined\n        return capability.promise;\n      }\n    });\n\n    defineProperties(Promise$prototype, {\n      'catch': function (onRejected) {\n        return this.then(null, onRejected);\n      },\n\n      then: function then(onFulfilled, onRejected) {\n        var promise = this;\n        if (!ES.IsPromise(promise)) { throw new TypeError('not a promise'); }\n        var C = ES.SpeciesConstructor(promise, Promise);\n        var resultCapability;\n        var returnValueIsIgnored = arguments.length > 2 && arguments[2] === PROMISE_FAKE_CAPABILITY;\n        if (returnValueIsIgnored && C === Promise) {\n          resultCapability = PROMISE_FAKE_CAPABILITY;\n        } else {\n          resultCapability = new PromiseCapability(C);\n        }\n        // PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)\n        // Note that we've split the 'reaction' object into its two\n        // components, \"capabilities\" and \"handler\"\n        // \"capabilities\" is always equal to `resultCapability`\n        var fulfillReactionHandler = ES.IsCallable(onFulfilled) ? onFulfilled : PROMISE_IDENTITY;\n        var rejectReactionHandler = ES.IsCallable(onRejected) ? onRejected : PROMISE_THROWER;\n        var _promise = promise._promise;\n        var value;\n        if (_promise.state === PROMISE_PENDING) {\n          if (_promise.reactionLength === 0) {\n            _promise.fulfillReactionHandler0 = fulfillReactionHandler;\n            _promise.rejectReactionHandler0 = rejectReactionHandler;\n            _promise.reactionCapability0 = resultCapability;\n          } else {\n            var idx = 3 * (_promise.reactionLength - 1);\n            _promise[idx + PROMISE_FULFILL_OFFSET] = fulfillReactionHandler;\n            _promise[idx + PROMISE_REJECT_OFFSET] = rejectReactionHandler;\n            _promise[idx + PROMISE_CAPABILITY_OFFSET] = resultCapability;\n          }\n          _promise.reactionLength += 1;\n        } else if (_promise.state === PROMISE_FULFILLED) {\n          value = _promise.result;\n          enqueuePromiseReactionJob(\n            fulfillReactionHandler, resultCapability, value\n          );\n        } else if (_promise.state === PROMISE_REJECTED) {\n          value = _promise.result;\n          enqueuePromiseReactionJob(\n            rejectReactionHandler, resultCapability, value\n          );\n        } else {\n          throw new TypeError('unexpected Promise state');\n        }\n        return resultCapability.promise;\n      }\n    });\n    // This helps the optimizer by ensuring that methods which take\n    // capabilities aren't polymorphic.\n    PROMISE_FAKE_CAPABILITY = new PromiseCapability(Promise);\n    Promise$prototype$then = Promise$prototype.then;\n\n    return Promise;\n  }());\n\n  // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.\n  if (globals.Promise) {\n    delete globals.Promise.accept;\n    delete globals.Promise.defer;\n    delete globals.Promise.prototype.chain;\n  }\n\n  if (typeof PromiseShim === 'function') {\n    // export the Promise constructor.\n    defineProperties(globals, { Promise: PromiseShim });\n    // In Chrome 33 (and thereabouts) Promise is defined, but the\n    // implementation is buggy in a number of ways.  Let's check subclassing\n    // support to see if we have a buggy implementation.\n    var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {\n      return S.resolve(42).then(function () {}) instanceof S;\n    });\n    var promiseIgnoresNonFunctionThenCallbacks = !throwsError(function () { globals.Promise.reject(42).then(null, 5).then(null, noop); });\n    var promiseRequiresObjectContext = throwsError(function () { globals.Promise.call(3, noop); });\n    // Promise.resolve() was errata'ed late in the ES6 process.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1170742\n    //      https://code.google.com/p/v8/issues/detail?id=4161\n    // It serves as a proxy for a number of other bugs in early Promise\n    // implementations.\n    var promiseResolveBroken = (function (Promise) {\n      var p = Promise.resolve(5);\n      p.constructor = {};\n      var p2 = Promise.resolve(p);\n      return (p === p2); // This *should* be false!\n    }(globals.Promise));\n\n    // Chrome 46 (probably older too) does not retrieve a thenable's .then synchronously\n    var getsThenSynchronously = supportsDescriptors && (function () {\n      var count = 0;\n      var thenable = Object.defineProperty({}, 'then', { get: function () { count += 1; } });\n      Promise.resolve(thenable);\n      return count === 1;\n    }());\n\n    var BadResolverPromise = function BadResolverPromise(executor) {\n      var p = new Promise(executor);\n      executor(3, function () {});\n      this.then = p.then;\n      this.constructor = BadResolverPromise;\n    };\n    BadResolverPromise.prototype = Promise.prototype;\n    BadResolverPromise.all = Promise.all;\n    // Chrome Canary 49 (probably older too) has some implementation bugs\n    var hasBadResolverPromise = valueOrFalseIfThrows(function () {\n      return !!BadResolverPromise.all([1, 2]);\n    });\n\n    if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks ||\n        !promiseRequiresObjectContext || promiseResolveBroken ||\n        !getsThenSynchronously || hasBadResolverPromise) {\n      /*globals Promise: true */\n      /* eslint-disable no-undef */\n      Promise = PromiseShim;\n      /* eslint-enable no-undef */\n      /*globals Promise: false */\n      overrideNative(globals, 'Promise', PromiseShim);\n    }\n    if (Promise.all.length !== 1) {\n      var origAll = Promise.all;\n      overrideNative(Promise, 'all', function all(iterable) {\n        return ES.Call(origAll, this, arguments);\n      });\n    }\n    if (Promise.race.length !== 1) {\n      var origRace = Promise.race;\n      overrideNative(Promise, 'race', function race(iterable) {\n        return ES.Call(origRace, this, arguments);\n      });\n    }\n    if (Promise.resolve.length !== 1) {\n      var origResolve = Promise.resolve;\n      overrideNative(Promise, 'resolve', function resolve(x) {\n        return ES.Call(origResolve, this, arguments);\n      });\n    }\n    if (Promise.reject.length !== 1) {\n      var origReject = Promise.reject;\n      overrideNative(Promise, 'reject', function reject(r) {\n        return ES.Call(origReject, this, arguments);\n      });\n    }\n    ensureEnumerable(Promise, 'all');\n    ensureEnumerable(Promise, 'race');\n    ensureEnumerable(Promise, 'resolve');\n    ensureEnumerable(Promise, 'reject');\n    addDefaultSpecies(Promise);\n  }\n\n  // Map and Set require a true ES5 environment\n  // Their fast path also requires that the environment preserve\n  // property insertion order, which is not guaranteed by the spec.\n  var testOrder = function (a) {\n    var b = keys(_reduce(a, function (o, k) {\n      o[k] = true;\n      return o;\n    }, {}));\n    return a.join(':') === b.join(':');\n  };\n  var preservesInsertionOrder = testOrder(['z', 'a', 'bb']);\n  // some engines (eg, Chrome) only preserve insertion order for string keys\n  var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);\n\n  if (supportsDescriptors) {\n\n    var fastkey = function fastkey(key) {\n      if (!preservesInsertionOrder) {\n        return null;\n      }\n      var type = typeof key;\n      if (type === 'undefined' || key === null) {\n        return '^' + ES.ToString(key);\n      } else if (type === 'string') {\n        return '$' + key;\n      } else if (type === 'number') {\n        // note that -0 will get coerced to \"0\" when used as a property key\n        if (!preservesNumericInsertionOrder) {\n          return 'n' + key;\n        }\n        return key;\n      } else if (type === 'boolean') {\n        return 'b' + key;\n      }\n      return null;\n    };\n\n    var emptyObject = function emptyObject() {\n      // accomodate some older not-quite-ES5 browsers\n      return Object.create ? Object.create(null) : {};\n    };\n\n    var addIterableToMap = function addIterableToMap(MapConstructor, map, iterable) {\n      if (isArray(iterable) || Type.string(iterable)) {\n        _forEach(iterable, function (entry) {\n          if (!ES.TypeIsObject(entry)) {\n            throw new TypeError('Iterator value ' + entry + ' is not an entry object');\n          }\n          map.set(entry[0], entry[1]);\n        });\n      } else if (iterable instanceof MapConstructor) {\n        _call(MapConstructor.prototype.forEach, iterable, function (value, key) {\n          map.set(key, value);\n        });\n      } else {\n        var iter, adder;\n        if (iterable !== null && typeof iterable !== 'undefined') {\n          adder = map.set;\n          if (!ES.IsCallable(adder)) { throw new TypeError('bad map'); }\n          iter = ES.GetIterator(iterable);\n        }\n        if (typeof iter !== 'undefined') {\n          while (true) {\n            var next = ES.IteratorStep(iter);\n            if (next === false) { break; }\n            var nextItem = next.value;\n            try {\n              if (!ES.TypeIsObject(nextItem)) {\n                throw new TypeError('Iterator value ' + nextItem + ' is not an entry object');\n              }\n              _call(adder, map, nextItem[0], nextItem[1]);\n            } catch (e) {\n              ES.IteratorClose(iter, true);\n              throw e;\n            }\n          }\n        }\n      }\n    };\n    var addIterableToSet = function addIterableToSet(SetConstructor, set, iterable) {\n      if (isArray(iterable) || Type.string(iterable)) {\n        _forEach(iterable, function (value) {\n          set.add(value);\n        });\n      } else if (iterable instanceof SetConstructor) {\n        _call(SetConstructor.prototype.forEach, iterable, function (value) {\n          set.add(value);\n        });\n      } else {\n        var iter, adder;\n        if (iterable !== null && typeof iterable !== 'undefined') {\n          adder = set.add;\n          if (!ES.IsCallable(adder)) { throw new TypeError('bad set'); }\n          iter = ES.GetIterator(iterable);\n        }\n        if (typeof iter !== 'undefined') {\n          while (true) {\n            var next = ES.IteratorStep(iter);\n            if (next === false) { break; }\n            var nextValue = next.value;\n            try {\n              _call(adder, set, nextValue);\n            } catch (e) {\n              ES.IteratorClose(iter, true);\n              throw e;\n            }\n          }\n        }\n      }\n    };\n\n    var collectionShims = {\n      Map: (function () {\n\n        var empty = {};\n\n        var MapEntry = function MapEntry(key, value) {\n          this.key = key;\n          this.value = value;\n          this.next = null;\n          this.prev = null;\n        };\n\n        MapEntry.prototype.isRemoved = function isRemoved() {\n          return this.key === empty;\n        };\n\n        var isMap = function isMap(map) {\n          return !!map._es6map;\n        };\n\n        var requireMapSlot = function requireMapSlot(map, method) {\n          if (!ES.TypeIsObject(map) || !isMap(map)) {\n            throw new TypeError('Method Map.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(map));\n          }\n        };\n\n        var MapIterator = function MapIterator(map, kind) {\n          requireMapSlot(map, '[[MapIterator]]');\n          this.head = map._head;\n          this.i = this.head;\n          this.kind = kind;\n        };\n\n        MapIterator.prototype = {\n          next: function next() {\n            var i = this.i, kind = this.kind, head = this.head, result;\n            if (typeof this.i === 'undefined') {\n              return { value: void 0, done: true };\n            }\n            while (i.isRemoved() && i !== head) {\n              // back up off of removed entries\n              i = i.prev;\n            }\n            // advance to next unreturned element.\n            while (i.next !== head) {\n              i = i.next;\n              if (!i.isRemoved()) {\n                if (kind === 'key') {\n                  result = i.key;\n                } else if (kind === 'value') {\n                  result = i.value;\n                } else {\n                  result = [i.key, i.value];\n                }\n                this.i = i;\n                return { value: result, done: false };\n              }\n            }\n            // once the iterator is done, it is done forever.\n            this.i = void 0;\n            return { value: void 0, done: true };\n          }\n        };\n        addIterator(MapIterator.prototype);\n\n        var Map$prototype;\n        var MapShim = function Map() {\n          if (!(this instanceof Map)) {\n            throw new TypeError('Constructor Map requires \"new\"');\n          }\n          if (this && this._es6map) {\n            throw new TypeError('Bad construction');\n          }\n          var map = emulateES6construct(this, Map, Map$prototype, {\n            _es6map: true,\n            _head: null,\n            _storage: emptyObject(),\n            _size: 0\n          });\n\n          var head = new MapEntry(null, null);\n          // circular doubly-linked list.\n          head.next = head.prev = head;\n          map._head = head;\n\n          // Optionally initialize map from iterable\n          if (arguments.length > 0) {\n            addIterableToMap(Map, map, arguments[0]);\n          }\n          return map;\n        };\n        Map$prototype = MapShim.prototype;\n\n        Value.getter(Map$prototype, 'size', function () {\n          if (typeof this._size === 'undefined') {\n            throw new TypeError('size method called on incompatible Map');\n          }\n          return this._size;\n        });\n\n        defineProperties(Map$prototype, {\n          get: function get(key) {\n            requireMapSlot(this, 'get');\n            var fkey = fastkey(key);\n            if (fkey !== null) {\n              // fast O(1) path\n              var entry = this._storage[fkey];\n              if (entry) {\n                return entry.value;\n              } else {\n                return;\n              }\n            }\n            var head = this._head, i = head;\n            while ((i = i.next) !== head) {\n              if (ES.SameValueZero(i.key, key)) {\n                return i.value;\n              }\n            }\n          },\n\n          has: function has(key) {\n            requireMapSlot(this, 'has');\n            var fkey = fastkey(key);\n            if (fkey !== null) {\n              // fast O(1) path\n              return typeof this._storage[fkey] !== 'undefined';\n            }\n            var head = this._head, i = head;\n            while ((i = i.next) !== head) {\n              if (ES.SameValueZero(i.key, key)) {\n                return true;\n              }\n            }\n            return false;\n          },\n\n          set: function set(key, value) {\n            requireMapSlot(this, 'set');\n            var head = this._head, i = head, entry;\n            var fkey = fastkey(key);\n            if (fkey !== null) {\n              // fast O(1) path\n              if (typeof this._storage[fkey] !== 'undefined') {\n                this._storage[fkey].value = value;\n                return this;\n              } else {\n                entry = this._storage[fkey] = new MapEntry(key, value);\n                i = head.prev;\n                // fall through\n              }\n            }\n            while ((i = i.next) !== head) {\n              if (ES.SameValueZero(i.key, key)) {\n                i.value = value;\n                return this;\n              }\n            }\n            entry = entry || new MapEntry(key, value);\n            if (ES.SameValue(-0, key)) {\n              entry.key = +0; // coerce -0 to +0 in entry\n            }\n            entry.next = this._head;\n            entry.prev = this._head.prev;\n            entry.prev.next = entry;\n            entry.next.prev = entry;\n            this._size += 1;\n            return this;\n          },\n\n          'delete': function (key) {\n            requireMapSlot(this, 'delete');\n            var head = this._head, i = head;\n            var fkey = fastkey(key);\n            if (fkey !== null) {\n              // fast O(1) path\n              if (typeof this._storage[fkey] === 'undefined') {\n                return false;\n              }\n              i = this._storage[fkey].prev;\n              delete this._storage[fkey];\n              // fall through\n            }\n            while ((i = i.next) !== head) {\n              if (ES.SameValueZero(i.key, key)) {\n                i.key = i.value = empty;\n                i.prev.next = i.next;\n                i.next.prev = i.prev;\n                this._size -= 1;\n                return true;\n              }\n            }\n            return false;\n          },\n\n          clear: function clear() {\n            requireMapSlot(this, 'clear');\n            this._size = 0;\n            this._storage = emptyObject();\n            var head = this._head, i = head, p = i.next;\n            while ((i = p) !== head) {\n              i.key = i.value = empty;\n              p = i.next;\n              i.next = i.prev = head;\n            }\n            head.next = head.prev = head;\n          },\n\n          keys: function keys() {\n            requireMapSlot(this, 'keys');\n            return new MapIterator(this, 'key');\n          },\n\n          values: function values() {\n            requireMapSlot(this, 'values');\n            return new MapIterator(this, 'value');\n          },\n\n          entries: function entries() {\n            requireMapSlot(this, 'entries');\n            return new MapIterator(this, 'key+value');\n          },\n\n          forEach: function forEach(callback) {\n            requireMapSlot(this, 'forEach');\n            var context = arguments.length > 1 ? arguments[1] : null;\n            var it = this.entries();\n            for (var entry = it.next(); !entry.done; entry = it.next()) {\n              if (context) {\n                _call(callback, context, entry.value[1], entry.value[0], this);\n              } else {\n                callback(entry.value[1], entry.value[0], this);\n              }\n            }\n          }\n        });\n        addIterator(Map$prototype, Map$prototype.entries);\n\n        return MapShim;\n      }()),\n\n      Set: (function () {\n        var isSet = function isSet(set) {\n          return set._es6set && typeof set._storage !== 'undefined';\n        };\n        var requireSetSlot = function requireSetSlot(set, method) {\n          if (!ES.TypeIsObject(set) || !isSet(set)) {\n            // https://github.com/paulmillr/es6-shim/issues/176\n            throw new TypeError('Set.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(set));\n          }\n        };\n\n        // Creating a Map is expensive.  To speed up the common case of\n        // Sets containing only string or numeric keys, we use an object\n        // as backing storage and lazily create a full Map only when\n        // required.\n        var Set$prototype;\n        var SetShim = function Set() {\n          if (!(this instanceof Set)) {\n            throw new TypeError('Constructor Set requires \"new\"');\n          }\n          if (this && this._es6set) {\n            throw new TypeError('Bad construction');\n          }\n          var set = emulateES6construct(this, Set, Set$prototype, {\n            _es6set: true,\n            '[[SetData]]': null,\n            _storage: emptyObject()\n          });\n          if (!set._es6set) {\n            throw new TypeError('bad set');\n          }\n\n          // Optionally initialize Set from iterable\n          if (arguments.length > 0) {\n            addIterableToSet(Set, set, arguments[0]);\n          }\n          return set;\n        };\n        Set$prototype = SetShim.prototype;\n\n        var decodeKey = function (key) {\n          var k = key;\n          if (k === '^null') {\n            return null;\n          } else if (k === '^undefined') {\n            return void 0;\n          } else {\n            var first = k.charAt(0);\n            if (first === '$') {\n              return _strSlice(k, 1);\n            } else if (first === 'n') {\n              return +_strSlice(k, 1);\n            } else if (first === 'b') {\n              return k === 'btrue';\n            }\n          }\n          return +k;\n        };\n        // Switch from the object backing storage to a full Map.\n        var ensureMap = function ensureMap(set) {\n          if (!set['[[SetData]]']) {\n            var m = set['[[SetData]]'] = new collectionShims.Map();\n            _forEach(keys(set._storage), function (key) {\n              var k = decodeKey(key);\n              m.set(k, k);\n            });\n            set['[[SetData]]'] = m;\n          }\n          set._storage = null; // free old backing storage\n        };\n\n        Value.getter(SetShim.prototype, 'size', function () {\n          requireSetSlot(this, 'size');\n          if (this._storage) {\n            return keys(this._storage).length;\n          }\n          ensureMap(this);\n          return this['[[SetData]]'].size;\n        });\n\n        defineProperties(SetShim.prototype, {\n          has: function has(key) {\n            requireSetSlot(this, 'has');\n            var fkey;\n            if (this._storage && (fkey = fastkey(key)) !== null) {\n              return !!this._storage[fkey];\n            }\n            ensureMap(this);\n            return this['[[SetData]]'].has(key);\n          },\n\n          add: function add(key) {\n            requireSetSlot(this, 'add');\n            var fkey;\n            if (this._storage && (fkey = fastkey(key)) !== null) {\n              this._storage[fkey] = true;\n              return this;\n            }\n            ensureMap(this);\n            this['[[SetData]]'].set(key, key);\n            return this;\n          },\n\n          'delete': function (key) {\n            requireSetSlot(this, 'delete');\n            var fkey;\n            if (this._storage && (fkey = fastkey(key)) !== null) {\n              var hasFKey = _hasOwnProperty(this._storage, fkey);\n              return (delete this._storage[fkey]) && hasFKey;\n            }\n            ensureMap(this);\n            return this['[[SetData]]']['delete'](key);\n          },\n\n          clear: function clear() {\n            requireSetSlot(this, 'clear');\n            if (this._storage) {\n              this._storage = emptyObject();\n            }\n            if (this['[[SetData]]']) {\n              this['[[SetData]]'].clear();\n            }\n          },\n\n          values: function values() {\n            requireSetSlot(this, 'values');\n            ensureMap(this);\n            return this['[[SetData]]'].values();\n          },\n\n          entries: function entries() {\n            requireSetSlot(this, 'entries');\n            ensureMap(this);\n            return this['[[SetData]]'].entries();\n          },\n\n          forEach: function forEach(callback) {\n            requireSetSlot(this, 'forEach');\n            var context = arguments.length > 1 ? arguments[1] : null;\n            var entireSet = this;\n            ensureMap(entireSet);\n            this['[[SetData]]'].forEach(function (value, key) {\n              if (context) {\n                _call(callback, context, key, key, entireSet);\n              } else {\n                callback(key, key, entireSet);\n              }\n            });\n          }\n        });\n        defineProperty(SetShim.prototype, 'keys', SetShim.prototype.values, true);\n        addIterator(SetShim.prototype, SetShim.prototype.values);\n\n        return SetShim;\n      }())\n    };\n\n    if (globals.Map || globals.Set) {\n      // Safari 8, for example, doesn't accept an iterable.\n      var mapAcceptsArguments = valueOrFalseIfThrows(function () { return new Map([[1, 2]]).get(1) === 2; });\n      if (!mapAcceptsArguments) {\n        var OrigMapNoArgs = globals.Map;\n        globals.Map = function Map() {\n          if (!(this instanceof Map)) {\n            throw new TypeError('Constructor Map requires \"new\"');\n          }\n          var m = new OrigMapNoArgs();\n          if (arguments.length > 0) {\n            addIterableToMap(Map, m, arguments[0]);\n          }\n          delete m.constructor;\n          Object.setPrototypeOf(m, globals.Map.prototype);\n          return m;\n        };\n        globals.Map.prototype = create(OrigMapNoArgs.prototype);\n        defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);\n        Value.preserveToString(globals.Map, OrigMapNoArgs);\n      }\n      var testMap = new Map();\n      var mapUsesSameValueZero = (function () {\n        // Chrome 38-42, node 0.11/0.12, iojs 1/2 also have a bug when the Map has a size > 4\n        var m = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]);\n        m.set(-0, m);\n        return m.get(0) === m && m.get(-0) === m && m.has(0) && m.has(-0);\n      }());\n      var mapSupportsChaining = testMap.set(1, 2) === testMap;\n      if (!mapUsesSameValueZero || !mapSupportsChaining) {\n        var origMapSet = Map.prototype.set;\n        overrideNative(Map.prototype, 'set', function set(k, v) {\n          _call(origMapSet, this, k === 0 ? 0 : k, v);\n          return this;\n        });\n      }\n      if (!mapUsesSameValueZero) {\n        var origMapGet = Map.prototype.get;\n        var origMapHas = Map.prototype.has;\n        defineProperties(Map.prototype, {\n          get: function get(k) {\n            return _call(origMapGet, this, k === 0 ? 0 : k);\n          },\n          has: function has(k) {\n            return _call(origMapHas, this, k === 0 ? 0 : k);\n          }\n        }, true);\n        Value.preserveToString(Map.prototype.get, origMapGet);\n        Value.preserveToString(Map.prototype.has, origMapHas);\n      }\n      var testSet = new Set();\n      var setUsesSameValueZero = (function (s) {\n        s['delete'](0);\n        s.add(-0);\n        return !s.has(0);\n      }(testSet));\n      var setSupportsChaining = testSet.add(1) === testSet;\n      if (!setUsesSameValueZero || !setSupportsChaining) {\n        var origSetAdd = Set.prototype.add;\n        Set.prototype.add = function add(v) {\n          _call(origSetAdd, this, v === 0 ? 0 : v);\n          return this;\n        };\n        Value.preserveToString(Set.prototype.add, origSetAdd);\n      }\n      if (!setUsesSameValueZero) {\n        var origSetHas = Set.prototype.has;\n        Set.prototype.has = function has(v) {\n          return _call(origSetHas, this, v === 0 ? 0 : v);\n        };\n        Value.preserveToString(Set.prototype.has, origSetHas);\n        var origSetDel = Set.prototype['delete'];\n        Set.prototype['delete'] = function SetDelete(v) {\n          return _call(origSetDel, this, v === 0 ? 0 : v);\n        };\n        Value.preserveToString(Set.prototype['delete'], origSetDel);\n      }\n      var mapSupportsSubclassing = supportsSubclassing(globals.Map, function (M) {\n        var m = new M([]);\n        // Firefox 32 is ok with the instantiating the subclass but will\n        // throw when the map is used.\n        m.set(42, 42);\n        return m instanceof M;\n      });\n      var mapFailsToSupportSubclassing = Object.setPrototypeOf && !mapSupportsSubclassing; // without Object.setPrototypeOf, subclassing is not possible\n      var mapRequiresNew = (function () {\n        try {\n          return !(globals.Map() instanceof globals.Map);\n        } catch (e) {\n          return e instanceof TypeError;\n        }\n      }());\n      if (globals.Map.length !== 0 || mapFailsToSupportSubclassing || !mapRequiresNew) {\n        var OrigMap = globals.Map;\n        globals.Map = function Map() {\n          if (!(this instanceof Map)) {\n            throw new TypeError('Constructor Map requires \"new\"');\n          }\n          var m = new OrigMap();\n          if (arguments.length > 0) {\n            addIterableToMap(Map, m, arguments[0]);\n          }\n          delete m.constructor;\n          Object.setPrototypeOf(m, Map.prototype);\n          return m;\n        };\n        globals.Map.prototype = OrigMap.prototype;\n        defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);\n        Value.preserveToString(globals.Map, OrigMap);\n      }\n      var setSupportsSubclassing = supportsSubclassing(globals.Set, function (S) {\n        var s = new S([]);\n        s.add(42, 42);\n        return s instanceof S;\n      });\n      var setFailsToSupportSubclassing = Object.setPrototypeOf && !setSupportsSubclassing; // without Object.setPrototypeOf, subclassing is not possible\n      var setRequiresNew = (function () {\n        try {\n          return !(globals.Set() instanceof globals.Set);\n        } catch (e) {\n          return e instanceof TypeError;\n        }\n      }());\n      if (globals.Set.length !== 0 || setFailsToSupportSubclassing || !setRequiresNew) {\n        var OrigSet = globals.Set;\n        globals.Set = function Set() {\n          if (!(this instanceof Set)) {\n            throw new TypeError('Constructor Set requires \"new\"');\n          }\n          var s = new OrigSet();\n          if (arguments.length > 0) {\n            addIterableToSet(Set, s, arguments[0]);\n          }\n          delete s.constructor;\n          Object.setPrototypeOf(s, Set.prototype);\n          return s;\n        };\n        globals.Set.prototype = OrigSet.prototype;\n        defineProperty(globals.Set.prototype, 'constructor', globals.Set, true);\n        Value.preserveToString(globals.Set, OrigSet);\n      }\n      var mapIterationThrowsStopIterator = !valueOrFalseIfThrows(function () {\n        return (new Map()).keys().next().done;\n      });\n      /*\n        - In Firefox < 23, Map#size is a function.\n        - In all current Firefox, Set#entries/keys/values & Map#clear do not exist\n        - https://bugzilla.mozilla.org/show_bug.cgi?id=869996\n        - In Firefox 24, Map and Set do not implement forEach\n        - In Firefox 25 at least, Map and Set are callable without \"new\"\n      */\n      if (\n        typeof globals.Map.prototype.clear !== 'function' ||\n        new globals.Set().size !== 0 ||\n        new globals.Map().size !== 0 ||\n        typeof globals.Map.prototype.keys !== 'function' ||\n        typeof globals.Set.prototype.keys !== 'function' ||\n        typeof globals.Map.prototype.forEach !== 'function' ||\n        typeof globals.Set.prototype.forEach !== 'function' ||\n        isCallableWithoutNew(globals.Map) ||\n        isCallableWithoutNew(globals.Set) ||\n        typeof (new globals.Map().keys().next) !== 'function' || // Safari 8\n        mapIterationThrowsStopIterator || // Firefox 25\n        !mapSupportsSubclassing\n      ) {\n        defineProperties(globals, {\n          Map: collectionShims.Map,\n          Set: collectionShims.Set\n        }, true);\n      }\n\n      if (globals.Set.prototype.keys !== globals.Set.prototype.values) {\n        // Fixed in WebKit with https://bugs.webkit.org/show_bug.cgi?id=144190\n        defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);\n      }\n\n      // Shim incomplete iterator implementations.\n      addIterator(Object.getPrototypeOf((new globals.Map()).keys()));\n      addIterator(Object.getPrototypeOf((new globals.Set()).keys()));\n\n      if (functionsHaveNames && globals.Set.prototype.has.name !== 'has') {\n        // Microsoft Edge v0.11.10074.0 is missing a name on Set#has\n        var anonymousSetHas = globals.Set.prototype.has;\n        overrideNative(globals.Set.prototype, 'has', function has(key) {\n          return _call(anonymousSetHas, this, key);\n        });\n      }\n    }\n    defineProperties(globals, collectionShims);\n    addDefaultSpecies(globals.Map);\n    addDefaultSpecies(globals.Set);\n  }\n\n  var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {\n    if (!ES.TypeIsObject(target)) {\n      throw new TypeError('target must be an object');\n    }\n  };\n\n  // Some Reflect methods are basically the same as\n  // those on the Object global, except that a TypeError is thrown if\n  // target isn't an object. As well as returning a boolean indicating\n  // the success of the operation.\n  var ReflectShims = {\n    // Apply method in a functional form.\n    apply: function apply() {\n      return ES.Call(ES.Call, null, arguments);\n    },\n\n    // New operator in a functional form.\n    construct: function construct(constructor, args) {\n      if (!ES.IsConstructor(constructor)) {\n        throw new TypeError('First argument must be a constructor.');\n      }\n      var newTarget = arguments.length > 2 ? arguments[2] : constructor;\n      if (!ES.IsConstructor(newTarget)) {\n        throw new TypeError('new.target must be a constructor.');\n      }\n      return ES.Construct(constructor, args, newTarget, 'internal');\n    },\n\n    // When deleting a non-existent or configurable property,\n    // true is returned.\n    // When attempting to delete a non-configurable property,\n    // it will return false.\n    deleteProperty: function deleteProperty(target, key) {\n      throwUnlessTargetIsObject(target);\n      if (supportsDescriptors) {\n        var desc = Object.getOwnPropertyDescriptor(target, key);\n\n        if (desc && !desc.configurable) {\n          return false;\n        }\n      }\n\n      // Will return true.\n      return delete target[key];\n    },\n\n    enumerate: function enumerate(target) {\n      throwUnlessTargetIsObject(target);\n      return new ObjectIterator(target, 'key');\n    },\n\n    has: function has(target, key) {\n      throwUnlessTargetIsObject(target);\n      return key in target;\n    }\n  };\n\n  if (Object.getOwnPropertyNames) {\n    Object.assign(ReflectShims, {\n      // Basically the result of calling the internal [[OwnPropertyKeys]].\n      // Concatenating propertyNames and propertySymbols should do the trick.\n      // This should continue to work together with a Symbol shim\n      // which overrides Object.getOwnPropertyNames and implements\n      // Object.getOwnPropertySymbols.\n      ownKeys: function ownKeys(target) {\n        throwUnlessTargetIsObject(target);\n        var keys = Object.getOwnPropertyNames(target);\n\n        if (ES.IsCallable(Object.getOwnPropertySymbols)) {\n          _pushApply(keys, Object.getOwnPropertySymbols(target));\n        }\n\n        return keys;\n      }\n    });\n  }\n\n  var callAndCatchException = function ConvertExceptionToBoolean(func) {\n    return !throwsError(func);\n  };\n\n  if (Object.preventExtensions) {\n    Object.assign(ReflectShims, {\n      isExtensible: function isExtensible(target) {\n        throwUnlessTargetIsObject(target);\n        return Object.isExtensible(target);\n      },\n      preventExtensions: function preventExtensions(target) {\n        throwUnlessTargetIsObject(target);\n        return callAndCatchException(function () {\n          Object.preventExtensions(target);\n        });\n      }\n    });\n  }\n\n  if (supportsDescriptors) {\n    var internalGet = function get(target, key, receiver) {\n      var desc = Object.getOwnPropertyDescriptor(target, key);\n\n      if (!desc) {\n        var parent = Object.getPrototypeOf(target);\n\n        if (parent === null) {\n          return void 0;\n        }\n\n        return internalGet(parent, key, receiver);\n      }\n\n      if ('value' in desc) {\n        return desc.value;\n      }\n\n      if (desc.get) {\n        return ES.Call(desc.get, receiver);\n      }\n\n      return void 0;\n    };\n\n    var internalSet = function set(target, key, value, receiver) {\n      var desc = Object.getOwnPropertyDescriptor(target, key);\n\n      if (!desc) {\n        var parent = Object.getPrototypeOf(target);\n\n        if (parent !== null) {\n          return internalSet(parent, key, value, receiver);\n        }\n\n        desc = {\n          value: void 0,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n      }\n\n      if ('value' in desc) {\n        if (!desc.writable) {\n          return false;\n        }\n\n        if (!ES.TypeIsObject(receiver)) {\n          return false;\n        }\n\n        var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);\n\n        if (existingDesc) {\n          return Reflect.defineProperty(receiver, key, {\n            value: value\n          });\n        } else {\n          return Reflect.defineProperty(receiver, key, {\n            value: value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n\n      if (desc.set) {\n        _call(desc.set, receiver, value);\n        return true;\n      }\n\n      return false;\n    };\n\n    Object.assign(ReflectShims, {\n      defineProperty: function defineProperty(target, propertyKey, attributes) {\n        throwUnlessTargetIsObject(target);\n        return callAndCatchException(function () {\n          Object.defineProperty(target, propertyKey, attributes);\n        });\n      },\n\n      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {\n        throwUnlessTargetIsObject(target);\n        return Object.getOwnPropertyDescriptor(target, propertyKey);\n      },\n\n      // Syntax in a functional form.\n      get: function get(target, key) {\n        throwUnlessTargetIsObject(target);\n        var receiver = arguments.length > 2 ? arguments[2] : target;\n\n        return internalGet(target, key, receiver);\n      },\n\n      set: function set(target, key, value) {\n        throwUnlessTargetIsObject(target);\n        var receiver = arguments.length > 3 ? arguments[3] : target;\n\n        return internalSet(target, key, value, receiver);\n      }\n    });\n  }\n\n  if (Object.getPrototypeOf) {\n    var objectDotGetPrototypeOf = Object.getPrototypeOf;\n    ReflectShims.getPrototypeOf = function getPrototypeOf(target) {\n      throwUnlessTargetIsObject(target);\n      return objectDotGetPrototypeOf(target);\n    };\n  }\n\n  if (Object.setPrototypeOf && ReflectShims.getPrototypeOf) {\n    var willCreateCircularPrototype = function (object, lastProto) {\n      var proto = lastProto;\n      while (proto) {\n        if (object === proto) {\n          return true;\n        }\n        proto = ReflectShims.getPrototypeOf(proto);\n      }\n      return false;\n    };\n\n    Object.assign(ReflectShims, {\n      // Sets the prototype of the given object.\n      // Returns true on success, otherwise false.\n      setPrototypeOf: function setPrototypeOf(object, proto) {\n        throwUnlessTargetIsObject(object);\n        if (proto !== null && !ES.TypeIsObject(proto)) {\n          throw new TypeError('proto must be an object or null');\n        }\n\n        // If they already are the same, we're done.\n        if (proto === Reflect.getPrototypeOf(object)) {\n          return true;\n        }\n\n        // Cannot alter prototype if object not extensible.\n        if (Reflect.isExtensible && !Reflect.isExtensible(object)) {\n          return false;\n        }\n\n        // Ensure that we do not create a circular prototype chain.\n        if (willCreateCircularPrototype(object, proto)) {\n          return false;\n        }\n\n        Object.setPrototypeOf(object, proto);\n\n        return true;\n      }\n    });\n  }\n  var defineOrOverrideReflectProperty = function (key, shim) {\n    if (!ES.IsCallable(globals.Reflect[key])) {\n      defineProperty(globals.Reflect, key, shim);\n    } else {\n      var acceptsPrimitives = valueOrFalseIfThrows(function () {\n        globals.Reflect[key](1);\n        globals.Reflect[key](NaN);\n        globals.Reflect[key](true);\n        return true;\n      });\n      if (acceptsPrimitives) {\n        overrideNative(globals.Reflect, key, shim);\n      }\n    }\n  };\n  Object.keys(ReflectShims).forEach(function (key) {\n    defineOrOverrideReflectProperty(key, ReflectShims[key]);\n  });\n  if (functionsHaveNames && globals.Reflect.getPrototypeOf.name !== 'getPrototypeOf') {\n    var originalReflectGetProto = globals.Reflect.getPrototypeOf;\n    overrideNative(globals.Reflect, 'getPrototypeOf', function getPrototypeOf(target) {\n      return _call(originalReflectGetProto, globals.Reflect, target);\n    });\n  }\n  if (globals.Reflect.setPrototypeOf) {\n    if (valueOrFalseIfThrows(function () {\n      globals.Reflect.setPrototypeOf(1, {});\n      return true;\n    })) {\n      overrideNative(globals.Reflect, 'setPrototypeOf', ReflectShims.setPrototypeOf);\n    }\n  }\n  if (globals.Reflect.defineProperty) {\n    if (!valueOrFalseIfThrows(function () {\n      var basic = !globals.Reflect.defineProperty(1, 'test', { value: 1 });\n      // \"extensible\" fails on Edge 0.12\n      var extensible = typeof Object.preventExtensions !== 'function' || !globals.Reflect.defineProperty(Object.preventExtensions({}), 'test', {});\n      return basic && extensible;\n    })) {\n      overrideNative(globals.Reflect, 'defineProperty', ReflectShims.defineProperty);\n    }\n  }\n  if (globals.Reflect.construct) {\n    if (!valueOrFalseIfThrows(function () {\n      var F = function F() {};\n      return globals.Reflect.construct(function () {}, [], F) instanceof F;\n    })) {\n      overrideNative(globals.Reflect, 'construct', ReflectShims.construct);\n    }\n  }\n\n  if (String(new Date(NaN)) !== 'Invalid Date') {\n    var dateToString = Date.prototype.toString;\n    var shimmedDateToString = function toString() {\n      var valueOf = +this;\n      if (valueOf !== valueOf) {\n        return 'Invalid Date';\n      }\n      return ES.Call(dateToString, this);\n    };\n    overrideNative(Date.prototype, 'toString', shimmedDateToString);\n  }\n\n  // Annex B HTML methods\n  // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-additional-properties-of-the-string.prototype-object\n  var stringHTMLshims = {\n    anchor: function anchor(name) { return ES.CreateHTML(this, 'a', 'name', name); },\n    big: function big() { return ES.CreateHTML(this, 'big', '', ''); },\n    blink: function blink() { return ES.CreateHTML(this, 'blink', '', ''); },\n    bold: function bold() { return ES.CreateHTML(this, 'b', '', ''); },\n    fixed: function fixed() { return ES.CreateHTML(this, 'tt', '', ''); },\n    fontcolor: function fontcolor(color) { return ES.CreateHTML(this, 'font', 'color', color); },\n    fontsize: function fontsize(size) { return ES.CreateHTML(this, 'font', 'size', size); },\n    italics: function italics() { return ES.CreateHTML(this, 'i', '', ''); },\n    link: function link(url) { return ES.CreateHTML(this, 'a', 'href', url); },\n    small: function small() { return ES.CreateHTML(this, 'small', '', ''); },\n    strike: function strike() { return ES.CreateHTML(this, 'strike', '', ''); },\n    sub: function sub() { return ES.CreateHTML(this, 'sub', '', ''); },\n    sup: function sub() { return ES.CreateHTML(this, 'sup', '', ''); }\n  };\n  _forEach(Object.keys(stringHTMLshims), function (key) {\n    var method = String.prototype[key];\n    var shouldOverwrite = false;\n    if (ES.IsCallable(method)) {\n      var output = _call(method, '', ' \" ');\n      var quotesCount = _concat([], output.match(/\"/g)).length;\n      shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;\n    } else {\n      shouldOverwrite = true;\n    }\n    if (shouldOverwrite) {\n      overrideNative(String.prototype, key, stringHTMLshims[key]);\n    }\n  });\n\n  var JSONstringifiesSymbols = (function () {\n    // Microsoft Edge v0.12 stringifies Symbols incorrectly\n    if (!hasSymbols) { return false; } // Symbols are not supported\n    var stringify = typeof JSON === 'object' && typeof JSON.stringify === 'function' ? JSON.stringify : null;\n    if (!stringify) { return false; } // JSON.stringify is not supported\n    if (typeof stringify(Symbol()) !== 'undefined') { return true; } // Symbols should become `undefined`\n    if (stringify([Symbol()]) !== '[null]') { return true; } // Symbols in arrays should become `null`\n    var obj = { a: Symbol() };\n    obj[Symbol()] = true;\n    if (stringify(obj) !== '{}') { return true; } // Symbol-valued keys *and* Symbol-valued properties should be omitted\n    return false;\n  }());\n  var JSONstringifyAcceptsObjectSymbol = valueOrFalseIfThrows(function () {\n    // Chrome 45 throws on stringifying object symbols\n    if (!hasSymbols) { return true; } // Symbols are not supported\n    return JSON.stringify(Object(Symbol())) === '{}' && JSON.stringify([Object(Symbol())]) === '[{}]';\n  });\n  if (JSONstringifiesSymbols || !JSONstringifyAcceptsObjectSymbol) {\n    var origStringify = JSON.stringify;\n    overrideNative(JSON, 'stringify', function stringify(value) {\n      if (typeof value === 'symbol') { return; }\n      var replacer;\n      if (arguments.length > 1) {\n        replacer = arguments[1];\n      }\n      var args = [value];\n      if (!isArray(replacer)) {\n        var replaceFn = ES.IsCallable(replacer) ? replacer : null;\n        var wrappedReplacer = function (key, val) {\n          var parsedValue = replacer ? _call(replacer, this, key, val) : val;\n          if (typeof parsedValue !== 'symbol') {\n            if (Type.symbol(parsedValue)) {\n              return assignTo({})(parsedValue);\n            } else {\n              return parsedValue;\n            }\n          }\n        };\n        args.push(wrappedReplacer);\n      } else {\n        // create wrapped replacer that handles an array replacer?\n        args.push(replacer);\n      }\n      if (arguments.length > 2) {\n        args.push(arguments[2]);\n      }\n      return origStringify.apply(this, args);\n    });\n  }\n\n  return globals;\n}));\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"_process\":303}],282:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],283:[function(require,module,exports){\n(function (Buffer){\nvar md5 = require('create-hash/md5')\nmodule.exports = EVP_BytesToKey\nfunction EVP_BytesToKey (password, salt, keyLen, ivLen) {\n  if (!Buffer.isBuffer(password)) {\n    password = new Buffer(password, 'binary')\n  }\n  if (salt && !Buffer.isBuffer(salt)) {\n    salt = new Buffer(salt, 'binary')\n  }\n  keyLen = keyLen / 8\n  ivLen = ivLen || 0\n  var ki = 0\n  var ii = 0\n  var key = new Buffer(keyLen)\n  var iv = new Buffer(ivLen)\n  var addmd = 0\n  var md_buf\n  var i\n  var bufs = []\n  while (true) {\n    if (addmd++ > 0) {\n      bufs.push(md_buf)\n    }\n    bufs.push(password)\n    if (salt) {\n      bufs.push(salt)\n    }\n    md_buf = md5(Buffer.concat(bufs))\n    bufs = []\n    i = 0\n    if (keyLen > 0) {\n      while (true) {\n        if (keyLen === 0) {\n          break\n        }\n        if (i === md_buf.length) {\n          break\n        }\n        key[ki++] = md_buf[i]\n        keyLen--\n        i++\n      }\n    }\n    if (ivLen > 0 && i !== md_buf.length) {\n      while (true) {\n        if (ivLen === 0) {\n          break\n        }\n        if (i === md_buf.length) {\n          break\n        }\n        iv[ii++] = md_buf[i]\n        ivLen--\n        i++\n      }\n    }\n    if (keyLen === 0 && ivLen === 0) {\n      break\n    }\n  }\n  for (i = 0; i < md_buf.length; i++) {\n    md_buf[i] = 0\n  }\n  return {\n    key: key,\n    iv: iv\n  }\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243,\"create-hash/md5\":250}],284:[function(require,module,exports){\nvar hash = exports;\n\nhash.utils = require('./hash/utils');\nhash.common = require('./hash/common');\nhash.sha = require('./hash/sha');\nhash.ripemd = require('./hash/ripemd');\nhash.hmac = require('./hash/hmac');\n\n// Proxy hash functions to the main object\nhash.sha1 = hash.sha.sha1;\nhash.sha256 = hash.sha.sha256;\nhash.sha224 = hash.sha.sha224;\nhash.sha384 = hash.sha.sha384;\nhash.sha512 = hash.sha.sha512;\nhash.ripemd160 = hash.ripemd.ripemd160;\n\n},{\"./hash/common\":285,\"./hash/hmac\":286,\"./hash/ripemd\":287,\"./hash/sha\":288,\"./hash/utils\":289}],285:[function(require,module,exports){\nvar hash = require('../hash');\nvar utils = hash.utils;\nvar assert = utils.assert;\n\nfunction BlockHash() {\n  this.pending = null;\n  this.pendingTotal = 0;\n  this.blockSize = this.constructor.blockSize;\n  this.outSize = this.constructor.outSize;\n  this.hmacStrength = this.constructor.hmacStrength;\n  this.padLength = this.constructor.padLength / 8;\n  this.endian = 'big';\n\n  this._delta8 = this.blockSize / 8;\n  this._delta32 = this.blockSize / 32;\n}\nexports.BlockHash = BlockHash;\n\nBlockHash.prototype.update = function update(msg, enc) {\n  // Convert message to array, pad it, and join into 32bit blocks\n  msg = utils.toArray(msg, enc);\n  if (!this.pending)\n    this.pending = msg;\n  else\n    this.pending = this.pending.concat(msg);\n  this.pendingTotal += msg.length;\n\n  // Enough data, try updating\n  if (this.pending.length >= this._delta8) {\n    msg = this.pending;\n\n    // Process pending data in blocks\n    var r = msg.length % this._delta8;\n    this.pending = msg.slice(msg.length - r, msg.length);\n    if (this.pending.length === 0)\n      this.pending = null;\n\n    msg = utils.join32(msg, 0, msg.length - r, this.endian);\n    for (var i = 0; i < msg.length; i += this._delta32)\n      this._update(msg, i, i + this._delta32);\n  }\n\n  return this;\n};\n\nBlockHash.prototype.digest = function digest(enc) {\n  this.update(this._pad());\n  assert(this.pending === null);\n\n  return this._digest(enc);\n};\n\nBlockHash.prototype._pad = function pad() {\n  var len = this.pendingTotal;\n  var bytes = this._delta8;\n  var k = bytes - ((len + this.padLength) % bytes);\n  var res = new Array(k + this.padLength);\n  res[0] = 0x80;\n  for (var i = 1; i < k; i++)\n    res[i] = 0;\n\n  // Append length\n  len <<= 3;\n  if (this.endian === 'big') {\n    for (var t = 8; t < this.padLength; t++)\n      res[i++] = 0;\n\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = (len >>> 24) & 0xff;\n    res[i++] = (len >>> 16) & 0xff;\n    res[i++] = (len >>> 8) & 0xff;\n    res[i++] = len & 0xff;\n  } else {\n    res[i++] = len & 0xff;\n    res[i++] = (len >>> 8) & 0xff;\n    res[i++] = (len >>> 16) & 0xff;\n    res[i++] = (len >>> 24) & 0xff;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n\n    for (var t = 8; t < this.padLength; t++)\n      res[i++] = 0;\n  }\n\n  return res;\n};\n\n},{\"../hash\":284}],286:[function(require,module,exports){\nvar hmac = exports;\n\nvar hash = require('../hash');\nvar utils = hash.utils;\nvar assert = utils.assert;\n\nfunction Hmac(hash, key, enc) {\n  if (!(this instanceof Hmac))\n    return new Hmac(hash, key, enc);\n  this.Hash = hash;\n  this.blockSize = hash.blockSize / 8;\n  this.outSize = hash.outSize / 8;\n  this.inner = null;\n  this.outer = null;\n\n  this._init(utils.toArray(key, enc));\n}\nmodule.exports = Hmac;\n\nHmac.prototype._init = function init(key) {\n  // Shorten key, if needed\n  if (key.length > this.blockSize)\n    key = new this.Hash().update(key).digest();\n  assert(key.length <= this.blockSize);\n\n  // Add padding to key\n  for (var i = key.length; i < this.blockSize; i++)\n    key.push(0);\n\n  for (var i = 0; i < key.length; i++)\n    key[i] ^= 0x36;\n  this.inner = new this.Hash().update(key);\n\n  // 0x36 ^ 0x5c = 0x6a\n  for (var i = 0; i < key.length; i++)\n    key[i] ^= 0x6a;\n  this.outer = new this.Hash().update(key);\n};\n\nHmac.prototype.update = function update(msg, enc) {\n  this.inner.update(msg, enc);\n  return this;\n};\n\nHmac.prototype.digest = function digest(enc) {\n  this.outer.update(this.inner.digest());\n  return this.outer.digest(enc);\n};\n\n},{\"../hash\":284}],287:[function(require,module,exports){\nvar hash = require('../hash');\nvar utils = hash.utils;\n\nvar rotl32 = utils.rotl32;\nvar sum32 = utils.sum32;\nvar sum32_3 = utils.sum32_3;\nvar sum32_4 = utils.sum32_4;\nvar BlockHash = hash.common.BlockHash;\n\nfunction RIPEMD160() {\n  if (!(this instanceof RIPEMD160))\n    return new RIPEMD160();\n\n  BlockHash.call(this);\n\n  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];\n  this.endian = 'little';\n}\nutils.inherits(RIPEMD160, BlockHash);\nexports.ripemd160 = RIPEMD160;\n\nRIPEMD160.blockSize = 512;\nRIPEMD160.outSize = 160;\nRIPEMD160.hmacStrength = 192;\nRIPEMD160.padLength = 64;\n\nRIPEMD160.prototype._update = function update(msg, start) {\n  var A = this.h[0];\n  var B = this.h[1];\n  var C = this.h[2];\n  var D = this.h[3];\n  var E = this.h[4];\n  var Ah = A;\n  var Bh = B;\n  var Ch = C;\n  var Dh = D;\n  var Eh = E;\n  for (var j = 0; j < 80; j++) {\n    var T = sum32(\n      rotl32(\n        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),\n        s[j]),\n      E);\n    A = E;\n    E = D;\n    D = rotl32(C, 10);\n    C = B;\n    B = T;\n    T = sum32(\n      rotl32(\n        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),\n        sh[j]),\n      Eh);\n    Ah = Eh;\n    Eh = Dh;\n    Dh = rotl32(Ch, 10);\n    Ch = Bh;\n    Bh = T;\n  }\n  T = sum32_3(this.h[1], C, Dh);\n  this.h[1] = sum32_3(this.h[2], D, Eh);\n  this.h[2] = sum32_3(this.h[3], E, Ah);\n  this.h[3] = sum32_3(this.h[4], A, Bh);\n  this.h[4] = sum32_3(this.h[0], B, Ch);\n  this.h[0] = T;\n};\n\nRIPEMD160.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'little');\n  else\n    return utils.split32(this.h, 'little');\n};\n\nfunction f(j, x, y, z) {\n  if (j <= 15)\n    return x ^ y ^ z;\n  else if (j <= 31)\n    return (x & y) | ((~x) & z);\n  else if (j <= 47)\n    return (x | (~y)) ^ z;\n  else if (j <= 63)\n    return (x & z) | (y & (~z));\n  else\n    return x ^ (y | (~z));\n}\n\nfunction K(j) {\n  if (j <= 15)\n    return 0x00000000;\n  else if (j <= 31)\n    return 0x5a827999;\n  else if (j <= 47)\n    return 0x6ed9eba1;\n  else if (j <= 63)\n    return 0x8f1bbcdc;\n  else\n    return 0xa953fd4e;\n}\n\nfunction Kh(j) {\n  if (j <= 15)\n    return 0x50a28be6;\n  else if (j <= 31)\n    return 0x5c4dd124;\n  else if (j <= 47)\n    return 0x6d703ef3;\n  else if (j <= 63)\n    return 0x7a6d76e9;\n  else\n    return 0x00000000;\n}\n\nvar r = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n];\n\nvar rh = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n];\n\nvar s = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n];\n\nvar sh = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n];\n\n},{\"../hash\":284}],288:[function(require,module,exports){\nvar hash = require('../hash');\nvar utils = hash.utils;\nvar assert = utils.assert;\n\nvar rotr32 = utils.rotr32;\nvar rotl32 = utils.rotl32;\nvar sum32 = utils.sum32;\nvar sum32_4 = utils.sum32_4;\nvar sum32_5 = utils.sum32_5;\nvar rotr64_hi = utils.rotr64_hi;\nvar rotr64_lo = utils.rotr64_lo;\nvar shr64_hi = utils.shr64_hi;\nvar shr64_lo = utils.shr64_lo;\nvar sum64 = utils.sum64;\nvar sum64_hi = utils.sum64_hi;\nvar sum64_lo = utils.sum64_lo;\nvar sum64_4_hi = utils.sum64_4_hi;\nvar sum64_4_lo = utils.sum64_4_lo;\nvar sum64_5_hi = utils.sum64_5_hi;\nvar sum64_5_lo = utils.sum64_5_lo;\nvar BlockHash = hash.common.BlockHash;\n\nvar sha256_K = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\nvar sha512_K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nvar sha1_K = [\n  0x5A827999, 0x6ED9EBA1,\n  0x8F1BBCDC, 0xCA62C1D6\n];\n\nfunction SHA256() {\n  if (!(this instanceof SHA256))\n    return new SHA256();\n\n  BlockHash.call(this);\n  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];\n  this.k = sha256_K;\n  this.W = new Array(64);\n}\nutils.inherits(SHA256, BlockHash);\nexports.sha256 = SHA256;\n\nSHA256.blockSize = 512;\nSHA256.outSize = 256;\nSHA256.hmacStrength = 192;\nSHA256.padLength = 64;\n\nSHA256.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++)\n    W[i] = msg[start + i];\n  for (; i < W.length; i++)\n    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n  var f = this.h[5];\n  var g = this.h[6];\n  var h = this.h[7];\n\n  assert(this.k.length === W.length);\n  for (var i = 0; i < W.length; i++) {\n    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);\n    var T2 = sum32(s0_256(a), maj32(a, b, c));\n    h = g;\n    g = f;\n    f = e;\n    e = sum32(d, T1);\n    d = c;\n    c = b;\n    b = a;\n    a = sum32(T1, T2);\n  }\n\n  this.h[0] = sum32(this.h[0], a);\n  this.h[1] = sum32(this.h[1], b);\n  this.h[2] = sum32(this.h[2], c);\n  this.h[3] = sum32(this.h[3], d);\n  this.h[4] = sum32(this.h[4], e);\n  this.h[5] = sum32(this.h[5], f);\n  this.h[6] = sum32(this.h[6], g);\n  this.h[7] = sum32(this.h[7], h);\n};\n\nSHA256.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\nfunction SHA224() {\n  if (!(this instanceof SHA224))\n    return new SHA224();\n\n  SHA256.call(this);\n  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];\n}\nutils.inherits(SHA224, SHA256);\nexports.sha224 = SHA224;\n\nSHA224.blockSize = 512;\nSHA224.outSize = 224;\nSHA224.hmacStrength = 192;\nSHA224.padLength = 64;\n\nSHA224.prototype._digest = function digest(enc) {\n  // Just truncate output\n  if (enc === 'hex')\n    return utils.toHex32(this.h.slice(0, 7), 'big');\n  else\n    return utils.split32(this.h.slice(0, 7), 'big');\n};\n\nfunction SHA512() {\n  if (!(this instanceof SHA512))\n    return new SHA512();\n\n  BlockHash.call(this);\n  this.h = [ 0x6a09e667, 0xf3bcc908,\n             0xbb67ae85, 0x84caa73b,\n             0x3c6ef372, 0xfe94f82b,\n             0xa54ff53a, 0x5f1d36f1,\n             0x510e527f, 0xade682d1,\n             0x9b05688c, 0x2b3e6c1f,\n             0x1f83d9ab, 0xfb41bd6b,\n             0x5be0cd19, 0x137e2179 ];\n  this.k = sha512_K;\n  this.W = new Array(160);\n}\nutils.inherits(SHA512, BlockHash);\nexports.sha512 = SHA512;\n\nSHA512.blockSize = 1024;\nSHA512.outSize = 512;\nSHA512.hmacStrength = 192;\nSHA512.padLength = 128;\n\nSHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n  var W = this.W;\n\n  // 32 x 32bit words\n  for (var i = 0; i < 32; i++)\n    W[i] = msg[start + i];\n  for (; i < W.length; i += 2) {\n    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2\n    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n    var c1_hi = W[i - 14];  // i - 7\n    var c1_lo = W[i - 13];\n    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15\n    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n    var c3_hi = W[i - 32];  // i - 16\n    var c3_lo = W[i - 31];\n\n    W[i] = sum64_4_hi(c0_hi, c0_lo,\n                      c1_hi, c1_lo,\n                      c2_hi, c2_lo,\n                      c3_hi, c3_lo);\n    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,\n                          c1_hi, c1_lo,\n                          c2_hi, c2_lo,\n                          c3_hi, c3_lo);\n  }\n};\n\nSHA512.prototype._update = function _update(msg, start) {\n  this._prepareBlock(msg, start);\n\n  var W = this.W;\n\n  var ah = this.h[0];\n  var al = this.h[1];\n  var bh = this.h[2];\n  var bl = this.h[3];\n  var ch = this.h[4];\n  var cl = this.h[5];\n  var dh = this.h[6];\n  var dl = this.h[7];\n  var eh = this.h[8];\n  var el = this.h[9];\n  var fh = this.h[10];\n  var fl = this.h[11];\n  var gh = this.h[12];\n  var gl = this.h[13];\n  var hh = this.h[14];\n  var hl = this.h[15];\n\n  assert(this.k.length === W.length);\n  for (var i = 0; i < W.length; i += 2) {\n    var c0_hi = hh;\n    var c0_lo = hl;\n    var c1_hi = s1_512_hi(eh, el);\n    var c1_lo = s1_512_lo(eh, el);\n    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\n    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n    var c3_hi = this.k[i];\n    var c3_lo = this.k[i + 1];\n    var c4_hi = W[i];\n    var c4_lo = W[i + 1];\n\n    var T1_hi = sum64_5_hi(c0_hi, c0_lo,\n                           c1_hi, c1_lo,\n                           c2_hi, c2_lo,\n                           c3_hi, c3_lo,\n                           c4_hi, c4_lo);\n    var T1_lo = sum64_5_lo(c0_hi, c0_lo,\n                           c1_hi, c1_lo,\n                           c2_hi, c2_lo,\n                           c3_hi, c3_lo,\n                           c4_hi, c4_lo);\n\n    var c0_hi = s0_512_hi(ah, al);\n    var c0_lo = s0_512_lo(ah, al);\n    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\n    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n\n    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);\n    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n\n    hh = gh;\n    hl = gl;\n\n    gh = fh;\n    gl = fl;\n\n    fh = eh;\n    fl = el;\n\n    eh = sum64_hi(dh, dl, T1_hi, T1_lo);\n    el = sum64_lo(dl, dl, T1_hi, T1_lo);\n\n    dh = ch;\n    dl = cl;\n\n    ch = bh;\n    cl = bl;\n\n    bh = ah;\n    bl = al;\n\n    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);\n    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n  }\n\n  sum64(this.h, 0, ah, al);\n  sum64(this.h, 2, bh, bl);\n  sum64(this.h, 4, ch, cl);\n  sum64(this.h, 6, dh, dl);\n  sum64(this.h, 8, eh, el);\n  sum64(this.h, 10, fh, fl);\n  sum64(this.h, 12, gh, gl);\n  sum64(this.h, 14, hh, hl);\n};\n\nSHA512.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\nfunction SHA384() {\n  if (!(this instanceof SHA384))\n    return new SHA384();\n\n  SHA512.call(this);\n  this.h = [ 0xcbbb9d5d, 0xc1059ed8,\n             0x629a292a, 0x367cd507,\n             0x9159015a, 0x3070dd17,\n             0x152fecd8, 0xf70e5939,\n             0x67332667, 0xffc00b31,\n             0x8eb44a87, 0x68581511,\n             0xdb0c2e0d, 0x64f98fa7,\n             0x47b5481d, 0xbefa4fa4 ];\n}\nutils.inherits(SHA384, SHA512);\nexports.sha384 = SHA384;\n\nSHA384.blockSize = 1024;\nSHA384.outSize = 384;\nSHA384.hmacStrength = 192;\nSHA384.padLength = 128;\n\nSHA384.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h.slice(0, 12), 'big');\n  else\n    return utils.split32(this.h.slice(0, 12), 'big');\n};\n\nfunction SHA1() {\n  if (!(this instanceof SHA1))\n    return new SHA1();\n\n  BlockHash.call(this);\n  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,\n             0x10325476, 0xc3d2e1f0 ];\n  this.W = new Array(80);\n}\n\nutils.inherits(SHA1, BlockHash);\nexports.sha1 = SHA1;\n\nSHA1.blockSize = 512;\nSHA1.outSize = 160;\nSHA1.hmacStrength = 80;\nSHA1.padLength = 64;\n\nSHA1.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++)\n    W[i] = msg[start + i];\n\n  for(; i < W.length; i++)\n    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n\n  for (var i = 0; i < W.length; i++) {\n    var s = ~~(i / 20);\n    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\n    e = d;\n    d = c;\n    c = rotl32(b, 30);\n    b = a;\n    a = t;\n  }\n\n  this.h[0] = sum32(this.h[0], a);\n  this.h[1] = sum32(this.h[1], b);\n  this.h[2] = sum32(this.h[2], c);\n  this.h[3] = sum32(this.h[3], d);\n  this.h[4] = sum32(this.h[4], e);\n};\n\nSHA1.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\nfunction ch32(x, y, z) {\n  return (x & y) ^ ((~x) & z);\n}\n\nfunction maj32(x, y, z) {\n  return (x & y) ^ (x & z) ^ (y & z);\n}\n\nfunction p32(x, y, z) {\n  return x ^ y ^ z;\n}\n\nfunction s0_256(x) {\n  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n}\n\nfunction s1_256(x) {\n  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n}\n\nfunction g0_256(x) {\n  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);\n}\n\nfunction g1_256(x) {\n  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);\n}\n\nfunction ft_1(s, x, y, z) {\n  if (s === 0)\n    return ch32(x, y, z);\n  if (s === 1 || s === 3)\n    return p32(x, y, z);\n  if (s === 2)\n    return maj32(x, y, z);\n}\n\nfunction ch64_hi(xh, xl, yh, yl, zh, zl) {\n  var r = (xh & yh) ^ ((~xh) & zh);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction ch64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = (xl & yl) ^ ((~xl) & zl);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction maj64_hi(xh, xl, yh, yl, zh, zl) {\n  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction maj64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 28);\n  var c1_hi = rotr64_hi(xl, xh, 2);  // 34\n  var c2_hi = rotr64_hi(xl, xh, 7);  // 39\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 28);\n  var c1_lo = rotr64_lo(xl, xh, 2);  // 34\n  var c2_lo = rotr64_lo(xl, xh, 7);  // 39\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 14);\n  var c1_hi = rotr64_hi(xh, xl, 18);\n  var c2_hi = rotr64_hi(xl, xh, 9);  // 41\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 14);\n  var c1_lo = rotr64_lo(xh, xl, 18);\n  var c2_lo = rotr64_lo(xl, xh, 9);  // 41\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 1);\n  var c1_hi = rotr64_hi(xh, xl, 8);\n  var c2_hi = shr64_hi(xh, xl, 7);\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 1);\n  var c1_lo = rotr64_lo(xh, xl, 8);\n  var c2_lo = shr64_lo(xh, xl, 7);\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 19);\n  var c1_hi = rotr64_hi(xl, xh, 29);  // 61\n  var c2_hi = shr64_hi(xh, xl, 6);\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 19);\n  var c1_lo = rotr64_lo(xl, xh, 29);  // 61\n  var c2_lo = shr64_lo(xh, xl, 6);\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\n},{\"../hash\":284}],289:[function(require,module,exports){\nvar utils = exports;\nvar inherits = require('inherits');\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg === 'string') {\n    if (!enc) {\n      for (var i = 0; i < msg.length; i++) {\n        var c = msg.charCodeAt(i);\n        var hi = c >> 8;\n        var lo = c & 0xff;\n        if (hi)\n          res.push(hi, lo);\n        else\n          res.push(lo);\n      }\n    } else if (enc === 'hex') {\n      msg = msg.replace(/[^a-z0-9]+/ig, '');\n      if (msg.length % 2 !== 0)\n        msg = '0' + msg;\n      for (var i = 0; i < msg.length; i += 2)\n        res.push(parseInt(msg[i] + msg[i + 1], 16));\n    }\n  } else {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nfunction htonl(w) {\n  var res = (w >>> 24) |\n            ((w >>> 8) & 0xff00) |\n            ((w << 8) & 0xff0000) |\n            ((w & 0xff) << 24);\n  return res >>> 0;\n}\nutils.htonl = htonl;\n\nfunction toHex32(msg, endian) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++) {\n    var w = msg[i];\n    if (endian === 'little')\n      w = htonl(w);\n    res += zero8(w.toString(16));\n  }\n  return res;\n}\nutils.toHex32 = toHex32;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction zero8(word) {\n  if (word.length === 7)\n    return '0' + word;\n  else if (word.length === 6)\n    return '00' + word;\n  else if (word.length === 5)\n    return '000' + word;\n  else if (word.length === 4)\n    return '0000' + word;\n  else if (word.length === 3)\n    return '00000' + word;\n  else if (word.length === 2)\n    return '000000' + word;\n  else if (word.length === 1)\n    return '0000000' + word;\n  else\n    return word;\n}\nutils.zero8 = zero8;\n\nfunction join32(msg, start, end, endian) {\n  var len = end - start;\n  assert(len % 4 === 0);\n  var res = new Array(len / 4);\n  for (var i = 0, k = start; i < res.length; i++, k += 4) {\n    var w;\n    if (endian === 'big')\n      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n    else\n      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n    res[i] = w >>> 0;\n  }\n  return res;\n}\nutils.join32 = join32;\n\nfunction split32(msg, endian) {\n  var res = new Array(msg.length * 4);\n  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n    var m = msg[i];\n    if (endian === 'big') {\n      res[k] = m >>> 24;\n      res[k + 1] = (m >>> 16) & 0xff;\n      res[k + 2] = (m >>> 8) & 0xff;\n      res[k + 3] = m & 0xff;\n    } else {\n      res[k + 3] = m >>> 24;\n      res[k + 2] = (m >>> 16) & 0xff;\n      res[k + 1] = (m >>> 8) & 0xff;\n      res[k] = m & 0xff;\n    }\n  }\n  return res;\n}\nutils.split32 = split32;\n\nfunction rotr32(w, b) {\n  return (w >>> b) | (w << (32 - b));\n}\nutils.rotr32 = rotr32;\n\nfunction rotl32(w, b) {\n  return (w << b) | (w >>> (32 - b));\n}\nutils.rotl32 = rotl32;\n\nfunction sum32(a, b) {\n  return (a + b) >>> 0;\n}\nutils.sum32 = sum32;\n\nfunction sum32_3(a, b, c) {\n  return (a + b + c) >>> 0;\n}\nutils.sum32_3 = sum32_3;\n\nfunction sum32_4(a, b, c, d) {\n  return (a + b + c + d) >>> 0;\n}\nutils.sum32_4 = sum32_4;\n\nfunction sum32_5(a, b, c, d, e) {\n  return (a + b + c + d + e) >>> 0;\n}\nutils.sum32_5 = sum32_5;\n\nfunction assert(cond, msg) {\n  if (!cond)\n    throw new Error(msg || 'Assertion failed');\n}\nutils.assert = assert;\n\nutils.inherits = inherits;\n\nfunction sum64(buf, pos, ah, al) {\n  var bh = buf[pos];\n  var bl = buf[pos + 1];\n\n  var lo = (al + bl) >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  buf[pos] = hi >>> 0;\n  buf[pos + 1] = lo;\n}\nexports.sum64 = sum64;\n\nfunction sum64_hi(ah, al, bh, bl) {\n  var lo = (al + bl) >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  return hi >>> 0;\n};\nexports.sum64_hi = sum64_hi;\n\nfunction sum64_lo(ah, al, bh, bl) {\n  var lo = al + bl;\n  return lo >>> 0;\n};\nexports.sum64_lo = sum64_lo;\n\nfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n  var carry = 0;\n  var lo = al;\n  lo = (lo + bl) >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = (lo + cl) >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = (lo + dl) >>> 0;\n  carry += lo < dl ? 1 : 0;\n\n  var hi = ah + bh + ch + dh + carry;\n  return hi >>> 0;\n};\nexports.sum64_4_hi = sum64_4_hi;\n\nfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n  var lo = al + bl + cl + dl;\n  return lo >>> 0;\n};\nexports.sum64_4_lo = sum64_4_lo;\n\nfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var carry = 0;\n  var lo = al;\n  lo = (lo + bl) >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = (lo + cl) >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = (lo + dl) >>> 0;\n  carry += lo < dl ? 1 : 0;\n  lo = (lo + el) >>> 0;\n  carry += lo < el ? 1 : 0;\n\n  var hi = ah + bh + ch + dh + eh + carry;\n  return hi >>> 0;\n};\nexports.sum64_5_hi = sum64_5_hi;\n\nfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var lo = al + bl + cl + dl + el;\n\n  return lo >>> 0;\n};\nexports.sum64_5_lo = sum64_5_lo;\n\nfunction rotr64_hi(ah, al, num) {\n  var r = (al << (32 - num)) | (ah >>> num);\n  return r >>> 0;\n};\nexports.rotr64_hi = rotr64_hi;\n\nfunction rotr64_lo(ah, al, num) {\n  var r = (ah << (32 - num)) | (al >>> num);\n  return r >>> 0;\n};\nexports.rotr64_lo = rotr64_lo;\n\nfunction shr64_hi(ah, al, num) {\n  return ah >>> num;\n};\nexports.shr64_hi = shr64_hi;\n\nfunction shr64_lo(ah, al, num) {\n  var r = (ah << (32 - num)) | (al >>> num);\n  return r >>> 0;\n};\nexports.shr64_lo = shr64_lo;\n\n},{\"inherits\":292}],290:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],291:[function(require,module,exports){\n\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n},{}],292:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],293:[function(require,module,exports){\n/**\n * Determine if an object is Buffer\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n * `npm install is-buffer`\n */\n\nmodule.exports = function (obj) {\n  return !!(obj != null &&\n    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n      (obj.constructor &&\n      typeof obj.constructor.isBuffer === 'function' &&\n      obj.constructor.isBuffer(obj))\n    ))\n}\n\n},{}],294:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],295:[function(require,module,exports){\nvar bn = require('bn.js');\nvar brorand = require('brorand');\n\nfunction MillerRabin(rand) {\n  this.rand = rand || new brorand.Rand();\n}\nmodule.exports = MillerRabin;\n\nMillerRabin.create = function create(rand) {\n  return new MillerRabin(rand);\n};\n\nMillerRabin.prototype._rand = function _rand(n) {\n  var len = n.bitLength();\n  var buf = this.rand.generate(Math.ceil(len / 8));\n\n  // Set low bits\n  buf[0] |= 3;\n\n  // Mask high bits\n  var mask = len & 0x7;\n  if (mask !== 0)\n    buf[buf.length - 1] >>= 7 - mask;\n\n  return new bn(buf);\n}\n\nMillerRabin.prototype.test = function test(n, k, cb) {\n  var len = n.bitLength();\n  var red = bn.mont(n);\n  var rone = new bn(1).toRed(red);\n\n  if (!k)\n    k = Math.max(1, (len / 48) | 0);\n\n  // Find d and s, (n - 1) = (2 ^ s) * d;\n  var n1 = n.subn(1);\n  var n2 = n1.subn(1);\n  for (var s = 0; !n1.testn(s); s++) {}\n  var d = n.shrn(s);\n\n  var rn1 = n1.toRed(red);\n\n  var prime = true;\n  for (; k > 0; k--) {\n    var a = this._rand(n2);\n    if (cb)\n      cb(a);\n\n    var x = a.toRed(red).redPow(d);\n    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)\n      continue;\n\n    for (var i = 1; i < s; i++) {\n      x = x.redSqr();\n\n      if (x.cmp(rone) === 0)\n        return false;\n      if (x.cmp(rn1) === 0)\n        break;\n    }\n\n    if (i === s)\n      return false;\n  }\n\n  return prime;\n};\n\nMillerRabin.prototype.getDivisor = function getDivisor(n, k) {\n  var len = n.bitLength();\n  var red = bn.mont(n);\n  var rone = new bn(1).toRed(red);\n\n  if (!k)\n    k = Math.max(1, (len / 48) | 0);\n\n  // Find d and s, (n - 1) = (2 ^ s) * d;\n  var n1 = n.subn(1);\n  var n2 = n1.subn(1);\n  for (var s = 0; !n1.testn(s); s++) {}\n  var d = n.shrn(s);\n\n  var rn1 = n1.toRed(red);\n\n  for (; k > 0; k--) {\n    var a = this._rand(n2);\n\n    var g = n.gcd(a);\n    if (g.cmpn(1) !== 0)\n      return g;\n\n    var x = a.toRed(red).redPow(d);\n    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)\n      continue;\n\n    for (var i = 1; i < s; i++) {\n      x = x.redSqr();\n\n      if (x.cmp(rone) === 0)\n        return x.fromRed().subn(1).gcd(n);\n      if (x.cmp(rn1) === 0)\n        break;\n    }\n\n    if (i === s) {\n      x = x.redSqr();\n      return x.fromRed().subn(1).gcd(n);\n    }\n  }\n\n  return false;\n};\n\n},{\"bn.js\":215,\"brorand\":216}],296:[function(require,module,exports){\nmodule.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n\n},{}],297:[function(require,module,exports){\nmodule.exports={\"2.16.840.1.101.3.4.1.1\": \"aes-128-ecb\",\n\"2.16.840.1.101.3.4.1.2\": \"aes-128-cbc\",\n\"2.16.840.1.101.3.4.1.3\": \"aes-128-ofb\",\n\"2.16.840.1.101.3.4.1.4\": \"aes-128-cfb\",\n\"2.16.840.1.101.3.4.1.21\": \"aes-192-ecb\",\n\"2.16.840.1.101.3.4.1.22\": \"aes-192-cbc\",\n\"2.16.840.1.101.3.4.1.23\": \"aes-192-ofb\",\n\"2.16.840.1.101.3.4.1.24\": \"aes-192-cfb\",\n\"2.16.840.1.101.3.4.1.41\": \"aes-256-ecb\",\n\"2.16.840.1.101.3.4.1.42\": \"aes-256-cbc\",\n\"2.16.840.1.101.3.4.1.43\": \"aes-256-ofb\",\n\"2.16.840.1.101.3.4.1.44\": \"aes-256-cfb\"\n}\n},{}],298:[function(require,module,exports){\n// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js\n// Fedor, you are amazing.\n\nvar asn1 = require('asn1.js')\n\nvar RSAPrivateKey = asn1.define('RSAPrivateKey', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('modulus').int(),\n    this.key('publicExponent').int(),\n    this.key('privateExponent').int(),\n    this.key('prime1').int(),\n    this.key('prime2').int(),\n    this.key('exponent1').int(),\n    this.key('exponent2').int(),\n    this.key('coefficient').int()\n  )\n})\nexports.RSAPrivateKey = RSAPrivateKey\n\nvar RSAPublicKey = asn1.define('RSAPublicKey', function () {\n  this.seq().obj(\n    this.key('modulus').int(),\n    this.key('publicExponent').int()\n  )\n})\nexports.RSAPublicKey = RSAPublicKey\n\nvar PublicKey = asn1.define('SubjectPublicKeyInfo', function () {\n  this.seq().obj(\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('subjectPublicKey').bitstr()\n  )\n})\nexports.PublicKey = PublicKey\n\nvar AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {\n  this.seq().obj(\n    this.key('algorithm').objid(),\n    this.key('none').null_().optional(),\n    this.key('curve').objid().optional(),\n    this.key('params').seq().obj(\n      this.key('p').int(),\n      this.key('q').int(),\n      this.key('g').int()\n    ).optional()\n  )\n})\n\nvar PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('subjectPrivateKey').octstr()\n  )\n})\nexports.PrivateKey = PrivateKeyInfo\nvar EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {\n  this.seq().obj(\n    this.key('algorithm').seq().obj(\n      this.key('id').objid(),\n      this.key('decrypt').seq().obj(\n        this.key('kde').seq().obj(\n          this.key('id').objid(),\n          this.key('kdeparams').seq().obj(\n            this.key('salt').octstr(),\n            this.key('iters').int()\n          )\n        ),\n        this.key('cipher').seq().obj(\n          this.key('algo').objid(),\n          this.key('iv').octstr()\n        )\n      )\n    ),\n    this.key('subjectPrivateKey').octstr()\n  )\n})\n\nexports.EncryptedPrivateKey = EncryptedPrivateKeyInfo\n\nvar DSAPrivateKey = asn1.define('DSAPrivateKey', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('p').int(),\n    this.key('q').int(),\n    this.key('g').int(),\n    this.key('pub_key').int(),\n    this.key('priv_key').int()\n  )\n})\nexports.DSAPrivateKey = DSAPrivateKey\n\nexports.DSAparam = asn1.define('DSAparam', function () {\n  this.int()\n})\nvar ECPrivateKey = asn1.define('ECPrivateKey', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').optional().explicit(0).use(ECParameters),\n    this.key('publicKey').optional().explicit(1).bitstr()\n  )\n})\nexports.ECPrivateKey = ECPrivateKey\nvar ECParameters = asn1.define('ECParameters', function () {\n  this.choice({\n    namedCurve: this.objid()\n  })\n})\n\nexports.signature = asn1.define('signature', function () {\n  this.seq().obj(\n    this.key('r').int(),\n    this.key('s').int()\n  )\n})\n\n},{\"asn1.js\":200}],299:[function(require,module,exports){\n(function (Buffer){\n// adapted from https://github.com/apatil/pemstrip\nvar findProc = /Proc-Type: 4,ENCRYPTED\\r?\\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\\r?\\n\\r?\\n([0-9A-z\\n\\r\\+\\/\\=]+)\\r?\\n/m\nvar startRegex = /^-----BEGIN (.*) KEY-----\\r?\\n/m\nvar fullRegex = /^-----BEGIN (.*) KEY-----\\r?\\n([0-9A-z\\n\\r\\+\\/\\=]+)\\r?\\n-----END \\1 KEY-----$/m\nvar evp = require('evp_bytestokey')\nvar ciphers = require('browserify-aes')\nmodule.exports = function (okey, password) {\n  var key = okey.toString()\n  var match = key.match(findProc)\n  var decrypted\n  if (!match) {\n    var match2 = key.match(fullRegex)\n    decrypted = new Buffer(match2[2].replace(/\\r?\\n/g, ''), 'base64')\n  } else {\n    var suite = 'aes' + match[1]\n    var iv = new Buffer(match[2], 'hex')\n    var cipherText = new Buffer(match[3].replace(/\\r?\\n/g, ''), 'base64')\n    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key\n    var out = []\n    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)\n    out.push(cipher.update(cipherText))\n    out.push(cipher.final())\n    decrypted = Buffer.concat(out)\n  }\n  var tag = key.match(startRegex)[1] + ' KEY'\n  return {\n    tag: tag,\n    data: decrypted\n  }\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"browserify-aes\":220,\"buffer\":243,\"evp_bytestokey\":283}],300:[function(require,module,exports){\n(function (Buffer){\nvar asn1 = require('./asn1')\nvar aesid = require('./aesid.json')\nvar fixProc = require('./fixProc')\nvar ciphers = require('browserify-aes')\nvar compat = require('pbkdf2')\nmodule.exports = parseKeys\n\nfunction parseKeys (buffer) {\n  var password\n  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {\n    password = buffer.passphrase\n    buffer = buffer.key\n  }\n  if (typeof buffer === 'string') {\n    buffer = new Buffer(buffer)\n  }\n\n  var stripped = fixProc(buffer, password)\n\n  var type = stripped.tag\n  var data = stripped.data\n  var subtype, ndata\n  switch (type) {\n    case 'PUBLIC KEY':\n      ndata = asn1.PublicKey.decode(data, 'der')\n      subtype = ndata.algorithm.algorithm.join('.')\n      switch (subtype) {\n        case '1.2.840.113549.1.1.1':\n          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')\n        case '1.2.840.10045.2.1':\n          ndata.subjectPrivateKey = ndata.subjectPublicKey\n          return {\n            type: 'ec',\n            data: ndata\n          }\n        case '1.2.840.10040.4.1':\n          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')\n          return {\n            type: 'dsa',\n            data: ndata.algorithm.params\n          }\n        default: throw new Error('unknown key id ' + subtype)\n      }\n      throw new Error('unknown key type ' + type)\n    case 'ENCRYPTED PRIVATE KEY':\n      data = asn1.EncryptedPrivateKey.decode(data, 'der')\n      data = decrypt(data, password)\n      // falls through\n    case 'PRIVATE KEY':\n      ndata = asn1.PrivateKey.decode(data, 'der')\n      subtype = ndata.algorithm.algorithm.join('.')\n      switch (subtype) {\n        case '1.2.840.113549.1.1.1':\n          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')\n        case '1.2.840.10045.2.1':\n          return {\n            curve: ndata.algorithm.curve,\n            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey\n          }\n        case '1.2.840.10040.4.1':\n          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')\n          return {\n            type: 'dsa',\n            params: ndata.algorithm.params\n          }\n        default: throw new Error('unknown key id ' + subtype)\n      }\n      throw new Error('unknown key type ' + type)\n    case 'RSA PUBLIC KEY':\n      return asn1.RSAPublicKey.decode(data, 'der')\n    case 'RSA PRIVATE KEY':\n      return asn1.RSAPrivateKey.decode(data, 'der')\n    case 'DSA PRIVATE KEY':\n      return {\n        type: 'dsa',\n        params: asn1.DSAPrivateKey.decode(data, 'der')\n      }\n    case 'EC PRIVATE KEY':\n      data = asn1.ECPrivateKey.decode(data, 'der')\n      return {\n        curve: data.parameters.value,\n        privateKey: data.privateKey\n      }\n    default: throw new Error('unknown key type ' + type)\n  }\n}\nparseKeys.signature = asn1.signature\nfunction decrypt (data, password) {\n  var salt = data.algorithm.decrypt.kde.kdeparams.salt\n  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)\n  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]\n  var iv = data.algorithm.decrypt.cipher.iv\n  var cipherText = data.subjectPrivateKey\n  var keylen = parseInt(algo.split('-')[1], 10) / 8\n  var key = compat.pbkdf2Sync(password, salt, iters, keylen)\n  var cipher = ciphers.createDecipheriv(algo, key, iv)\n  var out = []\n  out.push(cipher.update(cipherText))\n  out.push(cipher.final())\n  return Buffer.concat(out)\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./aesid.json\":297,\"./asn1\":298,\"./fixProc\":299,\"browserify-aes\":220,\"buffer\":243,\"pbkdf2\":301}],301:[function(require,module,exports){\n(function (Buffer){\nvar createHmac = require('create-hmac')\nvar MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs\n\nexports.pbkdf2 = pbkdf2\nfunction pbkdf2 (password, salt, iterations, keylen, digest, callback) {\n  if (typeof digest === 'function') {\n    callback = digest\n    digest = undefined\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error('No callback provided to pbkdf2')\n  }\n\n  var result = pbkdf2Sync(password, salt, iterations, keylen, digest)\n  setTimeout(function () {\n    callback(undefined, result)\n  })\n}\n\nexports.pbkdf2Sync = pbkdf2Sync\nfunction pbkdf2Sync (password, salt, iterations, keylen, digest) {\n  if (typeof iterations !== 'number') {\n    throw new TypeError('Iterations not a number')\n  }\n\n  if (iterations < 0) {\n    throw new TypeError('Bad iterations')\n  }\n\n  if (typeof keylen !== 'number') {\n    throw new TypeError('Key length not a number')\n  }\n\n  if (keylen < 0 || keylen > MAX_ALLOC) {\n    throw new TypeError('Bad key length')\n  }\n\n  digest = digest || 'sha1'\n\n  if (!Buffer.isBuffer(password)) password = new Buffer(password, 'binary')\n  if (!Buffer.isBuffer(salt)) salt = new Buffer(salt, 'binary')\n\n  var hLen\n  var l = 1\n  var DK = new Buffer(keylen)\n  var block1 = new Buffer(salt.length + 4)\n  salt.copy(block1, 0, 0, salt.length)\n\n  var r\n  var T\n\n  for (var i = 1; i <= l; i++) {\n    block1.writeUInt32BE(i, salt.length)\n    var U = createHmac(digest, password).update(block1).digest()\n\n    if (!hLen) {\n      hLen = U.length\n      T = new Buffer(hLen)\n      l = Math.ceil(keylen / hLen)\n      r = keylen - (l - 1) * hLen\n    }\n\n    U.copy(T, 0, 0, hLen)\n\n    for (var j = 1; j < iterations; j++) {\n      U = createHmac(digest, password).update(U).digest()\n\n      for (var k = 0; k < hLen; k++) {\n        T[k] ^= U[k]\n      }\n    }\n\n    var destPos = (i - 1) * hLen\n    var len = (i === l ? r : hLen)\n    T.copy(DK, destPos, 0, len)\n  }\n\n  return DK\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243,\"create-hmac\":251}],302:[function(require,module,exports){\n(function (process){\n'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn) {\n  var args = new Array(arguments.length - 1);\n  var i = 0;\n  while (i < args.length) {\n    args[i++] = arguments[i];\n  }\n  process.nextTick(function afterTick() {\n    fn.apply(null, args);\n  });\n}\n\n}).call(this,require('_process'))\n},{\"_process\":303}],303:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],304:[function(require,module,exports){\nexports.publicEncrypt = require('./publicEncrypt');\nexports.privateDecrypt = require('./privateDecrypt');\n\nexports.privateEncrypt = function privateEncrypt(key, buf) {\n  return exports.publicEncrypt(key, buf, true);\n};\n\nexports.publicDecrypt = function publicDecrypt(key, buf) {\n  return exports.privateDecrypt(key, buf, true);\n};\n},{\"./privateDecrypt\":306,\"./publicEncrypt\":307}],305:[function(require,module,exports){\n(function (Buffer){\nvar createHash = require('create-hash');\nmodule.exports = function (seed, len) {\n  var t = new Buffer('');\n  var  i = 0, c;\n  while (t.length < len) {\n    c = i2ops(i++);\n    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);\n  }\n  return t.slice(0, len);\n};\n\nfunction i2ops(c) {\n  var out = new Buffer(4);\n  out.writeUInt32BE(c,0);\n  return out;\n}\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243,\"create-hash\":248}],306:[function(require,module,exports){\n(function (Buffer){\nvar parseKeys = require('parse-asn1');\nvar mgf = require('./mgf');\nvar xor = require('./xor');\nvar bn = require('bn.js');\nvar crt = require('browserify-rsa');\nvar createHash = require('create-hash');\nvar withPublic = require('./withPublic');\nmodule.exports = function privateDecrypt(private_key, enc, reverse) {\n  var padding;\n  if (private_key.padding) {\n    padding = private_key.padding;\n  } else if (reverse) {\n    padding = 1;\n  } else {\n    padding = 4;\n  }\n  \n  var key = parseKeys(private_key);\n  var k = key.modulus.byteLength();\n  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {\n    throw new Error('decryption error');\n  }\n  var msg;\n  if (reverse) {\n    msg = withPublic(new bn(enc), key);\n  } else {\n    msg = crt(enc, key);\n  }\n  var zBuffer = new Buffer(k - msg.length);\n  zBuffer.fill(0);\n  msg = Buffer.concat([zBuffer, msg], k);\n  if (padding === 4) {\n    return oaep(key, msg);\n  } else if (padding === 1) {\n    return pkcs1(key, msg, reverse);\n  } else if (padding === 3) {\n    return msg;\n  } else {\n    throw new Error('unknown padding');\n  }\n};\n\nfunction oaep(key, msg){\n  var n = key.modulus;\n  var k = key.modulus.byteLength();\n  var mLen = msg.length;\n  var iHash = createHash('sha1').update(new Buffer('')).digest();\n  var hLen = iHash.length;\n  var hLen2 = 2 * hLen;\n  if (msg[0] !== 0) {\n    throw new Error('decryption error');\n  }\n  var maskedSeed = msg.slice(1, hLen + 1);\n  var maskedDb =  msg.slice(hLen + 1);\n  var seed = xor(maskedSeed, mgf(maskedDb, hLen));\n  var db = xor(maskedDb, mgf(seed, k - hLen - 1));\n  if (compare(iHash, db.slice(0, hLen))) {\n    throw new Error('decryption error');\n  }\n  var i = hLen;\n  while (db[i] === 0) {\n    i++;\n  }\n  if (db[i++] !== 1) {\n    throw new Error('decryption error');\n  }\n  return db.slice(i);\n}\n\nfunction pkcs1(key, msg, reverse){\n  var p1 = msg.slice(0, 2);\n  var i = 2;\n  var status = 0;\n  while (msg[i++] !== 0) {\n    if (i >= msg.length) {\n      status++;\n      break;\n    }\n  }\n  var ps = msg.slice(2, i - 1);\n  var p2 = msg.slice(i - 1, i);\n\n  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){\n    status++;\n  }\n  if (ps.length < 8) {\n    status++;\n  }\n  if (status) {\n    throw new Error('decryption error');\n  }\n  return  msg.slice(i);\n}\nfunction compare(a, b){\n  a = new Buffer(a);\n  b = new Buffer(b);\n  var dif = 0;\n  var len = a.length;\n  if (a.length !== b.length) {\n    dif++;\n    len = Math.min(a.length, b.length);\n  }\n  var i = -1;\n  while (++i < len) {\n    dif += (a[i] ^ b[i]);\n  }\n  return dif;\n}\n}).call(this,require(\"buffer\").Buffer)\n},{\"./mgf\":305,\"./withPublic\":308,\"./xor\":309,\"bn.js\":215,\"browserify-rsa\":236,\"buffer\":243,\"create-hash\":248,\"parse-asn1\":300}],307:[function(require,module,exports){\n(function (Buffer){\nvar parseKeys = require('parse-asn1');\nvar randomBytes = require('randombytes');\nvar createHash = require('create-hash');\nvar mgf = require('./mgf');\nvar xor = require('./xor');\nvar bn = require('bn.js');\nvar withPublic = require('./withPublic');\nvar crt = require('browserify-rsa');\n\nvar constants = {\n  RSA_PKCS1_OAEP_PADDING: 4,\n  RSA_PKCS1_PADDIN: 1,\n  RSA_NO_PADDING: 3\n};\n\nmodule.exports = function publicEncrypt(public_key, msg, reverse) {\n  var padding;\n  if (public_key.padding) {\n    padding = public_key.padding;\n  } else if (reverse) {\n    padding = 1;\n  } else {\n    padding = 4;\n  }\n  var key = parseKeys(public_key);\n  var paddedMsg;\n  if (padding === 4) {\n    paddedMsg = oaep(key, msg);\n  } else if (padding === 1) {\n    paddedMsg = pkcs1(key, msg, reverse);\n  } else if (padding === 3) {\n    paddedMsg = new bn(msg);\n    if (paddedMsg.cmp(key.modulus) >= 0) {\n      throw new Error('data too long for modulus');\n    }\n  } else {\n    throw new Error('unknown padding');\n  }\n  if (reverse) {\n    return crt(paddedMsg, key);\n  } else {\n    return withPublic(paddedMsg, key);\n  }\n};\n\nfunction oaep(key, msg){\n  var k = key.modulus.byteLength();\n  var mLen = msg.length;\n  var iHash = createHash('sha1').update(new Buffer('')).digest();\n  var hLen = iHash.length;\n  var hLen2 = 2 * hLen;\n  if (mLen > k - hLen2 - 2) {\n    throw new Error('message too long');\n  }\n  var ps = new Buffer(k - mLen - hLen2 - 2);\n  ps.fill(0);\n  var dblen = k - hLen - 1;\n  var seed = randomBytes(hLen);\n  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));\n  var maskedSeed = xor(seed, mgf(maskedDb, hLen));\n  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));\n}\nfunction pkcs1(key, msg, reverse){\n  var mLen = msg.length;\n  var k = key.modulus.byteLength();\n  if (mLen > k - 11) {\n    throw new Error('message too long');\n  }\n  var ps;\n  if (reverse) {\n    ps = new Buffer(k - mLen - 3);\n    ps.fill(0xff);\n  } else {\n    ps = nonZero(k - mLen - 3);\n  }\n  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));\n}\nfunction nonZero(len, crypto) {\n  var out = new Buffer(len);\n  var i = 0;\n  var cache = randomBytes(len*2);\n  var cur = 0;\n  var num;\n  while (i < len) {\n    if (cur === cache.length) {\n      cache = randomBytes(len*2);\n      cur = 0;\n    }\n    num = cache[cur++];\n    if (num) {\n      out[i++] = num;\n    }\n  }\n  return out;\n}\n}).call(this,require(\"buffer\").Buffer)\n},{\"./mgf\":305,\"./withPublic\":308,\"./xor\":309,\"bn.js\":215,\"browserify-rsa\":236,\"buffer\":243,\"create-hash\":248,\"parse-asn1\":300,\"randombytes\":310}],308:[function(require,module,exports){\n(function (Buffer){\nvar bn = require('bn.js');\nfunction withPublic(paddedMsg, key) {\n  return new Buffer(paddedMsg\n    .toRed(bn.mont(key.modulus))\n    .redPow(new bn(key.publicExponent))\n    .fromRed()\n    .toArray());\n}\n\nmodule.exports = withPublic;\n}).call(this,require(\"buffer\").Buffer)\n},{\"bn.js\":215,\"buffer\":243}],309:[function(require,module,exports){\nmodule.exports = function xor(a, b) {\n  var len = a.length;\n  var i = -1;\n  while (++i < len) {\n    a[i] ^= b[i];\n  }\n  return a\n};\n},{}],310:[function(require,module,exports){\n(function (process,global,Buffer){\n'use strict'\n\nfunction oldBrowser () {\n  throw new Error('secure random number generation not supported by this browser\\nuse chrome, FireFox or Internet Explorer 11')\n}\n\nvar crypto = global.crypto || global.msCrypto\n\nif (crypto && crypto.getRandomValues) {\n  module.exports = randomBytes\n} else {\n  module.exports = oldBrowser\n}\n\nfunction randomBytes (size, cb) {\n  // phantomjs needs to throw\n  if (size > 65536) throw new Error('requested too many random bytes')\n  // in case browserify  isn't using the Uint8Array version\n  var rawBytes = new global.Uint8Array(size)\n\n  // This will not work in older browsers.\n  // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n  crypto.getRandomValues(rawBytes)\n\n  // phantomjs doesn't like a buffer being passed here\n  var bytes = new Buffer(rawBytes.buffer)\n\n  if (typeof cb === 'function') {\n    return process.nextTick(function () {\n      cb(null, bytes)\n    })\n  }\n\n  return bytes\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer)\n},{\"_process\":303,\"buffer\":243}],311:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_duplex.js\")\n\n},{\"./lib/_stream_duplex.js\":312}],312:[function(require,module,exports){\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n},{\"./_stream_readable\":314,\"./_stream_writable\":316,\"core-util-is\":246,\"inherits\":292,\"process-nextick-args\":302}],313:[function(require,module,exports){\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{\"./_stream_transform\":315,\"core-util-is\":246,\"inherits\":292}],314:[function(require,module,exports){\n(function (process){\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events');\n\n/*<replacement>*/\nvar EElistenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar Stream;\n(function (){try{\n  Stream = require('st' + 'ream');\n}catch(_){}finally{\n  if (!Stream)\n    Stream = require('events').EventEmitter;\n}}())\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar Duplex;\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nvar Duplex;\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function')\n    this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function() {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else {\n      return state.length;\n    }\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (ret !== null)\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!(Buffer.isBuffer(chunk)) &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      processNextTick(emitReadable_, stream);\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    processNextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      if (state.pipesCount === 1 &&\n          state.pipes[0] === dest &&\n          src.listenerCount('data') === 1 &&\n          !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }; }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else if (list.length === 1)\n      ret = list[0];\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":312,\"_process\":303,\"buffer\":243,\"core-util-is\":246,\"events\":282,\"inherits\":292,\"isarray\":294,\"process-nextick-args\":302,\"string_decoder/\":350,\"util\":217}],315:[function(require,module,exports){\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  this.once('prefinish', function() {\n    if (typeof this._flush === 'function')\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n},{\"./_stream_duplex\":312,\"core-util-is\":246,\"inherits\":292}],316:[function(require,module,exports){\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar Stream;\n(function (){try{\n  Stream = require('st' + 'ream');\n}catch(_){}finally{\n  if (!Stream)\n    Stream = require('events').EventEmitter;\n}}())\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nvar Duplex;\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function (){try {\nObject.defineProperty(WritableState.prototype, 'buffer', {\n  get: internalUtil.deprecate(function() {\n    return this.getBuffer();\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\n     'instead.')\n});\n}catch(_){}}());\n\n\nvar Duplex;\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!(Buffer.isBuffer(chunk)) &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = nop;\n\n  if (state.ended)\n    writeAfterEnd(this, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.bufferedRequest)\n      clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',\n'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']\n.indexOf((encoding + '').toLowerCase()) > -1))\n    throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync)\n    processNextTick(cb, er);\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      processNextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var buffer = [];\n    var cbs = [];\n    while (entry) {\n      cbs.push(entry.callback);\n      buffer.push(entry);\n      entry = entry.next;\n    }\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    doWrite(stream, state, true, state.length, buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null)\n      state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined)\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.length === 0 &&\n          state.bufferedRequest === null &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      processNextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n},{\"./_stream_duplex\":312,\"buffer\":243,\"core-util-is\":246,\"events\":282,\"inherits\":292,\"process-nextick-args\":302,\"util-deprecate\":351}],317:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_passthrough.js\")\n\n},{\"./lib/_stream_passthrough.js\":313}],318:[function(require,module,exports){\nvar Stream = (function (){\n  try {\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify\n  } catch(_){}\n}());\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream || exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":312,\"./lib/_stream_passthrough.js\":313,\"./lib/_stream_readable.js\":314,\"./lib/_stream_transform.js\":315,\"./lib/_stream_writable.js\":316}],319:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_transform.js\")\n\n},{\"./lib/_stream_transform.js\":315}],320:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_writable.js\")\n\n},{\"./lib/_stream_writable.js\":316}],321:[function(require,module,exports){\n(function (global){\n/*! *****************************************************************************\r\nCopyright (C) Microsoft. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\nvar Reflect;\r\n(function (Reflect) {\r\n    \"use strict\";\r\n    // Load global or shim versions of Map, Set, and WeakMap\r\n    var functionPrototype = Object.getPrototypeOf(Function);\r\n    var _Map = typeof Map === \"function\" ? Map : CreateMapPolyfill();\r\n    var _Set = typeof Set === \"function\" ? Set : CreateSetPolyfill();\r\n    var _WeakMap = typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\r\n    // [[Metadata]] internal slot\r\n    var __Metadata__ = new _WeakMap();\r\n    /**\r\n      * Applies a set of decorators to a property of a target object.\r\n      * @param decorators An array of decorators.\r\n      * @param target The target object.\r\n      * @param targetKey (Optional) The property key to decorate.\r\n      * @param targetDescriptor (Optional) The property descriptor for the target key\r\n      * @remarks Decorators are applied in reverse order.\r\n      * @example\r\n      *\r\n      *     class C {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     C = Reflect.decorate(decoratorsArray, C);\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.decorate(decoratorsArray, C, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.decorate(decoratorsArray, C.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Object.defineProperty(C, \"staticMethod\",\r\n      *         Reflect.decorate(decoratorsArray, C, \"staticMethod\",\r\n      *             Object.getOwnPropertyDescriptor(C, \"staticMethod\")));\r\n      *\r\n      *     // method (on prototype)\r\n      *     Object.defineProperty(C.prototype, \"method\",\r\n      *         Reflect.decorate(decoratorsArray, C.prototype, \"method\",\r\n      *             Object.getOwnPropertyDescriptor(C.prototype, \"method\")));\r\n      *\r\n      */\r\n    function decorate(decorators, target, targetKey, targetDescriptor) {\r\n        if (!IsUndefined(targetDescriptor)) {\r\n            if (!IsArray(decorators)) {\r\n                throw new TypeError();\r\n            }\r\n            else if (!IsObject(target)) {\r\n                throw new TypeError();\r\n            }\r\n            else if (IsUndefined(targetKey)) {\r\n                throw new TypeError();\r\n            }\r\n            else if (!IsObject(targetDescriptor)) {\r\n                throw new TypeError();\r\n            }\r\n            targetKey = ToPropertyKey(targetKey);\r\n            return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);\r\n        }\r\n        else if (!IsUndefined(targetKey)) {\r\n            if (!IsArray(decorators)) {\r\n                throw new TypeError();\r\n            }\r\n            else if (!IsObject(target)) {\r\n                throw new TypeError();\r\n            }\r\n            targetKey = ToPropertyKey(targetKey);\r\n            return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);\r\n        }\r\n        else {\r\n            if (!IsArray(decorators)) {\r\n                throw new TypeError();\r\n            }\r\n            else if (!IsConstructor(target)) {\r\n                throw new TypeError();\r\n            }\r\n            return DecorateConstructor(decorators, target);\r\n        }\r\n    }\r\n    Reflect.decorate = decorate;\r\n    /**\r\n      * A default metadata decorator factory that can be used on a class, class member, or parameter.\r\n      * @param metadataKey The key for the metadata entry.\r\n      * @param metadataValue The value for the metadata entry.\r\n      * @returns A decorator function.\r\n      * @remarks\r\n      * If `metadataKey` is already defined for the target and target key, the\r\n      * metadataValue for that key will be overwritten.\r\n      * @example\r\n      *\r\n      *     // constructor\r\n      *     @Reflect.metadata(key, value)\r\n      *     class C {\r\n      *     }\r\n      *\r\n      *     // property (on constructor, TypeScript only)\r\n      *     class C {\r\n      *         @Reflect.metadata(key, value)\r\n      *         static staticProperty;\r\n      *     }\r\n      *\r\n      *     // property (on prototype, TypeScript only)\r\n      *     class C {\r\n      *         @Reflect.metadata(key, value)\r\n      *         property;\r\n      *     }\r\n      *\r\n      *     // method (on constructor)\r\n      *     class C {\r\n      *         @Reflect.metadata(key, value)\r\n      *         static staticMethod() { }\r\n      *     }\r\n      *\r\n      *     // method (on prototype)\r\n      *     class C {\r\n      *         @Reflect.metadata(key, value)\r\n      *         method() { }\r\n      *     }\r\n      *\r\n      */\r\n    function metadata(metadataKey, metadataValue) {\r\n        function decorator(target, targetKey) {\r\n            if (!IsUndefined(targetKey)) {\r\n                if (!IsObject(target)) {\r\n                    throw new TypeError();\r\n                }\r\n                targetKey = ToPropertyKey(targetKey);\r\n                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);\r\n            }\r\n            else {\r\n                if (!IsConstructor(target)) {\r\n                    throw new TypeError();\r\n                }\r\n                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, /*targetKey*/ undefined);\r\n            }\r\n        }\r\n        return decorator;\r\n    }\r\n    Reflect.metadata = metadata;\r\n    /**\r\n      * Define a unique metadata entry on the target.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param metadataValue A value that contains attached metadata.\r\n      * @param target The target object on which to define metadata.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @example\r\n      *\r\n      *     class C {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, C);\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, C, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, C.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, C, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, C.prototype, \"method\");\r\n      *\r\n      *     // decorator factory as metadata-producing annotation.\r\n      *     function MyAnnotation(options): Decorator {\r\n      *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\r\n      *     }\r\n      *\r\n      */\r\n    function defineMetadata(metadataKey, metadataValue, target, targetKey) {\r\n        if (!IsObject(target)) {\r\n            throw new TypeError();\r\n        }\r\n        else if (!IsUndefined(targetKey)) {\r\n            targetKey = ToPropertyKey(targetKey);\r\n        }\r\n        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);\r\n    }\r\n    Reflect.defineMetadata = defineMetadata;\r\n    /**\r\n      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class C {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", C);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", C, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", C.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", C, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", C.prototype, \"method\");\r\n      *\r\n      */\r\n    function hasMetadata(metadataKey, target, targetKey) {\r\n        if (!IsObject(target)) {\r\n            throw new TypeError();\r\n        }\r\n        else if (!IsUndefined(targetKey)) {\r\n            targetKey = ToPropertyKey(targetKey);\r\n        }\r\n        return OrdinaryHasMetadata(metadataKey, target, targetKey);\r\n    }\r\n    Reflect.hasMetadata = hasMetadata;\r\n    /**\r\n      * Gets a value indicating whether the target object has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class C {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", C);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", C, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", C.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", C, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", C.prototype, \"method\");\r\n      *\r\n      */\r\n    function hasOwnMetadata(metadataKey, target, targetKey) {\r\n        if (!IsObject(target)) {\r\n            throw new TypeError();\r\n        }\r\n        else if (!IsUndefined(targetKey)) {\r\n            targetKey = ToPropertyKey(targetKey);\r\n        }\r\n        return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);\r\n    }\r\n    Reflect.hasOwnMetadata = hasOwnMetadata;\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class C {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", C);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", C, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", C.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", C, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", C.prototype, \"method\");\r\n      *\r\n      */\r\n    function getMetadata(metadataKey, target, targetKey) {\r\n        if (!IsObject(target)) {\r\n            throw new TypeError();\r\n        }\r\n        else if (!IsUndefined(targetKey)) {\r\n            targetKey = ToPropertyKey(targetKey);\r\n        }\r\n        return OrdinaryGetMetadata(metadataKey, target, targetKey);\r\n    }\r\n    Reflect.getMetadata = getMetadata;\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class C {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", C);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", C, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", C.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", C, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", C.prototype, \"method\");\r\n      *\r\n      */\r\n    function getOwnMetadata(metadataKey, target, targetKey) {\r\n        if (!IsObject(target)) {\r\n            throw new TypeError();\r\n        }\r\n        else if (!IsUndefined(targetKey)) {\r\n            targetKey = ToPropertyKey(targetKey);\r\n        }\r\n        return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);\r\n    }\r\n    Reflect.getOwnMetadata = getOwnMetadata;\r\n    /**\r\n      * Gets the metadata keys defined on the target object or its prototype chain.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class C {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getMetadataKeys(C);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getMetadataKeys(C, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getMetadataKeys(C.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getMetadataKeys(C, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getMetadataKeys(C.prototype, \"method\");\r\n      *\r\n      */\r\n    function getMetadataKeys(target, targetKey) {\r\n        if (!IsObject(target)) {\r\n            throw new TypeError();\r\n        }\r\n        else if (!IsUndefined(targetKey)) {\r\n            targetKey = ToPropertyKey(targetKey);\r\n        }\r\n        return OrdinaryMetadataKeys(target, targetKey);\r\n    }\r\n    Reflect.getMetadataKeys = getMetadataKeys;\r\n    /**\r\n      * Gets the unique metadata keys defined on the target object.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class C {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getOwnMetadataKeys(C);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getOwnMetadataKeys(C, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getOwnMetadataKeys(C.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getOwnMetadataKeys(C, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getOwnMetadataKeys(C.prototype, \"method\");\r\n      *\r\n      */\r\n    function getOwnMetadataKeys(target, targetKey) {\r\n        if (!IsObject(target)) {\r\n            throw new TypeError();\r\n        }\r\n        else if (!IsUndefined(targetKey)) {\r\n            targetKey = ToPropertyKey(targetKey);\r\n        }\r\n        return OrdinaryOwnMetadataKeys(target, targetKey);\r\n    }\r\n    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;\r\n    /**\r\n      * Deletes the metadata entry from the target object with the provided key.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata entry was found and deleted; otherwise, false.\r\n      * @example\r\n      *\r\n      *     class C {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", C);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", C, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", C.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", C, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", C.prototype, \"method\");\r\n      *\r\n      */\r\n    function deleteMetadata(metadataKey, target, targetKey) {\r\n        if (!IsObject(target)) {\r\n            throw new TypeError();\r\n        }\r\n        else if (!IsUndefined(targetKey)) {\r\n            targetKey = ToPropertyKey(targetKey);\r\n        }\r\n        // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#deletemetadata-metadatakey-p-\r\n        var metadataMap = GetOrCreateMetadataMap(target, targetKey, /*create*/ false);\r\n        if (IsUndefined(metadataMap)) {\r\n            return false;\r\n        }\r\n        if (!metadataMap.delete(metadataKey)) {\r\n            return false;\r\n        }\r\n        if (metadataMap.size > 0) {\r\n            return true;\r\n        }\r\n        var targetMetadata = __Metadata__.get(target);\r\n        targetMetadata.delete(targetKey);\r\n        if (targetMetadata.size > 0) {\r\n            return true;\r\n        }\r\n        __Metadata__.delete(target);\r\n        return true;\r\n    }\r\n    Reflect.deleteMetadata = deleteMetadata;\r\n    function DecorateConstructor(decorators, target) {\r\n        for (var i = decorators.length - 1; i >= 0; --i) {\r\n            var decorator = decorators[i];\r\n            var decorated = decorator(target);\r\n            if (!IsUndefined(decorated)) {\r\n                if (!IsConstructor(decorated)) {\r\n                    throw new TypeError();\r\n                }\r\n                target = decorated;\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {\r\n        for (var i = decorators.length - 1; i >= 0; --i) {\r\n            var decorator = decorators[i];\r\n            var decorated = decorator(target, propertyKey, descriptor);\r\n            if (!IsUndefined(decorated)) {\r\n                if (!IsObject(decorated)) {\r\n                    throw new TypeError();\r\n                }\r\n                descriptor = decorated;\r\n            }\r\n        }\r\n        return descriptor;\r\n    }\r\n    function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {\r\n        for (var i = decorators.length - 1; i >= 0; --i) {\r\n            var decorator = decorators[i];\r\n            decorator(target, propertyKey);\r\n        }\r\n    }\r\n    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#getorcreatemetadatamap--o-p-create-\r\n    function GetOrCreateMetadataMap(target, targetKey, create) {\r\n        var targetMetadata = __Metadata__.get(target);\r\n        if (!targetMetadata) {\r\n            if (!create) {\r\n                return undefined;\r\n            }\r\n            targetMetadata = new _Map();\r\n            __Metadata__.set(target, targetMetadata);\r\n        }\r\n        var keyMetadata = targetMetadata.get(targetKey);\r\n        if (!keyMetadata) {\r\n            if (!create) {\r\n                return undefined;\r\n            }\r\n            keyMetadata = new _Map();\r\n            targetMetadata.set(targetKey, keyMetadata);\r\n        }\r\n        return keyMetadata;\r\n    }\r\n    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasmetadata--metadatakey-o-p-\r\n    function OrdinaryHasMetadata(MetadataKey, O, P) {\r\n        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n        if (hasOwn) {\r\n            return true;\r\n        }\r\n        var parent = GetPrototypeOf(O);\r\n        if (parent !== null) {\r\n            return OrdinaryHasMetadata(MetadataKey, parent, P);\r\n        }\r\n        return false;\r\n    }\r\n    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-\r\n    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\r\n        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);\r\n        if (metadataMap === undefined) {\r\n            return false;\r\n        }\r\n        return Boolean(metadataMap.has(MetadataKey));\r\n    }\r\n    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetmetadata--metadatakey-o-p-\r\n    function OrdinaryGetMetadata(MetadataKey, O, P) {\r\n        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n        if (hasOwn) {\r\n            return OrdinaryGetOwnMetadata(MetadataKey, O, P);\r\n        }\r\n        var parent = GetPrototypeOf(O);\r\n        if (parent !== null) {\r\n            return OrdinaryGetMetadata(MetadataKey, parent, P);\r\n        }\r\n        return undefined;\r\n    }\r\n    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetownmetadata--metadatakey-o-p-\r\n    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\r\n        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);\r\n        if (metadataMap === undefined) {\r\n            return undefined;\r\n        }\r\n        return metadataMap.get(MetadataKey);\r\n    }\r\n    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-\r\n    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\r\n        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ true);\r\n        metadataMap.set(MetadataKey, MetadataValue);\r\n    }\r\n    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarymetadatakeys--o-p-\r\n    function OrdinaryMetadataKeys(O, P) {\r\n        var ownKeys = OrdinaryOwnMetadataKeys(O, P);\r\n        var parent = GetPrototypeOf(O);\r\n        if (parent === null) {\r\n            return ownKeys;\r\n        }\r\n        var parentKeys = OrdinaryMetadataKeys(parent, P);\r\n        if (parentKeys.length <= 0) {\r\n            return ownKeys;\r\n        }\r\n        if (ownKeys.length <= 0) {\r\n            return parentKeys;\r\n        }\r\n        var set = new _Set();\r\n        var keys = [];\r\n        for (var _i = 0; _i < ownKeys.length; _i++) {\r\n            var key = ownKeys[_i];\r\n            var hasKey = set.has(key);\r\n            if (!hasKey) {\r\n                set.add(key);\r\n                keys.push(key);\r\n            }\r\n        }\r\n        for (var _a = 0; _a < parentKeys.length; _a++) {\r\n            var key = parentKeys[_a];\r\n            var hasKey = set.has(key);\r\n            if (!hasKey) {\r\n                set.add(key);\r\n                keys.push(key);\r\n            }\r\n        }\r\n        return keys;\r\n    }\r\n    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryownmetadatakeys--o-p-\r\n    function OrdinaryOwnMetadataKeys(target, targetKey) {\r\n        var metadataMap = GetOrCreateMetadataMap(target, targetKey, /*create*/ false);\r\n        var keys = [];\r\n        if (metadataMap) {\r\n            metadataMap.forEach(function (_, key) { return keys.push(key); });\r\n        }\r\n        return keys;\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-undefined-type\r\n    function IsUndefined(x) {\r\n        return x === undefined;\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray\r\n    function IsArray(x) {\r\n        return Array.isArray(x);\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object-type\r\n    function IsObject(x) {\r\n        return typeof x === \"object\" ? x !== null : typeof x === \"function\";\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor\r\n    function IsConstructor(x) {\r\n        return typeof x === \"function\";\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-symbol-type\r\n    function IsSymbol(x) {\r\n        return typeof x === \"symbol\";\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey\r\n    function ToPropertyKey(value) {\r\n        if (IsSymbol(value)) {\r\n            return value;\r\n        }\r\n        return String(value);\r\n    }\r\n    function GetPrototypeOf(O) {\r\n        var proto = Object.getPrototypeOf(O);\r\n        if (typeof O !== \"function\" || O === functionPrototype) {\r\n            return proto;\r\n        }\r\n        // TypeScript doesn't set __proto__ in ES5, as it's non-standard. \r\n        // Try to determine the superclass constructor. Compatible implementations\r\n        // must either set __proto__ on a subclass constructor to the superclass constructor,\r\n        // or ensure each class has a valid `constructor` property on its prototype that\r\n        // points back to the constructor.\r\n        // If this is not the same as Function.[[Prototype]], then this is definately inherited.\r\n        // This is the case when in ES6 or when using __proto__ in a compatible browser.\r\n        if (proto !== functionPrototype) {\r\n            return proto;\r\n        }\r\n        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\r\n        var prototype = O.prototype;\r\n        var prototypeProto = Object.getPrototypeOf(prototype);\r\n        if (prototypeProto == null || prototypeProto === Object.prototype) {\r\n            return proto;\r\n        }\r\n        // if the constructor was not a function, then we cannot determine the heritage.\r\n        var constructor = prototypeProto.constructor;\r\n        if (typeof constructor !== \"function\") {\r\n            return proto;\r\n        }\r\n        // if we have some kind of self-reference, then we cannot determine the heritage.\r\n        if (constructor === O) {\r\n            return proto;\r\n        }\r\n        // we have a pretty good guess at the heritage.\r\n        return constructor;\r\n    }\r\n    // naive Map shim\r\n    function CreateMapPolyfill() {\r\n        var cacheSentinel = {};\r\n        function Map() {\r\n            this._keys = [];\r\n            this._values = [];\r\n            this._cache = cacheSentinel;\r\n        }\r\n        Map.prototype = {\r\n            get size() {\r\n                return this._keys.length;\r\n            },\r\n            has: function (key) {\r\n                if (key === this._cache) {\r\n                    return true;\r\n                }\r\n                if (this._find(key) >= 0) {\r\n                    this._cache = key;\r\n                    return true;\r\n                }\r\n                return false;\r\n            },\r\n            get: function (key) {\r\n                var index = this._find(key);\r\n                if (index >= 0) {\r\n                    this._cache = key;\r\n                    return this._values[index];\r\n                }\r\n                return undefined;\r\n            },\r\n            set: function (key, value) {\r\n                this.delete(key);\r\n                this._keys.push(key);\r\n                this._values.push(value);\r\n                this._cache = key;\r\n                return this;\r\n            },\r\n            delete: function (key) {\r\n                var index = this._find(key);\r\n                if (index >= 0) {\r\n                    this._keys.splice(index, 1);\r\n                    this._values.splice(index, 1);\r\n                    this._cache = cacheSentinel;\r\n                    return true;\r\n                }\r\n                return false;\r\n            },\r\n            clear: function () {\r\n                this._keys.length = 0;\r\n                this._values.length = 0;\r\n                this._cache = cacheSentinel;\r\n            },\r\n            forEach: function (callback, thisArg) {\r\n                var size = this.size;\r\n                for (var i = 0; i < size; ++i) {\r\n                    var key = this._keys[i];\r\n                    var value = this._values[i];\r\n                    this._cache = key;\r\n                    callback.call(this, value, key, this);\r\n                }\r\n            },\r\n            _find: function (key) {\r\n                var keys = this._keys;\r\n                var size = keys.length;\r\n                for (var i = 0; i < size; ++i) {\r\n                    if (keys[i] === key) {\r\n                        return i;\r\n                    }\r\n                }\r\n                return -1;\r\n            }\r\n        };\r\n        return Map;\r\n    }\r\n    // naive Set shim\r\n    function CreateSetPolyfill() {\r\n        var cacheSentinel = {};\r\n        function Set() {\r\n            this._map = new _Map();\r\n        }\r\n        Set.prototype = {\r\n            get size() {\r\n                return this._map.length;\r\n            },\r\n            has: function (value) {\r\n                return this._map.has(value);\r\n            },\r\n            add: function (value) {\r\n                this._map.set(value, value);\r\n                return this;\r\n            },\r\n            delete: function (value) {\r\n                return this._map.delete(value);\r\n            },\r\n            clear: function () {\r\n                this._map.clear();\r\n            },\r\n            forEach: function (callback, thisArg) {\r\n                this._map.forEach(callback, thisArg);\r\n            }\r\n        };\r\n        return Set;\r\n    }\r\n    // naive WeakMap shim\r\n    function CreateWeakMapPolyfill() {\r\n        var UUID_SIZE = 16;\r\n        var isNode = typeof global !== \"undefined\" && Object.prototype.toString.call(global.process) === '[object process]';\r\n        var nodeCrypto = isNode && require(\"crypto\");\r\n        var hasOwn = Object.prototype.hasOwnProperty;\r\n        var keys = {};\r\n        var rootKey = CreateUniqueKey();\r\n        function WeakMap() {\r\n            this._key = CreateUniqueKey();\r\n        }\r\n        WeakMap.prototype = {\r\n            has: function (target) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                if (table) {\r\n                    return this._key in table;\r\n                }\r\n                return false;\r\n            },\r\n            get: function (target) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                if (table) {\r\n                    return table[this._key];\r\n                }\r\n                return undefined;\r\n            },\r\n            set: function (target, value) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ true);\r\n                table[this._key] = value;\r\n                return this;\r\n            },\r\n            delete: function (target) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                if (table && this._key in table) {\r\n                    return delete table[this._key];\r\n                }\r\n                return false;\r\n            },\r\n            clear: function () {\r\n                // NOTE: not a real clear, just makes the previous data unreachable\r\n                this._key = CreateUniqueKey();\r\n            }\r\n        };\r\n        function FillRandomBytes(buffer, size) {\r\n            for (var i = 0; i < size; ++i) {\r\n                buffer[i] = Math.random() * 255 | 0;\r\n            }\r\n        }\r\n        function GenRandomBytes(size) {\r\n            if (nodeCrypto) {\r\n                var data = nodeCrypto.randomBytes(size);\r\n                return data;\r\n            }\r\n            else if (typeof Uint8Array === \"function\") {\r\n                var data = new Uint8Array(size);\r\n                if (typeof crypto !== \"undefined\") {\r\n                    crypto.getRandomValues(data);\r\n                }\r\n                else if (typeof msCrypto !== \"undefined\") {\r\n                    msCrypto.getRandomValues(data);\r\n                }\r\n                else {\r\n                    FillRandomBytes(data, size);\r\n                }\r\n                return data;\r\n            }\r\n            else {\r\n                var data = new Array(size);\r\n                FillRandomBytes(data, size);\r\n                return data;\r\n            }\r\n        }\r\n        function CreateUUID() {\r\n            var data = GenRandomBytes(UUID_SIZE);\r\n            // mark as random - RFC 4122 § 4.4\r\n            data[6] = data[6] & 0x4f | 0x40;\r\n            data[8] = data[8] & 0xbf | 0x80;\r\n            var result = \"\";\r\n            for (var offset = 0; offset < UUID_SIZE; ++offset) {\r\n                var byte = data[offset];\r\n                if (offset === 4 || offset === 6 || offset === 8) {\r\n                    result += \"-\";\r\n                }\r\n                if (byte < 16) {\r\n                    result += \"0\";\r\n                }\r\n                result += byte.toString(16).toLowerCase();\r\n            }\r\n            return result;\r\n        }\r\n        function CreateUniqueKey() {\r\n            var key;\r\n            do {\r\n                key = \"@@WeakMap@@\" + CreateUUID();\r\n            } while (hasOwn.call(keys, key));\r\n            keys[key] = true;\r\n            return key;\r\n        }\r\n        function GetOrCreateWeakMapTable(target, create) {\r\n            if (!hasOwn.call(target, rootKey)) {\r\n                if (!create) {\r\n                    return undefined;\r\n                }\r\n                Object.defineProperty(target, rootKey, { value: Object.create(null) });\r\n            }\r\n            return target[rootKey];\r\n        }\r\n        return WeakMap;\r\n    }\r\n    // hook global Reflect\r\n    (function (__global) {\r\n        if (typeof __global.Reflect !== \"undefined\") {\r\n            if (__global.Reflect !== Reflect) {\r\n                for (var p in Reflect) {\r\n                    __global.Reflect[p] = Reflect[p];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            __global.Reflect = Reflect;\r\n        }\r\n    })(typeof window !== \"undefined\" ? window :\r\n        typeof WorkerGlobalScope !== \"undefined\" ? self :\r\n            typeof global !== \"undefined\" ? global :\r\n                Function(\"return this;\")());\r\n})(Reflect || (Reflect = {}));\r\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"crypto\":252}],322:[function(require,module,exports){\n(function (Buffer){\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/** @preserve\n(c) 2012 by Cédric Mesnil. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// constants table\nvar zl = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n]\n\nvar zr = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n]\n\nvar sl = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n]\n\nvar sr = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n]\n\nvar hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]\nvar hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]\n\nfunction bytesToWords (bytes) {\n  var words = []\n  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {\n    words[b >>> 5] |= bytes[i] << (24 - b % 32)\n  }\n  return words\n}\n\nfunction wordsToBytes (words) {\n  var bytes = []\n  for (var b = 0; b < words.length * 32; b += 8) {\n    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)\n  }\n  return bytes\n}\n\nfunction processBlock (H, M, offset) {\n  // swap endian\n  for (var i = 0; i < 16; i++) {\n    var offset_i = offset + i\n    var M_offset_i = M[offset_i]\n\n    // Swap\n    M[offset_i] = (\n      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |\n      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)\n    )\n  }\n\n  // Working variables\n  var al, bl, cl, dl, el\n  var ar, br, cr, dr, er\n\n  ar = al = H[0]\n  br = bl = H[1]\n  cr = cl = H[2]\n  dr = dl = H[3]\n  er = el = H[4]\n\n  // computation\n  var t\n  for (i = 0; i < 80; i += 1) {\n    t = (al + M[offset + zl[i]]) | 0\n    if (i < 16) {\n      t += f1(bl, cl, dl) + hl[0]\n    } else if (i < 32) {\n      t += f2(bl, cl, dl) + hl[1]\n    } else if (i < 48) {\n      t += f3(bl, cl, dl) + hl[2]\n    } else if (i < 64) {\n      t += f4(bl, cl, dl) + hl[3]\n    } else {// if (i<80) {\n      t += f5(bl, cl, dl) + hl[4]\n    }\n    t = t | 0\n    t = rotl(t, sl[i])\n    t = (t + el) | 0\n    al = el\n    el = dl\n    dl = rotl(cl, 10)\n    cl = bl\n    bl = t\n\n    t = (ar + M[offset + zr[i]]) | 0\n    if (i < 16) {\n      t += f5(br, cr, dr) + hr[0]\n    } else if (i < 32) {\n      t += f4(br, cr, dr) + hr[1]\n    } else if (i < 48) {\n      t += f3(br, cr, dr) + hr[2]\n    } else if (i < 64) {\n      t += f2(br, cr, dr) + hr[3]\n    } else {// if (i<80) {\n      t += f1(br, cr, dr) + hr[4]\n    }\n\n    t = t | 0\n    t = rotl(t, sr[i])\n    t = (t + er) | 0\n    ar = er\n    er = dr\n    dr = rotl(cr, 10)\n    cr = br\n    br = t\n  }\n\n  // intermediate hash value\n  t = (H[1] + cl + dr) | 0\n  H[1] = (H[2] + dl + er) | 0\n  H[2] = (H[3] + el + ar) | 0\n  H[3] = (H[4] + al + br) | 0\n  H[4] = (H[0] + bl + cr) | 0\n  H[0] = t\n}\n\nfunction f1 (x, y, z) {\n  return ((x) ^ (y) ^ (z))\n}\n\nfunction f2 (x, y, z) {\n  return (((x) & (y)) | ((~x) & (z)))\n}\n\nfunction f3 (x, y, z) {\n  return (((x) | (~(y))) ^ (z))\n}\n\nfunction f4 (x, y, z) {\n  return (((x) & (z)) | ((y) & (~(z))))\n}\n\nfunction f5 (x, y, z) {\n  return ((x) ^ ((y) | (~(z))))\n}\n\nfunction rotl (x, n) {\n  return (x << n) | (x >>> (32 - n))\n}\n\nfunction ripemd160 (message) {\n  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]\n\n  if (typeof message === 'string') {\n    message = new Buffer(message, 'utf8')\n  }\n\n  var m = bytesToWords(message)\n\n  var nBitsLeft = message.length * 8\n  var nBitsTotal = message.length * 8\n\n  // Add padding\n  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)\n  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |\n    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)\n  )\n\n  for (var i = 0; i < m.length; i += 16) {\n    processBlock(H, m, i)\n  }\n\n  // swap endian\n  for (i = 0; i < 5; i++) {\n    // shortcut\n    var H_i = H[i]\n\n    // Swap\n    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |\n      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)\n  }\n\n  var digestbytes = wordsToBytes(H)\n  return new Buffer(digestbytes)\n}\n\nmodule.exports = ripemd160\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243}],323:[function(require,module,exports){\nvar root_1 = require('./util/root');\nvar SymbolShim_1 = require('./util/SymbolShim');\nvar toSubscriber_1 = require('./util/toSubscriber');\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is\n     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify\n     * of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @returns {Observable} a new observable with the Operator applied\n     * @description creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * @method subscribe\n     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @returns {Subscription} a subscription reference to the registered handlers\n     * @description registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var subscriber = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            subscriber.add(this._subscribe(this.operator.call(subscriber)));\n        }\n        else {\n            subscriber.add(this._subscribe(subscriber));\n        }\n        return subscriber;\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {any} [thisArg] a `this` context for the `next` handler function\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @returns {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, thisArg, PromiseCtor) {\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        var nextHandler;\n        if (thisArg) {\n            nextHandler = function nextHandlerFn(value) {\n                var _a = nextHandlerFn, thisArg = _a.thisArg, next = _a.next;\n                return next.call(thisArg, value);\n            };\n            nextHandler.thisArg = thisArg;\n            nextHandler.next = next;\n        }\n        else {\n            nextHandler = next;\n        }\n        var promiseCallback = function promiseCallbackFn(resolve, reject) {\n            var _a = promiseCallbackFn, source = _a.source, nextHandler = _a.nextHandler;\n            source.subscribe(nextHandler, reject, resolve);\n        };\n        promiseCallback.source = this;\n        promiseCallback.nextHandler = nextHandler;\n        return new PromiseCtor(promiseCallback);\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * @method Symbol.observable\n     * @returns {Observable} this instance of the observable\n     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     */\n    Observable.prototype[SymbolShim_1.SymbolShim.observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * @static\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @returns {Observable} a new cold observable\n     * @description creates a new cold Observable by calling the Observable constructor\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n})();\nexports.Observable = Observable;\n\n},{\"./util/SymbolShim\":332,\"./util/root\":337,\"./util/toSubscriber\":339}],324:[function(require,module,exports){\nexports.empty = {\n    isUnsubscribed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n\n},{}],325:[function(require,module,exports){\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('./Observable');\nvar Subscriber_1 = require('./Subscriber');\nvar Subscription_1 = require('./Subscription');\nvar SubjectSubscription_1 = require('./subject/SubjectSubscription');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject(source, destination) {\n        _super.call(this);\n        this.observers = [];\n        this.isUnsubscribed = false;\n        this.isStopped = false;\n        this.hasErrored = false;\n        this.dispatching = false;\n        this.hasCompleted = false;\n        this.source = source;\n        this.destination = destination;\n    }\n    Subject.prototype.lift = function (operator) {\n        var subject = new Subject(this, this.destination || this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.add = function (subscription) {\n        Subscription_1.Subscription.prototype.add.call(this, subscription);\n    };\n    Subject.prototype.remove = function (subscription) {\n        Subscription_1.Subscription.prototype.remove.call(this, subscription);\n    };\n    Subject.prototype.unsubscribe = function () {\n        Subscription_1.Subscription.prototype.unsubscribe.call(this);\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            if (subscriber.isUnsubscribed) {\n                return;\n            }\n            else if (this.hasErrored) {\n                return subscriber.error(this.errorValue);\n            }\n            else if (this.hasCompleted) {\n                return subscriber.complete();\n            }\n            else if (this.isUnsubscribed) {\n                throw new Error('Cannot subscribe to a disposed Subject.');\n            }\n            var subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n            this.observers.push(subscriber);\n            return subscription;\n        }\n    };\n    Subject.prototype._unsubscribe = function () {\n        this.source = null;\n        this.isStopped = true;\n        this.observers = null;\n        this.destination = null;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.isStopped) {\n            return;\n        }\n        this.dispatching = true;\n        this._next(value);\n        this.dispatching = false;\n        if (this.hasErrored) {\n            this._error(this.errorValue);\n        }\n        else if (this.hasCompleted) {\n            this._complete();\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.isStopped) {\n            return;\n        }\n        this.isStopped = true;\n        this.hasErrored = true;\n        this.errorValue = err;\n        if (this.dispatching) {\n            return;\n        }\n        this._error(err);\n    };\n    Subject.prototype.complete = function () {\n        if (this.isStopped) {\n            return;\n        }\n        this.isStopped = true;\n        this.hasCompleted = true;\n        if (this.dispatching) {\n            return;\n        }\n        this._complete();\n    };\n    Subject.prototype._next = function (value) {\n        if (this.destination) {\n            this.destination.next(value);\n        }\n        else {\n            this._finalNext(value);\n        }\n    };\n    Subject.prototype._finalNext = function (value) {\n        var index = -1;\n        var observers = this.observers.slice(0);\n        var len = observers.length;\n        while (++index < len) {\n            observers[index].next(value);\n        }\n    };\n    Subject.prototype._error = function (err) {\n        if (this.destination) {\n            this.destination.error(err);\n        }\n        else {\n            this._finalError(err);\n        }\n    };\n    Subject.prototype._finalError = function (err) {\n        var index = -1;\n        var observers = this.observers;\n        // optimization to block our SubjectSubscriptions from\n        // splicing themselves out of the observers list one by one.\n        this.observers = null;\n        this.isUnsubscribed = true;\n        if (observers) {\n            var len = observers.length;\n            while (++index < len) {\n                observers[index].error(err);\n            }\n        }\n        this.isUnsubscribed = false;\n        this.unsubscribe();\n    };\n    Subject.prototype._complete = function () {\n        if (this.destination) {\n            this.destination.complete();\n        }\n        else {\n            this._finalComplete();\n        }\n    };\n    Subject.prototype._finalComplete = function () {\n        var index = -1;\n        var observers = this.observers;\n        // optimization to block our SubjectSubscriptions from\n        // splicing themselves out of the observers list one by one.\n        this.observers = null;\n        this.isUnsubscribed = true;\n        if (observers) {\n            var len = observers.length;\n            while (++index < len) {\n                observers[index].complete();\n            }\n        }\n        this.isUnsubscribed = false;\n        this.unsubscribe();\n    };\n    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {\n        return new Subscriber_1.Subscriber(this);\n    };\n    Subject.create = function (source, destination) {\n        return new Subject(source, destination);\n    };\n    return Subject;\n})(Observable_1.Observable);\nexports.Subject = Subject;\n\n},{\"./Observable\":323,\"./Subscriber\":326,\"./Subscription\":327,\"./subject/SubjectSubscription\":330,\"./symbol/rxSubscriber\":331}],326:[function(require,module,exports){\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar noop_1 = require('./util/noop');\nvar throwError_1 = require('./util/throwError');\nvar tryOrThrowError_1 = require('./util/tryOrThrowError');\nvar Subscription_1 = require('./Subscription');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\nvar Observer_1 = require('./Observer');\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    function Subscriber(destination) {\n        if (destination === void 0) { destination = Observer_1.empty; }\n        _super.call(this);\n        this.isStopped = false;\n        this.destination = destination;\n        if (!destination ||\n            (destination instanceof Subscriber) ||\n            (destination === Observer_1.empty)) {\n            return;\n        }\n        if (typeof destination.next !== 'function') {\n            destination.next = noop_1.noop;\n        }\n        if (typeof destination.error !== 'function') {\n            destination.error = throwError_1.throwError;\n        }\n        if (typeof destination.complete !== 'function') {\n            destination.complete = noop_1.noop;\n        }\n    }\n    Subscriber.create = function (next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    };\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.isUnsubscribed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {\n        return this;\n    };\n    return Subscriber;\n})(Subscription_1.Subscription);\nexports.Subscriber = Subscriber;\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(next, error, complete) {\n        _super.call(this);\n        this._next = (typeof next === 'function') && tryOrThrowError_1.tryOrThrowError(next) || null;\n        this._error = (typeof error === 'function') && tryOrThrowError_1.tryOrThrowError(error) || throwError_1.throwError;\n        this._complete = (typeof complete === 'function') && tryOrThrowError_1.tryOrThrowError(complete) || null;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            this._next(value);\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            if (this._error) {\n                this._error(err);\n            }\n            this.unsubscribe();\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            if (this._complete) {\n                this._complete();\n            }\n            this.unsubscribe();\n        }\n    };\n    return SafeSubscriber;\n})(Subscriber);\n\n},{\"./Observer\":324,\"./Subscription\":327,\"./symbol/rxSubscriber\":331,\"./util/noop\":336,\"./util/throwError\":338,\"./util/tryOrThrowError\":340}],327:[function(require,module,exports){\nvar isArray_1 = require('./util/isArray');\nvar isObject_1 = require('./util/isObject');\nvar isFunction_1 = require('./util/isFunction');\nvar Subscription = (function () {\n    function Subscription(_unsubscribe) {\n        this.isUnsubscribed = false;\n        if (_unsubscribe) {\n            this._unsubscribe = _unsubscribe;\n        }\n    }\n    Subscription.prototype.unsubscribe = function () {\n        if (this.isUnsubscribed) {\n            return;\n        }\n        this.isUnsubscribed = true;\n        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this._subscriptions = null;\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            _unsubscribe.call(this);\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var subscription = _subscriptions[index];\n                if (isObject_1.isObject(subscription)) {\n                    subscription.unsubscribe();\n                }\n            }\n        }\n    };\n    Subscription.prototype.add = function (subscription) {\n        // return early if:\n        //  1. the subscription is null\n        //  2. we're attempting to add our this\n        //  3. we're attempting to add the static `empty` Subscription\n        if (!subscription || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var sub = subscription;\n        switch (typeof subscription) {\n            case 'function':\n                sub = new Subscription(subscription);\n            case 'object':\n                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.isUnsubscribed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('Unrecognized subscription ' + subscription + ' added to Subscription.');\n        }\n    };\n    Subscription.prototype.remove = function (subscription) {\n        // return early if:\n        //  1. the subscription is null\n        //  2. we're attempting to remove ourthis\n        //  3. we're attempting to remove the static `empty` Subscription\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.isUnsubscribed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n})();\nexports.Subscription = Subscription;\n\n},{\"./util/isArray\":333,\"./util/isFunction\":334,\"./util/isObject\":335}],328:[function(require,module,exports){\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Observable_1 = require('../Observable');\nvar PromiseObservable = (function (_super) {\n    __extends(PromiseObservable, _super);\n    function PromiseObservable(promise, scheduler) {\n        if (scheduler === void 0) { scheduler = null; }\n        _super.call(this);\n        this.promise = promise;\n        this.scheduler = scheduler;\n    }\n    PromiseObservable.create = function (promise, scheduler) {\n        if (scheduler === void 0) { scheduler = null; }\n        return new PromiseObservable(promise, scheduler);\n    };\n    PromiseObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var promise = this.promise;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            if (this._isScalar) {\n                if (!subscriber.isUnsubscribed) {\n                    subscriber.next(this.value);\n                    subscriber.complete();\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.isUnsubscribed) {\n                        subscriber.next(value);\n                        subscriber.complete();\n                    }\n                }, function (err) {\n                    if (!subscriber.isUnsubscribed) {\n                        subscriber.error(err);\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n        else {\n            if (this._isScalar) {\n                if (!subscriber.isUnsubscribed) {\n                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.isUnsubscribed) {\n                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n                    }\n                }, function (err) {\n                    if (!subscriber.isUnsubscribed) {\n                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n    };\n    return PromiseObservable;\n})(Observable_1.Observable);\nexports.PromiseObservable = PromiseObservable;\nfunction dispatchNext(_a) {\n    var value = _a.value, subscriber = _a.subscriber;\n    if (!subscriber.isUnsubscribed) {\n        subscriber.next(value);\n        subscriber.complete();\n    }\n}\nfunction dispatchError(_a) {\n    var err = _a.err, subscriber = _a.subscriber;\n    if (!subscriber.isUnsubscribed) {\n        subscriber.error(err);\n    }\n}\n\n},{\"../Observable\":323,\"../util/root\":337}],329:[function(require,module,exports){\nvar root_1 = require('../util/root');\nfunction toPromise(PromiseCtor) {\n    var _this = this;\n    if (!PromiseCtor) {\n        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n            PromiseCtor = root_1.root.Rx.config.Promise;\n        }\n        else if (root_1.root.Promise) {\n            PromiseCtor = root_1.root.Promise;\n        }\n    }\n    if (!PromiseCtor) {\n        throw new Error('no Promise impl found');\n    }\n    return new PromiseCtor(function (resolve, reject) {\n        var value;\n        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n    });\n}\nexports.toPromise = toPromise;\n\n},{\"../util/root\":337}],330:[function(require,module,exports){\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, observer) {\n        _super.call(this);\n        this.subject = subject;\n        this.observer = observer;\n        this.isUnsubscribed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.isUnsubscribed) {\n            return;\n        }\n        this.isUnsubscribed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isUnsubscribed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.observer);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n})(Subscription_1.Subscription);\nexports.SubjectSubscription = SubjectSubscription;\n\n},{\"../Subscription\":327}],331:[function(require,module,exports){\nvar SymbolShim_1 = require('../util/SymbolShim');\n/**\n * rxSubscriber symbol is a symbol for retreiving an \"Rx safe\" Observer from an object\n * \"Rx safety\" can be defined as an object that has all of the traits of an Rx Subscriber,\n * including the ability to add and remove subscriptions to the subscription chain and\n * guarantees involving event triggering (can't \"next\" after unsubscription, etc).\n */\nexports.rxSubscriber = SymbolShim_1.SymbolShim.for('rxSubscriber');\n\n},{\"../util/SymbolShim\":332}],332:[function(require,module,exports){\nvar root_1 = require('./root');\nfunction polyfillSymbol(root) {\n    var Symbol = ensureSymbol(root);\n    ensureIterator(Symbol, root);\n    ensureObservable(Symbol);\n    ensureFor(Symbol);\n    return Symbol;\n}\nexports.polyfillSymbol = polyfillSymbol;\nfunction ensureFor(Symbol) {\n    if (!Symbol.for) {\n        Symbol.for = symbolForPolyfill;\n    }\n}\nexports.ensureFor = ensureFor;\nvar id = 0;\nfunction ensureSymbol(root) {\n    if (!root.Symbol) {\n        root.Symbol = function symbolFuncPolyfill(description) {\n            return \"@@Symbol(\" + description + \"):\" + id++;\n        };\n    }\n    return root.Symbol;\n}\nexports.ensureSymbol = ensureSymbol;\nfunction symbolForPolyfill(key) {\n    return '@@' + key;\n}\nexports.symbolForPolyfill = symbolForPolyfill;\nfunction ensureIterator(Symbol, root) {\n    if (!Symbol.iterator) {\n        if (typeof Symbol.for === 'function') {\n            Symbol.iterator = Symbol.for('iterator');\n        }\n        else if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {\n            // Bug for mozilla version\n            Symbol.iterator = '@@iterator';\n        }\n        else if (root.Map) {\n            // es6-shim specific logic\n            var keys = Object.getOwnPropertyNames(root.Map.prototype);\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                if (key !== 'entries' && key !== 'size' && root.Map.prototype[key] === root.Map.prototype['entries']) {\n                    Symbol.iterator = key;\n                    break;\n                }\n            }\n        }\n        else {\n            Symbol.iterator = '@@iterator';\n        }\n    }\n}\nexports.ensureIterator = ensureIterator;\nfunction ensureObservable(Symbol) {\n    if (!Symbol.observable) {\n        if (typeof Symbol.for === 'function') {\n            Symbol.observable = Symbol.for('observable');\n        }\n        else {\n            Symbol.observable = '@@observable';\n        }\n    }\n}\nexports.ensureObservable = ensureObservable;\nexports.SymbolShim = polyfillSymbol(root_1.root);\n\n},{\"./root\":337}],333:[function(require,module,exports){\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n\n},{}],334:[function(require,module,exports){\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n\n},{}],335:[function(require,module,exports){\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n\n},{}],336:[function(require,module,exports){\n/* tslint:disable:no-empty */\nfunction noop() { }\nexports.noop = noop;\n\n},{}],337:[function(require,module,exports){\n(function (global){\nvar objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n/* tslint:disable:no-unused-variable */\nvar freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\nvar freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\nvar freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    exports.root = freeGlobal;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],338:[function(require,module,exports){\nfunction throwError(e) { throw e; }\nexports.throwError = throwError;\n\n},{}],339:[function(require,module,exports){\nvar Subscriber_1 = require('../Subscriber');\nvar rxSubscriber_1 = require('../symbol/rxSubscriber');\nfunction toSubscriber(next, error, complete) {\n    if (next && typeof next === 'object') {\n        if (next instanceof Subscriber_1.Subscriber) {\n            return next;\n        }\n        else if (typeof next[rxSubscriber_1.rxSubscriber] === 'function') {\n            return next[rxSubscriber_1.rxSubscriber]();\n        }\n        else {\n            return new Subscriber_1.Subscriber(next);\n        }\n    }\n    return Subscriber_1.Subscriber.create(next, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n\n},{\"../Subscriber\":326,\"../symbol/rxSubscriber\":331}],340:[function(require,module,exports){\nfunction tryOrThrowError(target) {\n    function tryCatcher() {\n        try {\n            tryCatcher.target.apply(this, arguments);\n        }\n        catch (e) {\n            throw e;\n        }\n    }\n    tryCatcher.target = target;\n    return tryCatcher;\n}\nexports.tryOrThrowError = tryOrThrowError;\n\n},{}],341:[function(require,module,exports){\n(function (Buffer){\n// prototype class for hash functions\nfunction Hash (blockSize, finalSize) {\n  this._block = new Buffer(blockSize)\n  this._finalSize = finalSize\n  this._blockSize = blockSize\n  this._len = 0\n  this._s = 0\n}\n\nHash.prototype.update = function (data, enc) {\n  if (typeof data === 'string') {\n    enc = enc || 'utf8'\n    data = new Buffer(data, enc)\n  }\n\n  var l = this._len += data.length\n  var s = this._s || 0\n  var f = 0\n  var buffer = this._block\n\n  while (s < l) {\n    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))\n    var ch = (t - f)\n\n    for (var i = 0; i < ch; i++) {\n      buffer[(s % this._blockSize) + i] = data[i + f]\n    }\n\n    s += ch\n    f += ch\n\n    if ((s % this._blockSize) === 0) {\n      this._update(buffer)\n    }\n  }\n  this._s = s\n\n  return this\n}\n\nHash.prototype.digest = function (enc) {\n  // Suppose the length of the message M, in bits, is l\n  var l = this._len * 8\n\n  // Append the bit 1 to the end of the message\n  this._block[this._len % this._blockSize] = 0x80\n\n  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize\n  this._block.fill(0, this._len % this._blockSize + 1)\n\n  if (l % (this._blockSize * 8) >= this._finalSize * 8) {\n    this._update(this._block)\n    this._block.fill(0)\n  }\n\n  // to this append the block which is equal to the number l written in binary\n  // TODO: handle case where l is > Math.pow(2, 29)\n  this._block.writeInt32BE(l, this._blockSize - 4)\n\n  var hash = this._update(this._block) || this._hash()\n\n  return enc ? hash.toString(enc) : hash\n}\n\nHash.prototype._update = function () {\n  throw new Error('_update must be implemented by subclass')\n}\n\nmodule.exports = Hash\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":243}],342:[function(require,module,exports){\nvar exports = module.exports = function SHA (algorithm) {\n  algorithm = algorithm.toLowerCase()\n\n  var Algorithm = exports[algorithm]\n  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')\n\n  return new Algorithm()\n}\n\nexports.sha = require('./sha')\nexports.sha1 = require('./sha1')\nexports.sha224 = require('./sha224')\nexports.sha256 = require('./sha256')\nexports.sha384 = require('./sha384')\nexports.sha512 = require('./sha512')\n\n},{\"./sha\":343,\"./sha1\":344,\"./sha224\":345,\"./sha256\":346,\"./sha384\":347,\"./sha512\":348}],343:[function(require,module,exports){\n(function (Buffer){\n/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined\n * in FIPS PUB 180-1\n * This source code is derived from sha1.js of the same repository.\n * The difference between SHA-0 and SHA-1 is just a bitwise rotate left\n * operation was added.\n */\n\nvar inherits = require('inherits')\nvar Hash = require('./hash')\n\nvar W = new Array(80)\n\nfunction Sha () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha, Hash)\n\nSha.prototype.init = function () {\n  this._a = 0x67452301 | 0\n  this._b = 0xefcdab89 | 0\n  this._c = 0x98badcfe | 0\n  this._d = 0x10325476 | 0\n  this._e = 0xc3d2e1f0 | 0\n\n  return this\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol (num, cnt) {\n  return (num << cnt) | (num >>> (32 - cnt))\n}\n\nSha.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a\n  var b = this._b\n  var c = this._c\n  var d = this._d\n  var e = this._e\n\n  var j = 0\n  var k\n\n  /*\n   * SHA-1 has a bitwise rotate left operation. But, SHA is not\n   * function calcW() { return rol(W[j - 3] ^ W[j -  8] ^ W[j - 14] ^ W[j - 16], 1) }\n   */\n  function calcW () { return W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16] }\n  function loop (w, f) {\n    W[j] = w\n\n    var t = rol(a, 5) + f + e + w + k\n\n    e = d\n    d = c\n    c = rol(b, 30)\n    b = a\n    a = t\n    j++\n  }\n\n  k = 1518500249\n  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))\n  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))\n  k = 1859775393\n  while (j < 40) loop(calcW(), b ^ c ^ d)\n  k = -1894007588\n  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))\n  k = -899497514\n  while (j < 80) loop(calcW(), b ^ c ^ d)\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha.prototype._hash = function () {\n  var H = new Buffer(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha\n\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./hash\":341,\"buffer\":243,\"inherits\":292}],344:[function(require,module,exports){\n(function (Buffer){\n/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar inherits = require('inherits')\nvar Hash = require('./hash')\n\nvar W = new Array(80)\n\nfunction Sha1 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha1, Hash)\n\nSha1.prototype.init = function () {\n  this._a = 0x67452301 | 0\n  this._b = 0xefcdab89 | 0\n  this._c = 0x98badcfe | 0\n  this._d = 0x10325476 | 0\n  this._e = 0xc3d2e1f0 | 0\n\n  return this\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol (num, cnt) {\n  return (num << cnt) | (num >>> (32 - cnt))\n}\n\nSha1.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a\n  var b = this._b\n  var c = this._c\n  var d = this._d\n  var e = this._e\n\n  var j = 0\n  var k\n\n  function calcW () { return rol(W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16], 1) }\n  function loop (w, f) {\n    W[j] = w\n\n    var t = rol(a, 5) + f + e + w + k\n\n    e = d\n    d = c\n    c = rol(b, 30)\n    b = a\n    a = t\n    j++\n  }\n\n  k = 1518500249\n  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))\n  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))\n  k = 1859775393\n  while (j < 40) loop(calcW(), b ^ c ^ d)\n  k = -1894007588\n  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))\n  k = -899497514\n  while (j < 80) loop(calcW(), b ^ c ^ d)\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha1.prototype._hash = function () {\n  var H = new Buffer(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha1\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./hash\":341,\"buffer\":243,\"inherits\":292}],345:[function(require,module,exports){\n(function (Buffer){\n/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar inherits = require('inherits')\nvar Sha256 = require('./sha256')\nvar Hash = require('./hash')\n\nvar W = new Array(64)\n\nfunction Sha224 () {\n  this.init()\n\n  this._w = W // new Array(64)\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha224, Sha256)\n\nSha224.prototype.init = function () {\n  this._a = 0xc1059ed8 | 0\n  this._b = 0x367cd507 | 0\n  this._c = 0x3070dd17 | 0\n  this._d = 0xf70e5939 | 0\n  this._e = 0xffc00b31 | 0\n  this._f = 0x68581511 | 0\n  this._g = 0x64f98fa7 | 0\n  this._h = 0xbefa4fa4 | 0\n\n  return this\n}\n\nSha224.prototype._hash = function () {\n  var H = new Buffer(28)\n\n  H.writeInt32BE(this._a, 0)\n  H.writeInt32BE(this._b, 4)\n  H.writeInt32BE(this._c, 8)\n  H.writeInt32BE(this._d, 12)\n  H.writeInt32BE(this._e, 16)\n  H.writeInt32BE(this._f, 20)\n  H.writeInt32BE(this._g, 24)\n\n  return H\n}\n\nmodule.exports = Sha224\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./hash\":341,\"./sha256\":346,\"buffer\":243,\"inherits\":292}],346:[function(require,module,exports){\n(function (Buffer){\n/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar inherits = require('inherits')\nvar Hash = require('./hash')\n\nvar K = [\n  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n]\n\nvar W = new Array(64)\n\nfunction Sha256 () {\n  this.init()\n\n  this._w = W // new Array(64)\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha256, Hash)\n\nSha256.prototype.init = function () {\n  this._a = 0x6a09e667 | 0\n  this._b = 0xbb67ae85 | 0\n  this._c = 0x3c6ef372 | 0\n  this._d = 0xa54ff53a | 0\n  this._e = 0x510e527f | 0\n  this._f = 0x9b05688c | 0\n  this._g = 0x1f83d9ab | 0\n  this._h = 0x5be0cd19 | 0\n\n  return this\n}\n\nfunction Ch (x, y, z) {\n  return z ^ (x & (y ^ z))\n}\n\nfunction Maj (x, y, z) {\n  return (x & y) | (z & (x | y))\n}\n\nfunction Sigma0 (x) {\n  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)\n}\n\nfunction Sigma1 (x) {\n  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)\n}\n\nfunction Gamma0 (x) {\n  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)\n}\n\nfunction Gamma1 (x) {\n  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)\n}\n\nSha256.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n  var f = this._f | 0\n  var g = this._g | 0\n  var h = this._h | 0\n\n  var j = 0\n\n  function calcW () { return Gamma1(W[j - 2]) + W[j - 7] + Gamma0(W[j - 15]) + W[j - 16] }\n  function loop (w) {\n    W[j] = w\n\n    var T1 = h + Sigma1(e) + Ch(e, f, g) + K[j] + w\n    var T2 = Sigma0(a) + Maj(a, b, c)\n\n    h = g\n    g = f\n    f = e\n    e = d + T1\n    d = c\n    c = b\n    b = a\n    a = T1 + T2\n\n    j++\n  }\n\n  while (j < 16) loop(M.readInt32BE(j * 4))\n  while (j < 64) loop(calcW())\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n  this._f = (f + this._f) | 0\n  this._g = (g + this._g) | 0\n  this._h = (h + this._h) | 0\n}\n\nSha256.prototype._hash = function () {\n  var H = new Buffer(32)\n\n  H.writeInt32BE(this._a, 0)\n  H.writeInt32BE(this._b, 4)\n  H.writeInt32BE(this._c, 8)\n  H.writeInt32BE(this._d, 12)\n  H.writeInt32BE(this._e, 16)\n  H.writeInt32BE(this._f, 20)\n  H.writeInt32BE(this._g, 24)\n  H.writeInt32BE(this._h, 28)\n\n  return H\n}\n\nmodule.exports = Sha256\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./hash\":341,\"buffer\":243,\"inherits\":292}],347:[function(require,module,exports){\n(function (Buffer){\nvar inherits = require('inherits')\nvar SHA512 = require('./sha512')\nvar Hash = require('./hash')\n\nvar W = new Array(160)\n\nfunction Sha384 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 128, 112)\n}\n\ninherits(Sha384, SHA512)\n\nSha384.prototype.init = function () {\n  this._a = 0xcbbb9d5d | 0\n  this._b = 0x629a292a | 0\n  this._c = 0x9159015a | 0\n  this._d = 0x152fecd8 | 0\n  this._e = 0x67332667 | 0\n  this._f = 0x8eb44a87 | 0\n  this._g = 0xdb0c2e0d | 0\n  this._h = 0x47b5481d | 0\n\n  this._al = 0xc1059ed8 | 0\n  this._bl = 0x367cd507 | 0\n  this._cl = 0x3070dd17 | 0\n  this._dl = 0xf70e5939 | 0\n  this._el = 0xffc00b31 | 0\n  this._fl = 0x68581511 | 0\n  this._gl = 0x64f98fa7 | 0\n  this._hl = 0xbefa4fa4 | 0\n\n  return this\n}\n\nSha384.prototype._hash = function () {\n  var H = new Buffer(48)\n\n  function writeInt64BE (h, l, offset) {\n    H.writeInt32BE(h, offset)\n    H.writeInt32BE(l, offset + 4)\n  }\n\n  writeInt64BE(this._a, this._al, 0)\n  writeInt64BE(this._b, this._bl, 8)\n  writeInt64BE(this._c, this._cl, 16)\n  writeInt64BE(this._d, this._dl, 24)\n  writeInt64BE(this._e, this._el, 32)\n  writeInt64BE(this._f, this._fl, 40)\n\n  return H\n}\n\nmodule.exports = Sha384\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./hash\":341,\"./sha512\":348,\"buffer\":243,\"inherits\":292}],348:[function(require,module,exports){\n(function (Buffer){\nvar inherits = require('inherits')\nvar Hash = require('./hash')\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n]\n\nvar W = new Array(160)\n\nfunction Sha512 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 128, 112)\n}\n\ninherits(Sha512, Hash)\n\nSha512.prototype.init = function () {\n  this._a = 0x6a09e667 | 0\n  this._b = 0xbb67ae85 | 0\n  this._c = 0x3c6ef372 | 0\n  this._d = 0xa54ff53a | 0\n  this._e = 0x510e527f | 0\n  this._f = 0x9b05688c | 0\n  this._g = 0x1f83d9ab | 0\n  this._h = 0x5be0cd19 | 0\n\n  this._al = 0xf3bcc908 | 0\n  this._bl = 0x84caa73b | 0\n  this._cl = 0xfe94f82b | 0\n  this._dl = 0x5f1d36f1 | 0\n  this._el = 0xade682d1 | 0\n  this._fl = 0x2b3e6c1f | 0\n  this._gl = 0xfb41bd6b | 0\n  this._hl = 0x137e2179 | 0\n\n  return this\n}\n\nfunction Ch (x, y, z) {\n  return z ^ (x & (y ^ z))\n}\n\nfunction Maj (x, y, z) {\n  return (x & y) | (z & (x | y))\n}\n\nfunction Sigma0 (x, xl) {\n  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)\n}\n\nfunction Sigma1 (x, xl) {\n  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)\n}\n\nfunction Gamma0 (x, xl) {\n  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)\n}\n\nfunction Gamma0l (x, xl) {\n  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)\n}\n\nfunction Gamma1 (x, xl) {\n  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)\n}\n\nfunction Gamma1l (x, xl) {\n  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)\n}\n\nSha512.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n  var f = this._f | 0\n  var g = this._g | 0\n  var h = this._h | 0\n\n  var al = this._al | 0\n  var bl = this._bl | 0\n  var cl = this._cl | 0\n  var dl = this._dl | 0\n  var el = this._el | 0\n  var fl = this._fl | 0\n  var gl = this._gl | 0\n  var hl = this._hl | 0\n\n  var i = 0\n  var j = 0\n  var Wi, Wil\n  function calcW () {\n    var x = W[j - 15 * 2]\n    var xl = W[j - 15 * 2 + 1]\n    var gamma0 = Gamma0(x, xl)\n    var gamma0l = Gamma0l(xl, x)\n\n    x = W[j - 2 * 2]\n    xl = W[j - 2 * 2 + 1]\n    var gamma1 = Gamma1(x, xl)\n    var gamma1l = Gamma1l(xl, x)\n\n    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n    var Wi7 = W[j - 7 * 2]\n    var Wi7l = W[j - 7 * 2 + 1]\n\n    var Wi16 = W[j - 16 * 2]\n    var Wi16l = W[j - 16 * 2 + 1]\n\n    Wil = gamma0l + Wi7l\n    Wi = gamma0 + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)\n    Wil = Wil + gamma1l\n    Wi = Wi + gamma1 + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)\n    Wil = Wil + Wi16l\n    Wi = Wi + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)\n  }\n\n  function loop () {\n    W[j] = Wi\n    W[j + 1] = Wil\n\n    var maj = Maj(a, b, c)\n    var majl = Maj(al, bl, cl)\n\n    var sigma0h = Sigma0(a, al)\n    var sigma0l = Sigma0(al, a)\n    var sigma1h = Sigma1(e, el)\n    var sigma1l = Sigma1(el, e)\n\n    // t1 = h + sigma1 + ch + K[i] + W[i]\n    var Ki = K[j]\n    var Kil = K[j + 1]\n\n    var ch = Ch(e, f, g)\n    var chl = Ch(el, fl, gl)\n\n    var t1l = hl + sigma1l\n    var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)\n    t1l = t1l + chl\n    t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)\n    t1l = t1l + Kil\n    t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)\n    t1l = t1l + Wil\n    t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)\n\n    // t2 = sigma0 + maj\n    var t2l = sigma0l + majl\n    var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)\n\n    h = g\n    hl = gl\n    g = f\n    gl = fl\n    f = e\n    fl = el\n    el = (dl + t1l) | 0\n    e = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0\n    d = c\n    dl = cl\n    c = b\n    cl = bl\n    b = a\n    bl = al\n    al = (t1l + t2l) | 0\n    a = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0\n\n    i++\n    j += 2\n  }\n\n  while (i < 16) {\n    Wi = M.readInt32BE(j * 4)\n    Wil = M.readInt32BE(j * 4 + 4)\n\n    loop()\n  }\n\n  while (i < 80) {\n    calcW()\n    loop()\n  }\n\n  this._al = (this._al + al) | 0\n  this._bl = (this._bl + bl) | 0\n  this._cl = (this._cl + cl) | 0\n  this._dl = (this._dl + dl) | 0\n  this._el = (this._el + el) | 0\n  this._fl = (this._fl + fl) | 0\n  this._gl = (this._gl + gl) | 0\n  this._hl = (this._hl + hl) | 0\n\n  this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0\n  this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0\n  this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0\n  this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0\n  this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0\n  this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0\n  this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0\n  this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0\n}\n\nSha512.prototype._hash = function () {\n  var H = new Buffer(64)\n\n  function writeInt64BE (h, l, offset) {\n    H.writeInt32BE(h, offset)\n    H.writeInt32BE(l, offset + 4)\n  }\n\n  writeInt64BE(this._a, this._al, 0)\n  writeInt64BE(this._b, this._bl, 8)\n  writeInt64BE(this._c, this._cl, 16)\n  writeInt64BE(this._d, this._dl, 24)\n  writeInt64BE(this._e, this._el, 32)\n  writeInt64BE(this._f, this._fl, 40)\n  writeInt64BE(this._g, this._gl, 48)\n  writeInt64BE(this._h, this._hl, 56)\n\n  return H\n}\n\nmodule.exports = Sha512\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./hash\":341,\"buffer\":243,\"inherits\":292}],349:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":282,\"inherits\":292,\"readable-stream/duplex.js\":311,\"readable-stream/passthrough.js\":317,\"readable-stream/readable.js\":318,\"readable-stream/transform.js\":319,\"readable-stream/writable.js\":320}],350:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n},{\"buffer\":243}],351:[function(require,module,exports){\n(function (global){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],352:[function(require,module,exports){\nvar indexOf = require('indexof');\n\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    forEach(Object_keys(ctx), function (key) {\n        context[key] = ctx[key];\n    });\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n},{\"indexof\":291}],353:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar core = require('../core');\nvar microtask = require('../microtask');\nvar browserPatch = require('../patch/browser');\nvar es6Promise = require('es6-promise');\n\nif (global.Zone) {\n  console.warn('Zone already exported on window the object!');\n}\n\nglobal.Zone = microtask.addMicrotaskSupport(core.Zone);\nglobal.zone = new global.Zone();\n\n// Monkey patch the Promise implementation to add support for microtasks\nglobal.Promise = es6Promise.Promise;\n\nbrowserPatch.apply();\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../core\":354,\"../microtask\":356,\"../patch/browser\":357,\"es6-promise\":280}],354:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar keys = require('./keys');\n\nfunction Zone(parentZone, data) {\n  var zone = (arguments.length) ? Object.create(parentZone) : this;\n\n  zone.parent = parentZone || null;\n\n  Object.keys(data || {}).forEach(function(property) {\n\n    var _property = property.substr(1);\n\n    // augment the new zone with a hook decorates the parent's hook\n    if (property[0] === '$') {\n      zone[_property] = data[property](parentZone[_property] || function () {});\n\n    // augment the new zone with a hook that runs after the parent's hook\n    } else if (property[0] === '+') {\n      if (parentZone[_property]) {\n        zone[_property] = function () {\n          var result = parentZone[_property].apply(this, arguments);\n          data[property].apply(this, arguments);\n          return result;\n        };\n      } else {\n        zone[_property] = data[property];\n      }\n\n    // augment the new zone with a hook that runs before the parent's hook\n    } else if (property[0] === '-') {\n      if (parentZone[_property]) {\n        zone[_property] = function () {\n          data[property].apply(this, arguments);\n          return parentZone[_property].apply(this, arguments);\n        };\n      } else {\n        zone[_property] = data[property];\n      }\n\n    // set the new zone's hook (replacing the parent zone's)\n    } else {\n      zone[property] = (typeof data[property] === 'object') ?\n                        JSON.parse(JSON.stringify(data[property])) :\n                        data[property];\n    }\n  });\n\n  zone.$id = Zone.nextId++;\n\n  return zone;\n}\n\nZone.prototype = {\n  constructor: Zone,\n\n  fork: function (locals) {\n    this.onZoneCreated();\n    return new Zone(this, locals);\n  },\n\n  bind: function (fn, skipEnqueue) {\n    if (typeof fn !== 'function') {\n      throw new Error('Expecting function got: ' + fn);\n    }\n    skipEnqueue || this.enqueueTask(fn);\n    var zone = this.isRootZone() ? this : this.fork();\n    return function zoneBoundFn() {\n      return zone.run(fn, this, arguments);\n    };\n  },\n\n  bindOnce: function (fn) {\n    var boundZone = this;\n    return this.bind(function () {\n      var result = fn.apply(this, arguments);\n      boundZone.dequeueTask(fn);\n      return result;\n    });\n  },\n\n  isRootZone: function() {\n    return this.parent === null;\n  },\n\n  run: function run (fn, applyTo, applyWith) {\n    applyWith = applyWith || [];\n\n    var oldZone = global.zone;\n\n    // MAKE THIS ZONE THE CURRENT ZONE\n    global.zone = this;\n\n    try {\n      this.beforeTask();\n      return fn.apply(applyTo, applyWith);\n    } catch (e) {\n      if (this.onError) {\n        this.onError(e);\n      } else {\n        throw e;\n      }\n    } finally {\n      this.afterTask();\n      // REVERT THE CURRENT ZONE BACK TO THE ORIGINAL ZONE\n      global.zone = oldZone;\n    }\n  },\n\n  // onError is used to override error handling.\n  // When a custom error handler is provided, it should most probably rethrow the exception\n  // not to break the expected control flow:\n  //\n  // `promise.then(fnThatThrows).catch(fn);`\n  //\n  // When this code is executed in a zone with a custom onError handler that doesn't rethrow, the\n  // `.catch()` branch will not be taken as the `fnThatThrows` exception will be swallowed by the\n  // handler.\n  onError: null,\n  beforeTask: function () {},\n  onZoneCreated: function () {},\n  afterTask: function () {},\n  enqueueTask: function () {},\n  dequeueTask: function () {},\n  addEventListener: function () {\n    return this[keys.common.addEventListener].apply(this, arguments);\n  },\n  removeEventListener: function () {\n    return this[keys.common.removeEventListener].apply(this, arguments);\n  }\n};\n\n// Root zone ID === 1\nZone.nextId = 1;\n\nZone.bindPromiseFn = require('./patch/promise').bindPromiseFn;\n\nmodule.exports = {\n  Zone: Zone\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./keys\":355,\"./patch/promise\":364}],355:[function(require,module,exports){\n/**\n * Creates keys for `private` properties on exposed objects to minimize interactions with other codebases.\n */\n\nfunction create(name) {\n  // `Symbol` implementation is broken in Chrome 39.0.2171, do not use them even if they are available\n  return '_zone$' + name;\n}\n\nvar commonKeys = {\n  addEventListener: create('addEventListener'),\n  removeEventListener: create('removeEventListener')\n};\n\nmodule.exports = {\n  create: create,\n  common: commonKeys\n};\n\n},{}],356:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// TODO(vicb): Create a benchmark for the different methods & the usage of the queue\n// see https://github.com/angular/zone.js/issues/97\n\n// It is required to initialize hasNativePromise before requiring es6-promise otherwise es6-promise would\n// overwrite the native Promise implementation on v8 and the check would always return false.\n// see https://github.com/jakearchibald/es6-promise/issues/140\nvar hasNativePromise = typeof Promise !== \"undefined\" &&\n    Promise.toString().indexOf(\"[native code]\") !== -1;\n\nvar isFirefox = global.navigator &&\n    global.navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n\nvar resolvedPromise;\n\n// TODO(vicb): remove '!isFirefox' when the bug gets fixed:\n// https://bugzilla.mozilla.org/show_bug.cgi?id=1162013\nif (hasNativePromise && !isFirefox) {\n  // When available use a native Promise to schedule microtasks.\n  // When not available, es6-promise fallback will be used\n  resolvedPromise = Promise.resolve();\n}\n\nvar es6Promise = require('es6-promise').Promise;\n\nif (resolvedPromise) {\n  es6Promise._setScheduler(function(fn) {\n    resolvedPromise.then(fn);\n  });\n}\n\n// es6-promise asap should schedule microtasks via zone.scheduleMicrotask so that any\n// user defined hooks are triggered\nes6Promise._setAsap(function(fn, arg) {\n  global.zone.scheduleMicrotask(function() {\n    fn(arg);\n  });\n});\n\n// The default implementation of scheduleMicrotask use the original es6-promise implementation\n// to schedule a microtask\nfunction scheduleMicrotask(fn) {\n  es6Promise._asap(this.bind(fn));\n}\n\nfunction addMicrotaskSupport(zoneClass) {\n  zoneClass.prototype.scheduleMicrotask = scheduleMicrotask;\n  return zoneClass;\n}\n\nmodule.exports = {\n  addMicrotaskSupport: addMicrotaskSupport\n};\n\n\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"es6-promise\":280}],357:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar fnPatch = require('./functions');\nvar promisePatch = require('./promise');\nvar mutationObserverPatch = require('./mutation-observer');\nvar definePropertyPatch = require('./define-property');\nvar registerElementPatch = require('./register-element');\nvar webSocketPatch = require('./websocket');\nvar eventTargetPatch = require('./event-target');\nvar propertyDescriptorPatch = require('./property-descriptor');\nvar geolocationPatch = require('./geolocation');\nvar fileReaderPatch = require('./file-reader');\n\nfunction apply() {\n  fnPatch.patchSetClearFunction(global, [\n    'timeout',\n    'interval',\n    'immediate'\n  ]);\n\n  fnPatch.patchRequestAnimationFrame(global, [\n    'requestAnimationFrame',\n    'mozRequestAnimationFrame',\n    'webkitRequestAnimationFrame'\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n\nmodule.exports = {\n  apply: apply\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./define-property\":358,\"./event-target\":359,\"./file-reader\":360,\"./functions\":361,\"./geolocation\":362,\"./mutation-observer\":363,\"./promise\":364,\"./property-descriptor\":365,\"./register-element\":366,\"./websocket\":367}],358:[function(require,module,exports){\n'use strict';\n\nvar keys = require('../keys');\n\n// might need similar for object.freeze\n// i regret nothing\n\nvar _defineProperty = Object.defineProperty;\nvar _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar _create = Object.create;\nvar unconfigurablesKey = keys.create('unconfigurables');\n\nfunction apply() {\n  Object.defineProperty = function (obj, prop, desc) {\n    if (isUnconfigurable(obj, prop)) {\n      throw new TypeError('Cannot assign to read only property \\'' + prop + '\\' of ' + obj);\n    }\n    if (prop !== 'prototype') {\n      desc = rewriteDescriptor(obj, prop, desc);\n    }\n    return _defineProperty(obj, prop, desc);\n  };\n\n  Object.defineProperties = function (obj, props) {\n    Object.keys(props).forEach(function (prop) {\n      Object.defineProperty(obj, prop, props[prop]);\n    });\n    return obj;\n  };\n\n  Object.create = function (obj, proto) {\n    if (typeof proto === 'object') {\n      Object.keys(proto).forEach(function (prop) {\n        proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);\n      });\n    }\n    return _create(obj, proto);\n  };\n\n  Object.getOwnPropertyDescriptor = function (obj, prop) {\n    var desc = _getOwnPropertyDescriptor(obj, prop);\n    if (isUnconfigurable(obj, prop)) {\n      desc.configurable = false;\n    }\n    return desc;\n  };\n};\n\nfunction _redefineProperty(obj, prop, desc) {\n  desc = rewriteDescriptor(obj, prop, desc);\n  return _defineProperty(obj, prop, desc);\n};\n\nfunction isUnconfigurable (obj, prop) {\n  return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];\n}\n\nfunction rewriteDescriptor (obj, prop, desc) {\n  desc.configurable = true;\n  if (!desc.configurable) {\n    if (!obj[unconfigurablesKey]) {\n      _defineProperty(obj, unconfigurablesKey, { writable: true, value: {} });\n    }\n    obj[unconfigurablesKey][prop] = true;\n  }\n  return desc;\n}\n\nmodule.exports = {\n  apply: apply,\n  _redefineProperty: _redefineProperty\n};\n\n\n\n},{\"../keys\":355}],359:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar utils = require('../utils');\n\nfunction apply() {\n  // patched properties depend on addEventListener, so this needs to come first\n  if (global.EventTarget) {\n    utils.patchEventTargetMethods(global.EventTarget.prototype);\n\n  // Note: EventTarget is not available in all browsers,\n  // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget\n  } else {\n    var apis = [\n      'ApplicationCache',\n      'EventSource',\n      'FileReader',\n      'InputMethodContext',\n      'MediaController',\n      'MessagePort',\n      'Node',\n      'Performance',\n      'SVGElementInstance',\n      'SharedWorker',\n      'TextTrack',\n      'TextTrackCue',\n      'TextTrackList',\n      'WebKitNamedFlow',\n      'Worker',\n      'WorkerGlobalScope',\n      'XMLHttpRequest',\n      'XMLHttpRequestEventTarget',\n      'XMLHttpRequestUpload'\n    ];\n\n    apis.forEach(function(api) {\n      var proto = global[api] && global[api].prototype;\n\n      // Some browsers e.g. Android 4.3's don't actually implement\n      // the EventTarget methods for all of these e.g. FileReader.\n      // In this case, there is nothing to patch.\n      if (proto && proto.addEventListener) {\n        utils.patchEventTargetMethods(proto);\n      }\n    });\n\n    // Patch the methods on `window` instead of `Window.prototype`\n    // `Window` is not accessible on Android 4.3\n    if (typeof(window) !== 'undefined') {\n      utils.patchEventTargetMethods(window);\n    }\n  }\n}\n\nmodule.exports = {\n  apply: apply\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":368}],360:[function(require,module,exports){\n'use strict';\n\nvar utils = require('../utils');\n\nfunction apply() {\n  utils.patchClass('FileReader');\n}\n\nmodule.exports = {\n  apply: apply\n};\n},{\"../utils\":368}],361:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar utils = require('../utils');\n\nfunction patchSetClearFunction(obj, fnNames) {\n  fnNames.map(function (name) {\n    return name[0].toUpperCase() + name.substr(1);\n  }).forEach(function (name) {\n    var setName = 'set' + name;\n    var delegate = obj[setName];\n\n    if (delegate) {\n      var clearName = 'clear' + name;\n      var ids = {};\n\n      var bindArgs = setName === 'setInterval' ? utils.bindArguments : utils.bindArgumentsOnce;\n\n      global.zone[setName] = function (fn) {\n        var id, fnRef = fn;\n        arguments[0] = function () {\n          delete ids[id];\n          return fnRef.apply(this, arguments);\n        };\n        var args = bindArgs(arguments);\n        id = delegate.apply(obj, args);\n        ids[id] = true;\n        return id;\n      };\n\n      obj[setName] = function () {\n        return global.zone[setName].apply(this, arguments);\n      };\n\n      var clearDelegate = obj[clearName];\n\n      global.zone[clearName] = function (id) {\n        if (ids[id]) {\n          delete ids[id];\n          global.zone.dequeueTask();\n        }\n        return clearDelegate.apply(this, arguments);\n      };\n\n      obj[clearName] = function () {\n        return global.zone[clearName].apply(this, arguments);\n      };\n    }\n  });\n};\n\n\n/**\n * requestAnimationFrame is typically recursively called from within the callback function\n * that it executes.  To handle this case, only fork a zone if this is executed\n * within the root zone.\n */\nfunction patchRequestAnimationFrame(obj, fnNames) {\n  fnNames.forEach(function (name) {\n    var delegate = obj[name];\n    if (delegate) {\n      global.zone[name] = function (fn) {\n        var callZone = global.zone.isRootZone() ? global.zone.fork() : global.zone;\n        if (fn) {\n          arguments[0] = function () {\n            return callZone.run(fn, this, arguments);\n          };\n        }\n        return delegate.apply(obj, arguments);\n      };\n\n      obj[name] = function () {\n        return global.zone[name].apply(this, arguments);\n      };\n    }\n  });\n};\n\nfunction patchSetFunction(obj, fnNames) {\n  fnNames.forEach(function (name) {\n    var delegate = obj[name];\n\n    if (delegate) {\n      global.zone[name] = function (fn) {\n        arguments[0] = function () {\n          return fn.apply(this, arguments);\n        };\n        var args = utils.bindArgumentsOnce(arguments);\n        return delegate.apply(obj, args);\n      };\n\n      obj[name] = function () {\n        return zone[name].apply(this, arguments);\n      };\n    }\n  });\n};\n\nfunction patchFunction(obj, fnNames) {\n  fnNames.forEach(function (name) {\n    var delegate = obj[name];\n    global.zone[name] = function () {\n      return delegate.apply(obj, arguments);\n    };\n\n    obj[name] = function () {\n      return global.zone[name].apply(this, arguments);\n    };\n  });\n};\n\n\nmodule.exports = {\n  patchSetClearFunction: patchSetClearFunction,\n  patchSetFunction: patchSetFunction,\n  patchRequestAnimationFrame: patchRequestAnimationFrame,\n  patchFunction: patchFunction\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":368}],362:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar utils = require('../utils');\n\nfunction apply() {\n  if (global.navigator && global.navigator.geolocation) {\n    utils.patchPrototype(global.navigator.geolocation, [\n      'getCurrentPosition',\n      'watchPosition'\n    ]);\n  }\n}\n\nmodule.exports = {\n  apply: apply\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":368}],363:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar keys = require('../keys');\n\nvar originalInstanceKey = keys.create('originalInstance');\nvar creationZoneKey = keys.create('creationZone');\nvar isActiveKey = keys.create('isActive');\n\n// wrap some native API on `window`\nfunction patchClass(className) {\n  var OriginalClass = global[className];\n  if (!OriginalClass) return;\n\n  global[className] = function (fn) {\n    this[originalInstanceKey] = new OriginalClass(global.zone.bind(fn, true));\n    // Remember where the class was instantiate to execute the enqueueTask and dequeueTask hooks\n    this[creationZoneKey] = global.zone;\n  };\n\n  var instance = new OriginalClass(function () {});\n\n  global[className].prototype.disconnect = function () {\n    var result = this[originalInstanceKey].disconnect.apply(this[originalInstanceKey], arguments);\n    if (this[isActiveKey]) {\n      this[creationZoneKey].dequeueTask();\n      this[isActiveKey] = false;\n    }\n    return result;\n  };\n\n  global[className].prototype.observe = function () {\n    if (!this[isActiveKey]) {\n      this[creationZoneKey].enqueueTask();\n      this[isActiveKey] = true;\n    }\n    return this[originalInstanceKey].observe.apply(this[originalInstanceKey], arguments);\n  };\n\n  var prop;\n  for (prop in instance) {\n    (function (prop) {\n      if (typeof global[className].prototype !== 'undefined') {\n        return;\n      }\n      if (typeof instance[prop] === 'function') {\n        global[className].prototype[prop] = function () {\n          return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n        };\n      } else {\n        Object.defineProperty(global[className].prototype, prop, {\n          set: function (fn) {\n            if (typeof fn === 'function') {\n              this[originalInstanceKey][prop] = global.zone.bind(fn);\n            } else {\n              this[originalInstanceKey][prop] = fn;\n            }\n          },\n          get: function () {\n            return this[originalInstanceKey][prop];\n          }\n        });\n      }\n    }(prop));\n  }\n};\n\nmodule.exports = {\n  patchClass: patchClass\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../keys\":355}],364:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar utils = require('../utils');\n\n/*\n * Patches a function that returns a Promise-like instance.\n *\n * This function must be used when either:\n * - Native Promises are not available,\n * - The function returns a Promise-like object.\n *\n * This is required because zones rely on a Promise monkey patch that could not be applied when\n * Promise is not natively available or when the returned object is not an instance of Promise.\n *\n * Note that calling `bindPromiseFn` on a function that returns a native Promise will also work\n * with minimal overhead.\n *\n * ```\n * var boundFunction = bindPromiseFn(FunctionReturningAPromise);\n *\n * boundFunction.then(successHandler, errorHandler);\n * ```\n */\nvar bindPromiseFn;\n\nif (global.Promise) {\n  bindPromiseFn = function (delegate) {\n    return function() {\n      var delegatePromise = delegate.apply(this, arguments);\n\n      // if the delegate returned an instance of Promise, forward it.\n      if (delegatePromise instanceof Promise) {\n        return delegatePromise;\n      }\n\n      // Otherwise wrap the Promise-like in a global Promise\n      return new Promise(function(resolve, reject) {\n        delegatePromise.then(resolve, reject);\n      });\n    };\n  };\n} else {\n  bindPromiseFn = function (delegate) {\n    return function () {\n      return _patchThenable(delegate.apply(this, arguments));\n    };\n  };\n}\n\n\nfunction _patchPromiseFnsOnObject(objectPath, fnNames) {\n  var obj = global;\n\n  var exists = objectPath.every(function (segment) {\n    obj = obj[segment];\n    return obj;\n  });\n\n  if (!exists) {\n    return;\n  }\n\n  fnNames.forEach(function (name) {\n    var fn = obj[name];\n    if (fn) {\n      obj[name] = bindPromiseFn(fn);\n    }\n  });\n}\n\nfunction _patchThenable(thenable) {\n  var then = thenable.then;\n  thenable.then = function () {\n    var args = utils.bindArguments(arguments);\n    var nextThenable = then.apply(thenable, args);\n    return _patchThenable(nextThenable);\n  };\n\n  var ocatch = thenable.catch;\n  thenable.catch = function () {\n    var args = utils.bindArguments(arguments);\n    var nextThenable = ocatch.apply(thenable, args);\n    return _patchThenable(nextThenable);\n  };\n\n  return thenable;\n}\n\n\nfunction apply() {\n  // Patch .then() and .catch() on native Promises to execute callbacks in the zone where\n  // those functions are called.\n  if (global.Promise) {\n    utils.patchPrototype(Promise.prototype, [\n      'then',\n      'catch'\n    ]);\n\n    // Patch browser APIs that return a Promise\n    var patchFns = [\n      // fetch\n      [[], ['fetch']],\n      [['Response', 'prototype'], ['arrayBuffer', 'blob', 'json', 'text']]\n    ];\n\n    patchFns.forEach(function(objPathAndFns) {\n      _patchPromiseFnsOnObject(objPathAndFns[0], objPathAndFns[1]);\n    });\n  }\n}\n\nmodule.exports = {\n  apply: apply,\n  bindPromiseFn: bindPromiseFn\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":368}],365:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar webSocketPatch = require('./websocket');\nvar utils = require('../utils');\nvar keys = require('../keys');\n\nvar eventNames = 'copy cut paste abort blur focus canplay canplaythrough change click contextmenu dblclick drag dragend dragenter dragleave dragover dragstart drop durationchange emptied ended input invalid keydown keypress keyup load loadeddata loadedmetadata loadstart message mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup pause play playing progress ratechange reset scroll seeked seeking select show stalled submit suspend timeupdate volumechange waiting mozfullscreenchange mozfullscreenerror mozpointerlockchange mozpointerlockerror error webglcontextrestored webglcontextlost webglcontextcreationerror'.split(' ');\n\nfunction apply() {\n  if (utils.isWebWorker()){\n    // on WebWorker so don't apply patch\n    return;\n  }\n\n  var supportsWebSocket = typeof WebSocket !== 'undefined';\n  if (canPatchViaPropertyDescriptor()) {\n    // for browsers that we can patch the descriptor:  Chrome & Firefox\n    var onEventNames = eventNames.map(function (property) {\n      return 'on' + property;\n    });\n    utils.patchProperties(HTMLElement.prototype, onEventNames);\n    utils.patchProperties(XMLHttpRequest.prototype);\n    if (supportsWebSocket) {\n      utils.patchProperties(WebSocket.prototype);\n    }\n  } else {\n    // Safari, Android browsers (Jelly Bean)\n    patchViaCapturingAllTheEvents();\n    utils.patchClass('XMLHttpRequest');\n    if (supportsWebSocket) {\n      webSocketPatch.apply();\n    }\n  }\n}\n\nfunction canPatchViaPropertyDescriptor() {\n  if (!Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') && typeof Element !== 'undefined') {\n    // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364\n    // IDL interface attributes are not configurable\n    var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');\n    if (desc && !desc.configurable) return false;\n  }\n\n  Object.defineProperty(HTMLElement.prototype, 'onclick', {\n    get: function () {\n      return true;\n    }\n  });\n  var elt = document.createElement('div');\n  var result = !!elt.onclick;\n  Object.defineProperty(HTMLElement.prototype, 'onclick', {});\n  return result;\n};\n\nvar unboundKey = keys.create('unbound');\n\n// Whenever any event fires, we check the event target and all parents\n// for `onwhatever` properties and replace them with zone-bound functions\n// - Chrome (for now)\nfunction patchViaCapturingAllTheEvents() {\n  eventNames.forEach(function (property) {\n    var onproperty = 'on' + property;\n    document.addEventListener(property, function (event) {\n      var elt = event.target, bound;\n      while (elt) {\n        if (elt[onproperty] && !elt[onproperty][unboundKey]) {\n          bound = global.zone.bind(elt[onproperty]);\n          bound[unboundKey] = elt[onproperty];\n          elt[onproperty] = bound;\n        }\n        elt = elt.parentElement;\n      }\n    }, true);\n  });\n};\n\nmodule.exports = {\n  apply: apply\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../keys\":355,\"../utils\":368,\"./websocket\":367}],366:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar _redefineProperty = require('./define-property')._redefineProperty;\nvar utils = require(\"../utils\");\n\nfunction apply() {\n  if (utils.isWebWorker() || !('registerElement' in global.document)) {\n    return;\n  }\n\n  var _registerElement = document.registerElement;\n  var callbacks = [\n    'createdCallback',\n    'attachedCallback',\n    'detachedCallback',\n    'attributeChangedCallback'\n  ];\n\n  document.registerElement = function (name, opts) {\n    if (opts && opts.prototype) {\n      callbacks.forEach(function (callback) {\n        if (opts.prototype.hasOwnProperty(callback)) {\n          var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);\n          if (descriptor && descriptor.value) {\n            descriptor.value = global.zone.bind(descriptor.value);\n            _redefineProperty(opts.prototype, callback, descriptor);\n          } else {\n            opts.prototype[callback] = global.zone.bind(opts.prototype[callback]);\n          }\n        } else if (opts.prototype[callback]) {\n          opts.prototype[callback] = global.zone.bind(opts.prototype[callback]);\n        }\n      });\n    }\n\n    return _registerElement.apply(document, [name, opts]);\n  };\n}\n\nmodule.exports = {\n  apply: apply\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":368,\"./define-property\":358}],367:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar utils = require('../utils');\n\n// we have to patch the instance since the proto is non-configurable\nfunction apply() {\n  var WS = global.WebSocket;\n  utils.patchEventTargetMethods(WS.prototype);\n  global.WebSocket = function(a, b) {\n    var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);\n    var proxySocket;\n\n    // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance\n    var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');\n    if (onmessageDesc && onmessageDesc.configurable === false) {\n      proxySocket = Object.create(socket);\n      ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function(propName) {\n        proxySocket[propName] = function() {\n          return socket[propName].apply(socket, arguments);\n        };\n      });\n    } else {\n      // we can patch the real socket\n      proxySocket = socket;\n    }\n\n    utils.patchProperties(proxySocket, ['onclose', 'onerror', 'onmessage', 'onopen']);\n\n    return proxySocket;\n  };\n}\n\nmodule.exports = {\n  apply: apply\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":368}],368:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar keys = require('./keys');\n\nfunction bindArguments(args) {\n  for (var i = args.length - 1; i >= 0; i--) {\n    if (typeof args[i] === 'function') {\n      args[i] = global.zone.bind(args[i]);\n    }\n  }\n  return args;\n};\n\nfunction bindArgumentsOnce(args) {\n  for (var i = args.length - 1; i >= 0; i--) {\n    if (typeof args[i] === 'function') {\n      args[i] = global.zone.bindOnce(args[i]);\n    }\n  }\n  return args;\n};\n\nfunction patchPrototype(obj, fnNames) {\n  fnNames.forEach(function (name) {\n    var delegate = obj[name];\n    if (delegate) {\n      obj[name] = function () {\n        return delegate.apply(this, bindArguments(arguments));\n      };\n    }\n  });\n};\n\nfunction isWebWorker() {\n  return (typeof document === \"undefined\");\n}\n\nfunction patchProperty(obj, prop) {\n  var desc = Object.getOwnPropertyDescriptor(obj, prop) || {\n    enumerable: true,\n    configurable: true\n  };\n\n  // A property descriptor cannot have getter/setter and be writable\n  // deleting the writable and value properties avoids this error:\n  //\n  // TypeError: property descriptors must not specify a value or be writable when a\n  // getter or setter has been specified\n  delete desc.writable;\n  delete desc.value;\n\n  // substr(2) cuz 'onclick' -> 'click', etc\n  var eventName = prop.substr(2);\n  var _prop = '_' + prop;\n\n  desc.set = function (fn) {\n    if (this[_prop]) {\n      this.removeEventListener(eventName, this[_prop]);\n    }\n\n    if (typeof fn === 'function') {\n      this[_prop] = fn;\n      this.addEventListener(eventName, fn, false);\n    } else {\n      this[_prop] = null;\n    }\n  };\n\n  desc.get = function () {\n    return this[_prop];\n  };\n\n  Object.defineProperty(obj, prop, desc);\n};\n\nfunction patchProperties(obj, properties) {\n  (properties || (function () {\n      var props = [];\n      for (var prop in obj) {\n        props.push(prop);\n      }\n      return props;\n    }()).\n    filter(function (propertyName) {\n      return propertyName.substr(0,2) === 'on';\n    })).\n    forEach(function (eventName) {\n      patchProperty(obj, eventName);\n    });\n};\n\nvar originalFnKey = keys.create('originalFn');\nvar boundFnsKey = keys.create('boundFns');\n\nfunction patchEventTargetMethods(obj) {\n  // This is required for the addEventListener hook on the root zone.\n  obj[keys.common.addEventListener] = obj.addEventListener;\n  obj.addEventListener = function (eventName, handler, useCapturing) {\n    //Ignore special listeners of IE11 & Edge dev tools, see https://github.com/angular/zone.js/issues/150\n    if (handler && handler.toString() !== \"[object FunctionWrapper]\") {\n      var eventType = eventName + (useCapturing ? '$capturing' : '$bubbling');\n      var fn;\n      if (handler.handleEvent) {\n        // Have to pass in 'handler' reference as an argument here, otherwise it gets clobbered in\n        // IE9 by the arguments[1] assignment at end of this function.\n        fn = (function(handler) {\n          return function() {\n            handler.handleEvent.apply(handler, arguments);\n          };\n        })(handler);\n      } else {\n        fn = handler;\n      }\n\n      handler[originalFnKey] = fn;\n      handler[boundFnsKey] = handler[boundFnsKey] || {};\n      handler[boundFnsKey][eventType] = handler[boundFnsKey][eventType] || zone.bind(fn);\n      arguments[1] = handler[boundFnsKey][eventType];\n    }\n\n    // - Inside a Web Worker, `this` is undefined, the context is `global` (= `self`)\n    // - When `addEventListener` is called on the global context in strict mode, `this` is undefined\n    // see https://github.com/angular/zone.js/issues/190\n    var target = this || global;\n    return global.zone.addEventListener.apply(target, arguments);\n  };\n\n  // This is required for the removeEventListener hook on the root zone.\n  obj[keys.common.removeEventListener] = obj.removeEventListener;\n  obj.removeEventListener = function (eventName, handler, useCapturing) {\n    var eventType = eventName + (useCapturing ? '$capturing' : '$bubbling');\n    if (handler && handler[boundFnsKey] && handler[boundFnsKey][eventType]) {\n      var _bound = handler[boundFnsKey];\n      arguments[1] = _bound[eventType];\n      delete _bound[eventType];\n      global.zone.dequeueTask(handler[originalFnKey]);\n    }\n\n    // - Inside a Web Worker, `this` is undefined, the context is `global`\n    // - When `addEventListener` is called on the global context in strict mode, `this` is undefined\n    // see https://github.com/angular/zone.js/issues/190\n    var target = this || global;\n    var result = global.zone.removeEventListener.apply(target, arguments);\n    return result;\n  };\n};\n\nvar originalInstanceKey = keys.create('originalInstance');\n\n// wrap some native API on `window`\nfunction patchClass(className) {\n  var OriginalClass = global[className];\n  if (!OriginalClass) return;\n\n  global[className] = function () {\n    var a = bindArguments(arguments);\n    switch (a.length) {\n      case 0: this[originalInstanceKey] = new OriginalClass(); break;\n      case 1: this[originalInstanceKey] = new OriginalClass(a[0]); break;\n      case 2: this[originalInstanceKey] = new OriginalClass(a[0], a[1]); break;\n      case 3: this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]); break;\n      case 4: this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]); break;\n      default: throw new Error('what are you even doing?');\n    }\n  };\n\n  var instance = new OriginalClass();\n\n  var prop;\n  for (prop in instance) {\n    (function (prop) {\n      if (typeof instance[prop] === 'function') {\n        global[className].prototype[prop] = function () {\n          return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n        };\n      } else {\n        Object.defineProperty(global[className].prototype, prop, {\n          set: function (fn) {\n            if (typeof fn === 'function') {\n              this[originalInstanceKey][prop] = global.zone.bind(fn);\n            } else {\n              this[originalInstanceKey][prop] = fn;\n            }\n          },\n          get: function () {\n            return this[originalInstanceKey][prop];\n          }\n        });\n      }\n    }(prop));\n  }\n\n  for (prop in OriginalClass) {\n    if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {\n      global[className][prop] = OriginalClass[prop];\n    }\n  }\n};\n\nmodule.exports = {\n  bindArguments: bindArguments,\n  bindArgumentsOnce: bindArgumentsOnce,\n  patchPrototype: patchPrototype,\n  patchProperty: patchProperty,\n  patchProperties: patchProperties,\n  patchEventTargetMethods: patchEventTargetMethods,\n  patchClass: patchClass,\n  isWebWorker: isWebWorker\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./keys\":355}],369:[function(require,module,exports){\n'use strict';\n\nrequire('es6-shim');\n\nrequire('reflect-metadata');\n\nrequire('zone.js/lib/browser/zone-microtask');\n\nvar _browser = require('angular2/platform/browser');\n\nvar _core = require('angular2/core');\n\nvar _dashboard = require('./dashboard/dashboard');\n\n// if (ENVIRONMENT == 'production') {\n//  enableProdMode();\n// }\n(0, _browser.bootstrap)(_dashboard.MyApp);\n\n},{\"./dashboard/dashboard\":370,\"angular2/core\":3,\"angular2/platform/browser\":4,\"es6-shim\":281,\"reflect-metadata\":321,\"zone.js/lib/browser/zone-microtask\":353}],370:[function(require,module,exports){\n'use strict';\n\nvar _dec, _class;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MyApp = undefined;\n\nvar _core = require('angular2/core');\n\nvar _initCapsPipe = require('../init-caps-pipe.js');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MyApp = exports.MyApp = (_dec = (0, _core.Component)({\n  selector: 'app',\n  pipes: [_initCapsPipe.InitCapsPipe],\n  templateUrl: '/dashboard/dashboard.html'\n}), _dec(_class = function MyApp() {\n  _classCallCheck(this, MyApp);\n\n  this.message = 'hello world';\n}) || _class);\n\n},{\"../init-caps-pipe.js\":371,\"angular2/core\":3}],371:[function(require,module,exports){\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _dec, _class;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InitCapsPipe = undefined;\n\nvar _core = require('angular2/core');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar InitCapsPipe = exports.InitCapsPipe = (_dec = (0, _core.Pipe)({ name: 'initCaps' }), _dec(_class = function () {\n  function InitCapsPipe() {\n    _classCallCheck(this, InitCapsPipe);\n  }\n\n  _createClass(InitCapsPipe, [{\n    key: 'transform',\n    value: function transform(value) {\n      return value.toLowerCase().replace(/(?:^|\\s)[a-z]/g, function (m) {\n        return m.toUpperCase();\n      });\n    }\n  }]);\n\n  return InitCapsPipe;\n}()) || _class);\n\n},{\"angular2/core\":3}]},{},[369]);\n"],"file":"frontend.js","sourceRoot":"/source/"}